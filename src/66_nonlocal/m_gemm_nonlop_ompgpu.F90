!!****m* ABINIT/m_gemm_nonlop_ompgpu
!! NAME
!! m_gemm_nonlop_ompgpu
!!
!! FUNCTION
!!  This module provides functions to compute the nonlocal operator by means of the BLAS GEMM
!!  routine. By treating ndat simultaneous wavefunctions, it is able to exploit BLAS3 routines,
!!  which leads to excellent CPU efficiency and OpenMP scalability.
!!
!! COPYRIGHT
!! Copyright (C) 2014-2024 ABINIT group (MS)
!! This file is distributed under the terms of the
!! GNU General Public License, see ~abinit/COPYING
!! or http://www.gnu.org/copyleft/gpl.txt .
!!
!! SOURCE

! TODO list :
! Don't allocate the full nkpt structures, only those that are treated by this proc: use same init as in m_bandfft_kpt
! support more options (forces & stresses mostly)
! Support RF/other computations (only GS right now)
! handle the case where nloalg(2) < 0, ie no precomputation of ph3d
! more systematic checking of the workflow (right now, only works if init/make/gemm/destroy, no multiple makes, etc)
! Avoid allocating the complex matrix when istwfk > 1
! Merge with chebfi's invovl


#if defined HAVE_CONFIG_H
#include "config.h"
#endif

#include "abi_common.h"

module m_gemm_nonlop_ompgpu

 use defs_basis
 use m_errors
 use m_abicore
 use m_xmpi
 use m_xomp
 use m_abi_linalg
 use m_gemm_nonlop_projectors

 use defs_abitypes, only : MPI_type
 use m_opernlc_ylm_ompgpu, only : opernlc_ylm_ompgpu
 use m_opernla_gemm, only : opernla_gemm
 use m_opernlb_gemm, only : opernlb_gemm
 use m_opernld_ylm_allwf, only : opernld_ylm_allwf
 use m_opernld_ylm, only : opernld_ylm
 use m_pawcprj, only : pawcprj_type
 use m_geometry, only : strconv
 use m_kg, only : mkkpg
 use m_hamiltonian, only : KPRIME_H_K, K_H_KPRIME, K_H_K, KPRIME_H_KPRIME

#if defined(HAVE_GPU)
 use m_gpu_toolbox
#endif

#ifdef HAVE_FC_ISO_C_BINDING
 use iso_c_binding
#endif


 implicit none

 private

 ! then call gemm_nonlop to do the actual computation, and call destroy when done. See gstate and vtorho.
 public :: gemm_nonlop_ompgpu

 ! Those routines are here to assess memory requirements
 public :: gemm_nonlop_ompgpu_work_mem
 public :: gemm_nonlop_ompgpu_static_mem
!!***

!----------------------------------------------------------------------

#ifdef HAVE_OPENMP_OFFLOAD
 integer, save :: gpu_initialised=0
 integer, save :: mod__ndat=0
 integer, save :: mod__nprojs=0
 integer, save :: mod__cplex=0
 integer, save :: mod__cplex_fac=0
 real(dp), save, allocatable, target :: projections_(:,:,:), s_projections(:,:,:), vnl_projections(:,:,:), dprojections(:,:,:)
 real(dp), save, allocatable :: temp_realvec_r(:),temp_realvec_i(:)
 real(dp), save, allocatable :: sij_typ(:,:)

#endif

contains

 function gemm_nonlop_ompgpu_work_mem(istwfk, ndat, npw, indlmn, nattyp, ntypat, lmnmax) result(req_mem)
   implicit none

   integer, intent(in) :: istwfk, ndat, npw, ntypat, lmnmax
   integer, intent(in) :: indlmn(:,:,:), nattyp(ntypat)

   integer :: nprojs, cplex, itypat
   real(dp) :: req_mem

! *************************************************************************

   cplex=2;if (istwfk>1) cplex=1
   nprojs=0
   do itypat=1,ntypat
     nprojs = nprojs + count(indlmn(3,:,itypat)>0)*nattyp(itypat)
   end do

   req_mem = 0

   if(cplex == 1) then
     req_mem = req_mem + dp * npw * ndat ! temp_realvec_r
     req_mem = req_mem + dp * npw * ndat ! temp_realvec_i
   end if

   req_mem = req_mem + dp * lmnmax * (lmnmax+1)/2 * ntypat  ! sij_typ

   req_mem = req_mem + dp * cplex * int(nprojs, c_size_t) * int(ndat, c_size_t)  ! projections_
   req_mem = req_mem + dp * cplex * int(nprojs, c_size_t) * int(ndat, c_size_t)  ! s_projections
   req_mem = req_mem + dp * cplex * int(nprojs, c_size_t) * int(ndat, c_size_t)  ! vnl_projections

 end function gemm_nonlop_ompgpu_work_mem

!----------------------------------------------------------------------

 function gemm_nonlop_ompgpu_static_mem(npw, indlmn, nattyp, ntypat, nblocks,&
     compute_grad_strain,compute_grad_atom) result(req_mem)
   implicit none

   integer, intent(in) :: npw, ntypat, nblocks
   integer, intent(in) :: indlmn(:,:,:), nattyp(ntypat)
   logical, intent(in), optional :: compute_grad_strain,compute_grad_atom

   integer :: nprojs, ngrads, itypat
   logical :: my_compute_grad_strain,my_compute_grad_atom
   integer(kind=c_size_t) :: req_mem

! *************************************************************************

   my_compute_grad_strain=.false. ; if (present(compute_grad_strain)) my_compute_grad_strain=compute_grad_strain
   my_compute_grad_atom=.false. ; if (present(compute_grad_atom)) my_compute_grad_atom=compute_grad_atom

   nprojs = 0
   do itypat=1,ntypat
     nprojs = nprojs + count(indlmn(3,:,itypat)>0)*nattyp(itypat)
   end do
   nprojs = nprojs / nblocks

   ngrads = 0
   if (my_compute_grad_strain) ngrads = ngrads + 6
   if (my_compute_grad_atom)   ngrads = ngrads + 3

   req_mem = 0

   if(nblocks>1) then
     req_mem = req_mem + dp * 2 * int(npw, c_size_t) * int(nprojs, c_size_t)          !projs_recv
   end if
   ! projs or projs_r + projs_i
   req_mem = req_mem + 2 * dp * int(npw, c_size_t) * int(nprojs, c_size_t)
   if(ngrads>0) then
     ! dprojs or dprojs_r + dprojs_i
     req_mem = req_mem + 2 * dp * int(npw, c_size_t) * int(ngrads, c_size_t) * int(nprojs, c_size_t)
     if(nblocks>1) then
       req_mem = req_mem + dp * 2 * int(npw, c_size_t) * int(ngrads, c_size_t)*int(nprojs, c_size_t)   !dprojs_recv
     end if
   end if

 end function gemm_nonlop_ompgpu_static_mem

!----------------------------------------------------------------------

!Tested usecases :
! - Nvidia GPUs : FC_NVHPC + CUDA
! - AMD GPUs    : FC_LLVM + HIP
! An eventual Intel implementation would use the OneAPI LLVM compiler.
! Homemade CUDA/HIP interfaces would allow the use of GCC.
! But it is likely that OpenMP performance won't be optimal outside GPU vendors compilers.
#ifdef HAVE_OPENMP_OFFLOAD

 subroutine alloc_work_buffers(cplex, cplex_fac, ndat, nprojs, ntypat, lmnmax, npw)

  integer,intent(in) :: cplex, cplex_fac, ndat, nprojs, ntypat, lmnmax, npw

! *************************************************************************

  call free_work_buffers()

  mod__ndat=ndat
  mod__nprojs=nprojs
  mod__cplex=cplex
  mod__cplex_fac=cplex_fac

  if(cplex == 1) then
    ABI_MALLOC(temp_realvec_r,(npw*ndat))
    ABI_MALLOC(temp_realvec_i,(npw*ndat))
    !$OMP TARGET ENTER DATA MAP(alloc:temp_realvec_r,temp_realvec_i)
  end if

  ABI_MALLOC(sij_typ,(lmnmax*(lmnmax+1)/2,ntypat))
  !$OMP TARGET ENTER DATA MAP(alloc:sij_typ)

  ABI_MALLOC(projections_,(cplex, nprojs, ndat))
  ABI_MALLOC(s_projections,(cplex, nprojs, ndat))
  ABI_MALLOC(vnl_projections,(cplex_fac, nprojs, ndat))

  !FIXME Smarter buffer management
#ifdef HAVE_GPU_HIP
  !Work buffer allocated once to save time in HIP (alloc costful)
  !$OMP TARGET ENTER DATA MAP(alloc:projections_,s_projections,vnl_projections)
#endif

  gpu_initialised=1

 end subroutine alloc_work_buffers
!!***

!----------------------------------------------------------------------

 subroutine free_work_buffers()


  !$OMP TARGET EXIT DATA MAP(delete:sij_typ)
  if(allocated(sij_typ)) then
    ABI_FREE(sij_typ)
  end if

  if(allocated(temp_realvec_r)) then
    !$OMP TARGET EXIT DATA MAP(delete:temp_realvec_r,temp_realvec_i)
    ABI_FREE(temp_realvec_r)
    ABI_FREE(temp_realvec_i)
  end if

  !FIXME Smarter buffer management
#ifdef HAVE_GPU_HIP
  !$OMP TARGET EXIT DATA MAP(delete:projections_,s_projections,vnl_projections)
#endif

  if(allocated(projections_)) then
    ABI_FREE(projections_)
    ABI_FREE(s_projections)
    ABI_FREE(vnl_projections)
  end if

  mod__ndat=0
  gpu_initialised=0

 end subroutine free_work_buffers

!----------------------------------------------------------------------

!!****f* m_gemm_nonlop_ompgpu/destroy_gpu_nonlop_ompgpu
!! NAME
!! destroy_gemm_nonlop_ompgpu
!!
!! FUNCTION
!! Destruction of the gemm_nonlop_kpt array
!!
!! INPUTS
!! nkpt= number of k-points
!!
!! SOURCE
 subroutine destroy_gemm_nonlop_ompgpu()

  character(len=200) :: msg

! *************************************************************************

  call free_work_buffers()

 end subroutine destroy_gemm_nonlop_ompgpu
!!***

!----------------------------------------------------------------------

!!****f* m_gemm_nonlop_ompgpu/gemm_nonlop_ompgpu
!! NAME
!! gemm_nonlop_ompgpu
!!
!! FUNCTION
!! Replacement of nonlop. same prototype as nonlop although not all options are implemented.
!!
!! INPUTS
!! [gpu_option] = GPU implementation to use, i.e. cuda, openMP, ... (0=not using GPU)
!!
!! SOURCE
 subroutine gemm_nonlop_ompgpu(atindx1,choice,cpopt,cprjin,dimenl1,dimenl2,dimekbq,dimffnlin,dimffnlout,&
&                 enl,enl_ndat,enlout,ffnlin,ffnlout,gmet,gprimd,idir,indlmn,istwf_k,&
&                 kgin,kgout,kpgin,kpgout,kptin,kptout,lambda,lmnmax,matblk,mgfft,&
&                 mpi_enreg,natom,nattyp,ndat,ngfft,nkpgin,nkpgout,nloalg,&
&                 nnlout,npwin,npwout,nspinor,nspinortot,ntypat,only_SO,paw_opt,&
&                 ph3din,ph3dout,signs,sij,svectout,&
&                 tim_nonlop,ucvol,useylm,vectin,vectout,&
&                 atom_proj_shift,select_k,iatom_only,typat,usepaw,&
&                 vectproj,gpu_option)

  !Arguments ------------------------------------
  !scalars
  integer,intent(in) :: choice,cpopt,dimenl1,dimenl2,dimekbq,dimffnlin,dimffnlout,idir
  integer,intent(in) :: istwf_k,lmnmax,matblk,mgfft,natom,ndat,nkpgin
  integer,intent(in) :: nkpgout,nnlout,npwin,npwout,nspinor,nspinortot,ntypat,only_SO
  integer,intent(in) :: paw_opt,signs,tim_nonlop,useylm,atom_proj_shift,select_k,iatom_only,usepaw
  integer,optional,intent(in) :: gpu_option
  real(dp),intent(in) :: lambda(ndat),ucvol
  type(MPI_type),intent(in) :: mpi_enreg
  !arrays
  integer,intent(in),target :: atindx1(natom),indlmn(6,lmnmax,ntypat),kgin(3,npwin)
  integer,intent(in),target :: kgout(3,npwout),nattyp(ntypat),ngfft(18),nloalg(3),typat(natom)
  real(dp),intent(in),ABI_CONTIGUOUS target :: enl(:,:,:,:),enl_ndat(:,:,:,:,:)
  real(dp),intent(in),target :: ffnlin(npwin,dimffnlin,lmnmax,ntypat)
  real(dp),intent(in),target :: ffnlout(npwout,dimffnlout,lmnmax,ntypat),gmet(3,3)
  real(dp),intent(in) :: gprimd(3,3),kptin(3),kptout(3)
  real(dp),intent(in),target :: kpgin(npwin,nkpgin*useylm),kpgout(npwout,nkpgout*useylm)
  real(dp),intent(in),target :: sij(dimenl1,ntypat*((paw_opt+1)/3))
  real(dp),intent(inout),target :: ph3din(2,npwin,matblk),ph3dout(2,npwout,matblk)
  real(dp),intent(inout),target :: vectin(2,npwin*nspinor*ndat)
  real(dp),intent(inout) :: enlout(nnlout*ndat)
  real(dp),intent(out),target :: svectout(:,:)
  real(dp),intent(inout),target :: vectout(:,:)
  real(dp),intent(inout),optional, ABI_CONTIGUOUS target :: vectproj(:,:,:)
  type(pawcprj_type),intent(inout) :: cprjin(natom,nspinor*((cpopt+5)/5)*ndat)

  ! locals
  integer :: ii, idat, igrad, nprojs, ngrads, ngrads2, shift, iatom, nlmn, ierr, ibeg, iend, ikin, ikout
  integer :: cplex, cplex_enl, cplex_fac
  integer :: nnlout_test
  integer :: iatm, ndgxdt, ndgxdtfac, nd2gxdt, nd2gxdtfac, optder, itypat, ilmn
  integer :: cplex_dgxdt(9), cplex_d2gxdt(18)
  logical :: local_vectproj,use_enl_ndat
  real(dp) :: d2gxdt_dum_in(1,1,1,1,1), d2gxdt_dum_out(1,1,1,1,1),d2gxdt_dum_out2(1,1,1,1,1)

  real(dp), ABI_CONTIGUOUS pointer :: projections(:,:,:)
  real(dp), allocatable, target :: s_dprojections(:,:,:), vnl_dprojections(:,:,:)
  real(dp), allocatable, target :: d2projections(:,:,:)
  integer :: ipw, iproj, iblock, nprojs_blk, i1, i2, i
  logical :: is_last
  real(dp), ABI_CONTIGUOUS pointer :: projs_(:,:,:),dprojs_(:,:,:),d2projs_(:,:,:)
  real(dp), ABI_CONTIGUOUS pointer :: projs_r_(:,:,:),projs_i_(:,:,:)
  real(dp), ABI_CONTIGUOUS pointer :: dprojs_r_(:,:,:),dprojs_i_(:,:,:)
  real(dp), ABI_CONTIGUOUS pointer :: d2projs_r_(:,:,:),d2projs_i_(:,:,:)
  real(dp), allocatable :: enlk(:),fnlk(:,:),ddkk(:,:),strnlk(:,:),gmet2(:,:)
  real(dp), allocatable :: work1(:),work2(:),work3(:,:),work4(:,:),work5(:,:,:),work6(:,:,:),work7(:,:,:)
  integer :: idbeg,idend,idfbeg,idfend,dshift,id2beg,id2end,d2shift,dfshift,enlout_shift,ndat_enl
  real(dp) :: work(6)
  integer :: ndgxdt_stored,ishift
  integer :: mu0,ic,nu,mu,jc,mua,mub,nua1,nua2,nub1,nub2
  integer,parameter :: alpha(6)=(/1,2,3,3,3,2/),beta(6)=(/1,2,3,2,1,1/)
  integer,parameter :: gamma(3,3)=reshape((/1,6,5,6,2,4,5,4,3/),(/3,3/))
  integer          ::  matblk_,natom_,ntypat_,ispden,dimenl2_,ia_beg,ia_end,dimsij,nkpgin_,nkpgout_
  integer, ABI_CONTIGUOUS pointer :: atindx1_(:),indlmn_(:,:,:),nattyp_(:)
  real(dp),pointer :: ffnlin_(:,:,:,:),ffnlout_(:,:,:,:)
  real(dp),pointer :: ph3din_(:,:,:),ph3dout_(:,:,:)
  real(dp), ABI_CONTIGUOUS pointer :: enl_(:,:,:,:,:),enl_ndat_(:,:,:,:,:)
  real(dp), ABI_CONTIGUOUS pointer :: sij_(:,:)
  real(dp), ABI_CONTIGUOUS pointer :: kpgin_(:,:),kpgout_(:,:)
  logical :: nld_on_gpu

  logical :: transfer_vectin,transfer_vectout,transfer_svectout
  integer(C_SIZE_T) :: byte_count
  real(dp), ABI_CONTIGUOUS pointer :: vectin_(:,:),vectout_(:,:),svectout_(:,:)

! *************************************************************************

  ! We keep the same interface as nonlop, but we don't use many of those
  ABI_UNUSED((/ffnlin,ffnlout,gmet,kpgin,kpgout/))
  ABI_UNUSED((/ph3din,ph3dout/))
  ABI_UNUSED((/ucvol/))
  ABI_UNUSED((/mgfft/))
  ABI_UNUSED((/kptin,kptout/))
  ABI_UNUSED((/idir,nloalg,ngfft,kgin,kgout,ngfft,only_SO,tim_nonlop,gpu_option/))

  ! Check supported options
  if (.not.gemm_nonlop_use_gemm) then
    ABI_BUG('computation not prepared for gemm_nonlop use!')
  end if
  if ( (choice>3.and.choice/=7.and.choice/=5.and.choice/=51.and.signs==2) .or. &
&      (choice>3.and.choice/=7.and.choice/=23.and.choice/=4.and.choice/=54.and.choice/=55.and.choice/=6.and.signs==1) .or. &
&      (useylm/=1) ) then
    ABI_BUG('gemm_nonlop option not supported!')
  end if
  if (signs==1) then
    nnlout_test=0
    if (choice==1) nnlout_test=1
    if (choice==2) nnlout_test=3*natom
    if (choice==3) nnlout_test=6
    if (choice==23) nnlout_test=6+3*natom
    if (nnlout<nnlout_test) then
      ABI_BUG('wrong nnlout size!')
    end if
  end if

  ikin=1; ikout=1;
  select case (select_k)
  case (K_H_K)
    ikin=1; ikout=1;
  case (K_H_KPRIME)
    ikin=2; ikout=1;
  case (KPRIME_H_K)
    ikin=1; ikout=2;
  case (KPRIME_H_KPRIME)
    ikin=2; ikout=2;
  end select
  cplex=2;if (istwf_k>1) cplex=1
  cplex_enl=1;if (paw_opt>0) cplex_enl=2*dimenl1/(lmnmax*(lmnmax+1)) ! is enl complex?
  cplex_fac=max(cplex,dimekbq)
  if ((nspinortot==2.or.cplex_enl==2).and.paw_opt>0.and.choice/=7) cplex_fac=2 ! is vnl_projections complex?
  use_enl_ndat=.false. ; if (size(enl_ndat)>0) use_enl_ndat=.true.
  ndat_enl=1; if(use_enl_ndat) ndat_enl=ndat

  ! Processing one atom : set pointers to atom-specific arrays (for opernlc)
  if(iatom_only > 0) then
    iatm=atindx1(iatom_only);itypat=typat(iatom_only)
    ia_beg=iatom_only; ia_end=iatom_only
    natom_=1 ; ntypat_=1 ; dimenl2_=1 ; matblk_=1
    ABI_MALLOC(atindx1_,(1))
    ABI_MALLOC(nattyp_,(1))
    atindx1_(1)=1 ; nattyp_(1)=1
    ABI_MALLOC(ph3din_,(2,npwin,1))
    ABI_MALLOC(ph3dout_,(2,npwout,1))
    ph3din_(:,1:npwin,1)=ph3din(:,1:npwin,iatm)
    ph3dout_(:,1:npwout,1)=ph3dout(:,1:npwout,iatm)
    ABI_MALLOC(ffnlin_,(npwin,dimffnlin,lmnmax,1))
    ABI_MALLOC(ffnlout_,(npwout,dimffnlout,lmnmax,1))
    ffnlin_(:,:,:,1)=ffnlin(:,:,:,itypat)
    ffnlout_(:,:,:,1)=ffnlout(:,:,:,itypat)
    ABI_MALLOC(indlmn_,(6,lmnmax,1))
    indlmn_(:,:,1)=indlmn(:,:,itypat)
    if (size(sij)>0) then
      dimsij=size(sij,1)
      ABI_MALLOC(sij_,(dimsij,1))
      if (size(sij,2)==ntypat) then
        sij_(:,1)=sij(:,itypat)
      else if (size(sij)>0) then
        sij_(:,1)=sij(:,1)
      end if
    end if
    if (size(enl_ndat)>0) then
      ABI_MALLOC(enl_,(size(enl_ndat,1),1,nspinor**2,ndat,size(enl_ndat,5)))
      do idat=1,ndat
        do ii=1,size(enl_ndat,5)
          do ispden=1,nspinor**2
            if (dimenl2==natom .and. usepaw==1) then
              enl_(:,1,ispden,idat,ii)=enl_ndat(:,iatom_only,ispden,idat,ii)
            else if (dimenl2==ntypat) then
              enl_(:,1,ispden,idat,ii)=enl_ndat(:,itypat,ispden,idat,ii)
            else
              enl_(:,1,ispden,idat,ii)=enl_ndat(:,1,ispden,idat,ii)
            end if
          end do
        end do
      end do
    else if (size(enl)>0) then
      ABI_MALLOC(enl_,(size(enl,1),1,nspinor**2,size(enl,4),1))
      do ii=1,size(enl,4)
        do ispden=1,nspinor**2
          if (dimenl2==natom .and. usepaw==1) then
            enl_(:,1,ispden,ii,1)=enl(:,iatom_only,ispden,ii)
          else if (dimenl2==ntypat) then
            enl_(:,1,ispden,ii,1)=enl(:,itypat,ispden,ii)
          else
            enl_(:,1,ispden,ii,1)=enl(:,1,ispden,ii)
          end if
        end do
      end do
    else
      ABI_MALLOC(enl_,(0,0,0,0,0))
    end if

  ! Usual case : all atoms are processed
  else
    natom_  =natom; ntypat_=ntypat
    ia_beg=1; ia_end=natom
    dimenl2_=dimenl2   ; matblk_=matblk
    atindx1_    => atindx1
    nattyp_     => nattyp
    ffnlin_     => ffnlin
    ffnlout_    => ffnlout
    enl_(1:dimenl1,1:dimenl2,1:nspinortot**2,1:dimekbq,1:1)        => enl(:,:,:,:)
    if(use_enl_ndat) then
      enl_   => enl_ndat
    end if
    sij_        => sij
    indlmn_     => indlmn
    ph3din_     => ph3din
    ph3dout_    => ph3dout
  end if

  !Eventually re-compute (k+G) vectors (and related data)
  nkpgin_=0
  if (choice==2.or.choice==54) nkpgin_=3
  if (signs==1) then
    if (choice==4) nkpgin_=9
    if (choice==3.or.choice==23.or.choice==6) nkpgin_=3
    if (choice==55) nkpgin_=3
  end if
  if (nkpgin<nkpgin_) then
    ABI_MALLOC(kpgin_,(npwin,nkpgin_))
    call mkkpg(kgin,kpgin_,kptin,nkpgin_,npwin)
  else
    nkpgin_ = nkpgin
    kpgin_  => kpgin
  end if

  nkpgout_=0
  if ((choice==2.or.choice==3.or.choice==54).and.signs==2) nkpgout_=3
  if (nkpgout<nkpgout_) then
    ABI_MALLOC(kpgout_,(npwout,nkpgout_))
    call mkkpg(kgout,kpgout_,kptout,nkpgout_,npwout)
  else
    nkpgout_ = nkpgout
    kpgout_ => kpgout
  end if

  !$OMP TARGET ENTER DATA MAP(to:kpgin_,kpgout_)

  ! The number of projectors used for computation may vary among
  ! nonlop calls, from computing on all atoms to a select one for
  ! some perturbations.
  ! In such cases, projs arrays must be recomputed
  nprojs=0
  do itypat=1,ntypat_
    nprojs = nprojs + count(indlmn_(3,:,itypat)>0)*nattyp_(itypat)
  end do

  ! Allocate and copy GPU buffers if user doesn't manage them
  transfer_vectin=.not. xomp_target_is_present(c_loc(vectin)) &
      .and. ((cpopt < 2 .and. choice < 2) .or. (cpopt <= 3 .and. choice >= 2) &
      .or. (choice/=7 .and.paw_opt >=3))
  transfer_vectout=.not. xomp_target_is_present(c_loc(vectout)) &
      .and. (signs==2 .and. (paw_opt == 0 .or. paw_opt == 1 .or. paw_opt == 4))
  transfer_svectout=.not. xomp_target_is_present(c_loc(svectout)) &
      .and. (signs==2 .and. (paw_opt == 3 .or. paw_opt == 4))
  !$OMP TARGET ENTER DATA MAP(to:vectin)      IF(transfer_vectin)
  !$OMP TARGET ENTER DATA MAP(alloc:vectout)  IF(transfer_vectout)
  !$OMP TARGET ENTER DATA MAP(alloc:svectout) IF(transfer_svectout)

  !FIXME These seemingly useless pointers are used in BLAS operations for
  ! working around a bug in AOMP LLVM misreading mapped device pointers.
  ! I chose to generalise the workaround to avoid dupplicating each
  ! BLAS call specifically for handling AOMP LLVM.
  vectin_   => vectin
  vectout_  => vectout
  svectout_ => svectout

  !$OMP TARGET ENTER DATA MAP(to:atindx1,indlmn,enl_)
  if(size(enl_)>0) then
    !$OMP TARGET ENTER DATA MAP(to:enl_)
  end if
  if(gpu_initialised == 0 .or. mod__ndat /= ndat*nspinor .or. nprojs /= mod__nprojs &
  &    .or. cplex /= mod__cplex .or. cplex_fac /= mod__cplex_fac) then
    call alloc_work_buffers(cplex, cplex_fac,&
&        nspinor*ndat, nprojs, ntypat_, lmnmax, MAX(npwin,npwout))
  end if

  if(paw_opt>=2 .and. choice > 0 .and. choice /= 7) then
    if (cplex_enl==1) then
      do itypat=1, ntypat_
        nlmn=count(indlmn_(3,:,itypat)>0)
        do ilmn=1,nlmn*(nlmn+1)/2
          sij_typ(ilmn,itypat)=sij_(ilmn,itypat)
        end do
      end do
    else
      do itypat=1, ntypat_
        nlmn=count(indlmn_(3,:,itypat)>0)
        do ilmn=1,nlmn*(nlmn+1)/2
          sij_typ(ilmn,itypat)=sij_(2*ilmn-1,itypat)
        end do
      end do
    end if
  end if
  !$OMP TARGET UPDATE TO(sij_typ)

  if(nprojs == 0) then
    ! TODO check if this is correct
    if(signs == 1) then
      enlout=zero
      return
    end if
    if(signs == 2) then
      vectout = zero
      if(paw_opt>0) svectout = vectin
      return
    end if
  end if

  ndgxdt = -1
  nd2gxdt = -1

  ndgxdtfac = 0; nd2gxdtfac = 0
  if (choice==2) then
    if (signs==1) ndgxdt=3
    if (signs==2) ndgxdt=1
    if (signs==2) ndgxdtfac=1
  end if
  if (choice==22) then
    if (signs==2) ndgxdtfac=1
  end if
  if (choice==23) then
    if (signs==1) ndgxdt=9
  end if
  if (choice==3) then
    if (signs==1) ndgxdt=6
    if (signs==2) ndgxdt=1
    if (signs==2) ndgxdtfac=1
  end if
  if (choice==4) then
    if(signs==1) ndgxdt=3
    if(signs==1) ndgxdtfac=3
    if(signs==1) nd2gxdt=6
  end if
  if (choice==5) then
    if(signs==1) ndgxdt=3
    if(signs==2) ndgxdt=1
    if(signs==2) ndgxdtfac=1
  end if
  if (choice==51) then
    if(signs==1) ndgxdt=3
    if(signs==2) ndgxdt=1
    if(signs==2) ndgxdtfac=1
  end if
  if (choice==54) then
    if(signs==1) ndgxdt=6
    if(signs==1) ndgxdtfac=6
    if(signs==1) nd2gxdt=9
    if(signs==2) ndgxdt=1
    if(signs==2) nd2gxdt=1
    if(signs==2) ndgxdtfac=1
    if(signs==2) nd2gxdtfac=1
  end if
  if (choice==55) then
    if(signs==1) ndgxdt=9
    if(signs==1) ndgxdtfac=9
    if(signs==1) nd2gxdt=18
  end if
  if (choice==6) then
    if(signs==1) ndgxdt=9
    if(signs==1) ndgxdtfac=9
    if(signs==1) nd2gxdt=54
  end if
  ngrads=0; ngrads2=0
  if(ndgxdt>0) ngrads=ndgxdt; if(ndgxdt>0) ngrads2=nd2gxdt
  if(ndgxdt>0) then
    ABI_CHECK(ndgxdtfac<=ndgxdt,"BUG: ndgxdtfac>ndgxdt!")
  end if
  optder = 0;if (ndgxdtfac>0) optder = 1
  if (nd2gxdtfac>0) optder=2
  cplex_dgxdt(:) = 1 ; cplex_d2gxdt(:) = 1
  ! When istwf_k > 1, gx derivatives can be real or pure imaginary
  ! cplex_dgxdt(i)  = 1 if dgxdt(1,i,:,:)  is real, 2 if it is pure imaginary
  ! cplex_d2gxdt(i) = 1 if d2gxdt(1,i,:,:) is real, 2 if it is pure imaginary
  if(ndgxdt > 0) then
   if (choice==5.or.choice==51) cplex_dgxdt(:) = 2
   if (choice==54.and.signs==1) cplex_dgxdt(4:6) = 2
   !if (choice==54.and.signs==2) cplex_dgxdt(:)   = 2
   if (choice==55.and.signs==1) cplex_dgxdt(7:9) = 2
  end if
  if(nd2gxdt > 0) then
    if (choice==54) cplex_d2gxdt(:) = 2
    if (choice==55.and.signs==1) cplex_d2gxdt(1:18)= 2
  end if

  ! If vectproj is provided, use it for further calculations, use static array otherwise
  projections => projections_
  local_vectproj=.false.
  if(PRESENT(vectproj)) then
    if(size(vectproj)>1) local_vectproj=.true.
  end if
  if (local_vectproj) projections => vectproj

#ifdef HAVE_GPU_CUDA
  !Work buffers allocated at each call to save memory in CUDA
  !$OMP TARGET ENTER DATA MAP(alloc:s_projections,vnl_projections)
  if(.not. local_vectproj) then
    !$OMP TARGET ENTER DATA MAP(alloc:projections_)
  end if
#endif

  ! These will store the non-local factors for vectin, svectout and vectout respectively
  if(cpopt < 2) then
    call gpu_set_to_zero(projections,   int(cplex,c_size_t)*nprojs*ndat*nspinor)
  end if
  call gpu_set_to_zero(s_projections,   int(cplex,c_size_t)*nprojs*ndat*nspinor)
  call gpu_set_to_zero(vnl_projections, int(cplex_fac,c_size_t)*nprojs*ndat*nspinor)

  ! Working buffers for storing derivative
  if (ndgxdt>0) then
    ABI_MALLOC(dprojections,(cplex, ndgxdt*nprojs,nspinor*ndat))
    !$OMP TARGET ENTER DATA MAP(alloc:dprojections)
    if(cpopt < 4) then
      call gpu_set_to_zero(dprojections, int(cplex,c_size_t)*ndgxdt*nprojs*ndat*nspinor)
    end if
  else
    ABI_MALLOC(dprojections,(1,1,ndat))
  end if

  if (ndgxdtfac>0) then
    ABI_MALLOC(s_dprojections,(cplex, ndgxdtfac*nprojs,nspinor*ndat))
    ABI_MALLOC(vnl_dprojections,(cplex_fac, ndgxdtfac*nprojs,nspinor*ndat))
    !$OMP TARGET ENTER DATA MAP(alloc:s_dprojections,vnl_dprojections)
    call gpu_set_to_zero(s_dprojections,   int(cplex,c_size_t)*ndgxdtfac*nprojs*ndat*nspinor)
    call gpu_set_to_zero(vnl_dprojections, int(cplex_fac,c_size_t)*ndgxdtfac*nprojs*ndat*nspinor)
  else
    ABI_MALLOC(s_dprojections,(1,1,ndat))
    ABI_MALLOC(vnl_dprojections,(1,1,ndat))
  end if

  ! Working buffers for storing 2nd-derivative
  if (nd2gxdt>0) then
    ABI_MALLOC(d2projections,(cplex, nd2gxdt*nprojs, nspinor*ndat))
    !$OMP TARGET ENTER DATA MAP(alloc:d2projections)
    if(cpopt < 4) then
      call gpu_set_to_zero(d2projections, int(cplex,c_size_t)*nd2gxdt*nprojs*ndat*nspinor)
    end if
  else
    ABI_MALLOC(d2projections,(1, 1, ndat))
  end if

  if(nprojs == 0) then
    ! TODO check if this is correct
    if(signs == 1) then
      enlout=zero
      return
    end if
    if(signs == 2) then
      vectout = zero
      if(paw_opt>0) svectout = vectin
      return
    end if
  end if

  if(signs == 1 .and. choice > 0) then
    enlout=zero
    !$OMP TARGET ENTER DATA MAP(to:enlout)
    ABI_MALLOC(enlk,(ndat))
    enlk=zero
    !$OMP TARGET ENTER DATA MAP(to:enlk)
    ABI_MALLOC(fnlk,(3*natom,ndat))
    fnlk=zero
    !$OMP TARGET ENTER DATA MAP(to:fnlk)
    ABI_MALLOC(ddkk,(6,ndat))
    ddkk=zero
    !$OMP TARGET ENTER DATA MAP(to:ddkk)
    ABI_MALLOC(strnlk,(6,ndat))
    strnlk=zero
    !$OMP TARGET ENTER DATA MAP(to:strnlk)
  end if

  if(cpopt >= 2) then
    ! retrieve from cprjin
    if(.not. local_vectproj .and. cpopt/=3) then
      !$OMP PARALLEL DO PRIVATE(shift,idat,iatom,nlmn)
      do idat=1, ndat*nspinor
        shift = 0
        do iatom = ia_beg, ia_end
          nlmn = cprjin(iatom, idat)%nlmn
          projections(1:cplex, shift+1:shift+nlmn, idat) = cprjin(iatom, idat)%cp(1:cplex, 1:nlmn)
          shift = shift + nlmn
        end do
      end do
      !$OMP TARGET UPDATE TO(projections)
    end if
    if(cpopt==4.and.allocated(dprojections)) then
      ABI_CHECK(cprjin(1,1)%ncpgr>=ndgxdt,"cprjin%ncpgr not correct! (1)")
      ndgxdt_stored = cprjin(1,1)%ncpgr
      ishift=0
      if (((choice==2).or.(choice==3)).and.(ndgxdt_stored>ndgxdt).and.(signs==2)) ishift=idir-ndgxdt
      if ((choice==2).and.(ndgxdt_stored==9).and.(signs==2)) ishift=ishift+6
      if (choice==2.and.(ndgxdt_stored>ndgxdt).and.(signs==1)) ishift=ndgxdt_stored-ndgxdt
      !$OMP PARALLEL DO PRIVATE(shift,idat,iatom,igrad,nlmn)
      do idat=1, ndat*nspinor
        shift = 0
        do iatom = ia_beg, ia_end
          nlmn  = cprjin(iatom, idat)%nlmn
          do ilmn=1,nlmn
            do igrad=1,ndgxdt
              dprojections(1:cplex, shift + igrad, idat) = &
                cprjin(iatom, idat)%dcp(1:cplex,igrad+ishift,ilmn)
            end do
            shift = shift + ndgxdt
          end do
        end do
      end do
      !$OMP TARGET UPDATE TO(dprojections)
    end if
  end if ! cpopt

  if(cpopt<=1.or.(cpopt<=3.and.(choice==2.or.choice==3.or.choice==5.or.choice==51.or.choice==23.or.choice==54.or.choice==55.or.choice==4))) then

    call opernla_gemm(choice,cplex,cplex_dgxdt,cplex_d2gxdt,dimffnlin,&
    &       d2projections,dprojections,ffnlin,projections,&
    &       idir,indlmn,istwf_k,kpgin_,matblk,mpi_enreg,nd2gxdt,ndgxdt,nkpgin_,&
    &       npwin,nspinor,ph3din,signs,ucvol,ndat,ntypat,lmnmax,nattyp,(ikin==2),&
    &       iatom_only,atom_proj_shift,cpopt,&
    &       nprojs,&
    &       vectin,&
    &       temp_realvec_r,&
    &       gpu_option,gemm_nonlop_is_distributed)

    if(cpopt >= 0) then
      ! store in cprjin
      if(.not. local_vectproj .and. cpopt/=3) then
        !$OMP TARGET UPDATE FROM(projections)
        !$OMP PARALLEL DO PRIVATE(shift,idat,iatom,nlmn)
        do idat=1, ndat*nspinor
          shift = 0
          do iatom = ia_beg, ia_end
            nlmn = cprjin(iatom, idat)%nlmn
            cprjin(iatom, idat)%cp(1:cplex, 1:nlmn) = projections(1:cplex, shift+1:shift+nlmn, idat)
            shift = shift + nlmn
          end do
        end do
      end if
      if(cpopt==1 .or. cpopt==3) then
        ABI_CHECK(cprjin(1,1)%ncpgr>=ndgxdt,"cprjin%ncpgr not correct! (2)")
        !$OMP TARGET UPDATE FROM(dprojections)
        !$OMP PARALLEL DO PRIVATE(shift,idat,iatom,igrad,nlmn)
        do idat=1, ndat*nspinor
          shift = 0
          do iatom = ia_beg, ia_end
            nlmn = cprjin(iatom, idat)%nlmn
            do ilmn=1,nlmn
              do igrad=1,ndgxdt
                cprjin(iatom, idat)%dcp(1:cplex,igrad,ilmn) = &
                &                   dprojections(1:cplex, shift + igrad, idat)
              end do
              shift = shift + ndgxdt
            end do
          end do
        end do
      end if
    end if ! cpopt >= 0
  end if ! cpopt >= 2

  if(choice > 0) then

    if(choice /= 7) then
      ! opernlc
      iatm = 0
      shift = 0
      do itypat=1, ntypat_
        nlmn=count(indlmn_(3,:,itypat)>0)

        ibeg = shift+1
        iend = shift+nattyp_(itypat)*nlmn

        call opernlc_ylm_ompgpu(atindx1_,cplex,cplex_dgxdt,cplex_d2gxdt,&
        &         cplex_enl,cplex_fac,&
        &         dprojections,&
        &         vnl_dprojections,&
        &         s_dprojections,&
        &         d2projections,d2gxdt_dum_out,d2gxdt_dum_out2,&
        &         dimenl1,dimenl2_,dimekbq,enl_,&
        &         projections,&
        &         vnl_projections,&
        &         s_projections,&
        &         iatm,indlmn_,itypat,lambda,mpi_enreg,natom_,&
        &         ndgxdt,ndgxdtfac,nd2gxdt,nd2gxdtfac,&
        &         nattyp_(itypat),nlmn,nspinor,nspinortot,optder,paw_opt,sij_typ(:,itypat),&
        &         ndat,ibeg-1,iend,nprojs,ntypat,ndat_enl,gpu_option)

        shift = shift + nattyp_(itypat)*nlmn
        iatm = iatm+nattyp_(itypat)
      end do
    else
      call gpu_copy(s_projections, projections, int(cplex,c_size_t) * nprojs * nspinor * ndat)
    end if

    ! opernlb
    if(signs==2) then

      call opernlb_gemm(choice,cplex,cplex_dgxdt,cplex_d2gxdt,cplex_fac,&
      &       d2gxdt_dum_out,d2gxdt_dum_out,&
      &       vnl_dprojections,s_dprojections,dimffnlout,ffnlout,&
      &       vnl_projections,s_projections,&
      &       idir,indlmn,kpgout_,matblk,istwf_k,&
      &       nd2gxdt,nd2gxdtfac,ndgxdt,ndgxdtfac,&
      &       nkpgout_,npwout,nspinor,signs,ucvol,ndat,&
      &       ntypat,lmnmax,nattyp,(ikout==2),iatom_only,atom_proj_shift,&
      &       paw_opt,ph3dout,&
      &       nprojs,&
      &       vectin_,vectout_,svectout_,&
      &       temp_realvec_r,temp_realvec_i,&
      &       gpu_option,gemm_nonlop_is_distributed)
    end if

    ! opernld
    if(signs==1) then
      if(choice==1 .or. choice==2 .or. choice==3 .or. choice==23 .or. choice==4 .or. choice==54 .or. choice==55 .or. choice==6) then
        nld_on_gpu = .true.
        call opernld_ylm_allwf(choice,cplex,cplex_fac,ddkk,&
        &       dprojections,vnl_dprojections,s_dprojections,d2projections,&
        &       enlk,enlout,fnlk,projections,vnl_projections,s_projections,&
        &       natom,ndat,nd2gxdt,ndgxdt,&
        &       ndgxdtfac,indlmn_,ntypat_,lmnmax,nprojs,nnlout,nspinor,paw_opt,&
        &       strnlk,nattyp_,gpu_option)
      else
        shift=0; dshift=0; dfshift = 0; d2shift = 0; iatm=1
        nld_on_gpu = .false.
        !$OMP TARGET UPDATE FROM(dprojections,vnl_dprojections,s_dprojections)
        !$OMP TARGET UPDATE FROM(d2projections)
        !$OMP TARGET UPDATE FROM(projections,vnl_projections,s_projections)
        do itypat=1, ntypat_
          nlmn=count(indlmn_(3,:,itypat)>0)

          ibeg = shift+1
          iend = shift+nattyp_(itypat)*nlmn

          idbeg = dshift+1
          idend = dshift+nattyp_(itypat)*nlmn*ngrads

          idfbeg = dshift+1
          idfend = dshift+nattyp_(itypat)*nlmn*ndgxdtfac

          id2beg = d2shift+1
          id2end = d2shift+nattyp_(itypat)*nlmn*ngrads2

          do idat=1,ndat
            call opernld_ylm             (choice,cplex,cplex_fac,ddkk(:,idat),&
            &       dprojections    (:, idbeg:idend, 1+nspinor*(idat-1):nspinor*idat),&
            &       vnl_dprojections(:, idfbeg:idfend, 1+nspinor*(idat-1):nspinor*idat),&
            &       s_dprojections  (:, idfbeg:idfend, 1+nspinor*(idat-1):nspinor*idat),&
            &       d2projections (:, id2beg:id2end, 1+nspinor*(idat-1):nspinor*idat),&
            &       enlk(idat),enlout(nnlout*(idat-1)+1:nnlout*idat),fnlk(:,idat),&
            &       projections    (:, ibeg:iend, 1+nspinor*(idat-1):nspinor*idat),&
            &       vnl_projections(:, ibeg:iend, 1+nspinor*(idat-1):nspinor*idat),&
            &       s_projections  (:, ibeg:iend, 1+nspinor*(idat-1):nspinor*idat),&
            &       iatm,natom_,1,nd2gxdt,ndgxdt,ndgxdtfac,&
            &       nattyp_(itypat),nlmn,nnlout,nspinor,paw_opt,strnlk(:,idat))
          end do

          shift = shift + nattyp_(itypat)*nlmn
          dshift = dshift + nattyp_(itypat)*nlmn*ngrads
          dfshift = dshift + nattyp_(itypat)*nlmn*ndgxdtfac
          d2shift = d2shift + nattyp_(itypat)*nlmn*ngrads2
          iatm = iatm+nattyp_(itypat)
        end do
      end if

      ! Reduction in case of parallelism
      if (mpi_enreg%paral_spinor==1) then
        if (size(enlout)>0) then
          !$OMP TARGET UPDATE FROM(enlout) if(nld_on_gpu)
          call xmpi_sum(enlout,mpi_enreg%comm_spinor,ierr)
          !$OMP TARGET UPDATE TO(enlout) if(nld_on_gpu)
        end if
        if (choice==3.or.choice==23) then
          !$OMP TARGET UPDATE FROM(enlk) if(nld_on_gpu)
          call xmpi_sum(enlk,mpi_enreg%comm_spinor,ierr)
        end if
        if (choice==55) then
          call xmpi_sum(ddkk,mpi_enreg%comm_spinor,ierr)
        end if
      end if

      !Need sometimes gmet
      if ((signs==1.and.paw_opt<=3).and. &
          & (choice==5 .or.choice==51.or.choice==52.or.choice==53.or.&
          & choice==54.or.choice==55)) then
        ABI_MALLOC(gmet2,(3,3))
        gmet2 = MATMUL(TRANSPOSE(gprimd),gprimd)
      end if

      !Coordinate transformations

      ! Derivatives wrt strain
      !  - Convert from reduced to cartesian coordinates
      !  - Substract volume contribution
      if ((choice==3.or.choice==23).and.paw_opt<=3) then
        !$OMP TARGET UPDATE FROM(enlout,enlk) if(nld_on_gpu)
        do idat=1,ndat
          enlout_shift=(idat-1)*nnlout
          call strconv(enlout(enlout_shift+1:enlout_shift+6),gprimd,work)
          enlout(enlout_shift+1:enlout_shift+3)=(work(1:3)-enlk(idat))
          enlout(enlout_shift+4:enlout_shift+6)= work(4:6)
        end do
        !$OMP TARGET UPDATE TO(enlout) if(nld_on_gpu)
      end if

      !2nd derivative wrt to k wave vector and atomic position (effective charges):
      ! - convert from cartesian to reduced coordinates
      if (choice==54.and.signs==1.and.paw_opt<=3) then
        !$OMP TARGET UPDATE FROM(enlout) if(nld_on_gpu)
        ABI_MALLOC(work1,(3))
        ABI_MALLOC(work2,(3))
        do idat=1,ndat
          mu0=0 ! Shift to be applied in enlout array
          enlout_shift=(idat-1)*nnlout
          do mu=1,3*natom
        !   First, real part
            work1(1)=enlout(enlout_shift+mu0+1);work1(2)=enlout(enlout_shift+mu0+3);work1(3)=enlout(enlout_shift+mu0+5)
            work2(:)=gmet2(:,1)*work1(1)+gmet2(:,2)*work1(2)+gmet2(:,3)*work1(3)
            enlout(enlout_shift+mu0+1)=work2(1);enlout(enlout_shift+mu0+3)=work2(2);enlout(enlout_shift+mu0+5)=work2(3)
        !   Then imaginary part
            work1(1)=enlout(enlout_shift+mu0+2);work1(2)=enlout(enlout_shift+mu0+4);work1(3)=enlout(enlout_shift+mu0+6)
            work2(:)=gmet2(:,1)*work1(1)+gmet2(:,2)*work1(2)+gmet2(:,3)*work1(3)
            enlout(enlout_shift+mu0+2)=work2(1);enlout(enlout_shift+mu0+4)=work2(2);enlout(enlout_shift+mu0+6)=work2(3)
            mu0=mu0+6
          end do
        end do !idat
        ABI_FREE(work1)
        ABI_FREE(work2)
        !$OMP TARGET UPDATE TO(enlout) if(nld_on_gpu)
      end if

      !2nd derivative wrt to k wave vector and strain (piezoelectric tensor):
      ! - convert from cartesian to reduced coordinates (k point)
      ! - convert from reduced to cartesian coordinates (strain)
      ! - substract volume contribution
      ! - symetrize strain components
      if (choice==55.and.signs==1.and.paw_opt<=3) then
        !$OMP TARGET UPDATE FROM(enlout,ddkk) if(nld_on_gpu)
        ABI_MALLOC(work3,(2,3))
        ABI_MALLOC(work4,(2,3))
        ABI_MALLOC(work5,(2,3,6))
        ABI_MALLOC(work7,(2,3,6))
        ABI_MALLOC(work6,(2,3,3))
        do idat=1,ndat
          enlout_shift=(idat-1)*nnlout
          do ic=1,3 ! gamma
            work5=zero
            do jc=1,3 ! nu
              do ii=1,3 ! lambda
                mu=(gamma(jc,ii)-1)*3+1
                work5(1,jc,ii)=gmet2(ic,1)*enlout(enlout_shift+2*mu-1)+gmet2(ic,2)*enlout(enlout_shift+2*mu+1) &
       &         +gmet2(ic,3)*enlout(enlout_shift+2*mu+3)
                work5(2,jc,ii)=gmet2(ic,1)*enlout(enlout_shift+2*mu  )+gmet2(ic,2)*enlout(enlout_shift+2*mu+2) &
       &         +gmet2(ic,3)*enlout(enlout_shift+2*mu+4)
              end do
            end do
            work6=zero
            do jc=1,3 ! nu
              do ii=1,3 ! beta
                work6(1:cplex,ii,jc)=gprimd(ii,1)*work5(1:cplex,jc,1)+gprimd(ii,2)*work5(1:cplex,jc,2) &
       &         +gprimd(ii,3)*work5(1:cplex,jc,3)
              end do
            end do
            do jc=1,3 ! alpha
              do ii=1,3 ! beta
                mu=gamma(jc,ii)
                work7(1:cplex,ic,mu)=gprimd(jc,1)*work6(1:cplex,ii,1)+gprimd(jc,2)*work6(1:cplex,ii,2) &
       &         +gprimd(jc,3)*work6(1:cplex,ii,3)
              end do
            end do
          end do ! gamma

          do ii=1,3 ! alpha
            work3(1,ii)=gprimd(ii,1)*ddkk(2*1-1,idat)+gprimd(ii,2)*ddkk(2*2-1,idat) &
       &     +gprimd(ii,3)*ddkk(2*3-1,idat)
            work3(2,ii)=gprimd(ii,1)*ddkk(2*1  ,idat)+gprimd(ii,2)*ddkk(2*2  ,idat) &
       &     +gprimd(ii,3)*ddkk(2*3  ,idat)
          end do
          do ii=1,3 ! gamma
            work4(1,ii)=gmet2(ii,1)*ddkk(2*1-1,idat)+gmet2(ii,2)*ddkk(2*2-1,idat) &
       &     +gmet2(ii,3)*ddkk(2*3-1,idat)
            work4(2,ii)=gmet2(ii,1)*ddkk(2*1  ,idat)+gmet2(ii,2)*ddkk(2*2  ,idat) &
       &     +gmet2(ii,3)*ddkk(2*3  ,idat)
          end do

          do mu=1,6
            ii=alpha(mu) ! alpha
            ic=beta(mu) ! beta
            do jc=1,3 ! gamma
              work7(1:cplex,jc,mu)=work7(1:cplex,jc,mu)-half &
       &       *(gprimd(ic,jc)*work3(1:cplex,ii)+gprimd(ii,jc)*work3(1:cplex,ic))
              if (ii==ic) work7(1:cplex,jc,mu)=work7(1:cplex,jc,mu)-work4(1:cplex,jc)
            end do
          end do
          do mu=1,6 ! alpha,beta
            do nu=1,3 ! gamma
              mu0=3*(mu-1)+nu
              enlout(enlout_shift+2*mu0-1)=work7(1,nu,mu)
              enlout(enlout_shift+2*mu0  )=work7(2,nu,mu)
            end do
          end do
        end do !idat
        !$OMP TARGET UPDATE TO(enlout) if(nld_on_gpu)
        ABI_FREE(work3)
        ABI_FREE(work4)
        ABI_FREE(work5)
        ABI_FREE(work6)
        ABI_FREE(work7)
      end if


     !2nd derivative wrt to 2 strains (elastic tensor):
     ! - convert from reduced to cartesian coordinates
     ! - substract volume contribution
      if (choice==6.and.signs==1.and.paw_opt<=3) then
        !$OMP TARGET UPDATE FROM(enlout,enlk,strnlk,fnlk) if(nld_on_gpu)
        ABI_MALLOC(work1,(6))
        ABI_MALLOC(work2,(6))
        ABI_MALLOC(work3,(6+3*natom,6))
        do idat=1,ndat
          mu0=(idat-1)*nnlout ! Shift to be applied in enlout array
          work3(:,:)=reshape(enlout(mu0+1:mu0+6*(6+3*natom)),(/6+3*natom,6/))
          do mu=1,6
            call strconv(work3(1:6,mu),gprimd,work3(1:6,mu))
          end do
          do mu=1,6+3*natom
            work1(1:6)=work3(mu,1:6)
            call strconv(work1,gprimd,work2)
            work3(mu,1:6)=work2(1:6)
          end do
          enlout(mu0+1:mu0+6*(6+3*natom))=reshape(work3(:,:),(/6*(6+3*natom)/))
          call strconv(strnlk(:,idat),gprimd,strnlk(:,idat))
          do mub=1,6
            nub1=alpha(mub);nub2=beta(mub)
            do mua=1,6
              mu=mu0+mua+(3*natom+6)*(mub-1)
              nua1=alpha(mua);nua2=beta(mua)
              if (mua<=3.and.mub<=3) enlout(mu)=enlout(mu)+enlk(idat)
              if (mua<=3) enlout(mu)=enlout(mu)-strnlk(mub,idat)
              if (mub<=3) enlout(mu)=enlout(mu)-strnlk(mua,idat)
              if (nub1==nua2) enlout(mu)=enlout(mu)-0.25d0*strnlk(gamma(nua1,nub2),idat)
              if (nub2==nua2) enlout(mu)=enlout(mu)-0.25d0*strnlk(gamma(nua1,nub1),idat)
              if (nub1==nua1) enlout(mu)=enlout(mu)-0.25d0*strnlk(gamma(nua2,nub2),idat)
              if (nub2==nua1) enlout(mu)=enlout(mu)-0.25d0*strnlk(gamma(nua2,nub1),idat)
            end do
            if (mub<=3) then
              do nua1=1,natom
                nua2=3*(nua1-1);mu=mu0+nua2+6+(3*natom+6)*(mub-1)
                enlout(mu+1:mu+3)=enlout(mu+1:mu+3)-fnlk(nua2+1:nua2+3,idat)
              end do
            end if
          end do
        end do
        ABI_FREE(work1)
        ABI_FREE(work2)
        ABI_FREE(work3)
        !$OMP TARGET UPDATE TO(enlout) if(nld_on_gpu)
      end if

    end if !opernld

  end if ! choice>0

  ! Retrieve and release allocated buffers
  !$OMP TARGET EXIT DATA MAP(delete:vectin) IF(transfer_vectin)
  !$OMP TARGET EXIT DATA MAP(from:vectout)   IF(transfer_vectout)
  !$OMP TARGET EXIT DATA MAP(from:svectout)  IF(transfer_svectout)

#ifdef HAVE_GPU_CUDA
  !$OMP TARGET EXIT DATA MAP(delete:s_projections,vnl_projections)
  if(.not. local_vectproj) then
    !$OMP TARGET EXIT DATA MAP(delete:projections_)
  end if
#endif

  if(size(enl_)>0) then
    !$OMP TARGET EXIT DATA MAP(delete:enl_)
  end if
! Release memory

  if (iatom_only>0) then
    ABI_FREE(atindx1_)
    ABI_FREE(nattyp_)
    ABI_FREE(ph3din_)
    ABI_FREE(ph3dout_)
    ABI_FREE(ffnlin_)
    ABI_FREE(ffnlout_)
    ABI_FREE(enl_)
    ABI_FREE(indlmn_)
    if (size(sij) > 1) then
      ABI_FREE(sij_)
    end if
  end if

  if(signs == 1 .and. choice > 0) then
    !$OMP TARGET EXIT DATA MAP(delete:enlk)
    ABI_FREE(enlk)
    !$OMP TARGET EXIT DATA MAP(delete:fnlk)
    ABI_FREE(fnlk)
    !$OMP TARGET EXIT DATA MAP(delete:strnlk)
    ABI_FREE(strnlk)
    !$OMP TARGET EXIT DATA MAP(delete:ddkk)
    ABI_FREE(ddkk)
    !$OMP TARGET UPDATE FROM(enlout) if(nld_on_gpu)
    !$OMP TARGET EXIT DATA MAP(delete:enlout)
  end if

  !$OMP TARGET EXIT DATA MAP(delete:kpgin_,kpgout_)

  if (nkpgin<nkpgin_) then
    ABI_FREE(kpgin_)
  end if
  if (nkpgout<nkpgout_) then
    ABI_FREE(kpgout_)
  end if

  if (allocated(gmet2)) then
    ABI_FREE(gmet2)
  end if

  !$OMP TARGET EXIT DATA MAP(delete:atindx1,indlmn)
  if (allocated(dprojections)) then
    !$OMP TARGET EXIT DATA MAP(delete:dprojections) IF(ndgxdt>0)
    ABI_FREE(dprojections)
  end if
  if (allocated(s_dprojections)) then
    !$OMP TARGET EXIT DATA MAP(delete:s_dprojections) IF(ndgxdtfac>0)
    ABI_FREE(s_dprojections)
  end if
  if (allocated(vnl_dprojections)) then
    !$OMP TARGET EXIT DATA MAP(delete:vnl_dprojections) IF(ndgxdtfac>0)
    ABI_FREE(vnl_dprojections)
  end if
  if (allocated(d2projections)) then
    !$OMP TARGET EXIT DATA MAP(delete:d2projections) IF(nd2gxdt>0)
    ABI_FREE(d2projections)
  end if

 end subroutine gemm_nonlop_ompgpu
!***


#else
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!! stubs for compiling with OpenMP GPU offload disabled.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 subroutine gemm_nonlop_ompgpu(atindx1,choice,cpopt,cprjin,dimenl1,dimenl2,dimekbq,dimffnlin,dimffnlout,&
&                 enl,enl_ndat,enlout,ffnlin,ffnlout,gmet,gprimd,idir,indlmn,istwf_k,&
&                 kgin,kgout,kpgin,kpgout,kptin,kptout,lambda,lmnmax,matblk,mgfft,&
&                 mpi_enreg,natom,nattyp,ndat,ngfft,nkpgin,nkpgout,nloalg,&
&                 nnlout,npwin,npwout,nspinor,nspinortot,ntypat,only_SO,paw_opt,&
&                 ph3din,ph3dout,signs,sij,svectout,&
&                 tim_nonlop,ucvol,useylm,vectin,vectout,&
&                 atom_proj_shift,select_k,iatom_only,typat,usepaw,&
&                 vectproj,gpu_option)

  !Arguments ------------------------------------
  !scalars
  integer,intent(in) :: choice,cpopt,dimenl1,dimenl2,dimekbq,dimffnlin,dimffnlout,idir
  integer,intent(in) :: istwf_k,lmnmax,matblk,mgfft,natom,ndat,nkpgin
  integer,intent(in) :: nkpgout,nnlout,npwin,npwout,nspinor,nspinortot,ntypat,only_SO
  integer,intent(in) :: paw_opt,signs,tim_nonlop,useylm,atom_proj_shift,select_k,iatom_only,usepaw
  integer,optional,intent(in) :: gpu_option
  real(dp),intent(in) :: lambda(ndat),ucvol
  type(MPI_type),intent(in) :: mpi_enreg
  !arrays
  integer,intent(in),target :: atindx1(natom),indlmn(6,lmnmax,ntypat),kgin(3,npwin)
  integer,intent(in),target :: kgout(3,npwout),nattyp(ntypat),ngfft(18),nloalg(3),typat(natom)
  real(dp),intent(in),target :: enl(:,:,:,:),enl_ndat(:,:,:,:,:)
  real(dp),intent(in),target :: ffnlin(npwin,dimffnlin,lmnmax,ntypat)
  real(dp),intent(in),target :: ffnlout(npwout,dimffnlout,lmnmax,ntypat),gmet(3,3)
  real(dp),intent(in) :: gprimd(3,3),kptin(3),kptout(3)
  real(dp),intent(in),target :: kpgin(npwin,nkpgin*useylm),kpgout(npwout,nkpgout*useylm)
  real(dp),intent(in),target :: sij(dimenl1,ntypat*((paw_opt+1)/3))
  real(dp),intent(inout),target :: ph3din(2,npwin,matblk),ph3dout(2,npwout,matblk)
  real(dp),intent(inout),target :: vectin(2,npwin*nspinor*ndat)
  real(dp),intent(inout) :: enlout(nnlout*ndat)
  real(dp),intent(out),target :: svectout(:,:)
  real(dp),intent(inout),target :: vectout(:,:)
  real(dp),intent(inout),optional, ABI_CONTIGUOUS target :: vectproj(:,:,:)
  type(pawcprj_type),intent(inout) :: cprjin(natom,nspinor*((cpopt+5)/5)*ndat)

  ABI_UNUSED((/choice,cpopt,dimenl1,dimenl2,dimekbq,dimffnlin,dimffnlout,idir/))
  ABI_UNUSED((/istwf_k,lmnmax,matblk,mgfft,natom,ndat,nkpgin,atom_proj_shift/))
  ABI_UNUSED((/nkpgout,nnlout,npwin,npwout,nspinor,nspinortot,ntypat,only_SO/))
  ABI_UNUSED((/paw_opt,signs,tim_nonlop,useylm,gpu_option,usepaw,select_k,iatom_only/))
  ABI_UNUSED((/atindx1,indlmn,kgin,kgout,nattyp,ngfft,nloalg,typat/))
  ABI_UNUSED((/enl,enl_ndat,ffnlin,ffnlout,gmet,gprimd,kpgin,kpgout,kptin,kptout/))
  ABI_UNUSED((/ucvol,lambda,sij,ph3din,ph3dout,vectin,enlout,svectout,vectout,vectproj/))
  ABI_UNUSED_A(cprjin)
  ABI_UNUSED_A(mpi_enreg)
  ABI_BUG("Unhandled configuration for OpenMP GPU immplementation")

 end subroutine gemm_nonlop_ompgpu

#endif

end module m_gemm_nonlop_ompgpu
!!***
