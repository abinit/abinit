- !variable
    abivarname: a2fsmear@anaddb
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 2.0E-5
    dimensions: scalar
    excludes: null
    mnemonics: Alpha2F SMEARing factor
    requires: null
    text: |-
        <p>Smearing width for the Eliashberg alpha^2F function
        (similar to a phonon DOS), which is sampled on a finite q and k grid. The Dirac delta
        functions in energy are replaced by Gaussians of width <b>a2fsmear</b>
        (by default in Hartree).
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: accuracy
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ACCURACY
    requires: null
    text: |-
        <p>
        Allows to tune the accuracy of a calculation by setting automatically the variables [[ecut]],  [[boxcutmin]], [[fband]],
         [[tolvrs]], [[tolmxf]],
         [[optforces]], [[timopt]], [[npulayit]],
         [[nstep]], [[prteig]], [[prtden]], and if [[usepaw]]=1,  [[pawecutdg]],
         [[bxctmindg]], [[pawxcdev]], [[pawmixdg]],
         [[pawovlp]], [[pawnhatxc]], according to the following table:

         <p style="margin-left: 40px;">
          <table style="border: medium none ; border-collapse: collapse; width: 549px; height: 102px;" summary="Input file examples">
            <tbody>
              <tr style="height: 33.45pt;">

                <td style="border-style: solid solid solid solid;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.45pt; font-weight: bold">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent" ><small>accuracy</small></p>
                </td>

                <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 1 </small></p>
                </td>

                <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 2 </small></p>
                 </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 3 </small></p>
                </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 4 </small></p>
                </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 5 </small></p>
                </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 6 </small></p>
                </td>
              </tr>

              <tr style="height: 33.45pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.45pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>E_min</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>E_med</small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>E_med</small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>E_max</b></small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>E_max</b></small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>E_max</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawecutdg</small></p>
                </small></td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.2*ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1.5*ecut</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2*ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2*ecut</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>fband</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0.75</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0.75</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>boxcutmin</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.5</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>bxctmindg</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.5</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawxcdev</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawmixdg</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawovlp</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>10</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>7</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>7</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawnhatxc</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>


             <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>tolvrs</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-3</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-5</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-7</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-9</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-10</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-12</small></p>
                </td>
              </tr>

             <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>tolmxf</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-3</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>5.0d-4</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-4</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5.0d-5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-6</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-6</small></p>
                </td>
              </tr>


             <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>optforces</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 1</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>
              </tr>


            <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>timopt</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>npulayit</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 4</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>7</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>7</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>7</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>15</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>15</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>nstep</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> <b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>50</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>50</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>prteig</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>prtden</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>

            </tbody>
          </table>
          </p>
        <br>For a parallel calculation, [[timopt]] is enforced to be 0.
        <br>E_min, E_med and E_max may be read from the pseudopotential file (available only for XML PAW atomic data files). If E_min, E_med and E_max are not given in the pseudopotential file, [[ecut]] must be given in the input file and E_max=E_med=E_max=ecut.
        <br>The values in bold font are the default values of ABINIT. [[accuracy]]=4 corresponds to the default tuning of ABINIT. It is already a very accurate tuning.
        <br>If the user wants to modify one of the input variable automatically tuned by [[accuracy]], he must put it in the input file. The other input variables automatically tuned by [[accuracy]] will not be affected.
        <br />
        [[accuracy]]=0 means that this input variable is desactivated.

        <p>
    topics: Planewaves_basic, SCFControl_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: acell
    characteristics:
    - '[[EVOLVING]]'
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: represented internally as acell(3,[[nimage]])
    defaultval: !multiplevalue
        number: 3
        value: 1
    dimensions:
    - 3
    excludes: null
    mnemonics: CELL lattice vector scaling
    requires: null
    text: |-
        <p>
         Gives the length scales by which
        dimensionless primitive translations (in [[rprim]]) are
        to be multiplied.  By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[acell]] has the
        '[[LENGTH]]' characteristics.
        See further description of [[acell]] related to the
        [[rprim]] input variable,
        the [[scalecart]] input variable,
        and the associated internal [[rprimd]] input variable.
        </p>
        <p>
         Note that [[acell]] is NOT the length of the conventional orthogonal basis vectors, but the scaling factors of the primitive vectors.
        Use [[scalecart]] to scale the cartesian coordinates.
        </p>
    topics: UnitCell_basic
    varset: basic
    vartype: real
- !variable
    abivarname: adpimd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ADiabatic Path-Integral Molecular Dynamics
    requires: '[[imgmov]]==9 or [[imgmov]]==13'
    text: |-
        <p>
         Controls whether adiabatic Path-Integral Molecular Dynamics is performed or not.
         <br />
         The corresponding adiabaticity parameter is given by [[adpimd_gamma]].
         <br />
         <br />
         If equal to 0, no adiabatic Path-Integral Molecular Dynamics (standard PIMD) is performed.
         <br />
         If equal to 1, adiabatic Path-Integral Molecular Dynamics is activated.
         <br />
         Only relevant with [[pitransform]]=1 (normal mode transformation). In that case,
         <br />
         - the mass associated with to the zero-frequency mode is the true mass [[amu]],
         <br />
         - the mass associated to the other higher frequency modes of the polymer chains is equal to the normal mode mass divided by
        [[adpimd_gamma]] (adiabaticity parameter),
         <br />
         - the equation of motion on the zero-frequency mode is not thermostated.
         <br />
         NOT YET USABLE
        </p>
    topics: PIMD_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: adpimd_gamma
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'ADiabatic Path-Integral Molecular Dynamics: GAMMA factor'
    requires: '[[adpimd]]==1 and [[imgmov]] in [9,13]'
    text: |-
        <p>
         Adiabaticity parameter to be used in adiabatic Path-Integral Molecular Dynamics.
         <br />
         NOT YET USABLE
        </p>
    topics: PIMD_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: algalch
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 1
    dimensions:
    - '[[ntypalch]]'
    excludes: null
    mnemonics: ALGorithm for generating ALCHemical pseudopotentials
    requires: null
    text: |-
        <p>
         Used for the generation of alchemical pseudopotentials, that is,
        when [[ntypalch]] is non-zero.
        </p>
        <p>
         Give the algorithm to be used to
        generate the [[ntypalch]] alchemical potentials
        from the different [[npspalch]] pseudopotentials
        dedicated to this use.
        </p>
        <p>
         Presently, [[algalch]] can only have the value 1, that is :
         <ul>
          <li>
           the local potentials are mixed, thanks to the [[mixalch]]
        mixing coefficients
          </li>
          <li>
           the form factors of the non-local projectors are all preserved, and all considered
        to generate the alchemical potential
          </li>
          <li>
           the scalar coefficients of the non-local projectors are multiplied by the proportion
        of the corresponding type of atom that is present in [[mixalch]]
          </li>
          <li>
           the characteristic radius for the core charge is a
        linear combination of the characteristic radii of the core charges,
        build with the [[mixalch]] mixing
        coefficients
          </li>
          <li>
           the core charge function f(r/rc) is a linear combination
        of the core charge functions, build with the [[mixalch]]
        mixing coefficients
          </li>
         </ul>
         Later, other algorithms for the mixing might be included.
        </p>
        <p>
         Note that alchemical mixing cannot be used with PAW.
        </p>
    topics: AtomTypes_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: alphon@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ALign PHONon mode eigendisplacements
    requires: null
    text: |-
        <p>In case <b>alphon</b> is set to 1, ANADDB will compute linear combinations of
        the eigendisplacements of modes that are degenerate (twice or three times),
        in order to align the mode effective charges along the cartesian axes.
        This option is useful in the mode-by-mode decomposition of the electrooptic tensor, and to compute
        the Raman susceptibilities of individual phonon modes.
        In case of uniaxial crystals, the z-axis should be chosen along the optical axis.
    topics: nonlinear_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: amu
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: provided by a database of atomic masses.
    commentdims: null
    defaultval: null
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: Atomic Mass Units
    requires: null
    text: |-
        <p>
         Gives the masses in atomic mass units for each kind
        of atom in cell. These masses are used in performing
        molecular dynamical atomic motion if
        [[ionmov]]=1, 6, 7 or 8.
        They are also used in phonon calculations, in the diagonalization of the dynamical matrix.
        Note that one may set all masses to 1 for certain cases
        in which merely structural relaxation is desired and not
        actual molecular dynamics.
        </p>
        <p>
         Using 1986 recommended values, 1 atomic mass unit =
        1.6605402e-27 kg.
        In this unit the mass of Carbon 12 is exactly 12.
        </p>
        <p>
         A database of atomic masses is provided, giving
        default values.
        Note that the default database uses mixed isotope masses (for Carbon
        the natural occurrence of Carbon 13 is taken into account).
        The values are those recommended by the commission on Atomic Weights
        and
        Isotopic Abundances, Inorganic Chemistry Division, IUPAC, in
         <i>
          Pure Appl. Chem.
         </i>
         <b>
          60
         </b>
         , 841 (1988).
        For Tc, Pm, Po to Ac, Pa and beyond U,
        none of the isotopes has a half-life greater than 3.0d10 years, and
        the values provided in the database do not come from that source.
        </p>
        <p>
         For alchemical pseudoatoms, the masses of the constituents
        atoms are mixed, according to the alchemical mixing
        coefficients [[mixalch]]
        </p>
        <p>
         In most cases, the use of [[amu]]
        will be as a static (non-evolving) variable. However, the possibility to have
        different values of [[amu]] for different images has been coded. A population of
        cells with different atomic characteristics can thus be considered,
        and can be made to evolve, e.g. with a genetic algorithm (not coded in v7.0.0 though).
        </p>
    topics: PIMD_useful, Phonons_useful, AtomTypes_basic, Artificial_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: angdeg
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: deduced from '[[rprim]]'
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    excludes: null
    mnemonics: ANGles in DEGrees
    requires: null
    text: |-
        <p>
         Gives the angles between directions of
        primitive vectors of the unit cell (in degrees),
        as an alternative to the input array [[rprim]] .
        Will be used to set up [[rprim]],
        that, together with the array [[acell]], will be used to define the
        primitive vectors.
         <ul>
          <li>
           [[angdeg]](1) is the angle between the 2nd and 3rd vectors,
          </li>
          <li>
           [[angdeg]](2) is the angle between the 1st and 3rd vectors,
          </li>
          <li>
           [[angdeg]](3) is the angle between the 1st and 2nd vectors,
          </li>
         </ul>
         If the three angles are equal within 1.0d-12 (except if they are exactly 90 degrees),
        the three primitive
        vectors are chosen so that the trigonal symmetry that exchange
        them is along the z cartesian axis :
         <pre>
        R1=( a , 0,c)
        R2=(-a/2, sqrt(3)/2*a,c)
        R3=(-a/2,-sqrt(3)/2*a,c)
         </pre>
         where a
         <sup>
          2
         </sup>
         +c
         <sup>
          2
         </sup>
         =1.0d0
         <br />
         If the angles are not all equal (or if they are all 90 degrees), one will have the following
        generic form :
         <ul>
          <li>
           R1=(1,0,0)
          </li>
          <li>
           R2=(a,b,0)
          </li>
          <li>
           R3=(c,d,e)
          </li>
         </ul>
         where each of the vectors is normalized,
        and form the desired angles with the others.
        </p>
    topics: UnitCell_useful
    varset: basic
    vartype: real
- !variable
    abivarname: asr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Acoustic Sum Rule
    requires: null
    text: |-
        Govern the imposition of the Acoustic Sum Rule (ASR) in phonon calculations. Same meaning as the corresponding anaddb variable.
    topics: DFPT_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: asr@anaddb
    characteristics: null
    commentdefault: was 0 before v5.3
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Acoustic Sum Rule
    requires: null
    text: |-
        <p>Govern the imposition of the Acoustic Sum Rule (ASR).
        <ul>
        <li>  0 => no ASR for interatomic force constants is imposed.</li>
        <li>  1 or 2 => the ASR for interatomic force constants
        is imposed by modifying the on-site interatomic force constants,
        in a symmetric way (<b>asr</b>=2), or in the more general case, unconstrained way (<b>asr</b>=1).</li>
        </ul>
        <p>

        More detailed explanations: the total energy should be
        invariant under translation of the crystal as a whole. This
        would guarantee that the three lowest phonon modes at Gamma
        have zero frequency (Acoustic Sum Rule - ASR).
        Unfortunately, the way the DDB is
        generated (presence of a discrete grid of points for the
        evaluation of the exchange-correlation potential and energy)
        slightly breaks the translational invariance.
        Well, in some pathological cases, the breaking can be rather important.

        <p>Two quantities are affected: the interatomic forces
        (or dynamical matrices), and the effective charges.
        The ASR for the effective charges is called the charge
        neutrality sum rule, and will be dealt with by the variable
        [[anaddb:chneut]].
        The ASR for the interatomic forces can be restored,
        by modifying the interatomic force of the atom on itself,
        (called self-IFC), as soon as the dynamical matrix at Gamma is known.
        This quantity should be equal to minus the sum of all interatomic
        forces generated by all others atoms (action-reaction law!),
        which is determined by the dynamical matrix at Gamma.
        <p>
        So, if <b>asr</b> is non-zero, the correction to the self-force
        will be determined, and the self-force will be imposed to be consistent with the ASR.
        This correction will work if IFCs are computed
        ([[anaddb:ifcflag]]/=0),
        as well as if the IFCs are not computed
        ([[anaddb:ifcflag]]==0).
        In both cases, the phonon frequencies will not be the same
        as the ones determined by the output of abinit, RF case.
        If you want to check that the DDB is correct, by comparing
        phonon frequencies from abinit and anaddb, you should turn off both <b>asr</b> and
        [[anaddb:chneut]].

        <p>Until now, we have not explained the difference between
        <b>asr</b>=1 and <b>asr</b>=2.
        This is rather subtle.
        In some local low-symmetry cases (basically the effective charges should be anisotropic),
        when the dipole-dipole contribution is evaluated and subtracted,
        the ASR cannot be imposed without breaking the
        symmetry of the on-site interatomic forces. That explains why two
        options are given: the second case (<b>asr</b>=2, sym) does not
        entirely impose the ASR, but simply the part that keeps the on-site
        interatomic forces symmetric (which means that the acoustic frequencies
        do not go to zero exactly), the first case (<b>asr</b>=1, asym)
        imposes the ASR, but breaks the symmetry.
        <b>asr</b>=2 is to be preferred for the analysis of the interatomic force
        constant in real space, while <b>asr</b>=1 should be used to get the phonon band structure.
        </p>
        <p>(NOTE: in order to confuse even more the situation,
        it seems that the acoustic phonon frequencies generated by the code
        for both the sym and asym options are exactly the same ...
        likely due to an extra symmetrisation in the diagonalisation routine.
        Of course, when the matrix at Gamma has been generated from IFCs coming from dynamical
        matrices none of which are Gamma, the breaking of the ASR is rather severe.
        In order to clear the situation, one should use a diagonalisation
        routine for non-hermitian matrices. So, at the present status of
        understanding, one should always use the <b>asr</b>=2 option ).
        <br>
    topics: Phonons_basic, PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: atftol@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.05
    dimensions: scalar
    excludes: null
    mnemonics: ATomic Temperature Factor TOLerance
    requires: null
    text: |-
        <p>The relative tolerance on the atomic temperature factors.
        This number will determine when the series of channel widths
        with which the DOS is calculated can be stopped, i.e.
        the mean of the relative change going from one grid
        to the next bigger is smaller than <b>wtol2</b>.
    topics: Temperature_expert
    varset: anaddb
    vartype: real
- !variable
    abivarname: atifc@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - array '[[anaddb:natifc]]'
    excludes: null
    mnemonics: AToms for IFC analysis
    requires: null
    text: |-
        <p>The actual numbers of the atoms for which the interatomic
        force constant have to be written and eventually analysed.
        <br>
        <p>WARNING: there will be an in-place change of meaning of atifc (this is
        confusing, and should be taken away in one future version - sorry for this).
    topics: PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: atom@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: index of ATOM
    requires: null
    text: |-
        Index of the investigated atom.
    topics: Bader_basic
    varset: aim
    vartype: integer
- !variable
    abivarname: atrad@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: bader ATomic RADius
    requires: null
    text: |-
        A first estimation of the Bader radius (not too
          important - it is used only two times)
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: atvshift
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0d0
    dimensions:
    - '[[natvshift]]'
    - '[[nsppol]]'
    - '[[natom]]'
    excludes: null
    mnemonics: ATomic potential (V) energy SHIFTs
    requires: '[[usepawu]] /= 0 and [[natvshift]] in [5,7]'
    text: |-
        <p>
         Defines for each atom and each spin channel (at present, can only be used
        with [[nsppol]]=1 or 2, like the +U scheme),
        a possible potential shift, for the d
        (with [[lpawu]]=2,
        [[natvshift]]=5),
        or f states
        (with [[lpawu]]=3,
        [[natvshift]]=7).
        In the case of d states, and 2 spin channels, a set of 10 numbers for
        each atom must be defined.
        The first set of 5 numbers corresponds to real spherical harmonics
        m=-2 to m=+2 for the spin-up channel,
        the second set of 5 numbers corresponds to real spherical harmonics
        m=-2 to m=+2 for the spin-down channel.
        In the case of f states, the same ordering applies, for sets of 7 numbers,
        corresponding to m=-3 to m=+3.
         <br />
         [[usepawu]] should be non-zero,
        [[lpawu]] should be 2 or 3.
        </p>
    topics: DFT+U_expert
    varset: ffield
    vartype: real
- !variable
    abivarname: autoparal
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: AUTOmatisation of the PARALlelism
    requires: null
    text: |-
        <p>
         This input variable is used only when running ABINIT in parallel and for Ground-State calculations.
         <br />
         It controls the automatic determination of parameters related to parallel work distribution (if not imposed in input file).
        Given a total number of processors, ABINIT can find a suitable distribution that fill (when possible)
        all the different levels of parallelization. ABINIT can also determine optimal parameters for
        the use of parallel Linear Algebra routines (using Scalapack or Cuda, at present).
         <br />
         The different values for [[autoparal]] are:
         <ul>
          <li>
           <b>
            0:
           </b>
           The [[autoparal]] feature is deactivated. For ground-state  and response function calculations,
        ABINIT can only activate automatically the parallelism over spins and k-points.
          </li>
          <li>
           <b>
            1:
           </b>
           The number of processors per parallelization level is determined by mean of
        a simple (but relatively efficient) heuristic. A scaling factor is attributed to each level
        and an simple speedup factor is computed. The selected parameters are those giving the best speedup factor.
           <br />
           Possibly concerned parameters: [[npimage]], [[npkpt]],
        [[npspinor]], [[npfft]],
        [[npband]], [[bandpp]].
          </li>
          <li>
           <b>
            2:
           </b>
           The number of processors per parallelization level is first determined by mean of
        a simple (but relatively efficient) heuristic (see 1 above). Then the code performs a series
        of small benchmarks using the scheme applied for the LOBPCG algorithm
        (see: [[wfoptalg]]=4 or 14). The parallel distribution is then
        changed according to the benchmarks.
           <br />
           Possibly concerned parameters: [[npimage]], [[npkpt]],
        [[npspinor]], [[npfft]],
        [[npband]], [[bandpp]].
          </li>
          <li>
           <b>
            3:
           </b>
           Same as [[autoparal]]=1, plus automatic determination of Linear Algebra routines parameters.
           <br />
           In addition, the code performs a series of small benchmarks using the Linear Algebra routines
        (ScaLapack or Cuda-GPU). The parameters used to optimize Linear Algebra work distribution
        are then changed according to the benchmarks.
           <br />
           Possibly concerned parameters (in addition to those modified for [[autoparal]]=1):
        [[use_slk]], [[np_slk]],
        [[gpu_linalg_limit]]
          </li>
          <li>
           <b>
            4:
           </b>
           combination of [[autoparal]]=2 and [[autoparal]]=3.
          </li>
         </ul>
         Note that [[autoparal]]=1 can be used on every set of processors; [[autoparal]] &gt; 1 should be used on a sufficiently large number of MPI process.
         <br />
         Also note that [[autoparal]] can be used simultaneously with
        [[max_ncpus]]; in this case, ABINIT performs
        an optimization of process distribution for each total number of processors from 2
        to [[max_ncpus]].
        A weight is associated to each distribution and the higher this weight is the better the distribution is.
        After having printed out the weights, the code stops.
        </p>
    topics: parallelism_basic
    varset: paral
    vartype: integer
- !variable
    abivarname: awtr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: evaluate the Adler-Wiser expression of $\chi^{0}_{KS}$ assuming Time-Reversal
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         This input variable defines whether the irreducible polarizability $\chi^{0}_{KS}$ is evaluated
        taking advantage of time-reversal symmetry or not.
         <ul>
          <li>
           0 =&gt; Use the "standard" Adler-Wiser expression without assuming time-reversal symmetry.
        In this case, the irreducible polarizability is calculated summing over all possible electronic
        transitions (both resonant and antiresonant).
          </li>
          <li>
           1 =&gt; Take advantage of time-reversal symmetry to halve the number of transitions to be
        explicitly considered. This method leads to a decrease in the CPU time by a factor two with respect
        to the [[awtr]]=0 case.
          </li>
         </ul>
        </p>
        <p>
         Note that the parallel algorithm [[gwpara]]=2 is not compatible with
        the choice [[awtr]]=0.
        </p>
    topics: Susceptibility_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: band_gap@anaddb
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 999.0
    dimensions: scalar
    excludes: null
    mnemonics: BAND GAP
    requires: null
    text: |-
        <p>Allow setting the target band gap, in eV.
        ([[elphflag@anaddb]]=1).
        <p>NOTE XG20170811 : apparently no effective test for this input variable. Also, the descirption is strange ...!
    topics: ElPhonTransport_expert
    varset: anaddb
    vartype: real
- !variable
    abivarname: bandpp
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: BAND Per Processor
    requires: '[[paral_kgb]]==1'
    text: |-
        <p>
         Control the size of the block in the LOBPCG algorithm.
        This keyword works only with [[paral_kgb]]=1 and has to be either 1 or a multiple of 2.
         <br />
         <br />
         -- With [[npband]]=1:
         <ul>
          <li>
           1 =&gt; band-per-band algorithm
          </li>
          <li>
           n =&gt; The minimization is performed using [[nband]]/n blocks of n bands.
          </li>
         </ul>
         Note: [[nband]]/n has to be an integer.
         <br />
         <br />
         -- With [[npband]]/=1:
         <ul>
          <li>
           1 =&gt; The minimization is performed using [[nband]]/[[npband]] blocks of [[npband]] bands.
          </li>
          <li>
           n =&gt; The minimization is performed using [[nband]]/([[npband]]*n) blocks of [[npband]]*n bands.
          </li>
         </ul>
         Note: [[nband]]/([[npband]]*n) has to be an integer.
         <br />
         <br />
         By minimizing a larger number of bands together in LOBPCG, we increase the convergency of the residual.
        The better minimization procedure (as concerns the convergency, but not as concerns the speed) is generally
        performed by using [[bandpp]]*[[npband]]=[[nband]].
        Put [[bandpp]]=2 when [[istwfk]]=2 (the time spent in FFTs is divided by two).
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: bdberry
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 4
        value: 0
    dimensions:
    - 4
    excludes: null
    mnemonics: BanD limits for BERRY phase
    requires: '[[berryopt]] in [1, 2, 3] and [[nberry]] > 0'
    text: |-
        <p>
         Give the lower band and the upper band of the set of bands
        for which the Berry phase must be computed.
        Irrelevant if [[nberry]] is not positive.
        When [[nsppol]] is 1 (no spin-polarisation),
        only the two first numbers, giving the lower and highest
        bands, are significant. Their occupation number is assumed to be 2.
        When [[nsppol]] is 2 (spin-polarized calculation),
        the two first numbers give the lowest and highest
        bands for spin up, and the third and fourth numbers
        give the lowest and highest bands for spin down.
        Their occupation number is assumed to be 1 .
        </p>
        <p>
         Presently, [[bdberry]] MUST be initialized by the user
        in case of a Berry phase calculation with [[berryopt]] = 1, 2, or 3: the above-mentioned
        default will cause an early exit.
        </p>
    topics: Berry_basic
    varset: ffield
    vartype: integer
- !variable
    abivarname: bdeigrf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -1
    dimensions: scalar
    excludes: null
    mnemonics: BanD for second-order EIGenvalues from Response-Function
    requires: '[[ieig2rf]] in [1,2,3,4,5]'
    text: |-
        <p>
        that is, if the user is performing second-order eigenvalue calculations using response-functions.
         <br />
         <br />
         The variable [[bdeigrf]] is the maximum number of bands for which the second-order eigenvalues must be calculated: the full number of bands is still used during the computation of these corrections.
         <br />
         <br />
         If [[bdeigrf]] is set to -1, the code will automatically set [[bdeigrf]] equal to nband.
        </p>
    topics: TDepES_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: bdgw
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - 2
    - '[[nkptgw]]'
    - '[[nsppol]]'
    excludes: null
    mnemonics: BanDs for GW calculation
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         For each k-point with number ikptgw in the range (1:[[nkptgw]]) and each
        spin index isppol,
         <b>
          bdgw(1,ikptgw,isppol)
         </b>
         is the number of the lowest band for which the GW computation must be done,
        and
         <b>
          bdgw(2,ikptgw,isppol)
         </b>
         is the number of the highest band for which the GW computation must be done.
        </p>
        <p>
         When [[gwcalctyp]] &#62;&#61; 20,
        the quasiparticle wavefunctions are computed and represented as linear combination of Kohn-Sham wavefunctions.
        In this case [[bdgw]] designates the range of KS wavefunctions used as basis set.
        For each k-point, indeed, the quasiparticle wavefunctions are expanded considering only the KS states between
         <b>
          bdgw(1,ikptgw,isppol)
         </b>
         and
         <b>
          bdgw(2,ikptgw,isppol)
         </b>
         .
        </p>
        <p>
        Note that the initial values given in the input file might be changed inside the code so that all
        the degenerate states at a given k-point and spin are included.
        This might happen when [[symsigma]]=1 is used or in the case of
        self-consistent GW calculations.
        </p>
        <p>
         When [[symsigma]]=1, the diagonal matrix elements of the
        self-energy are obtained by averaging the unsymmetrized results in the subspace spanned by the degenerate states.
        </p>
        <p>
         For self-consistent calculations, on the other hand, the basis set used to expand the GW
        wavefunctions should include all the degenerate states belonging to the same irreducible
        representation. Only in this case, indeed, the initial symmetries and energy degenerations are preserved.
        </p>
    topics: GW_basic, SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: berryopt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: BERRY phase OPTions
    requires: null
    text: |-
        <p>
         Specifies the use of Berry phase for the computation
        of either the polarization, the derivatives with respect to the
        wavevector, or finite electric field calculations.
         <ul>
          <li>
           0 =&gt; no computation of expressions relying on a Berry phase (default)
          </li>
          <li>
           1 =&gt; the computation of Berry phases is activated (berryphase routine)
          </li>
          <li>
           2 =&gt; the computation of derivatives with respect to the wavevector,
        thanks to the Berry phase finite-difference formula, is activated (uderiv routine)
          </li>
          <li>
           3 =&gt; same as option 1 and 2 together
          </li>
        <B>Note that options 1 to 3 require the use of a serial build of Abinit.</B>
         <li>
           -1 =&gt; alternative computation of Berry phases (berryphase_new routine)
          </li>
          <li>
           -2 =&gt; alternative computation of derivatives with respect to the wavevector,
        thanks to the Berry phase finite-difference formula (berryphase_new routine)
          </li>
          <li>
           -3 =&gt; same as option -1 and -2 together
          </li>
        <B>Options -1 to -3 permit use of a parallel build and will be preferred by most users.</B>
          <li>
           4 =&gt; finite electric field calculation (unreduced E-field)
          </li>
          <li>
           6 =&gt; finite electric displacement field calculation (unreduced D-field)
          </li>
          <li>
           14 =&gt; finite reduced electric field calculation
          </li>
          <li>
           16 =&gt; finite electric displacement field calculation
          </li>
          <li>
           17 =&gt; mixed electric boundary condition: finite reduced electric field in some directions, finite reduced electric displacement field along other directions. See variable [[jfielddir]] for more details.
          </li>

         </ul>
        </p>
        <p>
         Other related input variables are :
         <ul>
          <li>
           in case of [[berryopt]]=1,2, or 3 : [[bdberry]]
        and [[kberry]]; also, [[nberry]]
        must be larger than 0;
          </li>
          <li>
           in case of [[berryopt]]=-1,-2, or -3 : the variable
        [[rfdir]] must be used to specify the primitive
        vector along which the projection of the polarization or the ddk will be computed.
        For example if [[berryopt]]=-1 and [[rfdir]]=1 0 0,
        the projection of the polarization along the reciprocal lattice vector
        G_1 is computed. In case [[rfdir]]=1 1 1,
        ABINIT computes the projection of P along G_1, G_2 and G_3 and transforms the results
        to cartesian coordinates;
          </li>
          <li>
           in cases where [[berryopt]] is negative, [[berrystep]]
        allow a computation of multiple-step Berry phase in order to accelerate the convergence.
          </li>
          <li>
           [[efield]] and
        [[rfdir]] in case of [[berryopt]]=4 ;
          </li>
         </ul>
        </p>
        <p>
         The cases [[berryopt]]=-1,-2,-3, 4, 6, 7, 14, 16, and 17 have to be used with [[occopt]]=1.
        </p>
        <p>
         The cases [[berryopt]]=-1 and 4, 6, 7, 14, 16, 17 are compatible with PAW, howevever, if in these cases one uses
        [[kptopt]]/=3, one must also use only symmorphic symmetries (either because the space group is
        symmorphic or the variable [[symmorphi]] is set to zero).
        </p>
        <p>
         For a phonon calculation under a finite electric field, respect the following procedure.
         <ul>
          <li>
           1. Run a scf ground-state calculation at zero electric field
        to get wavefunctions to initialize the ground-state calculation in finite electric fields.
          </li>
          <li>
           2. Run a scf ground-state calculation in finite electric field. The
        electric field is controlled by the input variable [[efield]].
        [[berryopt]] should be 4.
        The input variable [[kptopt]] should be set to be 2.
          </li>
          <li>
           3. Based on the wave functions obtained in step (2), perform phonon
        calculation by setting [[berryopt]]=4, [[kptopt]]=3 and
        The same value of [[efield]] than in step 2.
        [[nsym]] should be set to 1 currently but this restriction may be
        removed later . The other
        parameters are the same as phonon calculation at zero electric field.
          </li>
          <li>
           Note : the choice of k-point sampling N x N x N should be the same in the three runs
        and N should be an even number.
          </li>
         </ul>
        </p>
        <p>
         In case of finite electric and displacement field calculations ([[berryopt]]=4,6,7,14,16,17), see also the input variables
        [[berrysav]], [[dfield]],
        [[red_dfield]], [[red_efield]],
        [[ddamp]]
        </p>
    topics: Berry_compulsory
    varset: ffield
    vartype: integer
- !variable
    abivarname: berrysav
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: BERRY SAVe
    requires: null
    text: |-
        <p>
         <ul>
          <li>
           0 =&gt; for finite electric field calculation ([[berryopt]]=4/14), the polarization branch will be chosen on each iteration from (-pi, pi);
        for finite electric displacement field calculation([[berryopt]]=6/7/16/17), the polarization will be chosen to minimize the internal energy.
          </li>
          <li>
           1 =&gt; the polarization will be kept in the same branch on each iteration. At the end of the run, a file "POLSAVE" will be saved containing the reduced polarization in atomic units. Note: Make sure that "POLSAVE" is empty or it does not exist before the calculation, or else that it specifies the desired polarization branch.
          </li>
         </ul>
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: integer
- !variable
    abivarname: berrystep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'BERRY phase : multiple STEP'
    requires: 0 > [[berryopt]]
    text: |-
        <p>
         If [[berryopt]] is negative,
        this variable is used to compute berry phases using multiple discrete steps, in order to accelerate convergence. The single-step berry phase
        is the standard calculation using strings of k-points based on overlap of Bloch function separated by dk, while the two-step
        berry phase use strings use overlaps based on dk and 2*dk, the three-step use overlaps based on dk, 2*dk and 3*dk...
        </p>
        <p>
         The default value of this variable is 1, meaning that only the single-step berry phase calculation is done.
        If a larger value is set, ABINIT will compute all the multiple-step berry phase from the single-step to the
        [[berrystep]]-step, and use the large-step values of berry phase to correct the single-step berry phase.
        Use with care: while experience is still to be gained with this procedure, the outlook is promising.
        </p>
    topics: Berry_expert
    varset: ffield
    vartype: integer
- !variable
    abivarname: bfield
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: finite B FIELD calculation
    requires: null
    text: |-
        <p>
         Perform finite magnetic field calculation. <br><b>THIS CODE IS UNDER DEVELOPMENT AND IS NOT READY FOR USE.</b>
        </p>
    topics: MagField_expert
    varset: ffield
    vartype: real
- !variable
    abivarname: bmass
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: Barostat MASS
    requires: null
    text: |-
        <p>
         bmass is the mass of the barostat when
        [[ionmov]]=13 (constant pressure molecular dynamics)
        </p>
    topics: MolecularDynamics_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: boxcenter
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.5
    - 0.5
    - 0.5
    dimensions:
    - 3
    excludes: null
    mnemonics: BOX CENTER
    requires: null
    text: |-
        <p>
         Defines the center of the box, in reduced coordinates.
        At present, this information is only used in the case of
        Time-Dependent DFT computation of the oscillator strength.
        One must take boxcenter such as to be roughly the center of
        the cluster or molecule. The default is sensible when
        the vacuum surrounding the cluster or molecule has xred 0 or 1.
        On the contrary, when the cluster or molecule is close to
        the origin, it is better to take [[boxcenter]]=(0 0 0).
        </p>
    topics: TDDFT_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: boxcutmin
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    dimensions: scalar
    excludes: null
    mnemonics: BOX CUT-off MINimum
    requires: null
    text: |-
        <p>
         The box cut-off ratio is the ratio between the wavefunction plane wave sphere
        radius, and the radius of the sphere that can be inserted in the
        FFT box, in reciprocal space. In order for the density to be exact
        (in the case of plane wave, not PAW), this ratio should be at least two.
        If one uses a smaller ratio, one will gain speed, at the expense of accuracy.
        In case of pure ground state calculation (e.g. for the determination
        of geometries), this is sensible. However,
        the wavefunctions that are obtained CANNOT be used for starting response function
        calculation.
        </p>
    topics: Planewaves_useful, TuningSpeed_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: brav@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: BRAVais
    requires: null
    text: |-
        <p>Allows to specify the Bravais lattice of the crystal,
        in order to help to generate a grid of special q points.
        <p></p>
        <ul>
        <li> 1 =&gt; all the lattices (including FCC, BCC
        and hexagonal) </li>
        <li> 2 =&gt; specific for Face Centered lattices </li>
        <li> 3 =&gt; specific for Body Centered lattices </li>
        <li> 4 =&gt; specific for the Hexagonal lattice </li>
        </ul>
        <p>
        Note that in the latter case, the rprim of
        the unit cell have to be 1.0 0.0 0.0 -.5 sqrt(3)/2 0.0 0.0 0.0 1.0
        in order for the code to work properly.
        <p> Warning: the generation of q-points in anaddb is rather
        old-fashioned, and should be replaced by routines used by the main abinit code.
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: broadening@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-3 Ha
    dimensions: scalar
    excludes: null
    mnemonics: BROADENING
    requires: null
    text: |-
        In Eq. 46 of <a href="../../users/generated_files/help_optic.html#Ref1">Ref. 1</a>, it is clear that when ever wnm(k) is equal to w,
          there is a resonance. Numerically this would lead to an infinity. In order to
          avoid this one could do two things. You could change the sum over k-points to
          integration and then use linear tetrahedron method (see <a href="../../users/generated_files/help_optic.html#Ref2">Ref. 2</a> for
          details). Another way to get around the problem is, like we do in the present
          case, avoid this singularity by adding a small complex number to the denominator.
          This prevents the denominator from ever going to 0 and acts as a broadening to
          the spectrum. The broadening should not be too large as this would wash out the
          features in the spectrum.
    topics: Optic_basic
    varset: optic
    vartype: real
- !variable
    abivarname: brvltt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: BRaVais LaTTice type
    requires: '[[spgroup]] != 0'
    text: |-
        <p>
         Set the type of Bravais lattice.
        The cell defined by [[acell]]
        and [[rprim]] or [[angdeg]]
        should be the CONVENTIONAL cell.
        </p>
        <p>
         If brvltt=0, the code will assign
        brvltt from the space group information
        [[spgroup]],
        and produce the symmetry operations for the conventional unit cell.
        If the conventional cell is not primitive, the user should
        set [[chkprim]]=0.
        </p>
        <p>
         If brvltt=-1, the code will assign brvltt from
        the space group information, then reduce the unit cell
        to a primitive unit cell. The echo of [[acell]]
        and [[rprim]] might thus differ from those
        derived directly from the input variables.
        Also, the input variable
        [[xred]] will refer to the
        CONVENTIONAL unit cell, but its echo will refer to the
        preprocessed PRIMITIVE unit cell.
        There is of course no problem with
        [[xangst]] and
        [[xcart]], as they are independent
        of the unit cell.
        </p>
        <p>
         The echo of [[brvltt]] in the output file will be one
        of the following Bravais lattices:
         <br />
         <ul>
          <li>
           1 = Primitive with no associated translations
          </li>
          <li>
           2 = Inner centered with (a/2 + b/2 + c/2)
        associated translation
          </li>
          <li>
           3 = Face centered with (a/2 + b/2; b/2 + c/2; c/2 + a/2)
        associated translations
          </li>
          <li>
           4 = C - centered with (a/2 + b/2) associated translation
          </li>
          <li>
           5 = A - centered with (b/2 + c/2) associated translation
          </li>
          <li>
           6 = B - centered with (c/2 + a/2) associated translation
          </li>
          <li>
           7 = Rhombohedral lattice.
          </li>
         </ul>
         The user might also input directly these values, although
        they might not be consistent
        with [[spgroup]].
        </p>
        <p>
         The space groups 146, 148, 155, 160, 161, 166, 167, when used
        with [[spgaxor]]=1 (hexagonal axes) will have [[brvltt]]=7
        and two associated translations: (2/3, 1/3, 1/3) and
        (1/3, 2/3, 2/3).
         <br />
         For more details see the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         .
        </p>
    topics: UnitCell_useful, SmartSymm_basic
    varset: geo
    vartype: integer
- !variable
    abivarname: bs_algorithm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter ALGORITHM
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
         The bs_algorithm input variable defines the algorithm employed to calculate the macroscopic dielectric function.
        Possible values are 1, 2 or 3:
         <ul>
          <li>
           1 =&gt;
        The macroscopic dielectric is obtained by performing a direct diagonalization of the excitonic Hamiltonian.
        Advantages: It gives direct access to the excitonic eigenvalues as well as to the oscillator strengths.
        Drawbacks: It is a very CPU- and memory-consuming approach as the size of the Hamiltonian scales as (nk*nc*nv)**2.
        where nk is the number of k-point in the FULL Brillouin zone, and nc and nv are the number of
        conduction and valence states, respectively.
        Pros: It can be used both for resonant-only and resonant+coupling calculations (non Tamm-Dancoff approximation).
          </li>
          <li>
           2 =&gt;
        Haydock iterative method. The macroscopic dielectric function
        is obtained by iterative applications of the Hamiltonian on a set of vectors in the electron-hole space.
        Advantages: It is less memory demanding and usually faster
        than the direct diagonalization provided that [[zcut]] is larger than the typical
        energy spacing of the eigenvalues. Drawbacks: It is an iterative method therefore
        the convergence with respect to bs_haydock_niter should be checked.
        It is not possible to have direct information on the exciton spectrum, oscillator strengths and excitonic wave functions.
        For the time being [[bs_algorithm]]=2 cannot be used for calculations in which the coupling term is included (Tamm-Dancoff approximation).
          </li>
          <li>
           3 =&gt;
        Conjugate-gradient method. This method allows to find the few first excitonic eigenvalues.
        Only available for resonant calculations (Tamm-Dancoff approximation).
          </li>
         </ul>
        </p>
    topics: BSE_basic
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_calctype
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter CALCulation TYPE
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
         Possible values are 1,2,3.
         <ul>
          <li>
           1 =&gt; use the KS eigenvalues and wave functions stored in the KSS file
        to construct the transition space
          </li>
          <li>
           2 =&gt; The transition space is constructed with Kohn-Sham orbitals
        but the energies are read from the external GW file
          </li>
          <li>
           3 =&gt; QP amplitudes and energies will be read from the QPS file and used to construct H_ex.
        Not coded yet because &lt;\psi|r|\psj&gt;^QP should be calculated taking into account the non-locality of
        the self-energy in the commutator [H,r].
          </li>
         </ul>
        </p>
    topics: BSE_expert
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_coulomb_term
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 11
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter COULOMB TERM
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
        This variable governs the choice among the different options that are available for the treatment
        of Coulomb term of the Bethe-Salpeter Hamiltonian.
        [[bs_coulomb_term]] is the concatenation of two digits, labelled (A) and (B).
        </p>
        <p>
         The first digit (A) can assume the values 0,1,2:
         <ul>
          <li>
           0 =&gt; The Coulomb term is not computed. This choice is equivalent to computing the RPA
        spectrum but using the representation in transition space instead of the
        more efficient approach based on the sum over states.
          </li>
          <li>
           1 =&gt; The Coulomb term is computed using the screened interaction read from an external SCR file
        (standard excitonic calculation).
          </li>
          <li>
           2 =&gt; The Coulomb term is computed using a model screening function
        (useful for convergence studies or for reproducing published results).
          </li>
         </ul>
        </p>
        <p>
         The second digit (B) can assume the values 0,1:
         <ul>
          <li>
           0 =&gt;
        Use a diagonal approximation for W_GG' (mainly used for accelerating convergence studies).
          </li>
          <li>
           1 =&gt;
        The Coulomb term is correctly evaluated using the truly non-local W(r,r').
          </li>
         </ul>
        </p>
    topics: BSE_expert
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_coupling
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter COUPLING
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
         The [[bs_coupling]] input variable defines the treatment of the coupling block of the
        Bethe-Salpeter Hamiltonian. Possible values are 0,1.
         <ul>
          <li>
           0 =&gt;
        The coupling block is neglected (the so-called Tamm-Dancoff approximation). The code runs faster and the Hamiltonian matrix requires
        less memory (factor 4). It is a good approximation for the absorption spectrum
        which only requires the knowledge of Im(\epsilon). The reliability of this
        approximation should be tested in the case of EELF calculations.
          </li>
          <li>
           1 =&gt;
        The coupling term is included (non Tamm-Dancoff approxmation).
          </li>
         </ul>
        </p>
    topics: BSE_useful
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_eh_cutoff
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - -.inf
    - .inf
    dimensions:
    - 2
    excludes: null
    mnemonics: Bethe-Salpeter Electron-Hole CUTOFF
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
         It is used to define a cutoff in the e-h basis set. Only those transitions whose
        energy is between bs_eh_window(1) and bs_eh_window(2) will be considered during
        the construction of the e-h Hamiltonian.
        </p>
    topics: BSE_expert
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_exchange_term
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter EXCHANGE TERM
    requires: '[[optdriver]] == 99'
    text: |-
        <p><ul>
        <li>0 =&gt;The exchange term is not calculated. This is equivalent to neglecting local field effects
        in the macroscopic dielectric function.</li>
        <li>1 =&gt;The exchange term is calculated and added to the excitonic Hamiltonian.
         </li></ul></p>
    topics: BSE_expert
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_freq_mesh
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    - 0.01
    dimensions:
    - 3
    excludes: null
    mnemonics: Bethe-Salpeter FREQuency MESH
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
        <b>bs_freq_mesh(1)</b> defines the first frequency for the calculation of the macroscopic dielectric function.
        <p>
        <b>bs_freq_mesh(2)</b> gives the last frequency for the calculation of the macroscopic dielectric function.
        If zero, <b>bs_freq_mesh(2)</b> is set automatically to MAX(resonant_energy) + 10%.
        <p>
        <b>bs_freq_mesh(3)</b> gives the step of the linear mesh used for evaluating the macroscopic dielectric function.
        </p>
    topics: BSE_basic
    varset: bse
    vartype: real
- !variable
    abivarname: bs_hayd_term
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter HAYdock TERMinator
    requires: '[[optdriver]] == 99 and [[bs_algorithm]]==2'
    text: |-
        <p>
         Defines how to terminate the continued fraction expression for the dielectric function.
        The terminator reduces the number of iterations needed to converge by smoothing the oscillation
        in the high energy part of the spectrum
         <ul>
          <li>
           0 =&gt;
        No terminator. The contribution given by the terms missing in the Lanczos chain are set to zero.
          </li>
          <li>
           1 =&gt; Use the terminator function. The particular expression depends on the type of calculation:
        In the resonant-only case, the a_i and b_i coefficients for i &gt; niter,
        are replaced by their values at i=niter.
        Even the coupling block is included, the terminator function described in D. Rocca, R. Gebauer, Y. Saad, S. Baroni, J. Chem. Phys.
        128, 154105 (2008) is used.
          </li>
         </ul>
        </p>
    topics: BSE_expert
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_haydock_niter
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter HAYDOCK Number of ITERations
    requires: '[[optdriver]] == 99 and [[bs_algorithm]]==2'
    text: |-
        <p>
         [[bs_haydock_niter]] defines the maximum number of iterations used to calculate the macroscopic dielectric function.
        The iterative algorithm stops when the difference between two consecutive evaluations of the optical
        spectra is less than [[bs_haydock_tol]].
        </p>
    topics: BSE_expert
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_haydock_tol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.02
    - 0
    dimensions:
    - 2
    excludes: null
    mnemonics: Bethe-Salpeter HAYDOCK TOLerance
    requires: '[[optdriver]] == 99 and [[bs_algorithm]]==2'
    text: |-
        <p>
         Defines the convergence criterion for the Haydock iterative method.
        The iterative algorithm stops when the difference between two consecutive evaluations of the
        macroscopic dielectric function is less than
         <b>
          bs_haydock_tol(1)
         </b>
         .
        The sign of
         <b>
          bs_haydock_tol(1)
         </b>
         defines how to estimate the convergence error.
        A negative value signals that the converge should be reached for each frequency (strict criterion),
        while a positive value indicates that the converge error is estimated
        by averaging over the entire frequency range (mild criterion).
        </p>
        <p>
        <b>bs_haydock_tol(2)</b> defines the quantity that will be checked for convergence:
         <ul>
          <li>
           0 &rarr; both the real and the imaginary part must converge
          </li>
          <li>
           1 &rarr; only the real part
          </li>
          <li>
           2 &rarr; only the imaginary part
          </li>
         </ul>
        </p>
    topics: BSE_expert
    varset: bse
    vartype: real
- !variable
    abivarname: bs_interp_kmult
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Bethe-Salpeter INTERPolation K-point MULTiplication factors
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    text: |-
        <p>
         [[bs_interp_kmult]] defines the number of divisions used to generate the dense mesh in the interpolation.
        [[ngkpt]] of the dense mesh =
         <b>
          bs_interp_kmult(:)
         </b>
         * [[ngkpt]] of the coarse mesh.
        </p>
    topics: BSE_useful
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_interp_m3_width
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter INTERPolation Method3 WIDTH
    requires: '[[bs_interp_mode]]==3 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    text: |-
        Defines the width of the region where divergence treatment is applied for BSE interpolation
    topics: BSE_useful
    varset: bse
    vartype: real
- !variable
    abivarname: bs_interp_method
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter INTERPolation METHOD
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    text: |-
        <p>
         [[bs_interp_method]] selects the method of interpolation:
         <ul>
          <li>
           0 =&gt; Interpolate using Y. Gillet technique with 8 neighbours (see Comput. Phys. Commun. 203, 83 (2016))
          </li>
          <li>
           1 =&gt; Interpolation using Rohlfing & Louie technique (see above-mentioned article and Phys. Rev. B 62, 4927 (2000))
          </li>
         </ul>
        </p>
    topics: BSE_useful
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_interp_mode
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter INTERPolation MODE
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    text: |-
        <p>
         [[bs_interp_mode]] selects the mode of interpolation:
         <ul>
          <li>
           0 =&gt; No interpolation. Standard Bethe-Salpeter computation is performed
          </li>
          <li>
           1 =&gt; Simple interpolation
          </li>
          <li>
           2 =&gt; Treatment of the divergence on the whole set of dense k-points
          </li>
          <li>
           3 =&gt; Treatment of the divergence along the diagonal in k-space and simple interpolation elsewhere.
          </li>
         </ul>
        </p>
    topics: BSE_basic
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_interp_prep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter INTERPolation PREParation
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    text: |-
        <p>
         [[bs_interp_prep]] allows to trigger the preparation of the interpolation with method 2 or method 3.
        It generates the decomposition of BSR in a,b,c coefficients used for the interpolation.
        </p>
    topics: BSE_useful
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_interp_rl_nb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter INTERPolation Rohlfing & Louie NeighBour
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_interp_method]]
        == 1 and [[bs_coupling]]==0'
    text: |-
        Gives the index of the neighbour that is used for Rohlfing & Louie method
    topics: BSE_useful
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_loband
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[nsppol]]'
    excludes: null
    mnemonics: Bethe-Salpeter Lowest Occupied BAND
    requires: '[[optdriver]] == 99'
    text: |-
        <p>
         This variable defines the index of the lowest occupied band used for the construction of the electron-hole basis set.
        For spin polarized calculations, one must provide two separated indices for spin up and spin down.
        An additional cutoff energy can be applied by means of the bs_eh_window input variable.
        </p>
    topics: BSE_compulsory
    varset: bse
    vartype: integer
- !variable
    abivarname: bs_nstates
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Bethe-Salpeter Number of STATES
    requires: '[[optdriver]] == 99 and [[bs_algorithm]] in [2,3]'
    text: |-
        <p>
         [[bs_nstates]] defines the maximum number of excitonic states calculated in
        the direct diagonalization of the excitonic matrix or in the conjugate-gradient method.
        The number of states should be sufficiently large
        for a correct description of the optical properties in the frequency range of interest.
        </p>
    topics: BSE_basic
    varset: bse
    vartype: integer
- !variable
    abivarname: builtintest
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: BUIT-IN TEST number
    requires: null
    text: |-
        <p>
        When [[builtintest]] is non-zero, the input file is a special one, that runs very quickly,
        and that is accompanied by a specific analysis by ABINIT, at the end of the run, against
        a hard-coded value of total energy (and possibly stresses, forces ...).
        The echo of the analysis is done in the STATUS file.
        In particular, such built-in tests can be used to check quickly
        whether ABINIT fallbacks have been connected or not (bigdft, etsf_io, libxc, wannier90).
        At present, [[builtintest]]=1 ... 7 are allowed. See more information in tests/built-in/README .
        </p>
    topics: Control_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: bxctmindg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    dimensions: scalar
    excludes: null
    mnemonics: BoX CuT-off MINimum for the Double Grid (PAW)
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         The box cut-off ratio is the ratio between the wavefunction plane wave
        sphere radius, and the radius of the sphere that can be inserted in the FFT box,
        in reciprocal space.
         <br />
         If the density was generated only from wavefunctions,
        this ratio should be at least two in order for the density to be exact. If one
        uses a smaller ratio, one will gain speed, at the expense of accuracy. In case
        of pure ground state calculation (e.g. for the determination of geometries),
        this is sensible. However, the wavefunctions that are obtained CANNOT be used
        for starting response function calculation.
         <br />
         However, some augmentation charge is always added in PAW, and even with the box cut-off
        ratio larger than two, the density is never exact. Sometimes, this ratio must be
        much larger than two for the computation to be converged at the
        required level of accuracy.
        </p>
    topics: PAW_expert
    varset: paw
    vartype: real
- !variable
    abivarname: cd_customnimfrqs
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Contour Deformation CUSTOM IMaginary FReQuencieS
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[gwcalctyp]] in [2,9,12,19,22,29]
    text: |-
        <p>
         [[cd_customnimfrqs]] lets the user define the grid points along the imaginary axis by hand. Set this
        to the number of frequencies you want. The frequencies are specified with [[cd_imfrqs]].
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: cd_frqim_method
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Contour Deformation FReQuency integration on IMaginary axis Method
    requires: '[[optdriver]]==4  and [[gwcalctyp]] in [2,9,12,19,22,29]'
    text: |-
        <p>
         [[cd_frqim_method]] defines the choice of integration method along the imaginary frequency axis
        for Contour Deformation calculations. The default method is very robust, fast and optimal for the
        vast majority of cases. However, for very accurate (&ldquo;paranoid level&rdquo;) convergence studies,
        ABINIT offers the possibility of a variety of methods and grids. Note that as one starts to change
        the defaults, one needs to carefully consider the grid used. Therefore we recommend that in
        addition to reading the information below, the user reads the description of the
        input variables [[freqim_alpha]],
        [[nfreqim]], [[ppmfrq]],
        [[gw_frqim_inzgrid]].
        </p>
        <p>
         The integration to be performed for each matrix element of the self energy along the imaginary axis is of the form:
        </p>
        <p align="center">
         <img style="width: 461px; height: 49px;" src="../vargw_img/self_energy_cd.png" />
        </p>
        <p>
         Where
         <span style="font-family:Times,Serif">
          <i>
           &omega;
          </i>
         </span>
         is the frequency point along the real axis,
         <span style="font-family:Times,Serif">
          <i>
           &epsilon;
           <sub>
            s
           </sub>
          </i>
         </span>
         is an eigenvalue,
        and
         <span style="font-family:Times,Serif">
          <i>
           i&omega;'
          </i>
         </span>
         is the variable along the
        imaginary axis. Thus the function to be integrated
        is a Lorentzian weight function centred on the origin (whose FWHM is decided by
        |
         <span style="font-family:Times,Serif">
          <i>
           &omega; - &epsilon;
           <sub>
            s
           </sub>
          </i>
         </span>
         |),
        times a function. The function is related to the inverse dielectric matrix. It might have a peaked structure near the origin and is very smooth otherwise. the function decays
        asymptotically as
         <span style="font-family:Times,Serif">
          1 /
          <i>
           i&omega;'
          </i>
         </span>
         , so the whole
        integral converges as this to the third power.
         <ul>
          <li>
           <b>
            cd_frqim_method = 1 - Histogram:
           </b>
           This is the
           <b>
            default
           </b>
           method where the function
           <span style="font-family:Times,Serif">
            <i>
             f(i&omega;')
            </i>
           </span>
           is approximated by a histogram,
        and the Lorentzian is integrated analytically in each sub-interval. See the section on grids
        below for a description of the default grid. This method combined with the default grid is the
        fastest and optimised for the use of few points along the imaginary axis.
          </li>
          <li>
           <b>
            cd_frqim_method = 2 - Trapezoid:
           </b>
           The next step up from the histogram approximation in the previous
        method. The integration region is transformed
           <span style="font-family:Times,Serif">
            <i>
             [0,&#8734;[ &rarr; [0,1]
            </i>
           </span>
           with a proper
        weight depending on the width of the Lorentzian. In this space
           <span style="font-family:Times,Serif">
            <i>
             f(i&omega;')
            </i>
           </span>
           is approximated by a linear function between grid points (trapezoids), and the integrand is
        integrated analytically in each sub-interval. This method tends to slightly overestimate contributions
        while the default method tends to slightly underestimate them, so the results from methods
        1 and 2 should bracket the converged values. The asymptotic behaviour is explicitly taken
        into account by a fit using the last two grid points.
          </li>
          <li>
           <b>
            cd_frqim_method = 3, 4, 5 - Natural Spline:
           </b>
           The function is transfomed
           <span style="font-family:Times,Serif">
            <i>
             [0,&#8734;[ &rarr; [0,1]
            </i>
           </span>
           . In this space
           <span style="font-family:Times,Serif">
            <i>
             f(i&omega;')
            </i>
           </span>
           is approximated by a natural spline function whose starting and ending sections are linear. This transform is chosen so that the function should approach a linear function asymptotically as the integration interval approaches 1, so that the asymptotic behaviour is automatically taken into account. For each Lorentzian width
        (determined by |
           <span style="font-family:Times,Serif">
            <i>
             &omega; - &epsilon;
             <sub>
              s
             </sub>
            </i>
           </span>
           |)
        the integrand is appropriately scaled in the interval
           <span style="font-family:Times,Serif">
            <i>
             [0,1]
            </i>
           </span>
           , and a nested Gauss-Kronrod (GK)
        numerical integration rule is performed. The integrand is evaluated at the GK nodes by means
        of a spline-fit. The order of the GK rule is controlled by the index of the method:
           <ul>
            <li>
             <b>
              3 =&gt; Gauss  7 point, Kronrod 15 point rule
             </b>
            </li>
            <li>
             <b>
              4 =&gt; Gauss 11 point, Kronrod 23 point rule
             </b>
            </li>
            <li>
             <b>
              5 =&gt; Gauss 15 point, Kronrod 31 point rule
             </b>
            </li>
           </ul>
           There is rarely any difference to machine precision between these rules, and the code will
        issue a warning if a higher-order rule is recommended.
          </li>
         </ul>
        </p>
        <p>
         <b>
          Grids for the integral along the imaginary axis:
         </b>
        </p>
        <p>
         All the methods above should execute no matter what grid is used along the imaginary axis, so this
        is very much under the control of the user. The only requirement is that the grid be strictly increasing.
        The point at zero frequency is assumed to lie on the real axis, so the calculation of that point
        is controlled by [[nfreqre]] and corresponding variables. We highly
        recommend extracting various elements of the dielectric matrix from the _SCR file using
        the
         <b>
          Mrgscr
         </b>
         utility and plotting them for visual inspection.
        </p>
        <p>
         <ul>
          <li>
           <b>
            Default
           </b>
           - The default grid is an exponentially increasing grid given by the formula:
           <p align="center">
            <img style="width: 309px; height: 46px;" src="../vargw_img/cd_default_grid.png" />
           </p>
           Here
           <span style="font-family:Times,Serif">
            <i>
             &omega;
             <sub>
              p
             </sub>
            </i>
           </span>
           is the
        plasma frequency (by default determined by the average density of the system, but this
        can be overridden by setting [[ppmfrq]]).
           <span style="font-family:Times,Serif">
            <i>
             N
            </i>
           </span>
           is the total number of grid points
        (set by [[nfreqim]]).
           <span style="font-family:Times,Serif">
            <i>
             &alpha;
            </i>
           </span>
           is a parameter which determines
        how far out the final grid point will lie. The final point will be at
           <span style="font-family:Times,Serif">
            <i>
             &alpha;&middot;&omega;
             <sub>
              p
              <sub>
              </sub>
             </sub>
            </i>
           </span>
           (the default is
           <span style="font-family:Times,Serif">
            <i>
             &alpha; = 5
            </i>
           </span>
           ,
        and was hard-coded in older versions of ABINIT).
        This grid is designed so that approximately half the grid points are always distributed
        to values lower than the plasma frequency, in order to resolve any peaked structure. If one
        seeks to increase the outermost reach by increasing [[ppmfrq]]
        one must simultaneously take care to increase [[nfreqim]]
        in order to have the appropriate resolution for the low-frequency region.
        In more recent versions of ABINIT one can also simply adjust the parameter
           <span style="font-family:Times,Serif">
            <i>
             &alpha;
            </i>
           </span>
           by using
        [[freqim_alpha]]. This grid is optimised for
        speed and accurate results with few grid points for
           <b>
            cd_frqim_method = 1
           </b>
           .
          </li>
          <li>
           <b>
            Inverse z transform
           </b>
           - This grid is activated by the use of the variable
        [[gw_frqim_inzgrid]]. This is the standard
           <span style="font-family:Times,Serif">
            <i>
             [0,&#8734;[ &rarr; [0,1]
            </i>
           </span>
           transform
        using the formula:
           <p align="center">
            <img style="width: 122px; height: 38px;" src="../vargw_img/cd_inzgrid.png" />
           </p>
           Here
           <span style="font-family:Times,Serif">
            <i>
             &omega;
             <sub>
              p
             </sub>
            </i>
           </span>
           is the
        plasma frequency (default can be overridden by setting [[ppmfrq]]).
        The grid points are then picked by an equidistant grid (number of points set by
        [[nfreqim]]) in the interval
           <span style="font-family:Times,Serif">
            <i>
             z &sub; [0,1]
            </i>
           </span>
           . This grid can easily
        be uniquely converged by just increasing [[nfreqim]]. Again
        the points are distributed so that approximately half of them lie below the plasma frequency.
          </li>
          <li>
           <b>
            User defined
           </b>
           - The user can also define their own grid using the variables [[cd_customnimfrqs]]
           and [[cd_imfrqs]]
           .
           <i>
            With great power comes great responsibility!
           </i>
          </li>
         </ul>
        </p>
        <p>
         The
         <b>
          Mrgscr
         </b>
         utility is handy in optimising the numerical effort expended in convergence studies.
        By estimating the densest grid one can afford to calculate in the SCR file, and successively removing
        frequencies from a single file (using the utility), one only needs to perform the screening
        calculation
         <b>
          once
         </b>
         on the dense mesh for a given convergence study. One can also use the utility to
        merge independent screening calculations over q-points and frequency sections.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: cd_full_grid
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Contour Deformation FULL GRID in complex plane
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,9,12,19,22,29]'
    text: |-
        <p>
         [[cd_full_grid]] enables the calculation of the screening [both chi0 and epsilon^(-1)] on a grid in the first
        quadrant of the complex plane. The grid is determined by the (tensor) product of the grid in real frequency and
        the grid in imaginary frequency. In the SUS and SCR files the grid points are stored as follows:
         <pre>
          <b>
           Index:
          </b>
          1   . . .   nfreqre   nfrqre+1 . . . nfreqre+nfreqim   nfreqre+nfreqim+1 . . . nfreqre*nfreqim
          <b>
           Entry:
          </b>
          | purely real freq.  |     purely imaginary freq.     |      gridpoints in complex plane        |
         </pre>
         The grid in the complex plane is stored looping over the real dimension as the inner loop and the imaginary as
        the outer loop. The contents of the generated SUS and SCR files can be extracted for visualisation and further
        analysis with the
         <b>
          Mrgscr
         </b>
         utility.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: cd_halfway_freq
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 100.0
    dimensions: scalar
    excludes: null
    mnemonics: Contour Deformation tangent grid HALFWAY FREQuency
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[gwcalctyp]] in [2,9,12,19,22,29]
    text: |-
        <p>
         [[cd_halfway_freq]] determines the frequency where half of the number of points defined in
        [[nfreqre]] are used up. The tangent transformed grid is approximately
        linear up to this point. To be used in conjunction with [[gw_frqre_tangrid]].
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: real
- !variable
    abivarname: cd_imfrqs
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[cd_customnimfrqs]]'
    excludes: null
    mnemonics: Contour Deformation IMaginary FReQuencieS
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,9,12,19,22,29] and
        [[cd_customnimfrqs]] != 0'
    text: |-
        <p>
         [[cd_imfrqs]] specifies the grid points for the imaginary axis.  The number of frequencies
        is set by the value of [[cd_customnimfrqs]]. Example:
         <pre>
        cd_customnimfrqs   5
        nfreqim            5
        cd_imfrqs          0.1  0.2  0.5  1.0  5.0
         </pre>
         If [[nfreqim]] is not equal to
        [[cd_customnimfrqs]] a warning will be issued.
        </p>
        <p>
         <b>
          Use at own risk!
         </b>
         The use of a custom grid makes it your responsibility that the SUS and
        SCR files are valid in self-energy (i.e. [[optdriver]]=4)
        calculations, so caution is advised. Note that frequencies have to be strictly increasing, and the
        point at zero frequency is
         <b>
          not
         </b>
         considered to be part of the imaginary grid, but rather
        the grid along the real axis. The calculation of that point should be controlled by
        [[nfreqre]] and related variables.
        </p>
        <p>
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: real
- !variable
    abivarname: cd_max_freq
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 1000.0
    dimensions: scalar
    excludes: null
    mnemonics: Contour Deformation grid MAXimum FREQuency
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[gwcalctyp]] in [2,9,12,19,22,29]
    text: |-
        <p>
         [[cd_max_freq]] determines the frequency where all the points defined in
        [[nfreqre]] are used up. To be used in conjunction with
        [[gw_frqre_tangrid]].
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: real
- !variable
    abivarname: cd_subset_freq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - '[[nfreqre]]'
    dimensions:
    - 2
    excludes: null
    mnemonics: Contour Deformation grid calculate SUBSET of FREQuencies
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,9,12,19,22,29] and  [[gw_frqre_tangrid]]==0'
    text: |-
        <p>
         [[cd_subset_freq]] Specifies that only a subset of the frequencies defined by
        [[nfreqre]] are to be calculated. The first index is the start and
        the second the end, with index number 1 always being the origin. For example a calculation with
         <b>
          [[nfreqre]]=100
         </b>
         could be separated into two datasets with:
         <pre>
        subset_freq1   1   50
        subset_freq2   51  100
         </pre>
         Any resulting susceptibility (_SUS) and screening (_SCR) files can then be merged with the
         <b>
          mrgscr
         </b>
         utility.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: cgtyphf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usefock]] == 1': 2
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Conjugate Gradient TYPe used for Hartree Fock exact exchange
    requires: null
    text: |-
        <p>
         Gives how is calculated Fock exact exchange contribution in the conjugate gradient,
        in the SCF case.
         <br />
        The value 2 corresponds to calculate the Fock
        exact exchange contribution each time in the conjugate gradient. The value 1 corresponds to calculate the Fock
        exact exchange contribution only for the initial guess (not for the gradient direction) in the conjugate gradient
        </p>
    topics: Hybrids_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: charge
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: CHARGE
    requires: null
    text: |-
        <p>
         Used to establish charge balance between
        the number of electrons filling the bands and the
        nominal [[charge]] associated with the atomic cores.
         <br />
         The code adds up the number of valence electrons
        provided by the pseudopotentials of each type
        (call this "zval"), then add [[charge]], to get the
        number of electrons per unit cell,
        [[nelect]].
         <br />
         Then, if [[iscf]] is positive,
        the code adds up the band occupancies (given in
        array [[occ]]) for all bands at each k point,
        then multiplies
        by the k point weight [[wtk]] at each k point.
        Call this sum "nelect_occ" (for the number of electrons
        from occupation numbers).  It is then
        required that:
         <br />
         nelect_occ = nelect
         <br />
         To treat a neutral
        system, which is desired in nearly all cases, one must
        use [[charge]]=0.  To treat a system missing one electron
        per unit cell, set [[charge]]=+1.
        </p>
    topics: Coulomb_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: chempot
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions:
    - 3
    - '[[nzchempot]]'
    - '[[ntypat]]'
    excludes: null
    mnemonics: spatially varying CHEMical POTential
    requires: '[[nzchempot]]/=0'
    text: |-
        For each type of atoms, from 1 to [[ntypat]], specifies the spatially varying chemical potential, through the specification of [[nzchempot]] triplets of real numbers. They give data for [[nzchempot]] delimiting planes, all parallel to each other, each determined by its z reduced coordinate.

        The first real number is the z reduced coordinate of the delimiting plane. The second real number is the value of the chemical potential for this type of atom on this plane. The third real number is the derivative of the chemical potential fior this type of atom with respect to the z reduced coordinate, evaluated on this plane.

        In the space between delimiting planes, a piecewise cubic polynomial interpolation is determined : the cubic polynomial between two delimiting planes will have the imposed chemical potentials and derivatives on the two delimiting planes.

        The z reduced coordinates must be ordered in increasing values, and cannot span more than 1.0 . There is an automatic periodic boundary condition imposed. Specifying two identical z reduced coordinates is allowed, and means that the first one applies to the adjacent space with lower values of z, while the second applies to the adjacent space with higher values of z.

        When the spatial chemical potential is defined only for one type of atom (and no chemical potential is present for the other atoms), simply set the related values to *0.0 in the [[chempot]] array.

        In the present input array, reduced positions, energies and derivatives of energies are mixed. Hence, although the chemical potential is an energy, one cannot use the usual energy definitions (i.e. the chemical potential is always to be input in Hartree atomic units).
    topics: Artificial_expert
    varset: geo
    vartype: real
- !variable
    abivarname: chkdilatmx
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: CHecK DILATMX
    requires: null
    text: |-
        If 0, will not stop the execution if the [[dilatmx]] threshold is exceeded, but simply issue a warning. There will be no rescaling.
        If 1, after tentative rescalings as described in [[dilatmx]], will stop the execution.
    topics: GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: chkexit
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: CHecK whether the user want to EXIT
    requires: null
    text: |-
        <p>
         If [[chkexit]] is 1 or 2, ABINIT
        will check whether the user wants to interrupt the run (using the keyword
        "exit" on the top of the input file or creating a file
        named "abinit.exit": see the [[chkexit|end of section 3.2]]
         </a>
         of the [[help_abinit]]).
        </p>
        <p>
         If [[chkexit]]=0, the check is not performed at all
        </p>
        <p>
         If [[chkexit]]=1, the check is not performed frequently (after each SCF step)
        </p>
        <p>
         If [[chkexit]]=2, the check is performed frequently
        (after a few bands, at each k point)
        </p>
        <p>
         In all cases, the check is performed at most every 2 seconds of CPU time.
        </p>
    topics: Control_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: chkprim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: CHecK whether the cell is PRIMitive
    requires: null
    text: |-
        <p>
         If the symmetry finder is used
        (see [[nsym]]), a non-zero
        value of [[chkprim]] will make the code stop if a non-primitive
        cell is used. If [[chkprim]]=0, a warning is issued, but the run
        does not stop.
        </p>
        <p>
         If you are generating the atomic and cell geometry using
        [[spgroup]], you might
        generate a PRIMITIVE cell using
        [[brvltt]]=-1 .
        </p>
    topics: crystal_useful, UnitCell_useful, SmartSymm_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: chksymbreak
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: CHecK SYMmetry BREAKing
    requires: null
    text: |-
        <p>
         This variable governs the behaviour of the code when there are potential
        source of symmetry breaking, related e.g. to the k point grid or the presence of
        non-symmorphic translations which might not be coherent with the exchange-correlation grid.
        </p>
        <p>
         When [[chksymbreak]]=1, the code stops (or issue a warning) if :
         <ul>
          <li>
           (1) The k point grid is non-symmetric, in case
           [[kptopt]] =1, 2, or 4 ;
          </li>
          <li>
           (2) The non-symmorphic translation part of the symmetry operations has components that are not zero,
        or simple fractions, with 2, 3, 4, 6, 8 or 12 as denominators.
          </li>
         </ul>
         <br />
         When [[chksymbreak]] is zero, there is no such check.
         <br />
         When [[chksymbreak]] is minus 1, the code stops if the condition (1) is met, but in case the condition (2) is met, there will be a trial
        to shift the atomic coordinates such as to obtain symmetry operations with the adequate non-symmorphic part.
        </p>
        <p>
         Explanation :
         <br />
         In the ground-state calculation, such breaking of the symmetry is usually harmless. However, if the user is doing a
        calculation of phonons using DFPT ([[rfphon]]=1), the convergence with respect to the number of k points will
        be much worse with a non-symmetric grid than with a symmetric one. Also, if the user is doing a GW calculation, the
        presence of non-symmorphic translations that are not coherent with the FFT grid might cause
        problems.
        In the GW part, indeed, one needs to reconstruct the wavefunctions in the full Brillouin zone for
        calculating both the polarizability and the self-energy.
        The wavefunctions in the full Brillouin zone are obtained from the irreducible wedge by applying the symmetry
        operations of the space group of the crystal.
        In the present implementation, the symmetrization of the wavefunctions is done in real space on the FFT mesh
        that, therefore, has to be coherent both with the rotational part as well as with the fractional translation
        of each symmetry operation.
        If the condition (2) is met, the GW code will not be able to find a symmetry-preserving FFT mesh.
         <br />
         So, it was decided to warn the user about these possible problems already at the level of the ground state calculations,
        although such warning might be irrelevant.
         <br />
         If you encounter a problem outlined above, you have two choices : change your atomic positions (translate them) such that the origin
        appears as the most symmetric point ; or ignore the problem, and set [[chksymbreak]]=0 .
        </p>
    topics: k-points_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: chneut
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'CHarge NEUTrality treatment '
    requires: null
    text: |-
        Set the treatment of the Charge Neutrality requirement for the effective charges.
        Same meaning as the corresponding anaddb variable.
    topics: Phonons_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: chneut@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer for CHarge NEUTrality treatment
    requires: null
    text: |-
        <p>Set the treatment of the Charge Neutrality requirement for
        the effective charges.
        <p>
        <ul>
        <li> chneut=0 => no ASR for effective charges is imposed</li>
        <li> chneut=1 => the ASR for effective charges is imposed
               by giving to each atom an equal portion
               of the missing charge. See Eq.(48) in Phys. Rev. B55, 10355 (1997).</li>
        <li> chneut=2 => the ASR for effective charges is imposed
               by giving to each atom a portion of the
               missing charge proportional to the screening charge
               already present. See Eq.(49) in Phys. Rev. B55, 10355 (1997).</li>
        </ul>
        <p>
        More detailed explanation: the sum of the effective charges
        in the unit cell should be equal to zero. It is not the case
        in the DDB, and this sum rule is sometimes strongly violated.
        In particular, this will make the lowest frequencies at Gamma
        non-zero. There is no "best" way of imposing the ASR on effective charges.
    topics: Phonons_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: cineb_start
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 7
    dimensions: scalar
    excludes: null
    mnemonics: 'Climbing-Image Nudged Elastic Band: STARTing iteration'
    requires: '[[imgmov]]== 5 and [[neb_algo]]==2'
    text: |-
        <p>
         Gives the index of the first CI-NEB iteration..
         <br />
         The CI-NEB method constitutes a small modification to the NEB method allowing a rigorous
        convergence to the saddle point. As the image with the highest energy has to be identified,
        the calculation begins with several iterations of the standard NEB algorithm.
        The effective CI-NEB begins at the [[cineb_start]] iteration.
         <br />
         <i>
          See: J. Chem. Phys. 113, 9901 (2000).
         </i>
        </p>
    topics: TransPath_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: coff1@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.98
    dimensions: scalar
    excludes: null
    mnemonics: COeFFicient 1
    requires: null
    text: |-
        See the input variable [[ratmin@aim]].
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: coff2@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.95
    dimensions: scalar
    excludes: null
    mnemonics: COeFFicient 2
    requires: null
    text: |-
        See the input variable [[ratmin@aim]].
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: cpuh
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[cpum]]) or specified([[cpus]])
    mnemonics: CPU time limit in Hours
    requires: null
    text: |-
        <p>
        Only one of the three real parameters [[cpus]], [[cpum]] and [[cpuh]] can be defined in the input file to set up a CPU time limit.
        When the job reaches that limit, it will try to end smoothly.
        However, note that this might still take some time.
        If the user want a firm CPU time limit, the present
        parameter must be reduced sufficiently. Intuition
        about the actual margin to be taken into account
        should come with experience ...
         <br />
        A zero value has no action of the job.
        </p>
    topics: Control_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: cpum
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[cpum]]) or specified([[cpus]])
    mnemonics: CPU time limit in Minutes
    requires: null
    text: |-
        <p>
        Only one of the three real parameters [[cpus]], [[cpum]] and [[cpuh]] can be defined in the input file to set up a CPU time limit.
        When the job reaches that limit, it will try to end smoothly.
        However, note that this might still take some time.
        If the user want a firm CPU time limit, the present
        parameter must be reduced sufficiently. Intuition
        about the actual margin to be taken into account
        should come with experience ...
         <br />
        A zero value has no action of the job.
        </p>
    topics: Control_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: cpus
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[cpum]]) or specified([[cpus]])
    mnemonics: CPU time limit in seconds
    requires: null
    text: |-
        <p>
         Only one of the three real parameters [[cpus]], [[cpum]] and [[cpuh]] can be defined in the input file to set up a CPU time limit.
        When the job reaches that limit, it will try to end smoothly.
        However, note that this might still take some time.
        If the user want a firm CPU time limit, the present
        parameter must be reduced sufficiently. Intuition
        about the actual margin to be taken into account
        should come with experience ...
         <br />
        A zero value has no action of the job.
        </p>
    topics: Control_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: crit@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: computation of CRITical points
    requires: null
    text: |-
        Drives the computation of critical points.
          <ul>
           <li> [0] not
           <li> [-1] reading from the file ``root''.crit
           <li> [1] calculated (simplified version)
           <li> [2] calculated (standard version - recommended)
           <li> [3] calculated (the original version)
          </ul>
            <p> The original version searches all critical points (CPs)
            starting from the center between
            two and three atoms (atom - neighbor(s)) by
            Newton-Raphson algorithm - without tests (not recommended) - don't
            use together with surface analysis !
           <p> The simplified and standard versions search CP(3,-1) starting
            from the center of the pairs~atom-neighbor; then CP(3,1) from the
            center between two CP(3,-1) and finally CP(3,3) from the center
            between two CP(3,1). The robust Popeliers's algorithm is used.
            The difference between the two is based in the fact
            that the standard version makes the test if the CP is really
            on the Bader surface of the calculated atom for each CP, while
            the simplified version does this only for CP(3,-1). When CP analysis is
            rather fast (with respect to surface determination), 2 is recommended.
            In all cases the number of neighbors considered is limited by
            distance cutoff (variable  [[maxatd@aim]])
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: d3e_pert1_atpol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    dimensions:
    - 2
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 1: limits of
        ATomic POLarisations'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Controls the range of atoms for which displacements will be considered
        in non-linear computations (using the 2n+1 theorem), for the 1st perturbation.<br />
        May take values from 1 to [[natom]], with
        <b>d3e_pert1_atpol</b>(1)&lt;=<b>d3e_pert1_atpol</b>(2).<br />
        See [[rfatpol]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert1_dir
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 1: DIRections'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Gives the directions to be considered in non-linear computations
        (using the 2n+1 theorem), for the 1st perturbation.<br />
        The three elements corresponds to the three primitive
        vectors, either in real space (atomic displacement),
        or in reciprocal space (electric field perturbation).<br />
        See [[rfdir]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert1_elfd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 1: ELectric FielD'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Turns on electric field perturbation in non-linear computation, as 1st perturbation.
        Actually, such calculations requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the electric field perturbation itself.<br />
        See [[rfelfd]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert1_phon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 1: PHONons'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Turns on atomic displacement perturbation in non-linear computation, as 1st perturbation.<br />
        See [[rfphon]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert2_atpol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    dimensions:
    - 2
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 2: limits of
        ATomic POLarisations'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Controls the range of atoms for which displacements will be considered
        in non-linear computations (using the 2n+1 theorem), for the 2nd perturbation.<br />
        May take values from 1 to [[natom]], with
        <b>d3e_pert2_atpol</b>(1)&lt;=<b>d3e_pert2_atpol</b>(2).<br />
        See [[rfatpol]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert2_dir
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 2: DIRections'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Gives the directions to be considered in non-linear computations
        (using the 2n+1 theorem), for the 2nd perturbation.<br />
        The three elements corresponds to the three primitive
        vectors, either in real space (atomic displacement),
        or in reciprocal space (electric field perturbation).<br />
        See [[rfdir]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert2_elfd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 2: ELectric FielD'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Turns on electric field perturbation in non-linear computation, as 2nd perturbation.
        Actually, such calculations requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the electric field perturbation itself.<br />
        See [[rfelfd]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert2_phon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 2: PHONons'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Turns on atomic displacement perturbation in non-linear computation, as 2nd perturbation.<br />
        See [[rfphon]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert3_atpol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    dimensions:
    - 2
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 3: limits of
        ATomic POLarisations'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Controls the range of atoms for which displacements will be considered
        in non-linear computations (using the 2n+1 theorem), for the 3rd perturbation.<br />
        May take values from 1 to [[natom]], with
        <b>d3e_pert3_atpol</b>(1)&lt;=<b>d3e_pert3_atpol</b>(2).<br />
        See [[rfatpol]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert3_dir
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 3: DIRections'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Gives the directions to be considered in non-linear computations
        (using the 2n+1 theorem), for the 3rd perturbation.<br />
        The three elements corresponds to the three primitive
        vectors, either in real space (atomic displacement),
        or in reciprocal space (electric field perturbation).<br />
        See [[rfdir]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert3_elfd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 3: ELectric FielD'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Turns on electric field perturbation in non-linear computation, as 3rd perturbation.
        Actually, such calculations requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the electric field perturbation itself.<br />
        See [[rfelfd]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: d3e_pert3_phon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: '3rd Derivative of Energy, mixed PERTurbation 3: PHONons'
    requires: '[[optdriver]]==5 (non-linear response computations)'
    text: |-
        <p>
        Turns on atomic displacement perturbation in non-linear computation, as 3rd perturbation.<br />
        See [[rfphon]] for additional details.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: ddamp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    dimensions: scalar
    excludes: null
    mnemonics: electric Displacement field DAMPing parameter
    requires: '[[berryopt]] = 6 or 16'
    text: |-
        <p>
         In case [[berryopt]]=6,
        the electric field is updated after each SCF iteration according to
        E_{n+1}= [[ddamp]]*(D - 4*pi*P_{n}) + (1-[[ddamp]])*E_{n}
        where P_{n} and E_{n} are the polarization and electric field after nth SCF iteration.
        [[ddamp]] is a damping parameter used to control the convergence speed.
         <br />
         In case [[berryopt]]=16, the electric field is updated after each SCF iteration according to
        e_{n+1}= [[ddamp]]*(d - p_{n}) + (1-[[ddamp]])*e_{n}
         <br />
         If you have difficulty getting convergence, try to reduce this value or reduce maxestep.
        This parameter is used in finite electric displacement field calculations (berryopt=6,16,17).
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: ddb_ngqpt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: 'Derivative DataBase: Number of Grid points for Q-PoinTs'
    requires: null
    text: |-
        This variable is mandatory when [[optdriver]]==7.
        It defines the number of divisions in the (homogeneous) q-mesh
        used to generate the DDB file. See also the description of the [[getddb]] input variable.
    topics: ElPhonInt_expert
    varset: eph
    vartype: integer
- !variable
    abivarname: ddb_shiftq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    - 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: 'Derivative DataBase: SHIFT of the Q-points '
    requires: null
    text: |-
        Only relevant when [[optdriver]]==7.
        It defines the shift in the q-mesh used to generate the DDB file,
        which is defined by the [[ddb_ngqpt]] input variable.
        See [[shiftk]] for more information on the definition.
    topics: ElPhonInt_expert
    varset: eph
    vartype: real
- !variable
    abivarname: ddkfile@optic
    characteristics: null
    commentdefault: no default
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: DDK FILE
    requires: null
    text: |-
        Specify the filename that has been produced by the preparatory Abinit run.
          This file must contain the matrix elements of the d/dk operator along direction X.
          It must not contain the first-order wavefunctions and may be generated using [[prtwf]] 3.<br />
          You should make sure that the number of bands, of spin channels and of k-points are the same in all the files.

        <p>use as string with the filename: ddkfile_X, where X is the file number.
    topics: Optic_basic
    varset: optic
    vartype: string
- !variable
    abivarname: delayperm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: DELAY between trials to PERMUTE atoms
    requires: null
    text: |-
        <p>
         Delay (number of time steps) between trials to permute
        two atoms, in
        view of accelerated search of minima. Still in development. See the
        routine moldyn.F90. See also [[signperm]].
        When [[delayperm]] is zero, there is not permutation trials.
        </p>
    topics: MolecularDynamics_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: denout@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: electronic DENsity OUTput
    requires: null
    text: |-
        Output of the electronic density.
          The specification of the
          line (plane) in the real space must be given in the input variable
          [[vpts@aim]] and grid in
          [[ngrid@aim]].
          It is also possible to get only the
          valence density or the core density (see [[dltyp@aim]]).
          <ul>
           <li>0, no output
           <li>1, 1D distribution
           <li>2, 2D distribution
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: densfor_pred
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[paral_kgb]]==1': '6'
        defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: DENSity and FORces PREDictor
    requires: '[[iscf]] >0'
    text: |-
        <p>
         Used when [[iscf]]&gt;0, to define:
         <br />
         - the way a change of density is derived from a change of atomic position,
         <br />
         - the way forces are corrected when the SCF cycle is not converged.
         <br />
         <br />
         Supported values :
         <ul>
          <li>
           0 =&gt; density not changed (fixed charge), forces not corrected
          </li>
          <li>
           1 =&gt; density not changed, forces corrected with rigid ion hypothesis (atomic charge moved with atom)
          </li>
          <li>
           2 =&gt; density changed and forces corrected with rigid ion hypothesis (atomic charge moves with atom)
          </li>
          <li>
           3 =&gt; density changed and forces corrected with a different implementation of the rigid ion hypothesis
          </li>
          <li>
           4 =&gt; density not changed, forces corrected with the use of Harris functional formula (*)
          </li>
          <li>
           5 =&gt; density changed using D. Alfe 2nd-order algorithm (**), forces not corrected
          </li>
          <li>
           6 =&gt; density changed using D. Alfe 2nd-order algorithm (**) and forces corrected with the use of Harris functional formula (*)
          </li>
         </ul>
        Similar negative values are also allowed (see the meaning later), for development purposes only.
         No meaning for RF calculations.
         <br />
         <br />
         For the time being,
         <br />
         - [[densfor_pred]]=3 must be used with [[ionmov]]=4
        and [[iscf]]=5.
         <br />
         - [[densfor_pred]]=4, 5 or 6 must be used when band-FFT parallelism is selected.
         <br />
         Otherwise, use [[densfor_pred]]=2
         <br />
         <br />
         <b>
          (*)
         </b>
         <u>
         Note concerning the correction of forces (use of [[densfor_pred]]=1, 2, 3, 4 or 6)
         </u>
         :
         <br />
         The force on the atom located at R is corrected by the addition of the following term:
         <br />
         <i>
          F_residual=Int[dr.V_residual.dRho_atomic/dR]
         </i>
         ,  where Rho_atomic is an atomic (spherical) density.
         <br />
         - When such an atomic density (Rho_atomic) is found in the pseudopotential or PAW file, it is used. If not, a gaussian density
        (defined by [[densty]] parameter) is used.
         <br />
         - When SCF mixing is done on the density ([[iscf]]&gt;=10), the potential residual (V_residual)
        is obtained from the density residual with the first order formula
         <i>
          V_residual=dV/drho.Rho_residual
         </i>
         and uses the exchange-correlation kernel
         <i>
          dVxc/drho=Kxc
         </i>
         whose computation is time-consuming for GGA functionals.
        By default (positive values of [[densfor_pred]]), the local-density part of the GGA exchange-correlation kernel is used (even for GGA, for which it seems to give a reasonable accuracy).
        Using the full GGA exchange correlation kernel (so, including derivatives with respect to the gradient of the density) is always possible by giving a negative value to [[densfor_pred]]. In case of hybrid functionals, a similar correction term is added, although in the density mixing scheme, the related GGA kernel is used instead of the hybrid functional kernel.
         <br />
         <br />
         <b>
          (**)
         </b>
         <u>
          Note concerning the use of [[densfor_pred]]=5 or 6 (density prediction)
         </u>
         :
         <br />
         The algorithm is described in
         <i>
          Computer Physics Communications
          <b>
           118
          </b>
          (1999) 31-33
         </i>
         .
        It uses an atomic (spherical) density. When such an atomic density is found in the pseudopotential or PAW file, it is used. If not, a gaussian density
        (defined by [[densty]] parameter) is used.
         <br />
         Also note that, to be efficient, this algorithm requires a minimum convergence of the SCF cycle;
        Typically, vres2 (or nres2) has to be small enough (10
         <sup>
          -4
         </sup>
         ...10
         <sup>
          -5
         </sup>
         ).
        </p>
    topics: SCFAlgorithms_expert, MolecularDynamics_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: densty
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: initial DENSity for each TYpe of atom
    requires: null
    text: |-
        <p>
         Gives a rough description
        of the initial GS density, for each type of atom.
        This value is only used to create
        the first exchange and correlation potential,
        and is not used anymore afterwards.
        For the time being, it corresponds to an average
        radius (a.u.) of the density, and is used to generate
        a gaussian density. If set to 0.0d0, an optimized value is used.
         <br />
         No meaning for RF calculations.
        </p>
    topics: xc_expert
    varset: dev
    vartype: real
- !variable
    abivarname: dfield
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: Displacement FIELD
    requires: '[[berryopt]] = 6, [[efield]]'
    text: |-
        <p>
         In case [[berryopt]]=6,
        [[dfield]] specifies the (unreduced) finite electric displacement field vector, in atomic units, that is to be imposed as a constraint during the calculation.
        </p>
    topics: Berry_basic
    varset: ffield
    vartype: real
- !variable
    abivarname: dfpt_sciss
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: DFPT SCISSor operator
    requires: null
    text: |-
        <p>
         It is the value of the "scissors operator", the
        shift of conduction band eigenvalues,
        used in response function calculations.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         Typical use is for response to electric field ([[rfelfd]]=3),
        but NOT for d/dk ([[rfelfd]]=2) and phonon responses.
        </p>
    topics: DFPT_useful
    varset: dfpt
    vartype: real
- !variable
    abivarname: diecut
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 2.2
    dimensions: scalar
    excludes: null
    mnemonics: DIElectric matrix energy CUToff
    requires: null
    text: |-
        <p>
         Kinetic energy cutoff that controls the number
        of planewaves used to represent the dielectric matrix:
         <br />
         (1/2)[(2 Pi)*(Gmax)]
         <sup>
          2
         </sup>
         =[[ecut]] for Gmax.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[diecut]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         All planewaves inside this "basis sphere" centered
        at G=0 are included in the basis.
        This is useful only when [[iprcel]]&gt;=21, which means that
        a preconditioning scheme based on the dielectric matrix
        is used.
         <br />
         NOTE : a negative [[diecut]] will define the same dielectric
        basis sphere as the corresponding positive value,
        but the FFT grid will be identical to the one used
        for the wavefunctions.
        The much smaller FFT grid, used when [[diecut]] is positive,
        gives exactly the same results.
         <br />
         No meaning for RF calculations yet.
        </p>
    topics: SCFAlgorithms_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: dieflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: DIElectric FLAG
    requires: null
    text: |-
        <p>Integer. Frequency-dependent dielectric tensor flag.
        <br>
        <ul>
         <li> 0 => No dielectric tensor is calculated.</li>
         <li> 1 => The frequency-dependent dielectric tensor is calculated.
              Requirements for preceding response-function DDB generation
              run:  electric-field and full atomic-displacement responses.
              Set [[rfstrs]] = 1, 2, or 3 (preferably 3).
              Set [[rfatpol]] and
              [[rfdir]] to do a full calculation of
                phonons at Q=0.
          The frequencies are defined by the
        [[anaddb:nfreq]],[[anaddb:frmin]],[[anaddb:frmax]]
         variables. Also, the generalized Lyddane-Sachs-Teller
        relation will be used as an independent check of the
        dielectric tensor at zero frequency (this for the
        directions defined in the phonon list 2.
        See [[anaddb:nph2l]].</li>
        <li> 2 => Only the electronic dielectric tensor is calculated.
         It corresponds to a zero-frequency homogeneous field,
        with quenched atomic positions. For large band gap materials,
        this quantity is measurable because the highest phonon
        frequency is on the order of a few tenths of eV, and the
        band gap is larger than 5eV. Requirements for preceding response-function
        DDB generation: electric-field response.
        Set [[rfelfd]] = 1 or 3 (preferably 3).
        Note that the same information on the electronic dielectric tensor will be printed in the
        .out file of the [[rfelfd]] run.
        </li>
        <li> 3 => Compute and print the relaxed-ion dielectric tensor.
              Requirements for preceding response-function DDB generation
              run:  electric-field and full atomic-displacement responses.
              Set [[rfstrs]] = 1, 2, or 3 (preferably 3).
              Set [[rfatpol]] and
              [[rfdir]] to do a full calculation of
                phonons at Q=0 (needed because the inverse of
                force-constant tensor is required). Furthermore, in the anaddb input file the variable
                [[anaddb:nph2l]] must be nonzero in order to initiate
                computation of atomic displacements. If only the dielectric response is needed it
                is sufficient to set [[anaddb:nph2l]] to 1 and leave
                [[anaddb:qph2l]] at its default value (the Gamma point).
           Note that the relaxed-ion dielectric tensor computed here can
           also be obtained as the zero-frequency limit of the
           frequency-dependent dielectric tensor using input variables
           dieflag=1 and frmin=0.0.  (The results obtained using these two
           approaches should agree to good numerical precision.)  The ability
           to compute and print the static dielectric tensor here is provided
           for completeness and consistency with the other tensor
           quantities that are computed in this section of the code.
         </li>
         <li> 4 => Calculate dielectric tensor of both relaxed ion and
                       free stress.
           We need information of internal strain and elastic tensor (relaxed ion)
           in this computation. So please set:
           [[anaddb:elaflag]]=2,3,4 or 5  and
           [[anaddb:instrflag]]=1
         </ul>
    topics: Phonons_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: diegap
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    dimensions: scalar
    excludes: null
    mnemonics: DIElectric matrix GAP
    requires: null
    text: |-
        <p>
         Gives a rough estimation of the dielectric gap
        between the highest energy level computed in the run,
        and the set of bands not represented.
        Used to extrapolate dielectric matrix when [[iprcel]] &gt;= 21.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[diegap]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         No meaning for RF calculations yet.
        </p>
    topics: SCFAlgorithms_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: dielam
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    dimensions: scalar
    excludes: null
    mnemonics: DIElectric matrix LAMbda
    requires: '[[iprcel]] >= 21'
    text: |-
        <p>
         Gives the amount of occupied states with mean energy given by the
        highest level computed in the run, included
        in the extrapolation of the dielectric matrix.
         <br />
         No meaning for RF calculations yet.
        </p>
    topics: SCFAlgorithms_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: dielng
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0774841d0
    dimensions: scalar
    excludes: null
    mnemonics: model DIElectric screening LeNGth
    requires: null
    text: |-
        <p>
         Used for screening length (in Bohr) of the model
        dielectric function, diagonal in reciprocal space.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstrom), although Angstrom can be specified,
        if preferred, since [[dielng]] has the
        '[[LENGTH]]' characteristics.
         <br />
         This model dielectric function is as follows (K being a wavevector) :
         <pre>
                 (     1        +     [[dielng]]<sup>2</sup>* K<sup>2</sup>   )
        diel(K)= ------------------------------------
                 ( 1/[[diemac]] + [[dielng]]<sup>2</sup> * K<sup>2</sup> ) * [[diemix]]
         </pre>
         The inverse of this model dielectric function will be
        applied to the residual, to give the preconditioned
        change of potential. Right at K=0, diel(K) is imposed to be 1.
        </p>
        <p>
         If the preconditioning were perfect,
        the change of potential would lead to an exceedingly fast solution
        of the self-consistency problem (two or three steps).
        The present model dielectric function is excellent for
        rather homogeneous unit cells.
         <br />
         When K-&gt;0 , it tends to the macroscopic dielectric
        constant, eventually divided by the mixing factor [[diemix]]
        (or
         [[diemixmag]]
         </a>
         for magnetization).
         <br />
         For metals, simply put [[diemac]] to a very large value (10^6 is OK)
         <br />
         The screening length [[dielng]] governs the length scale
        to go from the macroscopic regime to the microscopic
        regime, where it is known that the dielectric function
        should tend to 1. It is on the order of 1 Bohr for
        metals with medium density of states at the Fermi level,
        like Molybdenum, and for Silicon. For metals with a
        larger DOS at the Fermi level (like Iron),
        the screening will be more effective, so that [[dielng]]
        has to be decreased by a factor of 2-4.
         <br />
         This works for GS and RF calculations.
        </p>
    topics: SCFAlgorithms_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: diemac
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1000000.0
    dimensions: scalar
    excludes: null
    mnemonics: model DIElectric MACroscopic constant
    requires: null
    text: |-
        <p>
         A rough knowledge of the macroscopic dielectric constant [[diemac]]
        of the system is a useful help to speed-up the SCF procedure:
        a model dielectric function,
        see the keyword [[dielng]], is used for that
        purpose.  It is especially
        useful for speeding up the treatment of rather homogeneous unit cells.
        </p>
        <p>
         Some hint :
         <br />
         The value of [[diemac]] should usually be bigger than 1.0d0,
        on physical grounds.
         <br />
         For metals, simply put [[diemac]] to a very large value (the default 10
         <sup>
          6
         </sup>
         is OK)
         <br />
         For silicon, use 12.0 . A similar value is likely to work well for
        other semiconductors
         <br />
         For wider gap insulators, use 2.0 ... 4.0
         <br />
         For molecules in an otherwise empty big box, try 1.5 ... 3.0
         <br />
         Systems that combine a highly polarisable part and some vacuum are rather
        badly treated by the model dielectric function. One has to use the
        "extrapolar" technique, activated by the  input variable
        [[iprcel]].
         <br />
         In sufficiently homogeneous systems, you might have to experiment
        a bit to find the best [[diemac]]. If you let [[diemac]]
        to its default value, you might even never obtain the self-consistent convergence !
         <br />
         For response function calculations, use the same
        values as for GS. The improvement in speed can be considerable
        for small (but non-zero) values of the wavevector.
        </p>
    topics: SCFAlgorithms_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: diemix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==0 or [[iprcel]] !=0': 1.0
        '[[usepaw]]==1 or [[iprcel]]==0': 0.7
        defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: model DIElectric MIXing factor
    requires: '[[diemix]] &gt;= 0.0 and [[diemix]] &lt;=  1.0'
    text: |-
        <p>
         Gives overall factor of the preconditioned
        residual density/potential to be transferred in the SCF cycle.
         <br />
         It should be between 0.0 and 1.0 .
         <br />
         If the model dielectric function were perfect, [[diemix]]
        should be 1.0 . By contrast, if the model dielectric function
        does nothing (when [[diemac]]=1.0d0 or [[dielng]]
        is larger than the
        size of the cell), [[diemix]] can be used
        to damp the amplifying factor inherent to the SCF loop.
         <br />
         For molecules, a value on the order 0.5 or 0.33 is rather usual.
         <br />
         When mod([[iscf]],10)=3, 4 ,5 or 7, [[diemix]]
        is only important at the
        few first iterations when anharmonic effects are important,
        since these schemes compute their own mixing factor
        for self-consistency.
         <br />
         Also note that a different value of diemix can be used for the magnetization
        (see [[diemixmag]]).
        </p>
    topics: SCFAlgorithms_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: diemixmag
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        70 < [[iprcel]] and [[iprcel]] < 80: '[[diemix]]'
        '[[iprcel]]==0': '[[diemix]]'
        '[[iscf]]<10': '[[diemix]]'
        defaultval: -[[diemix]]
    dimensions: scalar
    excludes: null
    mnemonics: model DIElectric MIXing factor for the MAGgnetization
    requires: null
    text: |-
        <p>
         Gives overall factor of the preconditioned
        residual magnetization/magnetic field to be transferred in the SCF cycle (see
         [[diemix]] for further information).
         <br />
         For the time being, apply only when the SCF mixing is done on the density
        ([[iscf]]&gt;=10).
         <br />
         <br />
         A negative value of diemixmag means that magnetization is only preconditionned by ABS(diemixmag),
        without the use of any preconditionner.
         <br />
         <br />
         When SCF cycle has some difficulties to converge, changing the value of [[diemixmag]]
        can have a positive effect.
         <br />
         In particular [[diemixmag]]=-4 is a good choice
        (i.e. diemixmag=4, no other preconditionner on magnetization).
        </p>
    topics: spinpolarisation_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: diismemory
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 8
    dimensions: scalar
    excludes: null
    mnemonics: Direct Inversion in the Iterative Subspace MEMORY
    requires: null
    text: |-
        <p>
         Gives the maximum number of "time" steps for which the
        forces and stresses are stored, and taken into account in the
        DIIS algorithm ([[ionmov]]=20)
        to find zero-force and stress configurations.
        </p>
    topics: MolecularDynamics_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: dilatmx
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: 'lattice DILATation : MaXimal value'
    requires: null
    text: |-
        <p>
        Gives the maximal permitted scaling of
        the lattice parameters when the cell shape and
        dimension is varied (see variable [[optcell]]). Accordingly defines the plane wave basis set for this purpose. The [[dilatmx]] threshold might be exceeded if [[chkdilatmx]]=0, otherwise ABINIT exits after three tentative rescalings, as described below.
        <p>
        [[dilatmx]] is used to define the sphere of plane waves
        and FFT box coherent with the possible modifications
        of the cell ([[ionmov]]==2 and
        [[optcell]] /=0).
        For these definitions, it is equivalent
        to changing [[ecut]] by multiplying it by [[dilatmx]]
         <sup>
          2
         </sup>
         (the result is an "effective ecut", called internally "ecut_eff",
        other uses of [[ecut]] being not modified
        when [[dilatmx]]&gt;1.0 .
         <br />
         Using [[dilatmx]]&lt;1.0 is equivalent to changing
        [[ecut]]
         in all its uses. This is allowed, although its meaning
        is no longer related to a maximal expected scaling.
         <br />
         Setting [[dilatmx]] to a large value leads to waste
        of CPU time and memory. Supposing you think that the
        optimized [[acell]] values might be 10%
        larger than your
        input values, use simply [[dilatmx]] 1.1 . This will already
        lead to an increase of the number of planewaves by a factor
        (1.1)
         <sup>
          3
         </sup>
         =1.331 , and a corresponding increase in CPU time
        and memory.
         <br />
         It is possible to use [[dilatmx]] when
        [[optcell]] =0, but
        a value larger than 1.0 will be a waste.
        </p>
        <p>
        When the [[dilatmx]] threshold is exceeded, ABINIT will rescale uniformly the tentative new primitive vectors to a value that leads at most to 90% of the maximal allowed [[dilatmx]] deviation from 1. It will do this three times (to forbid the geometry optimization algorithms to have take a too large trial step), but afterwards will exit. Setting [[chkdilatmx]]==0 allows the definition of an appropriate planewave basis, but will not lead to an exit when the threshold is exceeded.
    topics: GeoOpt_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: dipdip
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'DIPole-DIPole interaction '
    requires: null
    text: |-
        This variable defines the treatment of the dipole-dipole interaction.
        Same meaning as the corresponding anaddb variable [[dipdip@anaddb]]
    topics: Phonons_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: dipdip@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: DIPole-DIPole interaction
    requires: null
    text: |-
        <ul>
        <li>
         0 => the dipole-dipole interaction is not handled separately
         in the treatment of the interatomic forces.
         This option is available for testing purposes or if effective charge
         and/or dielectric tensor is not available in the derivative database.
         It gives results much less accurate than <b>dipdip</b>=1.</li>
        <li>
        1 => the dipole-dipole interaction is subtracted from the dynamical
         matrices before Fourier transform, so that only the short-range
         part is handled in real space. Of course, it is reintroduced
         analytically when the phonon spectrum is interpolated, or if
         the interatomic force constants have to be analysed in real space.</li>
         </ul>
        The abinit input variable [[dipdip]] has a similar meaning.
    topics: PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: dltyp@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Density or Laplacian TYP output
    requires: null
    text: |-
        Specification of the contribution of the electronic
          density corresponding to the density and/or laplacian output
          (see [[denout@aim]] and
               [[lapout@aim]])
          <ul>
           <li>0, total electronic density
           <li>1, only the valence density
           <li>2, only the core density
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: dmatpawu
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: -10.0
    dimensions:
    - 2*max([[lpawu]])+1
    - 2*max([[lpawu]])+1
    - max([[nsppol]], [[nspinor]])
    - '[[natpawu]]'
    excludes: null
    mnemonics: initial Density MATrix for PAW+U
    requires: '[[usepaw]]==1 and [[usepawu]]==1 and [[usedmatpu]]!=0'
    text: |-
        <p>
         For Ground state calculations only.
         <br />
         Gives the value of an initial density matrix used in LDA+U and kept
        fixed during the first abs([[usedmatpu]]) SCF iterations.
         <br />
         Only components corresponding to [[lpawu]] angular momentum are requested.
         <br />
         Restriction: In order to use dmatpawu, [[lpawu]] must be identical for all atom types (or -1).
         <br />
         The occupation matrix is in the basis of real spherical harmonics Slm (note that this differs from the choice made when
         [[prtdosm]]=1
         , that is in the basis of complex spherical harmonics).
        They are ordered by increasing m, and are defined e.g. in [[Blancoa1997]]
         </a>
         .
        For the case l=2 (d states), the five columns corresponds respectively to (the normalisation factor has been dropped)
         <br />
         <ul>
          <li>
           m=-2, xy
          </li>
          <li>
           m=-1, yz
          </li>
          <li>
           m=0, 3z^2-r^2
          </li>
          <li>
           m=1, xz
          </li>
          <li>
           m=2, x^2-y^2
          </li>
         </ul>
         <br />
         [[dmatpawu]] must always be given as a "spin-up" occupation matrix (and eventually a "spin-down" matrix).
        Be aware that its physical meaning depends on the magnetic properties imposed to the system
        (with [[nsppol]],
        [[nspinor]],
        [[nspden]]):
         <br />
         <ul>
          <li>
           <b>
            Non-magnetic system
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=1):
           <br />
           One (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrix is given for each atom on which +U is applied.
           <br />
           It contains the "spin-up" occupations.
          </li>
          <li>
           <b>
            Ferromagnetic spin-polarized (collinear) system
           </b>
           ([[nsppol]]=2,
        [[nspinor]]=1,
        [[nspden]]=2):
           <br />
           Two (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrices are given for each atom on which +U is applied.
           <br />
           They contain the "spin-up" and "spin-down" occupations.
          </li>
          <li>
           <b>
            Anti-ferromagnetic spin-polarized (collinear) system
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=2):
           <br />
           One (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrix is given for each atom on which +U is applied.
           <br />
           It contains the "spin-up" occupations.
          </li>
          <li>
           <b>
            Non-collinear magnetic system
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=2,
        [[nspden]]=4):
           <br />
           Two (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrices are given for each atom on which +U is applied.
           <br />
           They contains the "spin-up" and "spin-down" occupations
        (defined as n_up=(n+|m|)/2 and n_dn=(n-|m|)/2), where m is the integrated magnetization vector).
           <br />
           The direction of the magnetization (which is also the direction of n_up and n_dn) is given by
        [[spinat]].
           <br />
           <i>
            Warning: unlike collinear case, atoms having the same magnetization magnitude with different directions
        must be given the same occupation matrix;
            <br />
            the magnetization will be oriented by the value of [[spinat]]
        (this is the case for antiferro-magnetism).
           </i>
          </li>
          <li>
           <b>
            Non-collinear magnetic system with zero magnetization
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=2,
        [[nspden]]=1):
           <br />
           Two (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrices are given for each atom on which +U is applied.
           <br />
           They contain the "spin-up" and "spin-down" occupations;
           <br />
           But, as "spin-up" and "spin-down" are constrained identical, the "spin-down" one is ignored by the code.
          </li>
         </ul>
         <br />
        </p>
    topics: DFT+U_useful, ElecDOS_useful
    varset: paw
    vartype: real
- !variable
    abivarname: dmatpuopt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: Density MATrix for PAW+U OPTion
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    text: |-
        <p>
         This option governs the way occupations of localized atomic levels are computed:
         <br />
         <ul>
          <li>
           [[dmatpuopt]]=1: atomic occupations are projections on atomic orbitals (Eq. (6) of PRB 77, 155104 (2008)).
           <br />
          </li>
          <li>
           [[dmatpuopt]]=2: atomic occupations are integrated values in PAW spheres
        of angular-momentum-decomposed charge densities (Eq. (7) of PRB 77, 155104 (2008)).
           <br />
          </li>
          <li>
           [[dmatpuopt]]=3: only for tests
           <br />
          </li>
          <li>
           [[dmatpuopt]]=4: Extrapolations of occupancies outside the PAW-sphere. This Definition gives normalized operator for occupation.
           <br />
          </li>
         </ul>
         In the general case [[dmatpuopt]]=2 is suitable. The use of [[dmatpuopt]]=1
        is restricted to PAW datasets in which the first
        atomic wavefunction of the correlated subspace is a normalized atomic eigenfunction.
        </p>
    topics: DFT+U_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: dmatudiag
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Density MATrix for paw+U, DIAGonalization
    requires: '[[usepaw]]==1 and [[usepawu]]==1 and [[nspden]] != 4'
    text: |-
        <p>
         Relevant only  for Ground-State calculations.
         <br />
         This option can be used to diagonalize the occupation matrix Nocc_{m,m_prime}.
         <br />
         Relevant values are:
         <br />
         <ul>
          <li>
           0: desactivated.
          </li>
          <li>
           1: occupation matrix is diagonalized and printed in log file at each SCF cycle
        (eigenvectors are also given in the log file).
          </li>
          <li>
           2: for testing purpose.
          </li>
         </ul>
        </p>
    topics: DFT+U_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: dmft_dc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Double Counting'
    requires: null
    text: |-
        <p>
         <br />
         Value of double counting used for DMFT. Only value 1 is activated for the moment and is the FLL double counting.
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_entropy
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: ENTROPY'
    requires: '[[usedmft]]==1 and [[dmft_solv]]==5'
    text: |-
        If 1, enable the calculation of the entropy  within the DMFT framework and so allows the calculation of the total energy (free energy).
        In the current implementation, this is only possible with [[dmft_solv]]=5 (Continuous Time Quantum Monte Carlo).
        See also the input variable [[dmft_nlambda]].
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_iter
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: number of ITERation'
    requires: null
    text: |-
        <p>
         <br />
         Number of iterations for the DMFT inner loop.
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_mxsf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.3
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: MiXing parameter for the SelF
        energy'
    requires: null
    text: |-
        <p>
         <br />
         Mixing parameter for the simple mixing of the self-energy.
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: real
- !variable
    abivarname: dmft_nlambda
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 6
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Number of LAMBDA points'
    requires: '[[usedmft]]==1 and [[dmft_entropy]]==1'
    text: |-
        [[dmft_nlambda]] gives the number of integration points for the thermodynamical integration in case of free energy calculation within DMFT.
        Its value must be greater or equal to 3.
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_nwli
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Number of frequency omega (W)
        in the LInear mesh'
    requires: null
    text: |-
        <p>
         <br />
         Number of Matsubara frequencies (linear  mesh)
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_nwlo
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Number of frequency omega (W)
        in the LOg mesh'
    requires: null
    text: |-
        <p>
         <br />
         Number of frequencies in the log mesh.
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_read_occnd
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: READ OCCupations (Non Diagonal)'
    requires: null
    text: |-
        <p>
         <br />
         Flag to read/write Occupations as computed in DMFT. This flag is useful
        to restart a DFT+DMFT calculation with self-consistency over electronic density.
        The occupations are written each time a DMFT loop is finished. So if the calculation stops
        because the time limit is reached, this option offers the possibility to restart the self-consistent loop
        over density at the point where it stopped (assuming a restart with the wave functions, see [[getwfk]]).
         <ul>
          <li>
           0=&gt;  Occupations are written but never read.
          </li>
          <li>
           1=&gt;  Occupations are read from I_DMFTOCCND, where I is the root for input files.
          </li>
          <li>
           2=&gt;  Occupations are read from O_DMFTOCCND, where O is the root for output files.
          </li>
         </ul>
         An alternative and more simple way to restart a DFT+DMFT calculation is to use the density file (obtained with [[prtden]]=1
        or [[prtden]]=-1) and the self-energy (see [[dmft_rslf]]).
        </p>
    topics: DMFT_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: dmft_rslf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Read SeLF energy'
    requires: null
    text: |-
        <p>
         Flag to read/write Self-Energy. If put to one, self-energy is written and read at each DFT iteration.
        </p>
    topics: DMFT_basic
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_solv
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: choice of SOLVer'
    requires: null
    text: |-
        <p>
         <br />
         Choice of solver for the Impurity model.
         <ul>
          <li>
           0=&gt; No solver and U=0, J=0 (see [[upawu]] and [[jpawu]]).
          </li>
          <li>
           1=&gt; LDA+U self-energy is used (for testing purpose)
          </li>
          <li>
           2=&gt; Hubbard one solver. The Hubbard one solver is an approximation which gives a rough description of correlated Mott insulators. It should not be used for metals.
          </li>
          <li>
           5=&gt; Use the Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb of ABINIT
            in the density density representation,
        CTQMC calculations are much more time consuming that Hubbard I calculations. Nevertheless, the calculation is fully parallelised.
          </li>
          <li>
           6=&gt; Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb of TRIQS
            in the density density representation.
          </li>
          <li>
           7=&gt; Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb of TRIQS
            with the rotationally invariant formulation.
          </li>
         </ul>
         <br />
         The CT Hyb algorithm is described in
           <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.97.076405">
            Phys. Rev. Lett 97, 076405, (2006) </a>.
            For a discussion  of density-density approximation with respect
            with the rotationnally invariant formulation, see e.g.
           <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.86.155107">
             Phys. Rev. B 86, 155107 (2012)
           </a>.
         <br />
         The ABINIT/CT Hyb implementation is discussed in
           <a href="http://dx.doi.org/10.1016/j.cpc.2016.04.003">
              http://dx.doi.org/10.1016/j.cpc.2016.04.003 </a>.
         <br />
         The TRIQS/CT Hyb implementation is described in
           <a href="http://dx.doi.org/10.1016/j.cpc.2015.10.023">
            Comp. Phys. Comm. 200, 274 (2016)
           </a>. Before using it, it has to be installed following
            instructions at https://triqs.ipht.cnrs.fr/1.x/install.html.
            Starting from release 8.6.0, the interface is valid only for TRIQS 1.4 and TRIQS/CTHYB 1.4.
            An example of a config .ac file to compile ABINIT with TRIQS can be found in ~/doc/build/config-examples/ubu_gnu_4.9_triqs.ac.
         <br />
         See the useful variables for CT-QMC solver :
        [[dmftctqmc_basis]],
        [[dmftctqmc_check]],
        [[dmftctqmc_correl]],
        [[dmftctqmc_gmove]],
        [[dmftctqmc_grnns]],
        [[dmftctqmc_meas]],
        [[dmftctqmc_mrka]],
        [[dmftctqmc_mov]],
        [[dmftctqmc_order]],
        [[dmftctqmc_triqs_nleg]],
        [[dmftqmc_l]],
        [[dmftqmc_n]],
        [[dmftqmc_seed]],
        [[dmftqmc_therm]]
        </p>
    topics: DMFT_basic
    varset: dmft
    vartype: real
- !variable
    abivarname: dmft_t2g
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: t2g orbitals'
    requires: null
    text: |-
        <p>
         <br />
         Can be set to 1 only if in cubic symmetry. It enables one to carry a DFT+DMFT calculations only on t2g orbitals.
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmft_tolfreq
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-4
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: TOLerance on DFT correlated electron
        occupation matrix for the definition of the FREQuency grid'
    requires: null
    text: |-
        <p>
         <br />
         The LDA occupation matrix for correlated electrons can be computed directly. It can be compared to the calculation of the same quantity using LDA Green's function, a sum over Matsubara frequencies and
         a projection over correlated orbitals.
         Because the Matsubara grid is finite, the two quantities differ. If this difference is larger than dmft_tolfreq, then the code stops and an error message is given.
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: real
- !variable
    abivarname: dmft_tollc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-5
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: TOLerance on Local Charge for
        convergence of the DMFT loop'
    requires: null
    text: |-
        <p>
         <br />
         Tolerance for the variation of Local Charge during iterations of the DMFT Loop.
         <br />
         The default value is good for fast calculations. However, to obtain good convergence of the DFT Loop,
        the DMFT Loop needs a better convergence criterion.
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: real
- !variable
    abivarname: dmftbandf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Field Theory: BAND: Final'
    requires: null
    text: |-
        <p>
         [[dmftbandf]] is the last band taken into account in the Projected Local
        Orbitals scheme of DFT+DMFT. With [[dmftbandi]], they define the energy window used to define Wannier Functions.
        (see  Amadon, B., Lechermann, F., Georges, A., Jollet, F., Wehling, T. O., and Lichtenstein, A. I. Phys. Rev. B 77(20), (2008).)
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftbandi
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Field Theory: BAND: Initial'
    requires: null
    text: |-
        <p>
         [[dmftbandi]] is the first band taken into account in the Projected Local
        Orbitals scheme of LDA+DMFT. With [[dmftbandf]], they define the energy window used to define Wannier Functions.
        (see  Amadon, B., Lechermann, F., Georges, A., Jollet, F., Wehling, T. O., and Lichtenstein, A. I. Phys. Rev. B 77(20), (2008).)
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftcheck
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: CHECKs'
    requires: null
    text: |-
        <p>
         <br />
        Only for developer purposes.
         (Introduced by B. Amadon, v6.1.0)
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_basis
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo BASIS'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Choose the basis to perform CTQMC calculation.
         <ul>
          <li>
           0=&gt;  Use the local basis in the spherical harmonics basis. Can be useful if the Hamiltonian has weak off diagonal terms
           and for this reason, one want to keep the original basis for simplicity and for physical insight.
          </li>
          <li>
           1=&gt;  Default value, diagonalize the local Hamiltonian (but only if it is not diagonal). The best choice in general.
          </li>
          <li>
           2=&gt;  Diagonalise the local correlated occupation matrix. Can lead to non diagonal Hamiltonian that
           cannot be handled by CTQMC. This option should be thus avoided.
          </li>
         </ul>
        </p>
    topics: DMFT_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: dmftctqmc_check
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo CHECK'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Check the fast calculations during the Monte Carlo simulation with very slow but robust methods.
        Should only be used for debugging.
         <ul>
          <li>
           0=&gt;  No check.
          </li>
          <li>
           1=&gt;  Check the overlap calculations (Impurity operator).
          </li>
          <li>
           2=&gt;  Check the update of M matrix calculation (Bath operator).
          </li>
          <li>
           3=&gt;  Check both.
          </li>
         </ul>
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_correl
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo CORRELations'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Flag to compute statistics about segments and anti-segments during the simulation.
        Slow down the simulation.
         <ul>
          <li>
           0=&gt;  Nothing done
          </li>
          <li>
           1=&gt;  Calculations performed and written in "Correlation.dat" file
          </li>
         </ul>
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_gmove
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo Global MOVEs'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Default is no global moves.
        The value of this variable is the modulo used to try a global move.
        A value of 5000 means that a global move is tried every 5000 Monte Carlo sweep.
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_grnns
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo GReeNs NoiSe'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Compute the statistical noise for each time slice of each green function.
        This is a good approximation only if there is enough Monte Carlo sweeps per cpu.
         <ul>
          <li>
           0=&gt;  Nothing
          </li>
          <li>
           1=&gt;  Do it and write the noise in the "Gtau.dat" file.
          </li>
         </ul>
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_meas
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo MEASurements'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         The modulo used to measure the interaction energy and the number of electrons.
        Example : 2 means the measure is perform every two sweeps.
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_mov
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo MOVie'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Print a latex file per cpu displaying the full simulation.
        This option should only be use with very small number (&lt;1000) of Monte Carlo sweeps since it requires a lot of I/O band width.
         <ul>
          <li>
           0=&gt;  Nothing
          </li>
          <li>
           1=&gt;  Write the "Movie_id.dat" file where id is the MPI rank of each process
          </li>
         </ul>
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_mrka
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo MARKov Analysis'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Measure the time evolution of the number of electrons for each orbital and perform a fourier transform.
        The result can be plotted using the "Markov_id.dat" file
         <ul>
          <li>
           0=&gt;  Nothing
          </li>
          <li>
           1=&gt;  Do it and write the noise in the "Markov_id.dat" file where id is the rank of each MPI process.
          </li>
         </ul>
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_order
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo perturbation ORDER'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Print a file containing the statistic distribution of the number of segments per orbital.
        The maximal order taken into account [[dmftctqmc_order]] : 50 means that we have the statistic distribution from 0 to 50 segments.
        The result is written in the "Perturbation.dat" file.
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftctqmc_triqs_nleg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo perturbation of TRIQS, Number of LEGendre polynomials'
    requires: '[[dmft_solv]]==6 or 7'
    text: |-
        <p>
         <br />
         Specify the number of Legendre polynomials used for the calculation of Green's function in CTQMC code from the library TRIQS.
         Default is 30. The value of coefficients are given in file whose name ending is "Legendre_coefficient.dat".
         (see also <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.84.075145"> Phys. Rev. B 84, 075145 (2010))
         </a>
        </p>
    topics: DMFT_expert
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftqmc_l
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Quantum Monte Carlo time sLices'
    requires: '[[dmft_solv]]>=4'
    text: |-
        <p>
         <br />
         Number of time slices used to represent the time green function.
        This value should be carefully chosen according to Niquist frequency and the [[tsmear]] value.
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftqmc_n
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Quantum Monte Carlo Number of
        sweeps'
    requires: '[[dmft_solv]]>=4'
    text: |-
        <p>
         <br />
         Number of Monte Carlo sweeps. Should be at least 10^6.
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: real
- !variable
    abivarname: dmftqmc_seed
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[jdtset]]'
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Quantum Monte Carlo SEED'
    requires: '[[dmft_solv]]>=4'
    text: |-
        <p>
         <br />
         Seed to initilize the random number generator.
         <br />
         Should not be relevant except for testing purpose.
         <br />
         NOTE : If the CT-QMC ([[dmft_solv]]=5) is used on many CPUs, each CPU initializes its random number generator with dmftqmc_seed+rank where rank is the rank of the cpu in the MPI communicator.
        </p>
    topics: DMFT_useful
    varset: dmft
    vartype: integer
- !variable
    abivarname: dmftqmc_therm
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1000
    dimensions: scalar
    excludes: null
    mnemonics: 'Dynamical Mean Fied Theory: Quantum Monte Carlo THERMalization'
    requires: '[[dmft_solv]]==5'
    text: |-
        <p>
         <br />
         Number of Monte Carlo sweeps for the thermalization
        </p>
    topics: DMFT_compulsory
    varset: dmft
    vartype: integer
- !variable
    abivarname: domega@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-3 Ha
    dimensions: scalar
    excludes: null
    mnemonics: Delta OMEGA
    requires: null
    text: |-
        The step and maximum sets your energy grid for the calculation using the formula
          number of energy mesh points=maximum/step (zero excluded). So  in order to capture more
          features you can decrease the step size to get a finer energy grid. In order
          to go to higher frequency, increase the maximum.
    topics: Optic_basic
    varset: optic
    vartype: real
- !variable
    abivarname: dosdeltae
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: DOS DELTA in Energy
    requires: null
    text: |-
        <p>
         Defines the linear grid resolution (energy increment) to be used for the
        computation of the Density-Of-States, when [[prtdos]]
        is non-zero.
         <br />
         If [[dosdeltae]] is set to zero (the default value), the actual
        increment is 0.001 Ha if [[prtdos]]=1, and
        the much smaller value 0.00005 Ha if [[prtdos]]=2.
        This different default value arises because the [[prtdos]]=1 case,
        based on a smearing technique, gives a quite smooth DOS, while the DOS from the
        tetrahedron method, [[prtdos]]=2, is rapidly varying.
        </p>
    topics: printing_prdos, ElecDOS_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: dosdeltae@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 4.5E-06 Hartree = 1 cm<sup>-1</sup>
    dimensions: scalar
    excludes: null
    mnemonics: DOS DELTA in Energy
    requires: null
    text: |-
        <p>The input variable <b>dosdeltae</b> is used to define the step of the frequency grid used to
        calculate the phonon density of states when [[anaddb:prtdos]]=1.
    topics: PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: dossmear@anaddb
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 4.5E-05 Hartree = 10 cm<sup>-1</sup>
    dimensions: scalar
    excludes: null
    mnemonics: DOS SMEARing value
    requires: null
    text: |-
        <p><b>dossmear</b> defines the gaussian broadening used to calculate the phonon density
        of states when [[anaddb:prtdos]]=1.
    topics: PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: dossum@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: DOS SUM
    requires: null
    text: |-
        <p>Set the flag to calculate the two phonon dos density of states. Sum and Difference for
        the Gamma point. The DOS is converged and based on that, the sum and different is
        reported in the output file <b>dossum</b>.
    topics: PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: dostol@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.25
    dimensions: scalar
    excludes: null
    mnemonics: DOS TOLerance
    requires: null
    text: |-
        <p>The relative tolerance on the phonon density of state.
        This number will determine when the series of grids
        with which the DOS is calculated can be stopped, i.e.
        the mean of the relative change going from one grid
        to the next bigger is smaller than <b>dostol</b>.
    topics: PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: dpclim@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-2
    dimensions: scalar
    excludes: null
    mnemonics: DPCLIM
    requires: null
    text: |-
        If two "numerically different" critical points are separated by
          less than <b>dpclim</b>, they are considered to be the same
          critical point. This often happens because of numerical
          inaccuracies : one CP might be "seen" by
          two different finite elements. The default should be OK when
          the ecut is quite large, on the order of 60 Hartree. For less
          accurate calculations of the density, increase the default value
          to 5.d-2, let's say.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: dtion
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    dimensions: scalar
    excludes: null
    mnemonics: Delta Time for IONs
    requires: null
    text: |-
        <p>
         Used for controlling ion time steps.
        If [[ionmov]] is set to 1, 6 or 7, then
        molecular dynamics is&nbsp;
        used to update atomic positions in response to
        forces. The parameter [[dtion]] is a time step in
        atomic units of time. (One atomic time unit is
        2.418884e-17 seconds, which is the value of
        Planck's constant in hartree*sec.)
        In this case the atomic masses, in amu (given in array "
        [[amu]] "),
        are used in Newton's equation and the viscosity (for
        [[ionmov]] =1)
        and number of time steps are provided to the code using input
        variables "[[vis]]" and "[[ntime]]".
        The code actually converts
        from masses in amu to masses in atomic units (in units
        of electron masses) but the user enters masses in
        [[amu]] .
        (The conversion from amu to atomic units (electron
        masses) is 1822.88851 electron masses/amu.)
         <br />
         A typical good value for [[dtion]] is about 100.
        The user must try several values
        for [[dtion]] in order to establish the stable and efficient
        choice for the accompanying amu, atom types and positions,
        and [[vis]] (viscosity).
         <br />
         For quenched dynamics ([[ionmov]]=7), a
        larger time step might
        be taken, for example 200.
         <br />
         No meaning for RF calculations.
        </p>
    topics: PIMD_compulsory, MolecularDynamics_compulsory
    varset: rlx
    vartype: real
- !variable
    abivarname: dynimage
    characteristics: null
    commentdefault: if [[imgmov]] in [2,5] (String Method, NEB), <b>dynimage(1)</b>=0 and <b>dynimage([[nimage]])</b>=0.
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 1
    dimensions:
    - '[[nimage]]'
    excludes: null
    mnemonics: DYNamics of the IMAGE
    requires: null
    text: |-
        This input variable is relevant when sets of images are activated (see
        [[imgmov]]). Not all images might be required to evolve from one time step to the other.

        Indeed, in the String Method or the Nudged Elastic Band, one might impose that the extremal configurations of the string are fixed.
        In case the [[dynimage]](iimage)=0, the image with index "iimage" will be consider as fixed.
        Thus, there is no need to compute forces and stresses for this image at each time step. The purpose of defining extremal images is to make the input/output easier.
         <br />
         <br />
         In order to save CPU time, the computation of properties of static images ([[dynimage]](iimage)=0)
        can be avoided: see [[istatimg]] keyword.
    topics: PIMD_expert, TransPath_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: ecut
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Energy CUToff
    requires: null
    text: |-
        <p>
         Used for kinetic energy cutoff
        which controls number
        of planewaves at given k point by:
         <br />
         (1/2)[(2 Pi)*(k+Gmax)]
         <sup>
          2
         </sup>
         =[[ecut]] for Gmax.
         <br />
         All planewaves inside this "basis sphere" centered
        at k are included in the basis (except if [[dilatmx]]
        is defined).
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[ecut]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         This is the single parameter which can have an enormous
        effect on the quality of a calculation; basically the larger
        [[ecut]] is, the better converged the calculation is.  For fixed
        geometry, the total energy MUST always decrease as [[ecut]] is
        raised because of the variational nature of the problem.
        </p>
        <p>
         <i>
          Usually one runs at least several calculations at various [[ecut]]
        to investigate the convergence needed for reliable results.
         </i>
        </p>
        <p>
         For k-points whose coordinates are build from 0 or 1/2,
        the implementation of time-reversal symmetry that links
        coefficients of the wavefunctions in reciprocal space
        has been realized. See the input variable [[istwfk]].
        If activated (which corresponds to the Default mode),
        this input variable [[istwfk]] will allow to
        divide the number of plane wave (npw) treated explicitly
        by a factor of two. Still, the final result should be identical with
        the 'full' set of plane waves.
        </p>
        <p>
         See the input variable [[ecutsm]], for the
        smoothing of the kinetic energy, needed to optimize unit cell parameters.
        </p>
    topics: Planewaves_compulsory
    varset: basic
    vartype: real
- !variable
    abivarname: ecuteps
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Energy CUT-off for EPSilon (the dielectric matrix)
    requires: '[[optdriver]]==3 or [[optdriver]]==4'
    text: |-
        <p>
         [[ecuteps]] determines the cut-off energy of the planewave set used to represent the
        independent-particle susceptibility $\chi^{0}_{KS}$, the dielectric matrix $\epsilon$, and its inverse.
         <br />
         It is not worth to take [[ecuteps]] bigger than four times [[ecutwfn]],
        this latter limit corresponding to the highest Fourier components of a wavefunction convoluted with itself.
        Usually, even twice the value of [[ecutwfn]] might overkill. A value of [[ecuteps]]
        between 5 and 10 Hartree often (but not always) leads to converged results (at the level of 0.01 eV for the energy gap).
        In any case, a convergence study is worth.
        </p>
    topics: Susceptibility_compulsory, RandStopPow_compulsory
    varset: gw
    vartype: real
- !variable
    abivarname: ecutsigx
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Energy CUT-off for SIGma eXchange
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[ecutsigx]] determines the cut-off energy of the planewave set used to generate the
        exchange part of the self-energy operator. For norm-conserving calculations, it is pointless
        to have [[ecutsigx]] bigger than 4*[[ecut]],
        while for PAW calculations, the maximal useful value is
        [[pawecutdg]]. Thus, if you do not care about CPU time, please use these
        values. If you want to spare some CPU time, you might try to use a value between [[ecut]] and these
        upper limits.
        </p>
    topics: SelfEnergy_compulsory
    varset: gw
    vartype: real
- !variable
    abivarname: ecutsm
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Energy CUToff SMearing
    requires: null
    text: |-
        <p>
         This input variable is important when performing
        relaxation of unit cell
        size and shape (non-zero [[optcell]]).
        Using a non-zero
        [[ecutsm]], the total energy curves as a function of
        [[ecut]], or [[acell]],
        can be smoothed,
        keeping consistency with
        the stress (and automatically including the Pulay stress). The
        recommended
        value is 0.5 Ha. Actually, when [[optcell]]/=0,
        ABINIT requires
        [[ecutsm]] to be larger than zero. If you want to optimize cell
        shape and size without
        smoothing the total energy curve (a dangerous thing to do), use a very
        small [[ecutsm]],
        on the order of one microHartree.
        </p>
        <p>
         Technical information :
         <br />
         See Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995)
        for a related method.
         <br />
         [[ecutsm]] allows to define an effective kinetic energy for plane
        waves, close to, but
        lower than the
        maximal kinetic energy [[ecut]]. For
        kinetic
        energies less than [[ecut]]-[[ecutsm]],
        nothing is modified,
        while between [[ecut]]-[[ecutsm]] and
        [[ecut]] ,
        the kinetic energy is multiplied by:
         <br />
         1.0 / ( x
         <sup>
          2
         </sup>
         (3+x-6x
         <sup>
          2
         </sup>
         +3x
         <sup>
          3
         </sup>
         ))
         <br />
         where x = ([[ecut]] - kinetic_energy)/[[ecutsm]]
         <br />
         Note that x
         <sup>
          2
         </sup>
         ( 3+x-6x
         <sup>
          2
         </sup>
         +3x
         <sup>
          3
         </sup>
         ) is 0 at
        x=0, with vanishing derivative,
        and that at x=1 , it is 1, with also vanishing derivative.
         <br />
         If [[ecutsm]] is zero, the unmodified kinetic energy is used.
         <br />
         [[ecutsm]] can be specified in Ha (the default), Ry, eV or Kelvin,
        since
        [[ecutsm]] has the
        '[[ENERGY]]'
        characteristics.
        (1 Ha=27.2113845 eV).
         <br />
         A few test for Silicon (diamond structure, 2 k-points) have
        shown 0.5 Ha to be largely enough for [[ecut]]
        between 2Ha and 6Ha,
        to get smooth curves. It is likely that this value is OK
        as soon as [[ecut]] is larger than 4Ha.
        </p>
    topics: Planewaves_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: ecutwfn
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[optdriver]] in [3, 4]': '[[ecut]]'
        defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Energy CUT-off for WaveFunctioNs
    requires: ' [[optdriver]]==3 or [[optdriver]]==4'
    text: |-
        <p>
         [[ecutwfn]] determines the cut-off energy of the planewave set used to represent the wavefunctions
        in the formula that generates the independent-particle susceptibility $\chi^{0}_{KS}$
        (for [[optdriver]]=3), or the
        self-energy (for [[optdriver]]=4).
         <br />
         Usually, [[ecutwfn]] is smaller than [[ecut]],
        so that the wavefunctions are filtered, and some components are ignored.
        As a side effect, the wavefunctions are no more normalized, and also, no more orthogonal.
        Also, the set of plane waves can be much smaller for [[optdriver]]=3,
        than for [[optdriver]]=4, although a convergence
        study is needed to choose correctly both values.
        </p>
        <p>
         The size of this set of planewaves is [[npwwfn]].
        </p>
    topics: Susceptibility_compulsory, SelfEnergy_compulsory
    varset: gw
    vartype: real
- !variable
    abivarname: effmass_free
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: EFFective MASS for the FREE electron
    requires: null
    text: |-
        This parameter allows to change the free electron mass, with respect to its experimental value.
        <p>The electron mass is simply changed in the Schr&ouml;dinger equation.
        </p>
        Only for testing purposes, of course.
    topics: Artificial_expert
    varset: dev
    vartype: real
- !variable
    abivarname: efield
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: Electric FIELD
    requires: '[[berryopt]] = 4 or 6'
    text: |-
        <p>
         In case [[berryopt]]=4,
        a finite electric field calculation is performed. The value
        of this electric field, and its direction is determined by [[efield]].
        It must be given in atomic units (1 a.u. of electric field= 514220624373.482 V/m, see note below),
        in cartesian coordinates.
        </p>
        <p>
         References for the calculation under electric field (based on multi k point Berry phase) :
         <ul>
          <li>
           Nunes and Vanderbilt, PRL 73, 712 (1994) : real-space version of the finite-field Hamiltonian
          </li>
          <li>
           Nunes and Gonze, PRB 63, 155107 (2001) : reciprocal-space version of the finite-field Hamiltonian
        (the one presently implemented), and extensive theoretical analysis
          </li>
          <li>
           Souza, Iniguez and Vanderbilt, PRL 89, 117602 (2003) : implementation of the finite-field Hamiltonian
        (reciprocal-space version)
          </li>
          <li>
           Zwanziger, Galbraith, Kipouros, Torrent, Giantomassi and Gonze, Comp. Mater. Sci. 58, 113 (2012) : extension
        to PAW formalism
          </li>
         </ul>
         See also Umari, Gonze, Pasquarello, PRL 90, 027401 (2003).
        </p>
        <p>
         The atomic unit of electric field strength is :
        e_Cb/(4 pi eps0 a0**2), where e_Cb is the electronic charge in Coulomb (1.60217653e-19),
        eps0 is the electric constant (8.854187817d-12 F/m), and a0 is the Bohr radius
        in meter (0.5291772108e-10).
        </p>
    topics: Berry_basic
    varset: ffield
    vartype: real
- !variable
    abivarname: efmas
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs
    requires: null
    text: |-
        <p>
         Turns on effective mass tensor calculations.
         Such calculations requires the non-self-consistent calculation
         of derivatives with respect to k, in the same dataset.
         It must therefore be used with [[rfelfd]]=2.
         <br />
         <ul>
          <li>
           0=&gt;no effective mass tensor calculation
          </li>
          <li>
           1=&gt;effective mass tensor calculation
          </li>
         </ul>
        </p>

        <p>
        At the present time, both norm-conserving (NC) and PAW calculations are supported.
        Also, for PAW calculations only, [[nspinor]]==2 and [[pawspnorb]]==1
        (i.e. spin-orbit (SO) calculations) is supported. NC SO calculations are NOT currently
        supported. Also, for both NC and PAW, [[nspden]]/=1 and [[nsppol]]/=1 are NOT supported.
        </p>
    topics: EffMass_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: efmas_bands
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: The full range of band available in the calculation for each k-point.
    dimensions:
    - 2
    - '[[nkpt]]'
    excludes: null
    mnemonics: EFfective MASs, BANDS to be treated.
    requires: '[[efmas]]==1'
    text: |-
        <p>
        This variable controls the range of bands for which the effective mass is to be calculated.
        If a band is degenerate, all other bands of the degenerate group will automatically be treated,
        even if they were not part of the user specified range.
        </p>
    topics: EffMass_useful
    varset: dfpt
    vartype: integer
- !variable
    abivarname: efmas_calc_dirs
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs, CALCulate along DIRectionS
    requires: '[[efmas]]==1'
    text: |-
        <p>
        Allows the user to calculate the scalar effective mass of all bands specified by [[efmas_bands]] along
        specific directions in reciprocal space. This is particularly useful when considering degenerate bands,
        which are usually warped, and thus cannot have their dispersion (hessian) and effective mass expressed as
        a tensor. This allows the user to see the more complex angular behavior of effective masses in these cases,
        for instance.
        </p>

        <p>
        When [[efmas_calc_dirs]]==0, no directions are read from the input file (using [[efmas_dirs]]) and the
        effective masses along the 3 cartesian directions are output by default.
        </p>

        <p>
        When [[efmas_calc_dirs]]==1, 2 or 3, [[efmas_n_dirs]] directions are read from [[efmas_dirs]], assuming
        cartesian, reduced or angular (theta,phi) coordinates, respectively. In the case [[efmas_calc_dirs]]==3,
        2 real values per directions are read, whereas 3 real values are read in the two other cases.
        </p>
    topics: EffMass_useful
    varset: dfpt
    vartype: integer
- !variable
    abivarname: efmas_deg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs, activate DEGenerate formalism
    requires: '[[efmas]]>0'
    text: |-
        <p>
        Activate (==1) or not (==0) the treatment of degenerate bands (within a criterion [[efmas_deg_tol]])
        using the transport equivalent effective mass idea
        (see <a href="https://doi.org/10.1103/PhysRevB.89.155131">PRB 89 155131 (2014)</a>).
        </p>
    topics: EffMass_useful
    varset: dfpt
    vartype: integer
- !variable
    abivarname: efmas_deg_tol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-5
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs, DEGeneracy TOLerance
    requires: '[[efmas_deg]]==1'
    text: |-
        <p>
        Energy difference below which 2 bands are considered degenerate
        (and treated using the formalism activated with [[efmas_deg]]==1).
        [[efmas_deg_tol]] has the '[[ENERGY]]' characteristics.
        </p>
    topics: EffMass_useful
    varset: dfpt
    vartype: real
- !variable
    abivarname: efmas_dim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 3
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs, DIMension of the effective mass tensor
    requires: '[[efmas]]==1'
    text: |-
        <p>
        For 2D or 1D systems, the band dispersion goes to 0 perpendicular to the system,
        which causes the inverse effective mass to be singular, i.e. the effective mass
        to be NaN. This keyword circumvents the problem by eliminating the troublesome dimensions
        from the inverse effective mass.
        </p>

        <p>
        In 2D, the Z axis is ignored and, in 1D, the Z and Y axis are ignored.
        </p>

        <p>
        Also, note that in the 2D degenerate case, a subtlety arises: the 'transport equivalent'
        effective mass does not determine the scale of the transport tensors (conductivity and others).
        Therefore, for this specific case, the factor by which these transport tensors should be scaled
        once determined from the 'transport equivatlent' effective mass tensor is output separately on
        the line immediately after the effective mass.
        </p>
    topics: EffMass_useful
    varset: dfpt
    vartype: integer
- !variable
    abivarname: efmas_dirs
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 3 or 2
    - '[[efmas_n_dirs]]'
    excludes: null
    mnemonics: EFfective MASs, DIRectionS to be calculated
    requires: '[[efmas_calc_dirs]]>0'
    text: |-
        <p>
        List of [[efmas_n_dirs]] directions to be considered according to the value of [[efmas_calc_dirs]].
        The directions are specified by 3 real values if [[efmas_calc_dirs]]==1 or 2 and by
        2 real values if [[efmas_calc_dirs]]==3.
        </p>
    topics: EffMass_basic
    varset: dfpt
    vartype: real
- !variable
    abivarname: efmas_n_dirs
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs, Number of DIRectionS
    requires: '[[efmas_calc_dirs]]>0'
    text: |-
        <p>
        Number of directions in [[efmas_dirs]], to be considered according to [[efmas_calc_dirs]].
        </p>
    topics: EffMass_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: efmas_ntheta
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1000
    dimensions: scalar
    excludes: null
    mnemonics: EFfective MASs, Number of points for integration w/r to THETA
    requires: '[[efmas]]==1 and [[efmas_bands]]==(degenerate band index)'
    text: |-
        <p>
        When a band is degenerate, the usual definition of effective mass becomes invalid.
        However, it is still possible to define a 'transport equivalent mass tensor' that
        reproduces the contribution of the band to the conductivity tensor.
        To obtain this tensor, an integration over the solid sphere is required.
        The default value gives a tensor accurate to the 4th decimal in Ge.
        </p>
    topics: EffMass_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: einterp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    - 0
    dimensions:
    - 4
    excludes: null
    mnemonics: Electron bands INTERPolation
    requires: null
    text: |-
        This variable activates the interpolation of the electronic eigenvalues.
        It can be used to interpolate KS eigenvalues at the end of the GS run or to interpolate GW energies in sigma calculations ([[optdriver]] = 4).
        The k-path can be specified with [[kptbounds]] and [[nkpath]].

        einterp consists of 4 entries.
        The first element specificies the interpolation method.

        <ul>
        <li> 0 --> No interpolation (default) </li>
        <li> 1 --> Star-function interpolation (Shankland-Koelling-Wood Fourier interpolation scheme,
            see [[Pickett1988]]
        </li>
        <li> 2 --> B-spline interpolation. </li>
        </ul>

        The meaning of the other entries depend on the interpolation technique selected.
        <br>

        In the case of star-function interpolation:

        <ul>
        <li> einterp(2): Number of star-functions per ab-initio k-point </li>
        <li> einterp(3): If non-zero, activate Fourier filtering according to Eq 9 of [[Uehara2000]].
        In this case, rcut is given by einterp(2) * Rmax where Rmax is the maximum length of the lattice vectors included in the star expansion </li>
        <li> einterp(4): Used if einterp(2) /= 0. It defines rsigma in Eq 9</li>
        </ul>
        <br>

        For B-spline interpolation:

        einterp(2:4): Order of B-spline for the three reduced directions. Cubic spline (3) is the recommended value.
    topics: ElecBandStructure_useful, SelfEnergy_expert
    varset: basic
    vartype: real
- !variable
    abivarname: eivec@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: EIgenVECtors
    requires: null
    text: |-
        <ul>
        <li> 0 => do not write the phonon eigenvectors;</li>
        <li> 1 or 2 => write the phonon eigenvectors;</li>
        <li> 4 => generate output files for band2eps (drawing tool for the phonon band structure);</li>
        </ul>
    topics: Phonons_useful, PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: elaflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ELAstic tensor FLAG
    requires: null
    text: |-
        <p>Flag for calculation of elastic and compliance tensors
        <ul>
        <li>0 => No elastic or compliance tensor will be calculated.</li>
        <li>1 => Only clamped-ion elastic and compliance tensors will be
            calculated.
            Requirements for preceding response-function DDB generation
            run:  Strain perturbation.
            Set [[rfstrs]] to 1, 2, or 3.
            Note that [[rfstrs]]=3 is recommended so that responses to
            both uniaxial and shear strains will be computed.
        </li>
        <li>2 => Both relaxed- and clamped-ion elastic and compliance tensor
            will be calculated, but only the relaxed-ion quantities
            will be printed.
           The input variable [[anaddb:instrflag]]
            should also be set to 1, because
            the internal-strain tensor is needed to compute the relaxed-ion
            corrections.  Requirements for preceding response-function DDB
            generation run:  Strain and atomic-displacement responses at Q=0.
            Set [[rfstrs]] = 1, 2, or 3 (preferably 3).
            Set [[rfatpol]] and
            [[rfdir]] to do a full calculation of
              phonons at Q=0 (needed because the inverse of
              force-constant tensor is required).
        </li>
        <li>3 =>  Both relaxed and clamped-ion elastic and compliance tensors
            will be printed out.
            The input variable [[anaddb:instrflag]]
             should also be set to 1.
            Requirements for preceding response-function DDB generation
            run:  Same as for <b>elaflag</b>=2.
        </li>
        <li>4 => Calculate the elastic and compliance tensors (relaxed ion)
          at fixed displacement field, the relaxed-ion tensors at fixed
          electric field will be printed out too, for comparison.
          When <b>elaflag</b>=4, we need the information of internal strain and
         relaxed-ion dielectric tensor to build the whole tensor, so
         we need set [[anaddb:instrflag]]=1 and
         [[anaddb:dieflag]]=3 or 4 .
        </li>
        <li>5 => Calculate the relaxed ion elastic and compliance tensors, considering
         the stress left inside cell. At the same time, bare relaxed ion tensors
         will still be printed out for comparison.
         In this calculation, stress tensor is needed to compute the correction
         term, so one supposed to merge the first order derivative data base (DDB file)
         with the second order derivative data base (DDB file) into a new DDB file, which
         can contain both information. And the program will also check for the users.
        </li>
        </ul>
    topics: Elastic_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: elph2_imagden
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: 'ELectron-PHonon interaction at 2nd order : IMAGinary shift
        of the DENominator'
    requires: '[[ieig2rf]] != 0'
    text: |-
        <p>
        that is, if the user is performing performing second-order eigenvalue calculations using response-functions.
         <br />
         <br />
         The variable [[elph2_imagden]] determines the imaginary shift of the denominator of the sum-over-states
        in the perturbation denominator, (e_{nk}-e_{n'k'}+i [[elph2_imagden]]).
        One should use a width comparable with the Debye frequency or the maximum phonon frequency.
         <br />
         Can be
        specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
        </p>
    topics: TDepES_basic
    varset: dfpt
    vartype: real
- !variable
    abivarname: elph_fermie@anaddb
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: ELectron-PHonon FERMI Energy
    requires: null
    text: |-
        <p>If non-zero, will fix artificially the value of the Fermi energy
        (e.g. for semiconductors), in the electron-phonon case. Note that [[anaddb:elph_fermie]] and [[anaddb:ep_extrael]]
        should not be used at the same time. ([[anaddb:elphflag]]=1).
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: elphflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ELectron-PHonon FLAG
    requires: null
    text: |-
        <p>If <b>elphflag</b> is 1, anaddb performs an analysis of the electron-phonon coupling.
    topics: PhononWidth_compulsory, ElPhonTransport_compulsory
    varset: anaddb
    vartype: integer
- !variable
    abivarname: elphsmear@anaddb
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01 Hartree
    dimensions: scalar
    excludes: null
    mnemonics: ELectron-PHonon SMEARing factor
    requires: null
    text: |-
        <p>Smearing width for the Fermi surface integration (in Hartree by default).
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: enunit
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ENergy UNITs
    requires: null
    text: |-
        <p>
         Governs the units to be used for
        output of eigenvalues (and eventual phonon frequencies)
         <ul>
          <li>
           0=&gt;print eigenvalues in hartree;
          </li>
          <li>
           1=&gt;print eigenvalues in eV;
          </li>
          <li>
           2=&gt;print eigenvalues in both hartree and eV.
          </li>
         </ul>
         If phonon frequencies are to be computed :
         <ul>
          <li>
           0=&gt; phonon frequencies in Hartree and cm-1;
          </li>
          <li>
           1=&gt; phonon frequencies in eV and THz;
          </li>
          <li>
           2=&gt; phonon frequencies in hartree, eV, cm-1, Thz and Kelvin.
          </li>
         </ul>
        </p>
    topics: Output_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: enunit@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: ENergy UNITs
    requires: null
    text: |-
        <p>Give the energy for the phonon frequency output
        (in the output file, not in the console log file, for
         which Hartree units are used).
        <br>
        <ul>
         <li> 0 => Hartree and cm-1;</li>
         <li> 1 => meV and Thz;</li>
         <li> 2 => Hartree, cm-1, meV, Thz, and Kelvin.</li>
        </ul>
    topics: Phonons_useful, PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_b_max@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Electron Phonon integration Band MAXimum
    requires: null
    text: |-
        <p>When set, and [[anaddb:telphint]] is equal to 2, this variable determines the k-point integration weights which are used in the electron-phonon part of the code. Instead of weighting according to a distance from the Fermi surface, an equal weight is given to all k-points, for all bands between [[anaddb:ep_b_min]] and <b>ep_b_max</b>.
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_b_min@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Electron Phonon integration Band MINimum
    requires: null
    text: |-
        <p>As for [[anaddb:ep_b_max]], but <b>ep_b_min</b> is the lower bound on the band integration, instead of the upper bound. See also [[anaddb:telphint]].
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_extrael@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Electron-Phonon EXTRA ELectrons
    requires: null
    text: |-
        <p>If non-zero, will fix artificially the number of extra electrons per unit cell (positive for electron doping), according to a doped case.
        (e.g. for semiconductors), in the electron-phonon case.
        This field can also be filled with doping concentration, in the units of cm-3 (negative for electron doping).
        Note that <b>ep_extrael</b> and [[anaddb:elph_fermie]] should not be used at the same time.
        ([[anaddb:elphflag]]=1).
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: ep_int_gkk@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Electron-Phonon INTerpolation of GKK
    requires: null
    text: |-
        <p>This flag determines whether the interpolation of the electron-phonon matrix
        elements over the coarse k-grid is done (<b>ep_int_gkk</b> 1) before summing
        with appropriate Fermi Surface weights. In this way, the two integration weights
        are treated symmetrically.
    topics: PhononWidth_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_keepbands@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Electron-Phonon KEEP dependence on electron BANDS
    requires: null
    text: |-
        <p>This flag determines whether the dependency of the electron-phonon matrix
        elements on the electron band index is kept (<b>ep_keepbands</b> 1), or whether
        it is summed over immediately with appropriate Fermi Surface weights. For
        transport calculations <b>ep_keepbands</b> must be set to 1.
    topics: ElPhonTransport_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_nqpt@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Electron Phonon Number of Q PoinTs
    requires: null
    text: |-
        <p>In case a non-uniform grid of q-points is being used, for direct calculation
        of the electron-phonon quantities without interpolation, this specifies the
        number of q-points to be found in the GKK file, independently of the normal
        anaddb input (ngqpt)
    topics: ElPhonTransport_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_nspline@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 20
    dimensions: scalar
    excludes: null
    mnemonics: Electron Phonon Number for SPLINE interpolation
    requires: null
    text: |-
        <p>The scale factor for cubic spline interpolation, only used in the relaxation time approximation ([[anaddb:ifltransport]]=3).
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_prt_yambo@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Electron Phonon PRinTout YAMBO data
    requires: null
    text: |-
        <p>For electron-phonon calculations, print out matrix elements for use by the yambo code.
    topics: ElPhonInt_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ep_qptlist@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: (3*[[anaddb:ep_nqpt]])*0
    dimensions:
    - 3
    - '[[anaddb:ep_nqpt]]'
    excludes: null
    mnemonics: Electron Phonon Q PoinT LIST
    requires: null
    text: |-
        <p>In case a non-uniform grid of q-points is being used, for direct calculation
        of the electron-phonon quantities without interpolation, this specifies the
        q-points to be found in the GKK file, independently of the normal
        anaddb input (ngqpt), in reduced coordinates of the reciprocal space lattice.
    topics: PhononWidth_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: ep_scalprod@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: DO SCALar PRODuct for gkk matrix elements
    requires: null
    text: |-
        <p>The input variable <b>ep_scalprod</b> is a flag determining whether the scalar
        product of the electron-phonon matrix elements (gkk) with the phonon
        displacement vectors is done before or after interpolation. Doing so before
        (<b>ep_scalprod</b> 1) makes phonon linewidths smoother but introduces an error,
        as the interpolated phonons and gkk are not diagonalized in the same basis.
        Doing so afterwards (<b>ep_scalprod</b> 0) eliminates the diagonalization error,
        but sometimes gives small spikes in the phonon linewidths near band crossings
        or high symmetry points. I do not know why...
    topics: PhononWidth_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: eph_extrael
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-PHonon: EXTRA ELectrons'
    requires: null
    text: |-
        Number of electrons per unit cell to be added to the initial value computed from the pseudopotentials and unit cell.
    topics: ElPhonInt_expert
    varset: eph
    vartype: real
- !variable
    abivarname: eph_fermie
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-PHonon: FERMI Energy'
    requires: null
    text: |-
        This variable can be used to change the value of the Fermi level
        when performing electron-phonon calculations with [[optdriver]]==7.
        This variable has effect only if set to a non-zero value.
        See also [[eph_extrael]].
    topics: ElPhonInt_expert
    varset: eph
    vartype: real
- !variable
    abivarname: eph_fsewin
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01 Hartree
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-Phonon: Fermi Surface Energy WINdow'
    requires: null
    text: |-
        This variable defines the energy window around the Fermi level
        used for e-ph calculations ([[optdriver]] = 7).
        Only the states located in the energy range
        [efermi - eph_fsewin, efermi + eph_fsewin] are included in the e-ph calculation.

        <p>
        Related input variables: [[eph_intmeth]], [[eph_fsmear]], [[eph_extrael]] and [[eph_fermie]].
        </p>
    topics: ElPhonInt_expert
    varset: eph
    vartype: real
- !variable
    abivarname: eph_fsmear
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01 Hartree
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-PHonon: Fermi surface SMEARing'
    requires: '[[eph_intmeth]] == 1'
    text: |-
        This variable defines the gaussian broadening used for the
        integration over the Fermi surface when [[eph_intmeth]] == 1.
    topics: ElPhonInt_expert
    varset: eph
    vartype: real
- !variable
    abivarname: eph_intmeth
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-Phonon: INTegration METHod'
    requires: null
    text: |-
        This variable defines the technique for the integration on the Fermi surface of electron-phonon quantities.
        <p>
        1 for Gaussian technique with broadening factor [[eph_fsmear]].
        2 for tetrahedron method.
        </p>

        See also [[eph_fsewin]], [[eph_extrael]] and [[eph_fermie]].
    topics: ElPhonInt_expert
    varset: eph
    vartype: integer
- !variable
    abivarname: eph_mustar
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-PHonon : MU STAR (electron-electron interaction strength)'
    requires: null
    text: |-
        Average electron-electron interaction strength, for the computation of the superconducting Tc using Mc-Millan's formula.
    topics: ElPhonInt_expert
    varset: eph
    vartype: real
- !variable
    abivarname: eph_ngqpt_fine
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: 'Electron-PHonon : Number of Grid Q-PoinTs in FINE grid.'
    requires: null
    text: |-
        This variable activates the interpolation of the first-order variation of the self-consistent potential in the electron-phonon code.
        If eph_nqgpt_fine differs from [0, 0, 0], the code will use the Fourier transform to interpolate the DFPT potentials on this fine
        q-mesh starting from the irreducible set of q-points read from
        the DDB file. This approach is similar to the one used
        to interpolate the interatomic force constants in q-space.
        If eph_ngqpt_fine is not given, the EPH code uses the list of irreducible q-points reported in the DDB file (default behavior).
    topics: ElPhonInt_expert
    varset: eph
    vartype: integer
- !variable
    abivarname: eph_task
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-PHonon: Task'
    requires: null
    text: |-
        <p>
        When [[optdriver]]==7, select the task to be performed.
         The choice is among :
         <br />
         [[eph_task]]=1 : phonon linewidth
         <br />
         [[eph_task]]=2 : electron-phonon coupling elements
        </p>
    topics: ElPhonInt_expert
    varset: dfpt
    vartype: integer
- !variable
    abivarname: eph_transport
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Electron-PHonon: TRANSPORT flag'
    requires: null
    text: |-
        NB - this does not work yet.
        This variable can be used to turn on the calculation of transport
        quantities in the eph module of abinit. Value of 1 corresponds to
        elastic LOVA as in the PRB by Savrasov and Savrasov
    topics: ElPhonInt_expert
    varset: eph
    vartype: integer
- !variable
    abivarname: eshift
    characteristics:
    - '[[DEVELOP]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Energy SHIFT
    requires: '[[wfoptalg]]==3'
    text: |-
        <p>
        [[eshift]] gives the shift of the energy used in the
        shifted Hamiltonian squared.
        The algorithm will determine eigenvalues and eigenvectors centered
        on [[eshift]].
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
        </p>
    topics: SCFAlgorithms_expert
    varset: dev
    vartype: real
- !variable
    abivarname: esmear
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    dimensions: scalar
    excludes: null
    mnemonics: Eigenvalue SMEARing
    requires: '[[smdelta]] != 0'
    text: |-
        <p>
        that is, if the user is performing simulations of the electronic lifetimes induced by the electron-phonon coupling.
         <br />
         <br />
         The variable [[esmear]] determines the width of the functions approximating the delta function, \delta(e_{nk}-e_{n'k'}),
        present in the expression of the lifetimes. One should use a width comparable with the Debye frequency or the maximum phonon frequency.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
        </p>
    topics: TDepES_useful
    varset: dfpt
    vartype: real
- !variable
    abivarname: exchmix
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.25
    dimensions: scalar
    excludes: null
    mnemonics: EXCHange MIXing
    requires: '[[useexexch]] == 1'
    text: |-
        <p>
         [[exchmix]] allows to tune the ratio of exact exchange when
        [[useexexch]] is used. The default value of 0.25 corresponds to PBE0.
        </p>
    topics: xc_useful
    varset: dev
    vartype: real
- !variable
    abivarname: exchn2n3d
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: EXCHange N2 and N3 Dimensions
    requires: null
    text: |-
        <p>
         If [[exchn2n3d]] is 1, the internal representation of the FFT arrays
        in reciprocal space will be array(n1,n3,n2), where the second and
        third dimensions have been switched. This is to allow to be coherent with the
        [[exchn2n3d]]=4xx FFT treatment.
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: extrapwf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: flag - EXTRAPolation of the Wave-Functions
    requires: '[[densfor_pred]]==5 or [[densfor_pred]]==6'
    text: |-
        <p>
        This flag activates the extrapolation of wave-functions from one Molecular Dynamics (or Structural Relaxation) step to another.
        The wave functions are extrapolated using 2nd-order algorithm of Arias, Payne and Joannopoulos
         (PRB 45, 1538 (1992)).<br>
         Note that, when activated, this extrapolation requires non-negligible additional memory resources
         as the wave functions are stored for the two previous time steps. Also, it can only be activated
         if a consistent density extrapolation is activated (see [[densfor_pred]]).<br>
        ABINIT 7.10: this option is <b>under development</b> and might give wrong results.
        </p>
    topics: TuningSpeed_expert, MolecularDynamics_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: f4of2_sla
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.625 for d electron
    - 0.6681 for f electron
    dimensions: scalar
    excludes: null
    mnemonics: F4 Over F2 ratio of Slater integrals
    requires: '[[usepaw]]==1 and ([[usepawu]]==1 or [[usedmft]]==1)'
    text: |-
        <p>
        This gives the ratio of Slater Integrals F4 and F2.
        It is used in DFT+U or DFT+DMFT for the calculation of the orbital
        dependent screened coulomb interaction.
        </p>
    topics: DFT+U_expert
    varset: paw
    vartype: real
- !variable
    abivarname: f6of2_sla
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.4943
    dimensions: scalar
    excludes: null
    mnemonics: F6 Over F2 ratio of Slater integrals
    requires: ([[usepawu]]==1 or [[usedmft]]==1) and [[lpawu]]=3
    text: |-
        <p>
        Gives the ratio of Slater Integrals F6 and F2.
        It is used with [[f4of2_sla]]==3 in DFT+U or DFT+DMFT for the calculation of the orbital dependent screened coulomb interaction.
        </p>
    topics: DFT+U_expert
    varset: paw
    vartype: real
- !variable
    abivarname: fband
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[occopt]]==1': 0.125
        '[[occopt]]>2': 0.5
        '[[usewvl]]==1': 0.0
        defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Factor for the number of BANDs
    requires: null
    text: |-
        <p>
         Governs the number of bands to be used in the code in the case
        the parameter [[nband]] is not defined in the input file
        (which means that [[occopt]] is not equal to 0 or 2).
        </p>
        <p>
         In case [[fband]] is 0.0d0, the code computes from
        the pseudopotential files and the geometry data
        contained in the input file, the number of electrons
        present in the system. Then, it computes the minimum
        number of bands that can accommodate them, and use
        that value for [[nband]].
         <br />
         In case [[fband]] differs from
        zero, other bands will be added, just
        larger than [[fband]] times the number of atoms.
        This parameter is not echoed in the top of the main
        output file, but only the parameter [[nband]] that it allowed
        to compute. It is also not present in the dtset array (no internal).
         <br />
         The default values are chosen such as to give naturally some
        conduction bands. This improves the robustness of the code,
        since this allows to identify lack of convergence coming from
        (near-)degeneracies at the Fermi level. In the metallic
        case, the number of bands generated might be too small
        if the smearing factor is large. The occupation numbers
        of the higher bands should be small enough such as to
        neglect higher bands. It is difficult to automate
        this, so a fixed default value has been chosen.
        </p>
    topics: BandOcc_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: fermie_nest
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: FERMI Energy for printing the NESTing function
    requires: null
    text: |-
        <p>
         This input variable is only effective when [[prtnest]]=1. The energy is relative to the calculated fermi energy.
        </p>
    topics: printing_prfermi
    varset: dev
    vartype: real
- !variable
    abivarname: fftalg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[FFTW3]] and [[usedmft]]==0': 312
        '[[paral_kgb]]==1': 401
        defaultval: 112
    dimensions: scalar
    excludes: null
    mnemonics: Fast Fourier Transform ALGorithm
    requires: null
    text: |-
        <p>
         This keyword is
         <b>
          irrelevant
         </b>
         when Fast Fourier Transforms are done using
         <b>
          Graphics Processing Units
         </b>
         (GPU),
        i.e. when [[use_gpu_cuda]]=1 (in that case, it is ignored).
         <br />
         <br />
         Allows to choose the algorithm
        for Fast Fourier Transforms. These have to be used
        when applied to wavefunctions (routine fourwf.F90),
        as well as when
        applied to densities and potentials (routine fourdp.F90).
        Presently, it is the concatenation of three digits,
        labelled (A), (B) and (C).
         <br />
         <br />
         The first digit (A) is to be chosen among 1, 2, 3, 4 or 5 :
         <ul>
          <li>
           1=&gt; use FFT routines written by S. Goedecker.
          </li>
          <li>
           2=&gt; not available anymore
          </li>
          <li>
           3=&gt; use serial or multi-threaded FFTW3 fortran routines (
           <a href="http://www.fftw.org">
            http://www.fftw.org
           </a>
           ).
        Currently implemented with [[fftalg]]=312.
          </li>
          <li>
           4=&gt; use FFT routines written by S. Goedecker, 2002 version, that will
        be suited for MPI and OpenMP parallelism.
          </li>
          <li>
           5=&gt; use serial or multi-threaded MKL routines
        Currently implemented with [[fftalg]]=512.
          </li>
         </ul>
         The second digit (B) is related to fourdp.f :
         <ul>
          <li>
           0=&gt; only use Complex-to-complex FFT
          </li>
          <li>
           1=&gt; real-to-complex is also allowed (only coded for A==1, A==3 and A==5)
          </li>
         </ul>
         The third digit (C) is related to fourwf.f :
         <ul>
          <li>
           0=&gt; no use of zero padding
          </li>
          <li>
           1=&gt; use of zero padding (only coded for A==1, A==4)
          </li>
          <li>
           2=&gt; use of zero padding, and also combines actual
        FFT operations (using 2 routines from S. Goedecker)
        with important pre- and post-processing
        operations, in order to maximize cache data reuse.
        This is very efficient for cache architectures.
        (coded for A==1 and A==4, but A==4 is not yet sufficiently tested)
          </li>
         </ul>
         Internal representation as [[ngfft]](7).
        </p>
    topics: TuningSpeed_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: fftcache
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: 'todo: Not yet machine-dependent'
    commentdims: null
    defaultval: 16
    dimensions: scalar
    excludes: null
    mnemonics: Fast Fourier Transform CACHE size
    requires: null
    text: |-
        <p>
         Gives the cache size of the current
        machine, in Kbytes.
         <br />
         Internal representation as [[ngfft]](8).
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: fftgw
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 21
    dimensions: scalar
    excludes: null
    mnemonics: FFT for GW calculation
    requires: ' [[optdriver]]==3 or [[optdriver]]==4'
    text: |-
        <p>
         The basic ingredients needed to perform both a screening and a sigma calculation are the so-called
        oscillator matrix elements defined as
         <br />
         <br />
        &lt;
         <b>
          k-q
         </b>
         , b1 | e^{-i (
         <b>
          q+G
         </b>
         ).
         <b>
          r
         </b>
         } |
         <b>
          k
         </b>
         b2 &gt;
         <br />
         <br />
         In reciprocal space, this expression is evaluated by a convolution in which the number of reciprocal
        lattice vectors employed to describe the wavefunctions is given
        by [[ecutwfn]].
        In the case of screening calculations, the number of
         <b>
          G
         </b>
         vectors in the above expression is defined
        by [[ecuteps]],
        while [[ecutsigx]] defined the number of
         <b>
          G
         </b>
         used in sigma calculations.
        To improve the efficiency of the code, the oscillator matrix elements are evaluated
        in real space through FFT techniques, and the [[fftgw]] input variable is used to select the FFT
        mesh to be used.
        </p>
        <p>
         [[fftgw]] is the concatenation of two digits, labelled (A) and (B) whose value is internally used
        to define the value of  [[ngfft]](1:3) (see the setmesh.F90 routine).
        </p>
        <p>
         The first digit (A) defines the augmentation of the FFT grid. Possible values are 1, 2 and 3.
         <ul>
          <li>
           0 =&gt; Use the FFT grid specified by the user through [[ngfft]](1:3)
          </li>
          <li>
           1 =&gt; Use a coarse FFT grid which encloses a sphere in reciprocal space whose radius depends
        on the largest value between
        [[ecutwfn]] and [[ecuteps]]
          </li>
          <li>
           2 =&gt;  Use a slightly augmented FFT which is sufficient for the correct treatment of the
        convolution
          </li>
          <li>
           3 =&gt; Doubled FFT grid (same mesh as that used for GS calculations).
          </li>
         </ul>
        </p>
        <p>
         The second digit (B) can be chosen between 0 and 1. It defines whether a FFT grid compatible with all
        the symmetries of the space group must be enforced or not:
         <ul>
          <li>
           0 =&gt; Use the smallest FFT mesh which is compatible with the FFT library (faster, save memory
        but is less accurate)
          </li>
          <li>
           1 =&gt; Enforce a FFT grid which is compatible with all the symmetry operations of the space
        group. This method leads to an increase both of CPU time and memory, but the matrix elements
        are more accurate since the symmetry properties of the system are preserved.
          </li>
         </ul>
         The behaviour of ABINIT before v5.5 corresponds to the default value 11.
        </p>
    topics: GW_expert, Susceptibility_expert, SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: fockoptmix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'FOCK operator : OPTions for MIXing'
    requires: '[[usefock]]==1'
    text: |-
        Governs the mixing algorithm at the level of the Fock operator, i.e.
        how to mix it, and how the underlying SCF calculation is to be performed. It is the most relevant when the Fock operator is not updated at each SCF step ([[nnsclohf]]/=0).
        <p>
        The last digit of [[fockoptmix]] governs what happens at the level of the SCF algorithm, when the Fock operator is updated.
        <ol>
        <li>
        If [[fockoptmix]]==0 : the SCF algorithm is not restarted (it continues to use the previous potential/density pairs without worrying).</li>
        <li>
        If [[fockoptmix]]==1 : the SCF algorithm is restarted (the previous potential/density pairs are discarted).</li>
        </ol>
        <p>
        The second-to-last (dozen) digit governs the possible modification of the XC functional inside the SCF loop to take into account the lack of update of the Fock operator. Irrelevant when the unit digit is 0.
        <p>
        The third-to-last (hundreds) digit governs the mixing of the Fock operator itself with its previous occurrences. Irrelevant when the unit digit is 0.
    topics: Hybrids_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: foldep@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: FOLlow DEParture
    requires: null
    text: |-
        Needed in the case [[aim:follow]]=1 only.
          Defines the starting point.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: follow@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: FOLLOW the gradient path
    requires: null
    text: |-
        Follow the gradient path to the corresponding atom
          starting from the position specified in the input variable
          [[aim:foldep]].
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: folstp@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    dimensions: scalar
    excludes: null
    mnemonics: FOLlow STeP
    requires: null
    text: |-
        The first step for following the gradient path.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: freeze_displ@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: FREEZE DISPLacement of phonons into supercells
    requires: null
    text: |-
        <p>If different from zero, <b>freeze_displ</b> will be used as the amplitude of a phonon displacement.
        For each q-point and mode in the [[anaddb:qph1l]] list,
        a file will be created containing a supercell
        of atoms with the corresponding phonon displacements frozen in.
        This is typically useful to freeze a soft phonon mode, then let it relax in abinit
        afterwards.
        <br>
        <b>freeze_displ</b> is unitless, but has a physical meaning: it is related to the Bose
        distribution n_B and the frequency w_qs of the phonon mode. At a given temperature T,
        <b>freeze_displ</b> will give the mean square displacement of atoms (along with the displacement
        vectors, which are in Bohr). In atomic units <b>freeze_displ</b> = sqrt((0.5 + n_B(w_qs/kT) / w_qs)
        Typical values are 50-200 for a frequency of a few hundred cm-1 and room temperature. If all you want
        is to break the symmetry in the right direction, any reasonable value (10-50) should be ok.
        <br>
        <b>WARNING</b>: this will create a <i>lot</i> of files (3*natom*nph1l), so it should be used with a small number
        [[anaddb:nph1l]] of q-points for interpolation.
    topics: PhononBands_expert
    varset: anaddb
    vartype: real
- !variable
    abivarname: freqim_alpha
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5.0
    dimensions: scalar
    excludes: null
    mnemonics: FREQuencies along the IMaginary axis ALPHA parameter
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[freqim_alpha]] is used only for numerical integration of the GW self-energy
        ([[gwcalctyp]]= 2, 12, 22, 9, 19, 29).
         <br />
         [[freqim_alpha]] determines the location of the maximum frequency point along the imaginary axis
        if the default grid is used in Contour Deformation (numerical integration) calculations. It is set
        as
         <span style="font-family:Times,Serif">
          <i>
           &alpha;&middot;&omega;
           <sub>
            p
            <sub>
            </sub>
           </sub>
          </i>
         </span>
         , where
         <span style="font-family:Times,Serif">
          <i>
           &omega;
           <sub>
            p
            <sub>
            </sub>
           </sub>
          </i>
         </span>
         is the plasma frequency
        determined by the average density of the system (this can be set by hand by using the variable [[ppmfrq]]). See the section on grids in the descriptive text for [[cd_frqim_method]] for a detailed description of the formula.
        </p>
    topics: SelfEnergy_expert
    varset: gw
    vartype: real
- !variable
    abivarname: freqremax
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: FREQuencies along the Real axis MAXimum
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         [[freqremax]] is used only for numerical integration of the GW self-energy
        ([[gwcalctyp]]= 2, 12, 22, 9, 19, 29).
         <br />
         [[freqremax]] sets the maximum real frequency used to calculate the dielectric matrix in order
        to perform the numerical integration of the GW self-energy.
        [[freqremax]], [[freqremin]] and [[nfreqre]]
        define the spacing of the frequency mesh along the real axis.
        </p>
    topics: FrequencyMeshMBPT_basic
    varset: gw
    vartype: real
- !variable
    abivarname: freqremin
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: FREQuencies along the Real axis MINimum
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         [[freqremin]] is used only for numerical integration of the GW self-energy
        ([[gwcalctyp]]= 2, 12, 22, 9, 19, 29).
         <br />
         [[freqremin]] sets the minimum real frequency used to calculate the dielectric matrix in order
        to perform the numerical integration of the GW self-energy.
        [[freqremin]] can be used to split a wide frequency interval into smaller subintervals that
        can be calculated independently.
        The different subintervals can then be merged together with the
         <b>
          Mrgscr
         </b>
         utility thus obtaining
        a single screening file that can used for self-energy calculations.

        Note that [[freqremax]], [[freqremin]]
        and [[nfreqre]] define the spacing of the frequency mesh along the real axis.
        </p>
    topics: FrequencyMeshMBPT_basic
    varset: gw
    vartype: real
- !variable
    abivarname: freqspmax
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: FREQuencies for the SPectral function MAXimum
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[freqspmax]] sets the maximum real frequency used to calculate the spectral function
        from the GW Green's function. [[freqspmin]], [[freqspmax]] and
        [[nfreqsp]] define the spacing of an equidistant frequency mesh along
        the real axis. Alternatively, the variables [[gw_customnfreqsp]] and
        [[gw_freqsp]] can be used to make a user-defined grid.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: freqspmin
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: -[[freqspmax]]
    dimensions: scalar
    excludes: null
    mnemonics: FREQuencies for the SPectral function MINimum
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[freqspmin]] sets the minimum real frequency used to calculate the spectral function
        from the GW Green's function. [[freqspmin]] is set to -[[freqspmax]]
        if left undefined. [[freqspmin]], [[freqspmax]], and
        [[nfreqsp]] define the spacing of an equidistant frequency mesh along
        the real axis. Alternatively, the variables [[gw_customnfreqsp]] and
        [[gw_freqsp]] can be used to make a user-defined grid.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: friction
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.001
    dimensions: scalar
    excludes: null
    mnemonics: internal FRICTION coefficient
    requires: null
    text: |-
        <p>
         Gives the internal friction coefficient (atomic units)
        for Langevin dynamics (when [[ionmov]]=9):
        fixed temperature simulations with random forces.
        </p>
        <p>
         The equation of motion is :
         <br />
         M
         <sub>
          I
         </sub>
         d
         <sup>
          2
         </sup>
         R
         <sub>
          I
         </sub>
         /dt
         <sup>
          2
         </sup>
         = F
         <sub>
          I
         </sub>
         - [[friction]] M
         <sub>
          I
         </sub>
         dR
         <sub>
          I
         </sub>
         /dt - F_random
         <sub>
          I
         </sub>
         <br />
         where F_random
         <sub>
          I
         </sub>
         is a Gaussian random force with average
        zero,
        and variance 2 [[friction]] M
         <sub>
          I
         </sub>
         kT.
         <br />
         The atomic unit of friction is
        hartrees*electronic mass*(atomic time units)/Bohr
         <sup>
          2
         </sup>
         . See J.
        Chelikowsky, J. Phys. D : Appl Phys. 33(2000)R33.
        </p>
    topics: MolecularDynamics_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: frmax@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    dimensions: scalar
    excludes: null
    mnemonics: FRequency MAXimum
    requires: null
    text: |-
        <p>Value of the largest frequency for the frequency-dependent dielectric tensor, in Hartree.
    topics: Phonons_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: frmin@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: FRequency MINimum
    requires: null
    text: |-
        <p>Value of the lowest frequency for the frequency-dependent dielectric tensor, in Hartree.
    topics: Phonons_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: frzfermi
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: FReeZe FERMI energy
    requires: null
    text: |-
        <p>
        Can be used to suppress artificially the first-order change of
        Fermi energy, in case of Response Function calculation
        for metals at Q=0.
        The input variable [[frzfermi]],
        if set to 1, allows to suppress this contribution, but this is incorrect.
        </p>
    topics: DFPT_expert
    varset: dfpt
    vartype: integer
- !variable
    abivarname: fxcartfactor
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: (Bohr^2)/Hartree
        value: 1
    dimensions: scalar
    excludes: null
    mnemonics: Forces to (X) CARTesian coordinates FACTOR
    requires: null
    text: |-
        <p>
         The forces multiplied
        by [[fxcartfactor]] will be treated like difference in cartesian coordinates in the
        process of optimization. This is a simple preconditioner.
         <br />
         TO BE UPDATED See ([[ionmov]]=2,
        non-zero
        [[optcell]]).
        For example, the stopping criterion defined by
        [[tolmxf]] relates to these scaled
        stresses.
        </p>
    topics: TransPath_expert, GeoOpt_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: ga_algor
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Genetic Algorithm - ALGOrithm selection
    requires: null
    text: |-
        <p>
         Choosing method to make the structure selection. Only the enthalpy is used now but we
        plan to include, energy, electronic band gap and alchemical potentials. Right now only value of 1 (enthalpy)
        works.
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: ga_fitness
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Genetic Algorithm FITNESS function selection
    requires: null
    text: |-
        <p>
         Different methodologies to perform the roulette-wheel selection of parents. Even though, the
        objective function is the crystalline enthalpy (H_i), the weight of the population elements to be chosen from
        in a roulette-wheel selection can be given through different functions. We consider the following cases.
         <br />
         1. F = H_i / Sum H_i
         <br />
         2. F = exp(-(H_i-H_min)) / Sum exp(-(H_i-H_min))
         <br />
         3. F = (1/n_i) / Sum (1/n_i). Where n_i is the position in the ordered list of enthalpies
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: ga_n_rules
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Genetic Algorithm Number of RULES
    requires: null
    text: |-
        <p>
         Different genetic rules have been implemented and the user has the change to choose between any of them.
        Right now we have 4 rules. See
        [[ga_rules]]
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: ga_opt_percent
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.2
    dimensions: scalar
    excludes: null
    mnemonics: Genetic Algorithm OPTimal PERCENT
    requires: null
    text: |-
        <p>
         Percentage of the population that according to the fitness function passes
        to the following iteration.
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: ga_rules
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Genetic Algorithm RULES
    requires: null
    text: |-
        <p>
         Different genetic rules have been implemented and the user has the change to choose between any of them.
        The chosen number of rules have been defined in
        [[ga_n_rules]]
         <br />
         <br />
         Implemented rules are
         <br />
         1) crossover. Two parents are randomly chosen and two springs are mixed from the two by (a) choosing randomly (through
        Fitness function) two parents and then randomly rotating and shifting the coordinates withing that particular cell.
        (b) Slice every one of the unit cell of the parents along a random direction and creating the spring offs from the
        pieces of the two parents.
         <br />
         2) Vector flip mutation. From the coordinates from a given parent, a piece of it is inverted.
         <br />
         3) random strain.  A random anisotropic deformation is given to the unit cell.
         <br />
         4) Coordinates mutation of 1/4 of the whole coordinates.
         <br />
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: genafm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: GENerator of the translation for Anti-FerroMagnetic space group
    requires: null
    text: |-
        <p>
         This input variable might be used to define a Shubnikov type IV magnetic space group (anti-ferromagnetic
        space group). The user is advised to consult
        "The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford."
         <br />
         A Shubnikov type IV magnetic space group might be defined by its Fedorov space group
        (set of spatial symmetries, that do not change the magnetization), and
        one translation associated with a change of magnetization.
        [[genafm]] is precisely this translation, in reduced coordinates (like [[xred]])
         <br />
         Thus, one way to specify a Shubnikov IV magnetic space group, is to define both
        [[spgroup]] and [[genafm]]. Alternatively, one might
        define [[spgroup]] and [[spgroupma]],
        or define by hand the set of symmetries, using [[symrel]],
        [[tnons]] and [[symafm]]
        </p>
    topics: spinpolarisation_useful, SmartSymm_useful
    varset: geo
    vartype: real
- !variable
    abivarname: get1den
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the first-order density from _1DEN file
    requires: null
    text: |-
        <p>
         Relevant only for non self consistent RF calculations (e.g. to get electron phonon matrix elements)
        or for non linear RF calculations (to get mixed higher order derivatives you need several perturbed
        densities and wave functions).
        Indicate the files from which first-order densities must be obtained,
        in multi-dataset mode (in single dataset mode, use [[ird1den]]).
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: nonlinear_useful, ElPhonInt_useful
    varset: files
    vartype: integer
- !variable
    abivarname: get1wf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'GET the first-order wavefunctions from _1WF file '
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],
        [[irdwfq]], [[ird1wf]], [[irdddk]]. One should first read the
        explanations given for these latter variables.
         <br />
         The
         <b>
          getwfk
         </b>
         ,
         <b>
          getwfq
         </b>
         , [[get1wf]] and
         <b>
          getddk
         </b>
         variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the
         <b>
          getwfk
         </b>
         input variable (the only
        one used in ground-state calculations), but
        the rules for
         <b>
          getwfq
         </b>
         and [[get1wf]] are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If
         <b>
          getwfk
         </b>
         ==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If
         <b>
          getwfk
         </b>
         is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If
         <b>
          getwfk
         </b>
         is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If
         <b>
          getwfk
         </b>
         is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if
         <b>
          getwfk
         </b>
         =0 for that
        initialisation.
        Thanks to this rule, the use of
         <b>
          getwfk
         </b>
         -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getbscoup
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the Bethe-Salpeter COUPling block from ...
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the starting coupling block of the excitonic Hamiltonian will be taken from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT coupling
        block is to be taken, as INPUT of the present dataset.
         <br />
         If [[getbscoup]]==0, no such use of previously computed coupling block file is done.
         <br />
         If [[getbscoup]] is positive, its value gives the index of the dataset to be used as input.
         <br />
         If [[getbscoup]] is -1, the output of the previous dataset must be taken, which is a frequently occuring case.
         <br />
         If [[getbscoup]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the coupling block is not initialised from
        a disk file, so that it is as if [[getbscoup]]=0 for that initialisation.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getbseig
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the Bethe-Salpeter EIGenstates from ...
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the starting excitonic eigenstates are to be taken from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT eigenstates
        are to be taken, as INPUT eigenstates of the present dataset.
         <br />
         If [[getbseig]]==0, no such use of previously computed output eigenstates file is done.
         <br />
         If [[getbseig]] is positive, its value gives the index of the dataset
        from which the output states is to be used as input.
         <br />
         If [[getbseig]] is -1, the output eigenstates of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getbseig]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the eigenstates are not initialised from
        a disk file, so that it is as if [[getbseig]]=0 for that initialisation.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getbsreso
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the Bethe-Salpeter RESOnant block from ...
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the starting resonant block of the excitonic Hamiltonian will be taken from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT resonant
        block is to be taken, as INPUT of the present dataset.
         <br />
         If [[getbsreso]]==0, no such use of previously computed resonant block file is done.
         <br />
         If [[getbsreso]] is positive, its value gives the index of the dataset to be used as input.
         <br />
         If [[getbsreso]] is -1, the output of the previous dataset must be taken, which is a frequently occurring case.
         <br />
         If [[getbsreso]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the resonant block is not initialised from
        a disk file, so that it is as if [[getbsreso]]=0 for that initialisation.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getcell
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET CELL parameters from ...
    requires: null
    text: |-
        <p>
         This variable is typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0),
        since it describes from which dataset [[acell]]
        and
        [[rprim]] are to be taken, as input of the
        present
        dataset. The cell parameters are [[EVOLVING]] variables,
        for which such a chain of calculations is useful.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
        </p>
    topics: multidtset_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: getddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the DDB from ...
    requires: null
    text: |-
        <p>
        This variable should be used when performing electron-phonon
        or temperature-dependence calculations.
        The Born effective charge
        as well as the dielectric tensor will be read from a previous
        DFPT calculations of the electric field at q=Gamma.

        The use of this variable will trigger the cancellation of a
        residual dipole that leads to an unphysical divergence of the
        GKK with vanishing q-points.

        The use of this variable greatly improves the k-point convergence
        speed as the density of the k-point grid required to obtain the
        fulfillment of the charge neutrality sum rule is usually prohibitively
        large.

         <br />
         If [[getddb]]==0, no such use of previously computed Born effective charge
         and dielectric tensor is done.
         <br />
         If [[getddb]] is positive, its value gives the index of the dataset
        from which the output density is to be used as input.
         <br />
         If [[getddb]] is -1, the output density of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getddb]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: ElPhonInt_expert, TDepES_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getddk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the DDK wavefunctions from _1WF file
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],[[irdwfq]],[[ird1wf]],[[irdddk]].
         One should first read the
        explanations given for these latter variables.
         <br />
         The
         <b>
          getwfk
         </b>
         ,
         <b>
          getwfq
         </b>
         ,
         <b>
          get1wf
         </b>
         and [[getddk]] variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the
         <b>
          getwfk
         </b>
         input variable (the only
        one used in ground-state calculations), but
        the rules for
         <b>
          getwfq
         </b>
         and
         <b>
          get1wf
         </b>
         are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If
         <b>
          getwfk
         </b>
         ==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If
         <b>
          getwfk
         </b>
         is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If
         <b>
          getwfk
         </b>
         is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If
         <b>
          getwfk
         </b>
         is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if
         <b>
          getwfk
         </b>
         =0 for that
        initialisation.
        Thanks to this rule, the use of
         <b>
          getwfk
         </b>
         -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the DENsity from ...
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a ground-state
        calculation, if [[iscf]]&lt;0 (non-SCF calculation),
        to indicate that the starting density is to be taken
        from the output of a previous dataset.
        It is used to chain the calculations,
        since it describes from which dataset the OUTPUT density
        are to be taken, as INPUT density of the present dataset.
         <br />
         If [[getden]]==0, no such use of previously computed output
        density file is done.
         <br />
         If [[getden]] is positive, its value gives the index of the dataset
        from which the output density is to be used as input.
         <br />
         If [[getden]] is -1, the output density of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getden]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior
        to the first), the density is not initialised from
        a disk file, so that it is as if [[getden]]=0 for that
        initialisation.
        Thanks to this rule, the use of [[getden]] -1 is rather
        straightforward : except for the first density, that
        is not initialized by reading a disk file, the output
        density of one dataset is input of the next one.
         <br />
         Be careful : the output density file of a run with
        non-zero [[ionmov]] does not have the proper name (it has a "TIM"
        indication) for use as an input of an [[iscf]]&lt;0 calculation.
         <br />
         One should use the output density of a [[ionmov]]==0 run.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getgam_eig2nkq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the GAMma phonon data EIG2NKQ from dataset
    requires: '[[ieig2rf]] != 0 and [[qpt]] != (0.0,0.0,0.0)'
    text: |-
        <p>
         Relevant for second-order
        eigenvalue calculations using response-functions ([[ieig2rf]] != 0), and only
        for non-zero wavevectors [[qpt]].
         <br>
         From the electron-phonon matrix elements at some wavevector only, it is not possible to determine the Debye-Waller contribution : one has to know also the q=Gamma electron-phonon matrix elements.
         <br />
         The variable [[getgam_eig2nkq]] allows to transmit the information about the second-order derivatives of the
        eigenvalues for q=Gamma from the dataset where the calculation at Gamma was done, to the datasets
        for other wavevectors.
        </p>
    topics: multidtset_useful, TDepES_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: gethaydock
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the HAYDOCK restart file from ...
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the Haydock iterative technique will be restarted from the output of a previous dataset.
         <br />
         If [[gethaydock]]==0, no such use of previously computed coupling block file is done.
         <br />
         If [[gethaydock]] is positive, its value gives the index of the dataset to be used as input.
         <br />
         If [[gethaydock]] is -1, the output of the previous dataset must be taken, which is a frequently occuring case.
         <br />
         If [[gethaydock]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the coupling block is not initialised from
        a disk file, so that it is as if [[gethaydock]]=0 for that initialisation.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getocc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET OCC parameters from ...
    requires: null
    text: |-
        <p>
         This variable is typically used to chain the calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0),
        since it describes from which dataset the array [[occ]]
        is to be taken, as input of the present
        dataset. The occupation numbers are [[EVOLVING]] variables,
        for which such a chain of calculations is useful.
         <br />
         If [[getocc]]==0, no such use of previously computed output occupations is done.
         <br />
         If [[getocc]] is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If [[getocc]] is -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getocc]] is a negative number, it indicates the number
        of datasets to go backward to find the needed data.
        In this case, if one refers to a non existent data set (prior to the first), the date is not initialised from a disk file, so that it is as if [[getocc]]==0 for that initialisation.
         <br />
         NOTE that a non-zero [[getocc]] MUST be used with [[occopt]]==2,
        so that the number of bands has to be initialized for
        each k point. Of course, these numbers of bands must be
        identical to the numbers of bands of the dataset from which
        [[occ]] will be copied. The same is true for the number of k points.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getqps
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET QuasiParticle Structure
    requires: null
    text: |-
        <p>
         Used when [[ndtset]]&gt;0
        (multi-dataset mode) and [[optdriver]]=3, or 4
        (screening or sigma step of a GW calculation),
        to indicate that the eigenvalues and possibly the wavefunctions have to be
        taken from a previous quasiparticle calculation (instead of the usual LDA starting
        point). This is to achieve quasiparticle self-consistency.
        See also [[irdqps]]
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful, GW_useful, Susceptibility_useful, SelfEnergy_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getscr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET SCReening (the inverse dielectric matrix) from ...
    requires: null
    text: |-
        <p>
         Used when [[ndtset]]&gt;0
        (multi-dataset mode) and [[optdriver]]=4
        (sigma step of a GW calculation),
        to indicate that the dielectric matrix (_SCR file) is to be taken
        from the output of a previous dataset.
        It is used to chain the calculations,
        since it describes from which dataset the OUTPUT dielectric matrix
        is to be taken, as INPUT of the present dataset.
         <br />
         If [[getscr]]==0, no such use of previously computed output
        _SCR file is done.
         <br />
         If [[getscr]] is positive, its value gives the index of the dataset
        from which the output _SCR file is to be used as input.
         <br />
         If [[getscr]] is -1, the output _SCR file of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getscr]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior
        to the first), the _SCR file is not initialised from
        a disk file, so that it is as if [[getscr]]=0 for that
        initialisation.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful, GW_useful, SelfEnergy_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getsuscep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET SUSCEPtibility (the irreducible polarizability) from ...
    requires: null
    text: |-
        <p>
         Used when [[ndtset]]&gt;0
        (multi-dataset mode) and [[optdriver]]=4
        (sigma step of a GW calculation),
        to indicate that the irreducible polarizability (_SUSC file) is to be taken
        from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT susceptibility
        is to be taken, as INPUT of the present dataset.
        Performing a GW calculations starting from the _SUSC file instead of the _SCR file presents
        the advantage that starting from the irreducible polarizability, one can calculate the screened interaction
        using different expressions without having to perform a screening calculation from scratch.
        For example, it is possible to apply a cutoff to the Coulomb interaction in order
        to facilitate the convergence of the GW correction with respect to the size of the supercell
        (see [[vcutgeo]] and [[icutcoul]])
         <br />
         If [[getsuscep]]==0, no such use of previously computed output _SUSC file is done.
         <br />
         If [[getsuscep]] is positive, its value gives the index of the dataset
        from which the output _SUSC file is to be used as input.
         <br />
         If [[getsuscep]] is -1, the output _SUSC file of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getsuscep]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior
        to the first), the _SUSC file is not initialised from
        a disk file, so that it is as if [[getsuscep]]=0 for that
        initialisation.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful, GW_useful, SelfEnergy_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getvel
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET VEL from ...
    requires: null
    text: |-
        <p>
         These variables are typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0)
        since they describe from which dataset the corresponding
        output variables are to be taken, as input of the present
        dataset. The atomic positions and velocities are [[EVOLVING]] variables,
        for which such a chain of calculation is useful.
         <br />
         Note that the use of
         <b>
          getxcart
         </b>
         and
         <b>
          getxred
         </b>
         differs when
        [[acell]] and [[rprim]]
        are different from one dataset
        to the other.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
         <br />
         Note :
         <b>
          getxred
         </b>
         and
         <b>
          getxcart
         </b>
         cannot be simultaneously
        non-zero for the same dataset. On the other hand the use of
        [[getvel]] with
         <b>
          getxred
         </b>
         is allowed, despite the different
        coordinate system.
        </p>
    topics: multidtset_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: getwfk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'GET the wavefunctions from _WFK file '
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],[[irdwfq]],[[ird1wf]], or [[irdddk]].
         One should first read the
        explanations given for these latter variables.
         <br />
         The [[getwfk]],
         <b>
          getwfq
         </b>
         ,
         <b>
          get1wf
         </b>
         and
         <b>
          getddk
         </b>
         variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the [[getwfk]] input variable (the only
        one used in ground-state calculations), but
        the rules for
         <b>
          getwfq
         </b>
         and
         <b>
          get1wf
         </b>
         are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If [[getwfk]]==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If [[getwfk]] is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If [[getwfk]] is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If [[getwfk]] is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if [[getwfk]]=0 for that
        initialisation.
        Thanks to this rule, the use of [[getwfk]] -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getwfkfine
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET the fine grid wavefunctions from _WFK file
    requires: null
    text: |-
        Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to
        [[irdwfkfine]]. One should first read the
        explanations given for these latter variables.
        <br />
        The [[getwfkfine]] variables is typically used to chain the calculations
        in the multi-dataset mode, since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
        <br />
        If [[getwfkfine]]==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
        <br />
        If [[getwfkfine]] is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
        <br />
        If [[getwfkfine]] is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
        <br />
        If [[getwfkfine]] is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if [[getwfkfine]]=0 for that
        initialisation.
        Thanks to this rule, the use of [[getwfkfine]] -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
        <br />
        NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
        <pre>
         ndtset 3   jdtset 1 2 4  getXXX -1
        </pre>
        refers to dataset 2 when dataset 4 is initialized.

        Response-function calculation :
        <ul>
         <li>
          one and only one of [[getwfkfine]] or [[irdwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[getwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/generated_files/help_abinit.html#4">
           section 4
          </a>
          of the [[help_abinit]]).
         </li>
         <li>
          Reading the fine grid wavefunction will trigger the k-points interpolation technique of the temperature dependent
        calculations.
         </li>
        </ul>
        Bethe-Salpeter calculation :
        <ul>
         <li>
          one and only one of [[getwfkfine]] or [[irdwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[getwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/generated_files/help_abinit.html#4">
           section 4
          </a>
          of the [[help_abinit]]).
         </li>
         <li>
          This variable or [[irdwfkfine]] is mandatory when [[bs_interp_mode]] == 1
         </li>
        </ul>
        <b>
         This variable is experimental. In development.
        </b>
    topics: multidtset_useful, DFPT_useful, TDepES_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: getwfq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'GET the wavefunctions from _WFQ file '
    requires: null
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],[[irdwfq]],[[ird1wf]] or [[irdddk]].
         One should first read the
        explanations given for these latter variables.
         <br />
         The
         <b>
          getwfk
         </b>
         , [[getwfq]],
         <b>
          get1wf
         </b>
         and
         <b>
          getddk
         </b>
         variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the
         <b>
          getwfk
         </b>
         input variable (the only
        one used in ground-state calculations), but
        the rules for [[getwfq]] and
         <b>
          get1wf
         </b>
         are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If
         <b>
          getwfk
         </b>
         ==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If
         <b>
          getwfk
         </b>
         is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If
         <b>
          getwfk
         </b>
         is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If
         <b>
          getwfk
         </b>
         is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if
         <b>
          getwfk
         </b>
         =0 for that
        initialisation.
        Thanks to this rule, the use of
         <b>
          getwfk
         </b>
         -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: getxcart
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET XCART from ...
    requires: null
    text: |-
        <p>
         These variables are typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0)
        since they describe from which dataset the corresponding
        output variables are to be taken, as input of the present
        dataset. The atomic positions and velocities are [[EVOLVING]] variables,
        for which such a chain of calculation is useful.
         <br />
         Note that the use of [[getxcart]] and
         <b>
          getxred
         </b>
         differs when
        [[acell]] and [[rprim]]
        are different from one dataset
        to the other.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
         <br />
         Note :
         <b>
          getxred
         </b>
         and [[getxcart]] cannot be simultaneously
        non-zero for the same dataset. On the other hand the use of
         <b>
          getvel
         </b>
         with
         <b>
          getxred
         </b>
         is allowed, despite the different
        coordinate system.
        </p>
    topics: multidtset_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: getxred
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GET XRED from ...
    requires: null
    text: |-
        <p>
         These variables are typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0)
        since they describe from which dataset the corresponding
        output variables are to be taken, as input of the present
        dataset. The atomic positions and velocities are [[EVOLVING]] variables,
        for which such a chain of calculation is useful.
         <br />
         Note that the use of
         <b>
          getxcart
         </b>
         and [[getxred]] differs when
        [[acell]] and [[rprim]]
        are different from one dataset
        to the other.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
         <br />
         Note : [[getxred]] and
         <b>
          getxcart
         </b>
         cannot be simultaneously
        non-zero for the same dataset. On the other hand the use of
         <b>
          getvel
         </b>
         with [[getxred]] is allowed, despite the different
        coordinate system.
        </p>
    topics: multidtset_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: gkqwrite@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GKk for input Q grid to be WRITtEn to disk
    requires: null
    text: |-
        <p>Flag to write out the reciprocal space matrix elements to a disk file named
        gkqfile. This reduces strongly the memory needed for an electron-phonon run.
    topics: ElPhonInt_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: goprecon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Geometry Optimization PRECONditioner equations
    requires: null
    text: |-
        <p>
         Set the kind of preconditioner to be used for Geometry Optimization
         <br />
         (Note : Under development now (2011.05.20))
         <ul>
          <li>
           [[goprecon]]=0 : No preconditioner
          </li>
          <li>
           [[goprecon]]=[1-9] : Linear preconditioner
          </li>
          <li>
           [[goprecon]]=[11-19] : Non-linear preconditioner
          </li>
         </ul>
         <br />
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: goprecprm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Geometry Optimization PREconditioner PaRaMeters equations
    requires: null
    text: |-
        <p>
         Set the paramenters use by the preconditioner to be
        used for Geometry Optimization
         <br />
         (Note : Under development now (2011.06.06))
        </p>
    topics: GeoOpt_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: gpsurf@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GraPhic output for the bader SURFace
    requires: null
    text: |-
        Drives the graphic output (gnuplot script) of the
          irreducible part of the calculated Bader surface.
          <ul>
           <li>0, not output
           <li>1, output
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: gpu_devices
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - -1
    - -1
    - -1
    - -1
    - -1
    dimensions:
    - 5
    excludes: null
    mnemonics: 'GPU: choice of DEVICES on one node'
    requires: '[[use_gpu_cuda]]==1 (CUDA functionality)'
    text: |-
        <p>
         To be used when several GPU devices are present on each node, assuming the same number of devices on all nodes.
        <br />
         Allows to choose in which order the GPU devices are chosen and distributed among MPI processes (see examples below). When the default value (-1) is set, the GPU devices are chosen by order of performance (FLOPS, memory).
        <br /><br />
        Examples:
        <ul>
        <li>2 GPU devices per node, 4 MPI processes per node,  <b>gpu_device</b>=[-1,-1,-1,-1,-1] (default):<br />MPI processes 0 and 2 use the best GPU card, MPI processes 1 and 3 use the slowest GPU card.</li>
        <li>3 GPU devices per node, 5 MPI processes per node,  <b>gpu_device</b>=[1,0,2,-1,-1]:<br />MPI processes 0 and 3 use GPU card 1, MPI processes 1  and 4 use GPU card 0, MPI process 2 uses GPU card 2.</li>
        <li>3 GPU devices per node, 5 MPI processes per node,  <b>gpu_device</b>=[0,1,-1,-1,-1]:<br />MPI processes 0, 2 and 4 use GPU card 0, MPI processes 1 and 3 use GPU card 1;  the 3rd GPU card is not used.</li>
        </ul>
        GPU card are numbered starting from 0; to get the GPU devices list, type "nvidia-smi" or "lspci | grep -i nvidia".
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: integer
- !variable
    abivarname: gpu_linalg_limit
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2000000
    dimensions: scalar
    excludes: null
    mnemonics: 'GPU (Cuda): LINear ALGebra LIMIT'
    requires: '[[use_gpu_cuda]]==1 (CUDA functionality)'
    text: |-
        <p>
         Use of linear algebra and matrix algebra on GPU is only efficient if the size of the involved matrices is large enough.
        The [[gpu_linalg_limit]] parameter defines the threshold above which linear (and matrix) algebra operations
        are done on the Graphics Processing Unit.
         <br />
         The considered matrix size is equal to:
         <br />
         <li>
          SIZE=([[mpw]]*[[nspinor]]/
        [[npspinor]])*
        ([[npband]]*[[bandpp]])**2
         </li>
         <br />
         When SIZE&gt;=[[gpu_linalg_limit]], [[wfoptalg]] parameter is
        automatically set to 14 which corresponds to the use of LOBPCG algorithm for the calculation of the eigenstates.
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: integer
- !variable
    abivarname: gruns_ddbs@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: Empty
    dimensions:
    - '[[anaddb:gruns_nddbs]]'
    excludes: null
    mnemonics: GRUNeiSen DDBS
    requires: null
    text: |-
        <p>List of strings with the paths of the DDB files used for the calculation of the Gruneisen parameters.
        Each string must be enclosed by quotation marks. The number of DDB files is defined by
        [[anaddb:gruns_nddbs]] (possible values are: 3,5,7,9)
        The DDB files correspond to phonon calculations performed at different volumes (usually &plusmn; 1%
        of the equilibrium volume). The DDB files must be ordered according to the volume of the unit cell
        (the DDB with smallest volume comes first) and the volume increment must be constant.
        The code computes the derivative of the dynamical matrix wrt the volume using central finite difference.
    topics: Temperature_useful
    varset: anaddb
    vartype: string
- !variable
    abivarname: gruns_nddbs@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GRUNeiSen Number of DDB files
    requires: null
    text: |-
        <p>This variable defines the number of DDB files (read from [[anaddb:gruns_ddbs]])
        used for the calculation of the Gruneisen parameters.
    topics: Temperature_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: gw_customnfreqsp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW CUSTOM FREQuencies for SPectral function
    requires: '[[optdriver]]==4 and [[gwcalctyp]] in [2,9,12,19,22,29]'
    text: |-
        <p>
         [[gw_customnfreqsp]] lets the user define the grid points along the real frequency axis by hand
        for the calculation of the self-energy along the real axis. Set this to the number of frequencies
        you want. The frequencies are specified with [[gw_freqsp]].
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_freqsp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !range
        start: 1
        stop: '[[gw_customnfreqsp]]'
    dimensions:
    - '[[gw_customnfreqsp]]'
    excludes: null
    mnemonics: GW SPectral FREQuencies
    requires: '[[optdriver]]==4 and [[gw_customnfreqsp]] > 0 '
    text: |-
        <p>
         [[gw_freqsp]] specifies the grid points for the real frequency axis when the real and imaginary
        (spectral funtion) parts of sigma are calculated explicitly for post-processing or plotting.
        Only activated if
        [[gw_customnfreqsp]] is not equal to 0. The number of frequencies
        is set by the value of [[gw_customnfreqsp]]. Example:
         <pre>
        gw_customnfreqsp   5
        nfreqsp            5
        gw_freqsp         -0.5  -0.1  0.0  1.0  10.0 eV
         </pre>
         If [[nfreqsp]] is not equal to
        [[gw_customnfreqsp]] a warning will be issued.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: real
- !variable
    abivarname: gw_frqim_inzgrid
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW Contour Deformation FReQuencies on IMaginary axis Inverse Z Grid
    requires: '[[optdriver]] in [3,4] and [[gwcalctyp]] in [2,9,12,19,22,29]'
    text: |-
        <p>
         [[gw_frqim_inzgrid]] creates gridpoints along the
        <b>
          imaginary
         </b>
         frequency axis by using an
        equidistant grid in the variable
         <span style="font-family:Times,Serif">
          <i>
           z &sub; [0,1]
          </i>
         </span>
         where the transform is:
        </p>
        <p align="center">
         <img style="width: 122px; height: 38px;" src="../vargw_img/cd_inzgrid.png" />
        </p>
        <p>
         Here
         <span style="font-family:Times,Serif">
          <i>
           &omega;
           <sub>
            p
           </sub>
          </i>
         </span>
         is the
        plasma frequency (default can be overridden by setting [[ppmfrq]]).
        The equidistant grid in z is determined uniquely by [[nfreqim]]) and
        the points are distributed so that half of them lie below the plasma frequency.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_frqre_inzgrid
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW Contour Deformation FReQuencies on REal axis Inverse Z Grid
    requires: '[[optdriver]] in [3,4] and [[gwcalctyp]] in [2,9,12,19,22,29]'
    text: |-
        <p>
         [[gw_frqre_inzgrid]] creates grid points along the
         <b>
          real
         </b>
         frequency axis by using an
        equidistant grid in the variable
         <span style="font-family:Times,Serif">
          <i>
           z &sub; [0,1]
          </i>
         </span>
         where the transform is:
        </p>
        <p align="center">
         <img style="width: 122px; height: 38px;" src="../vargw_img/cd_inzgrid_re.png" />
        </p>
        <p>
         Here
         <span style="font-family:Times,Serif">
          <i>
           &omega;
           <sub>
            p
           </sub>
          </i>
         </span>
         is the
        plasma frequency (default can be overridden by setting [[ppmfrq]]).
        The equidistant grid in z is determined uniquely by
        [[nfreqre]] ) and
        the points are distributed so that half of them lie below the plasma frequency. This is useful in
        conjuction with [[gw_frqim_inzgrid]] if one needs to use a grid
        which maps
         <span style="font-family:Times,Serif">
          <i>
           [0,&#8734;[ &rarr; [0,1]
          </i>
         </span>
         . Note that
        typically
         <i>
          many
         </i>
         more points are needed along the real axis in order to properly resolve
        peak structures. In contrast, both the screening and self-energy are very smooth along the
        imaginary axis. Also, please note that this is
         <b>
          not
         </b>
         an efficient grid for
         <b>
          standard
         </b>
         Contour Deformation calculations, where typically only a smaller range of frequencies near the
        origin is required. The maximum value needed along the real frequency axis is output in the
        logfile during Contour Deformation sigma calculations.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_frqre_tangrid
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW Contour Deformation FReQencies on REal axis - Use Tangent Grid
    requires: '[[optdriver]] in [3,4] and [[gwcalctyp]] in [2,9,12,19,22,29]'
    text: |-
        <p>
         [[gw_frqre_tangrid]] defines a nonuniform grid to be used in frequency, with stepsize increasing
        proportional to tan(x). This makes the grid approximately linear to start with, with a rapid increase
        towards the end. Also, this is the grid which gives equal importance to each point used in the integration
        of a function which decays as 1/x^2. To be used in conjunction with [[nfreqre]],
        [[cd_max_freq]] and [[cd_halfway_freq]]
         which determine the parameters of the transformed grid.
        </p>
    topics: FrequencyMeshMBPT_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_invalid_freq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW treatment of INVALID FREQuency for Hybertsen-Louie PPM
    requires: '[[optdriver]] in [3,4] and [[ppmodel]] in [2]'
    text: |-
        <p>
         [[gw_invalid_freq]] sets the procedure to follow when a PPM frequency is invalid (negative or imaginary).
          <ul>
            <li>
              [[gw_invalid_freq]]=0 : Drop them as proposed in Appendix B of PRB 34, 8, 5390, 1986.
            </li>
            <li>
              [[gw_invalid_freq]]=1 : Set them to 1 hartree, as done for the PPM of Godby-Needs.
            </li>
            <li>
              [[gw_invalid_freq]]=2 : Set them to infinity.
            </li>
          </ul>
        </p>
    topics: Susceptibility_expert, SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_nqlwl
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GW, Number of Q-points for the Long Wave-Length Limit
    requires: '[[optdriver]] in [3,4,99]'
    text: |-
        <p>
         Only relevant if [[optdriver]]=3,4,99 that is, screening, sigma or Bethe-Salpeter
        calculations, although the actual meaning of the variable depends on the particular run-level (see
        discussion below).
        </p>
        <p>
         [[gw_nqlwl]] defines the number of directions in reciprocal space used to describe the non-analytical behaviour
        of the heads (G = G'=0) and the wings (G=0 or G'=0) of the dielectric matrix in the optical limit
        (i.e. for q tending to zero).
        The number of directions is specified by the additional variable [[gw_qlwl]].
        </p>
        <p>
         When [[optdriver]]=3, [[gw_nqlwl]] and
         <b>
          gw_qlwl
         </b>
         define
        the set of "small" q that will be calculated and stored in the final SCR file. Therefore, the two
        variables can be used to analyze how the optical spectra depend on the direction
        of the incident phonon (useful especially in anisotropic systems).
        </p>
        <p>
         When [[optdriver]]=4, [[gw_nqlwl]] and
         <b>
          gw_qlwl
         </b>
         can be used
        to specify the heads and the wings to be used to perform the quadrature of the correlated
        part of the self-energy in the small region around the origin.
        (NB: not yet available, at present the quadrature is performed using a single direction in q-space)
        </p>
        <p>
         When [[optdriver]]=99, [[gw_nqlwl]] and
         <b>
          gw_qlwl
         </b>
         define
        the set of directions in q-space along which the macroscopic dielectric function is evaluated.
        By default the Bethe-Salpeter code calculates the macroscopic dielectric function using six different
        directions in q-space (the three basis vectors of the reciprocal lattice and the three Cartesian axis).
        </p>
    topics: GW_expert, BSE_expert, Susceptibility_expert, SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_nstep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: GW Number of self-consistent STEPs
    requires: '[[optdriver]]==8'
    text: |-
        <p>
         Gives the maximum number of self-consistent GW cycles (or "iterations").
        in which G and/or W will be updated until the quasi-particle energies are converged
        within [[gw_toldfeig]].
        [[gwcalctyp]] and [[gw_sctype]] are
        used to define the type of self-consistency.
        </p>
    topics: GW_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_qlwl
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1.0E-5
    - 2.0E-5
    - 3.0E-5
    dimensions:
    - 3
    - '[[gw_nqlwl]]'
    excludes: null
    mnemonics: GW, Q-points for the Long Wave-Length limit
    requires: '[[optdriver]] in [3,4,99]'
    text: |-
        <p>
         When [[optdriver]]=3,
        [[gw_qlwl]] defines the set of q-points around Gamma that are considered during the evaluation
        of the non-analytical behaviour of the dielectric matrix. Optical spectra (with and without
        non-local field effects) are evaluated for each direction specified by [[gw_qlwl]].
        </p>
        <p>
        </p>
    topics: Susceptibility_expert, SelfEnergy_expert, BSE_expert
    varset: gw
    vartype: real
- !variable
    abivarname: gw_qprange
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW QuasiParticle RANGE policy
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[gw_qprange]] is active only when [[nkptgw]] is equal to zero (default value).
        This variable simplifies the specification of the list of kpoints and of the bands to be used
        for the computation of the quasi-particle corrections.
        The possible values are:
         <ul>
          <li>
           0    =&gt; Compute the QP corrections only for the fundamental and the optical gap
          </li>
          <li>
           +num =&gt; Compute the QP corrections for all the k-points in the irreducible zone.
        and include `num` bands above and below the Fermi level.
          </li>
          <li>
           -num =&gt; Compute the QP corrections for all the k-points in the irreducible zone.
        Include all occupied states and `num` empty states.
          </li>
         </ul>
         The default value is 0 and is very handy for one-shot calculations.
        It is important to stress, however, that the position of the optical/fundamental gaps is deduced from the energies computed
        on the k-mesh used for the WFK file. Therefore the computed gaps might differ from the correct ones that can only be
        obtained with an appropriate sampling of the irreducible zone.

        Positive values are useful if we do not know the position of the GW HOMO, LOMO and we want to investigate
        the effect of the GW corrections on the states close to the gap
        Negative values are usually used for self-consistent calculations

        Note that, in the case of self-consistency or symsigma=1, the code might change the bands range
        so that all the degenerate states are included.

        Note also that [[kptgw]], and
         [[bdgw]]
         are ignored when this options is used.
        If you want to select manually the list of k-points and bands, you have
        to provide the three variables [[nkptgw]], [[kptgw]], and [[bdgw]].
        </p>
    topics: SelfEnergy_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_sctype
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GW, Self-Consistency TYPE
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         This variable is used to partially define the kind of self-consistency for GW calculations.
        The other piece of information is given by [[gwcalctyp]]
        that defines the particular approximation for the self-energy operator as well as whether the
        wavefunctions have to replaced by quasi-particle amplitudes.
        </p>
        <p>
         If [[gw_sctype]] is specified in the input file, the code will perform an iterative update
        of the quantities entering the GW equations until the quasi-particle energies are converged
        within [[gw_toldfeig]]. The maximum number of iterations is
        specified by [[gw_nstep]].
        Possible values are:
         <ul>
          <li>
           1 =&gt; standard one-shot method (one screening calculation followed by a single sigma run)
          </li>
          <li>
           2 =&gt; self-consistency only on W (iterative update of W followed by a sigma run in which G
        is approximated with the Kohn-Sham independent-particle Green's function G0)
          </li>
          <li>
           3 =&gt; self-consistency only of G (a single screening calculation to obtain the Kohn-Sham
        polarizability followed by an iterative update of the Green's functions in the self-energy)
          </li>
          <li>
           4 =&gt; fully self-consistent algorithm (iterative update of both G and W)
          </li>
         </ul>
         It is possible to initialize the self-consistent procedure by reading a previously calculated
        SCR or SUSC file via the variables [[getscr]] or
        [[getsuscep]], respectively.
        [[getqps]] can be used to read a previous QPS file thus initializing
        the Green functions to be used in the first self-consistent iteration.
        </p>
    topics: GW_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_sigxcore
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW, SIGma (self-energy) for the CORE contribution
    requires: '[[optdriver]]==4 and [[usepaw]]==1'
    text: |-
        <p>
         Only available for PAW and relevant if [[optdriver]]=4 that is, sigma calculations.
        </p>
        <p>
         Theoretical introduction: GW calculations performed on top of electronic calculations relying
        when the frozen-core approximation is used to separate inner-core electrons from valence electrons,
        only the contribution to the self-energy arising from valence electrons is explicitly accounted for.
        In the standard approach based on pseudopotentials the contribution to the self-energy due to core electrons is approximated
        by means of the KS exchange-correlation potential generated by the core density.
        In the case of GW calculations employing the PAW method, the core contribution to the self-energy
        can be more accurately estimated in terms of the Fock operator generated by the core wavefunctions.
        In the simplest approach, the only ingredients required for this more refined treatment are the wave
        functions of the core electrons in the reference atomic configuration that are calculated during the
        generation of the PAW setup. This is a good approximation provided that the core wave functions
        are strictly localized inside the PAW spheres.
        </p>
        <p>
         [[gw_sigxcore]] defines the approximation used to evaluate the core contribution to sigma.
         <ul>
          <li>
           [[gw_sigxcore]] = 0, standard approach, the core contribution is approximated with vxc.
          </li>
          <li>
           [[gw_sigxcore]] = 1, the core term is approximated with the Fock operator inside the PAW spheres.
          </li>
         </ul>
        </p>
        <p>
        </p>
    topics: SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gw_toldfeig
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 0.1
    dimensions: scalar
    excludes: null
    mnemonics: GW TOLerance on the DiFference of the EIGenvalues
    requires: '[[optdriver]]==8'
    text: |-
        <p>
         Sets a tolerance for absolute differences of QP energies that will cause one self-consistent GW cycle to stop.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          toldfe
         </b>
         has the '[[ENERGY]]' characteristics (1 Ha=27.2113845 eV)
         <br />
        </p>
    topics: GW_basic
    varset: gw
    vartype: real
- !variable
    abivarname: gwcalctyp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW CALCulation TYPe
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         [[gwcalctyp]] governs the choice between the different capabilities of the GW code.
         <ul>
          <li>
           0 &#60;&#61; [[gwcalctyp]] &#60;&#61;  9 : standard "1 shot" quasiparticle method
          </li>
          <li>
           10 &#60;&#61; [[gwcalctyp]] &#60;&#61; 19 : self-consistent quasiparticle method on energies only
          </li>
          <li>
           20 &#60;&#61; [[gwcalctyp]] &#60;&#61; 29 : self-consistent quasiparticle method on energies and wavefunctions
          </li>
         </ul>
        </p>
        <p>
         <ul>
          <li>
           [[gwcalctyp]] &#61; 0, 10, or 20 : standard Plasmon-Pole model GW calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 1 : GW calculation where the self-energy along the real axis is obtained by performing the analytic continuation from the imaginary axis to the full complex plane via the Pade approximant. Only available for standard "1 shot" quasiparticle method.
          </li>
          <li>
           [[gwcalctyp]] &#61; 2, 12, or 22 : GW calculation using numerical integration
        (contour deformation method, see e.g. S. Lebegue
           <i>
            et al.
           </i>
           PRB
           <b>
            67
           </b>
           , 155208 (2003).)
          </li>
          <li>
           [[gwcalctyp]] &#61; 5, 15, or 25 : Hartree-Fock calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 6, 16, or 26 : Screened Exchange calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 7, 17, or 27 : COHSEX calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 8, 18, or 28 : model GW calculation
        following S. Faleev
           <i>
            et al.
           </i>
           PRL
           <b>
            93
           </b>
           , 126406 (2004) using a Plasmon-Pole model
          </li>
          <li>
           [[gwcalctyp]] &#61; 9, 19, or 29 : model GW calculation
        following S. Faleev
           <i>
            et al.
           </i>
           PRL
           <b>
            93
           </b>
           , 126406 (2004) using numerical integration
        (contour deformation method)
          </li>
         </ul>
        </p>
        <p>
         Also
         <ul>
          <li>
           [[gwcalctyp]] &#61; 105,125 : HSE06 calculations (1-shot and self-consistent)
          </li>
          <li>
           [[gwcalctyp]] &#61; 205,225 : PBE0 calculations  (1-shot and self-consistent)
          </li>
          <li>
           [[gwcalctyp]] &#61; 305,325 : B3LYP calculations (1-shot and self-consistent)
          </li>
         </ul>
        </p>
    topics: GW_basic, SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: gwcomp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW COMPleteness
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         [[gwcomp]] governs the use of an extrapolar approximation. If [[gwcomp]]==1, one improves the completeness
        in a truncated sum over states. In practice, this permits one to reduce quite much the number of
        bands required in the calculation of the screening or of the self-energy.
        The energy parameter
        needed in the extrapolar approximation is set by [[gwencomp]].
        See F. Bruneval, X. Gonze, Phys. Rev. B 78, 085125 (2008) for a description of the methodology.
        </p>
    topics: SelfEnergy_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: gwencomp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    dimensions: scalar
    excludes: null
    mnemonics: GW ENergy for COMPleteness
    requires: '[[optdriver]] in [3,4] and [[gwcomp]]==1'
    text: |-
        <p>
         [[gwencomp]] sets the energy parameter used in the extrapolar approximation used to improve
        completeness and make the convergence against the number of bands much faster.
        </p>
        <p>
         See F. Bruneval, X. Gonze, Phys. Rev. B 78, 085125 (2008) for a description of the methodology.
        </p>
    topics: SelfEnergy_useful, Susceptibility_useful
    varset: gw
    vartype: real
- !variable
    abivarname: gwfockmix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.25
    dimensions: scalar
    excludes: null
    mnemonics: GW FOCK exchange MIXing parameter
    requires: '[[optdriver]]=4, [[gwcalctyp]] = 1x5 (HSE) or 2x5 (PBE0).'
    text: |-
        Mixing parameter of Fock exchange for PBE0 and HSE hybrid-functional calculations via the GW self-energy subroutine. [[gwfockmix]] ranges from 0 (essentially PBE) to 1.
    topics: GW_useful
    varset: gw
    vartype: real
- !variable
    abivarname: gwgamma
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW GAMMA
    requires: '[[optdriver]]=3 or 4 (Sigma calculations)'
    text: |-
        <p>
         If [[gwgamma]] is 1, the vertex correction will be included leading to what is known as "GW-Gamma" approximation.
        see R. Del Sole, L. Reining, and R. W. Godby, Phys. Rev. B  49, 8024 (1994).
        Note that, in order to include the vertex correction in W, one has to start the sigma calculation
        from the susceptibility file_SUSC instead of the _SCR file (see [[getsuscep]]&nbsp;&nbsp;
        and [[irdsuscep]]&nbsp;&nbsp;)
        Not available for PAW calculations.
        </p>
        <p>
        [[gwgamma]]=-4 activates the bootstrap kernel of Sharma et al. [Phys. Rev. Lett. 107, 186401 (2011)] in the test-charge-test-charge dielectric function [cf. Chen and Pasquarello, Phys. Rev. B 92, 041115(R) (2015)]. A cheaper one-shot variant can be achieved with [[gwgamma]]=-6 using only the head of the kernel.
        </p>
        <p>
        [[gwgamma]]=-8 uses the RPA bootstrap-like kernel (one-shot) [Phys. Rev.  Lett. 115, 137402 (2015), ibid. 114, 146402 (2015)].
        </p>
        </p>
    topics: Susceptibility_expert, SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_band_index
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GWLS BAND INDEX
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        Governs the DFT eigenstate |e> in which the self-energy will be evaluated, as shown in eq. (7) of  Phys. Rev. B 91, 125120 (2015).
        That is, it is the state to be corrected in the G0W0 scheme.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_correlation
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 3
    dimensions: scalar
    excludes: null
    mnemonics: GWLS CORRELATION
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        Governs the use of a dielectric model (as explained in section V of Phys. Rev. B 91, 125120 (2015).
        and the use of the Lanczos scheme to solve eqs. (30) and (35) of the same reference at all external [[gw_freqsp]] and integration (as generated from [[gwls_npt_gauss_quad]]) frequencies.
        The different choices are:
        <ul>
        <li> [[gwls_correlation]] == 1 : GWLS calculation WITH the dielectric model and WITHOUT the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 2 : GWLS calculation WITHOUT the dielectric model and WITHOUT the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 3 : GWLS calculation WITH the dielectric model and WITH the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 4 : GWLS calculation WITHOUT the dielectric model and WITH the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 5 : Not a GWLS calculation; just calculate and print the eigenvalues of the (static) dielectric matrix (for debugging purposes). </li>
        </ul>
        </p>
        <p>
        The default, ([[gwls_correlation]] == 3), is the most performant option and should be kept by the user.
        Option 1, 2 and 5 are deprecated and will be removed.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_diel_model
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: GWLS dielectric model
    requires: '[[optdriver]]==66'
    text: |-
        Not used yet.
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_exchange
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GWLS exact EXCHANGE
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        Governs whether the exact exchange for the state to be corrected ([[gwls_band_index]]) is calculated ([[gwls_exchange]]==1) or not ([[gwls_exchange]]==0).
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_first_seed
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[gwls_band_index]]'
    dimensions: scalar
    excludes: null
    mnemonics: GWLS FIRST SEED vector
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        This variable sets the band index to be used to generate the first seed vector to be used in the construction of the Lanczos basis for the (static) dielectric matrix in a GWLS calculation.
        See section IV of  Phys. Rev. B 91, 125120 (2015).
        Together with [[gwls_nseeds]], defines the seeds for the Lanczos procedure.
        That is, the states associated to band index [[gwls_first_seed]] to [[gwls_first_seed]]+[[gwls_nseeds]]-1 are used to generate the seed vectors.
        </p>
        <p>
        The default [[gwls_first_seed]]==[[gwls_band_index]] and [[gwls_nseeds]]==1 has been thoroughly tested and seems to be the most performant.
        Users should therefore keep the default value.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_kmax_analytic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 8
    dimensions: scalar
    excludes: null
    mnemonics: GWLS KMAX for the ANALYTIC term
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        Governs the number of iterations to be done in the shift Lanczos solution of eq. (35) of Phys. Rev. B 91, 125120 (2015) to solve it at all external frequencies requested by the user ([[gw_freqsp]]).
        The default value is converged to a few 10s of meV for all molecules studied so far.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_kmax_complement
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GWLS KMAX for the COMPLEMENT space.
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        The G0W0 formalism involves the calculation of a summation conceptually linked to the trace of the dielectric matrix (see eq. (38)
        of  Phys. Rev. B 91, 125120 (2015).
        Since the eigenvalues spectrum of the dielectric matrix of formed by a few large discrete eigenvalues and an integrable divergence in the density of eigenvalues around 0, it is expensive to sample accurately this divergence using the exact dielectric operator.
        It this becomes interesting to calculate the 'trace' of the 'exact - model' dielectric matrix in a small basis and add it to the 'trace' of the 'model' dielectric matrix obtained in a large bais.
        In the context where the model dielectric matrix is used in the calculations, [[gwls_stern_kmax]] determines the size of the 'small' basis and [[gwls_kmax_complement]] determines the size of the 'large' basis.
        </p>
        <p>
        For more information on the exact role of these bases and on the model dielectric operator used, see section V of  Phys. Rev. B 91, 125120 (2015).
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_kmax_numeric
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 16
    dimensions: scalar
    excludes: null
    mnemonics: GWLS KMAX for the NUMERIC term
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        Governs the number of iterations to be done in the shift Lanczos solution of eq. (30) of  Phys. Rev. B 91, 125120 (2015) to solve it simultaneously at all integration frequencies (generated automatically by the number of points [[gwls_npt_gauss_quad]] to use in the gaussian quadrature) and all external frequencies requested by the user ([[gw_freqsp]]).
        The default value is converged to a few 10s of meV for all molecules studied so far.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_kmax_poles
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 4
    dimensions: scalar
    excludes: null
    mnemonics: GWLS KMAX for the calculation of the POLES residue
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        The contour deformation technique, in the G0W0 context, will involve the calculation of pole residues associated to states lying between the one corrected ([[gwls_band_index]]) and the fermi level.
        These residues take the form of a matrix element of the inverse dielectric matrix at a real frequency (see eq. (11) of Phys. Rev. B 91, 125120 (2015)).
        Therefore, the dielectric matrix must be constructed in some basis at these frequencies and inverted to calculate the matrix element.
        The present input variable sets the size of the Lanczos basis to be constructed for this purpose.
        The default value has proven to be very robust for many molecular systems and should therefore be left to the default value by the user.
        </p>
        <p>
        For more information on the Lanczos basis constructed for the calculation of the residues, see section IV of Phys. Rev. B 91, 125120 (2015).
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_list_proj_freq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '*0.0'
    dimensions:
    - '[[gwls_n_proj_freq]]'
    excludes: null
    mnemonics: GWLS LIST of the PROJection FREQuencies
    requires: '[[optdriver]]==66'
    text: |-
        This variable sets the frequencies to be used to construct the basis in which the Hamiltonian is projected to accelerate the solution of the Sternheimer equations involved by the construction of the dielectric matrix at finite frequencies.
        See section VI of Phys. Rev. B 91, 125120 (2015).
        For most cases, since the frequencies \Infty and (if [[gwls_recycle]]>0) 0.0 are used at no computational cost, [[gwls_n_proj_freq]]==0 (which means no ADDITIONAL frequency is to be used) is fine and no frequencies need to be picked up.
    topics: GWls_expert
    varset: gw
    vartype: real
- !variable
    abivarname: gwls_model_parameter
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: GWLS MODEL PARAMETER
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        This is the width of the lorentzian, in Ha, used to model the frequency dependence of the dielectric matrix in the GWLS calculation
        (see eqs. (12), (13), (14), (15), (16) and (34) of  Phys. Rev. B 91, 125120 (2015)).
        More precisely, this parameter is the value of \alpha used in eq. (34).
        This model is then used to separate the integration over frequencies into a 'model' part (second term of eq. (12)) and a 'exact - model' part (first term of eq. (12)).
        Since the 'model' part can be integrated analytically (see eqs. (15), (16) and (34)), only the the 'exact - model' part needs to be integrated numerically.
        </p>
        <p>
        The only effect of this model is therefore to alleviate the numerical cost of the integration over frequencies in the G0W0 calculation.
        The value of the associated parameter has thus an impact on the convergence rate of the GWLS calculation with respect to the number of frequencies of integration ([[gwls_npt_gauss_quad]]), but no impact on the converged result of the GWLS calculation.
        Typically, the default ([[gwls_model_parameter]]==1.0) is optimal.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: real
- !variable
    abivarname: gwls_n_proj_freq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: ''
    mnemonics: GWLS Number of PROJection FREQuencies
    requires: '[[optdriver]]==66'
    text: |-
        This variable sets the number of frequencies, on top of \Infty and (if [[gwls_recycle]]>0) 0.0, to be used for the construction of the basis in which the hamiltonian is projected to accelerate the solution of the Sternheimer equations involved in the construction of the dielectric matrix at finite frequencies.
        See section VI of  Phys. Rev. B 91, 125120 (2015).
        For most cases, the default ([[gwls_n_proj_freq]]==0) is fine.
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_npt_gauss_quad
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: ''
    mnemonics: 'GWLS Number of PoinTs to use for the GAUSSian QUADrature '
    requires: '[[optdriver]]==66'
    text: |-
        This variable defines the number of points used for the numerical integration of the self-energy over frequencies in GWLS computations
        (see eq. (12) of  Phys. Rev. B 91, 125120 (2015)).
        The default is fine for most cases.
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_nseeds
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GWLS Number of SEED vectorS
    requires: '[[optdriver]]==66'
    text: |-
        This variable sets the number of seed vectors to be used in the construction of the Lanczos basis for the (static) dielectric matrix in a GWLS calculation.
        See section IV of  Phys. Rev. B 91, 125120 (2015).
        Only [[gwls_nseeds]]==1 has been tested for now and users should keep this value.
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_print_debug
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GWLS PRINT level for DEBUGging
    requires: '[[optdriver]]==66'
    text: |-
        Influences the level of verbosity for debugging purposes in a GWLS calculation. Users should keep its value at the default.
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_recycle
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: GWLS RECYCLE
    requires: '[[optdriver]]==66'
    text: |-
        <p>
        This variable let the user choose if and how he wants to recycle the solutions of the Sternheimer equations involved in the construction of the static dielectric matrix.
        <ul>
        <li> [[gwls_recycle]]==0 : No recycling of the solutions </li>
        <li> [[gwls_recycle]]==1 : Recycle the solutions. To do so, store them in RAM. </li>
        <li> [[gwls_recycle]]==2 : Recycle the solutions. To do so, store them on disk. </li>
        </ul>
        If the user choose to recycle the solutions, they are used to construct the basis in which the hamiltonian is projected for the solution of the Sternheimer equations involved by the calculation of the dielectric matrix at finite frequencies.
        The other solutions used will be those at \omega \to \Infty (alwyas used) and those at \omega=[[gwls_list_proj_freq]].
        For more information of the basis constructed, see section IV of  Phys. Rev. B 91, 125120 (2015).
        </p>
        <p>
        It is important to note that the solutions rapidly take much space to store.
        Therefore, it is often not possible to store them in RAM in production calculations, yet still desirable to retain them.
        This is when it becomes interesting to store them on disk.
        It is particularly efficient to choose the path of the file to be on disk space local to the processor in large MPI calculations, since each processor need only his own solutions in the construction of the basis.
        </p>
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwls_stern_kmax
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: GWLS Kmax
    requires: '[[optdriver]]==66'
    text: |-
        This variable sets the dimension of the dielectric matrix used in a GWLS calculation (see section IV of  Phys. Rev. B 91, 125120 (2015)).
        Typically converged at a value of a few hundreds to a few thousands for a convergence criterion of 50meV on the  eigenenergies.
    topics: GWls_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwmem
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 11
    dimensions: scalar
    excludes: null
    mnemonics: GW MEMory
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         [[gwmem]] governs the memory strategy during a screening and/or a sigma run.
         <ul>
          <li>
           [[gwmem]] = 1x , the screening matrix are read for all q-vectors and stored in the memory.
          </li>
          <li>
           [[gwmem]] = 0x , the screening matrix are read just a q-vector after another.
           <br />
          </li>
          <li>
           [[gwmem]] = x1 , the real-space wavefunctions are stored in the memory.
          </li>
          <li>
           [[gwmem]] = x0 , the real-space wavefunctions are not stored, but rather recalculated on-fly each abinit needs them using FFTs.
          </li>
         </ul>
         The default is [[gwmem]] = 11, which is the fastest, but also the most memory consuming.
        When experiencing memory shortage, one should try [[gwmem]] = 0.
        The first digit is only meaningful when performing sigma calculations.
        </p>
        <p>
        </p>
    topics: Susceptibility_expert, SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: gwpara
    characteristics: null
    commentdefault: 'The default value has been changed in v8. From 1 to 2 '
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: GW PARAllelization level
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         [[gwpara]] is used to choose between the two different parallelization levels
        available in the GW code. The available options are:
         <ul>
          <li>
           =1 =&gt; parallelisation on k points
          </li>
          <li>
           =2 =&gt; parallelisation on bands
          </li>
         </ul>
        </p>
        <p>
         Additional notes:
         <br />
         In the present status of the code, only the parallelization over bands ([[gwpara]]=2)
        allows to reduce the memory allocated by each processor.
         <br />
         Using [[gwpara]]=1, indeed, requires the same amount of memory as a sequential run,
        irrespectively of the number of CPUs used.
        </p>
    topics: parallelism_useful, GW_basic, Susceptibility_basic, SelfEnergy_basic
    varset: paral
    vartype: integer
- !variable
    abivarname: gwrpacorr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: GW RPA CORRelation energy
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [1,11,21]'
    text: |-
        <p>
         [[gwrpacorr]] governs the calculation of the RPA correlation energy.
         <ul>
          <li>
           [[gwrpacorr]] = 0, no RPA correlation energy is calculated
          </li>
          <li>
           [[gwrpacorr]] = 1, the RPA correlation energy is calculated using an exact integration over the coupling constant: it requires one diagonalization of the polarizability matrix
          </li>
          <li>
           [[gwrpacorr]] =
           <i>
            n
           </i>
           &gt; 1, the RPA correlation energy is calculated using
           <i>
            n
           </i>
           values for the coupling constant: it requires
           <i>
            n
           </i>
           inversions of the polarizability matrix
          </li>
         </ul>
        </p>
        <p>
        </p>
    topics: RPACorrEn_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: iatcon
    characteristics:
    - '[[NO_MULTI]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[natcon]]'
    - '[[nconeq]]'
    excludes: null
    mnemonics: Indices of AToms in CONstraint equations
    requires: null
    text: |-
        <p>
         Gives the indices of the atoms appearing in each of the
        [[nconeq]]
        independent equations constraining the motion of
        atoms during structural optimization or molecular dynamics (see
        [[nconeq]] , [[natcon]],
        and [[wtatcon]]).
         <br />
         (Note : combined with wtatcon to give internal representation of the
        latter - this should be described)
        </p>
    topics: GeoConstraints_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: iatfix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[natfix]]'
    excludes: null
    mnemonics: 'Indices of AToms that are FIXed '
    requires: '[[natfix]] > 0'
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        </p>
        <p>
         WARNING : The implementation is inconsistent !! For
        [[ionmov]] ==1, the fixing of directions
        was done in cartesian coordinates, while for the other values
        of [[ionmov]], it was done in reduced
        coordinates. Sorry for this.
        </p>
        <p>
         There is no harm in fixing one atom in the three
        directions
        using [[iatfix]], then fixing it again in other directions
        by mentioning it in
         <b>
          iatfixx
         </b>
         ,
         <b>
          iatfixy
         </b>
         or
         <b>
          iatfixz
         </b>
         .
         <br />
         The internal representation of these input data is done
        by the mean of one variable [[iatfix]](3,[[natom]]),
        defined
        for each direction and each atom, being 0 if the atom is
        not fixed along the direction, and 1 if the atom is fixed
        along the direction.
        When some atoms are fixed along 1 or 2 directions, the
        use of symmetries is restricted to symmetry operations
        whose (3x3) matrices [[symrel]] are
        diagonal.
         <br />
         If the atom manipulator is used, [[iatfix]] will be related
        to the preprocessed set of atoms, generated by the
        atom manipulator. The user must thus foresee the effect
        of this atom manipulator (see [[objarf]]).
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: iatfix@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[anaddb:natfix]]'
    excludes: null
    mnemonics: Indices of the AToms that are FIXed
    requires: null
    text: |-
        <p>Indices of the atoms that are fixed during a structural relaxation at constrained polarization.
        See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: iatfixx
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[natfixx]]'
    excludes: null
    mnemonics: Indices of AToms that are FIXed along the X direction
    requires: '[[natfixx]] > 0'
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed ALONG THE X direction for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        See the variable [[iatfix]] for more information.
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: iatfixy
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[natfixy]]'
    excludes: null
    mnemonics: Indices of AToms that are FIXed along the Y direction
    requires: '[[natfixy]] > 0'
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed ALONG THE Y direction for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        See the variable [[iatfix]] for more information.
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: iatfixz
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[natfixz]]'
    excludes: null
    mnemonics: Indices of AToms that are FIXed along the Z direction
    requires: '[[natfixz]] > 0'
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed ALONG THE Z direction for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        See the variable [[iatfix]] for more information.
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: iatprj_bs@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0*'[[anaddb:natprj_bs]]'
    dimensions:
    - '[[anaddb:natprj_bs]]'
    excludes: null
    mnemonics: Indices of the AToms for the PRoJection of the phonon Band Structure
    requires: null
    text: |-
        <p>Indices of the atoms that are chosen for projection of the phonon eigenvectors, giving a weighted phonon band structure file.
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: iatsph
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !range
        start: 1
        stop: '[[natsph]]'
    dimensions:
    - '[[natsph]]'
    excludes: null
    mnemonics: Index for the ATomic SPHeres of the atom-projected density-of-states
    requires: '[[prtdos]] == 3 or [[pawfatbnd]] in [1,2]'
    text: |-
        <p>
         [[iatsph]] gives the number of the [[natsph]] atoms around which the sphere
        for atom-projected density-of-states will be build,
        in the [[prtdos]]=3 case.
        The radius of these spheres is given by [[ratsph]].
         <br />
         If [[pawfatbnd]]=1 or 2, it gives the number of the [[natsph]] atoms around which atom-projected band structure will be built.
        </p>
    topics: printing_prdos, ElecBandStructure_useful, ElecDOS_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: iboxcut
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer governing the internal use of BOXCUT - not a very good choice of variable name
    requires: null
    text: |-
        <p>
         Concern all summations in the reciprocal space and is
        allowed in PAW and norm-conserving.
         <ul>
          <li>
           if set to 0 all reciprocal space summations are done in a sphere
        contained in the FFT box.
          </li>
          <li>
           if set to 1 all reciprocal space summations are done in the whole
        FFT box (useful for tests).
          </li>
         </ul>
        </p>
    topics: TuningSpeed_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: icoulomb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Index for the Coulomb TReaTMenT
    requires: null
    text: |-
        <p>
         Defines the type of computation used for Hartree potential, local part of pseudo-potential and ion-ion interaction:
        </p>
        <ul>
         <li>
          [[icoulomb]]=0 : usual reciprocal space computation, using 1 / g^2 for the Hartree potential and using Ewald correction.
         </li>
         <li>
          [[icoulomb]]=1 : free boundary conditions are used when the Hartree potential is computed, real space expressions of pseudo-potentials are involved (restricted to GTH pseudo-potentials) and simple coulomb interaction gives the ion-ion energy.
         </li>
        </ul>
    topics: Coulomb_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: icutcoul
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 6
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the CUT-off for COULomb interaction
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         Many-body calculations for isolated systems present a slow convergence with respect to the size of
        the supercell due to the long ranged Coulomb interaction and the high degree of non-locality of the
        operators involved. A similar issue also occurs in fully periodic systems due to the presence
        of the integrable Coulomb singularity at G=0 that hinders the convergence with respect to the number
        of q-points used to sample the Brillouin zone.
        The convergence can be accelerated by replacing the true bare Coulomb interaction with other
        expressions.
        <p>
        [[icutcoul]] defines the particular expression to be used for the Coulomb term in reciprocal
        space. The choice of [[icutcoul]]  depends on the dimensionality of the system.
        Possible values of [[icutcoul]] are from 0 to 6. The corresponding influential variables are [[vcutgeo]]
        and [[rcut]].
         <ul>
          <li>
           0 =&gt; sphere (molecules but also 3D-crystals)
          </li>
          <li>
           1 =&gt; cylinder (nanowires, nanotubes)
          </li>
          <li>
           2 =&gt; surface
          </li>
          <li>
           3 =&gt; 3D crystal (no cut-off, integration in a spherical mini-Brillouin Zone, legacy value)
          </li>
          <li>
           4 =&gt; ERF, long-range only Coulomb interaction
          </li>
          <li>
           5 =&gt; ERFC, short-range only Coulomb interaction (e.g. as used in the HSE functional)
          </li>
          <li>
           6 =&gt; auxiliary function integration for 3D systems from P. Carrier
           <i>
            et al.
           </i>
           , PRB
           <b>
            75
           </b>
           ,205126 (2007).
          </li>
          <li>
           7 =&gt; auxiliary function for 3D systems of Gygi and Baldereschi [cf. Phys. Rev. B <b>34</b>, 4405 (1986) and Massidda et al., ibid. <b>48</b>, 5058 (1993)].
          </li>
         </ul>
         Note that Spencer and Alavi PRB <b>77</b>, 193110 (2008) showed that the spherical cutoff can efficiently be used also for 3D systems.
        In the latter case, use a negative value for the cutoff radius of the sphere ([[rcut]]&lt;0),
        which is automatically calculated so that the volume enclosed in the sphere is equal to the volume of the solid.
        </p>
    topics: GWls_compulsory, Susceptibility_basic, Coulomb_useful, SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: ieig2rf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer for second-order EIGenvalues from Response-Function
    requires: null
    text: |-
        <p>
         If [[ieig2rf]] is greater then 0, the code will produce a file, named with the trailing suffix _EIGR2D, containing the second-order electronic eigenvalues for the perturbation. These files are used in the calculation of the thermal correction to the electronic eigenvalues.
         <br />
         <br />
         If [[ieig2rf]] is set to 1, the second-order electronic eigenvalues will be calculated from the DFPT method (Sternheimer).
         <br />
         If [[ieig2rf]] is set to 2, the second-order electronic eigenvalues will be calculated from the Allen-Cardona method. (sum over states)
         <br />
         If [[ieig2rf]] is set to 3, the second-order electronic eigenvalues will be calculated from the DFPT method (sum over states) but using a different part of the code. This is equivalent to [[ieig2rf]] = 1 [debuging]
         <br />
         If [[ieig2rf]] is set to 4, the second-order electronic eigenvalues will be calculated from the dynamical DFPT method (Sternheimer).
         The code will generate _EIGR2D.nc files that contain the electron-phonon matrix element squared on the space orthogonal to the active space.
         The code will also produce _FAN.nc files that contain the electron-phonon matrix elements squared.
         Note that [[ieig2rf]]=4 can only be used if Abinit is compiled with NETCDF support.
         <br />
         If [[ieig2rf]] is set to 5, the second-order electronic eigenvalues will be calculated from the dynamical DFPT method (Sternheimer).
         The code will generate _EIGR2D.nc files that contain the electron-phonon matrix element square on the space orthogonal to the active space.
         The code will also produce _GKK.nc files that contain electron-phonon matrix elements.
         This option is preferable for large system to [[ieig2rf]]=4 as the GKK files take less much less disk space and memory (but run a little bit slower).
         Note that [[ieig2rf]]=5 can only be used if Abinit is compiled with NETCDF support.
         <br />
         Related variables : [[bdeigrf]],[[elph2_imagden]],[[getgam_eig2nkq]],[[smdelta]]
        </p>
    topics: TDepES_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: ifcana@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: IFC ANAlysis
    requires: null
    text: |-
        <ul>
        <li> 0 => no analysis of interatomic force constants; </li>
        <li> 1 => analysis of interatomic force constants.
        </ul>

        <p> If the analysis is activated, one get the
        trace of the matrices between pairs of atoms,
        if [[anaddb:dipdip]] is 1,
        get also the trace of the short-range
        and electrostatic part, and
        calculate the ratio with the full matrix;
        then define a local coordinate reference (using
        the next-neighbour coordinates), and express
        the interatomic force constant matrix between
        pairs of atoms in that local coordinate reference
        (the first vector is along the bond; the second
        vector is along the perpendicular force exerted
        on the generic atom by a longitudinal displacement
        of the neighbouring atom - in case it does not vanish;
        the third vector is perpendicular to the two other)
        also calculate ratios with respect to the
        longitudinal force constant ( the (1,1) element of
        the matrix in local coordinates).
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ifcflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Interatomic Force Constants FLAG
    requires: null
    text: |-
        <ul>
        <li> 0 => do all calculations directly from the DDB, without the
                   use of the interatomic force constant.</li>
        <li> 1 => calculate and use the interatomic force constants
                for interpolating the phonon spectrum and dynamical
                matrices at every q wavevector, and eventually analyse
                the interatomic force constants, according to the
                informations given by
        [[anaddb:atifc]],[[anaddb:dipdip]],[[anaddb:ifcana]],[[anaddb:ifcout]],[[anaddb:natifc]],[[anaddb:nsphere]],[[anaddb:rifcsph]]</li>
        </ul>
           More detailed explanations: if the dynamical matrices
           are known on a regular set of wavevectors, they
           can be used to get the interatomic forces, which are simply
           their Fourier transform. When non-analyticities
           can been removed by the use of effective charge at Gamma
           (option offered by putting
           [[anaddb:dipdip]] to 1),
           the interatomic forces are known to decay rather fast (in real space).
           The interatomic forces generated from a small set of
           dynamical matrices
           could be of sufficient range to allow
           the remaining interatomic forces to be neglected.
           This gives a practical way to interpolate the content
           of a small set of dynamical matrices, because dynamical
           matrices can everywhere be generated starting from this
           set of interatomic force constants. It is suggested to
           always use <b>ifcflag</b>=1. The <b>ifcflag</b>=0 option
           is available for checking purpose, and if there is not enough information in the DDB.
    topics: PhononBands_compulsory
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ifcout@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: IFC OUTput
    requires: null
    text: |-
        <p>For each atom in the list [[anaddb:atifc]] (generic atoms),
        <b>ifcout</b> give the number
        of neighbouring atoms for which the ifc's will be
        output (written) and eventually analysed. The
        neighbouring atoms are selected by decreasing distance with respect to
        the generic atom.
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ifltransport@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: IFLag for TRANSPORT
    requires: null
    text: |-
        <p>if ifltransport=1 (LOVA) or ifltransport=2 (non-LOVA), anaddb calculates the transport
        properties: electrical and thermal resistivities from electron-phonon
        interactions in the variational approach. If ifltransport=3, anaddb calculates the
        k-dependent relaxation time. (needs[[anaddb:elphflag]] = 1)
    topics: ElPhonTransport_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: imgmov
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: IMaGe MOVEs
    requires: null
    text: |-
        <p> Control the collective changes of images (see [[nimage]],[[npimage]], [[dynimage]],
        [[ntimimage]], [[tolimg]], [[istatimg]], [[prtvolimg]]).
        <br> Similar to [[ionmov]] in spirit, although here, a population
        of self-consistent calculations for different geometries is managed, while with [[ionmov]],
        only one geometry for self-consistent calculation is managed.
        <br> In this respect the maximal number of time step for image propagation is [[ntimimage]],
        corresponding to the input variable [[ntime]] of the single geometry case.
        Also, the stopping criterion is governed by [[tolimg]], corresponding to the
        input variable [[toldfe]] of the single geometry case.
        The stopping  condition is crude: the image propagation is stopped when the mean value (over dynamic images)
        of the absolute difference of total energy (previous and current time step) is less than [[tolimg]].

        <p>Actually, there might be combinations of [[ionmov]] and [[imgmov]]
        in which the two mechanisms are at work.
        Usually, however, only one mechanism will be activated
        (so, usually, either [[ntimimage]] is bigger than one OR [[ntime]] is bigger than one).
        In order for the user to acquire a mental representation of the interplay between [[ionmov]] and [[imgmov]],
        here is a F90 pseudo-code presenting the interplay between the different above-mentioned input variables,
        as well as with the parallelism (see input variable [[npimage]]).
        </p>
        <p><pre>
        do itimimage=1,ntimimage
          do iimage=1,nimage
            (possibly, parallelisation over images)
            do itime=1,ntime
              Compute the forces and stresses for image(iimage)
              Examine whether the stopping criterion defined by tolmxf is fulfilled
              Predict the next geometry for image(iimage) using ionmov
            enddo
          enddo
          Examine whether the stopping criterion defined by tolimg is fulfilled
          Predict the next geometries for all images using imgmov
        enddo
        </pre></p>
        <ul>
          <li>    = 0  => simply <b> copy </b> images from previous timimage step.</li>
          <li>    = 1  => move images according to <b> Steepest Descent </b>
                         following the (scaled) forces, the scaling factor being [[fxcartfactor]]. </li>
          <li>    = 2  => <b> String Method </b> for finding Minimal Energy Path (MEP)
               connecting to minima (see PRB 66, 052301 (2002));
               the algorithm variant can be selected with the [[string_algo]] keyword
               (Simplified String Method by default).
               The solver for the Ordinary Differential Equation (ODE) can be selected with [[mep_solver]]
               (steepest-descent by default). See also [[mep_mxstep]] keyword.</li>
          <li>    = 3  => (tentatively, not yet coded) <b> Metadynamics </b>.</li>
          <li>    = 4  => (tentatively, not yet coded) <b> Genetic Algorithm</b>.</li>
          <li>    = 5  => <b> Nudged Elastic Band (NEB) </b> for finding Minimal Energy Path (MEP)
               connecting two minima;
               the algorithm variant can be selected with the [[neb_algo]] keyword
               (NEB+improved tangent by default).
               The solver for the Ordinary Differential Equation (ODE) can be selected with [[mep_solver]]
               (steepest-descent by default).
               The spring constant connecting images along the path is defined by [[neb_spring]].
               See also [[mep_mxstep]] keyword.</li>
          <li>    = 9 or 13  => <b> Path-Integral Molecular Dynamics </b>
               (see e.g. [D. Marx and M. Parrinello, J. Chem. Phys. 104, 4077 (1996)]).
               Will use 9 for <b>  Langevin thermostat </b> (associated friction coefficient given by [[vis]])
               and 13 for <b>  Nose-Hoover thermostat chains </b>
               (associated input variables are the number of thermostats in the chains, [[nnos]],
               and the masses of these thermostats [[qmass]]).
               [[nimage]] is the Trotter number (no use of [[dynimage]]);
               possible transformations of coordinates are defined by [[pitransform]];
               Fictitious masses of the atoms (possibly different from the true masses given by [[amu]])
               can be specified by [[pimass]].
               At present, it is only possible to perform calculations in the (N,V,T) ensemble ([[optcell]]=0).</li>
          </ul>
          No meaning for RF calculations.
        </p>
    topics: PIMD_compulsory, TransPath_compulsory
    varset: rlx
    vartype: integer
- !variable
    abivarname: inclvkb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: INCLude VKB
    requires: '[[optdriver]] in [3,99]'
    text: |-
        <p>
        Possible values of [[inclvkb]] are 0,1,2.
        If [[inclvkb]] is 1 or 2, the commutator of the non-local part of the pseudopotential with the position operator is correctly included in the q =&gt; 0 contribution.
        This is unfortunately time-consuming and in particular when the old algorithm implemented by inclvkb==1 is used (inclvkb=2 is the recommended option).
        When [[inclvkb]] is 0, this contribution is incorrectly
        omitted, but the computation is much faster.
        </p>
        <p>
         The importance of this contribution depends on the number of k points. Turning off [[inclvkb]] is let to the choice of the user.
        </p>
        <p>
        In general, the use of [[inclvkb]]=0 is fine for GW calculations in crystalline systems provided that the k-point sampling is sufficiently converged.
        <p>
        The use of [[inclvkb]]=2 is strongly recommended for the calculation of optical properties.
        </p>
    topics: Susceptibility_expert, BSE_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: inpt@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    dimensions: scalar
    excludes: null
    mnemonics: numer of INtegration PoinTs
    requires: null
    text: |-
        Number of radial points used for integration of the
          Bader charge (not too sensitive).
    topics: Bader_expert
    varset: aim
    vartype: integer
- !variable
    abivarname: instrflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: INternal STRain FLAG
    requires: null
    text: |-
        <p>Internal strain tensor flag.
        <br>
        <ul>
        <li> 0 => No internal-strain calculation.</li>
         <li> 1 => Print out both force-response and displacement-response
            internal-strain tensor.
            Requirements for preceding response-function DDB generation
            run:  Strain and full atomic-displacement responses.
            Set [[rfstrs]] = 1, 2, or 3 (preferably 3).
            Set [[rfatpol]] and
            [[rfdir]] to do a full calculation of
              phonons at Q=0.
          </li>
        </ul>
    topics: Elastic_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: intxc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: INTerpolation for eXchange-Correlation
    requires: null
    text: |-
        <p>
         <ul>
          <li>
           0=&gt; do "usual" xc quadrature on fft grid
          </li>
          <li>
           1=&gt; do higher accuracy xc quadrature using fft grid
        and additional points at the centers of each cube
        (doubles number of grid points)--the high accuracy version
        is only valid for boxcut&gt;=2.  If boxcut &lt; 2, the code stops.
          </li>
         </ul>
         <br />
         For RF calculations only [[intxc]]=0 is allowed yet. Moreover,
        the GS preparation runs (giving the density file and zero-order
        wavefunctions) must be done with [[intxc]]=0
        </p>
        <p>
         Prior to ABINITv2.3, the choice [[intxc]]=1 was favoured (it was the default),
        but the continuation of the development of the code lead to prefer
        the default [[intxc]]=0 . Indeed, the benefit of [[intxc]]=1 is
        rather small, while making it available for all cases is a
        non-negligible development effort. Other targets are prioritary...
        You will notice that many automatic tests use [[intxc]]=1. Please,
        do not follow this historical choice for your production runs.
        </p>
    topics: xc_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: iomode
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[MPI_IO]] and [[paral_kgb]]==1': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Input-Output MODE
    requires: null
    text: |-
        <p>
        This option selects the format used to produce the output wavefunction files and the files containing
        densities and potentials. It mainly affects the creation of the output files since several parts
        of Abinit are able to read data from files independently of their format (either binary files or netcdf files).
        The possible values are:
        </p>

        <ul>
         <li>
          0 =&gt; Use standard Fortran IO (ok for sequential runs, not suitable for large parallel runs)
         </li>
         <li>
          1 =&gt; Use MPI/IO routines (ok both for sequential and large parallel runs)
         </li>
         <li>
          3 =&gt; Use NetCDF library to produce files according to the ETSF specification
         (ok for sequential, requires netcdf4 + hdf5 + MPI-IO support for large parallel runs)
         </li>
        </ul>
        <br />

        <p>
        By default, Abinit produces Fortran files and uses parallel MPI-IO under the hood when these
        operations cannot be implemented in terms of simple Fortran write/read statements.
        For example, [[paral_kgb]]=1 uses the MPI-IO API provided by your MPI library.
        </p>

        <p>
        In a nutshell, use the default value and make sure that your MPI library supports MPI-IO
        before embarking yourself in large parallel runs (HAVE_MPI_IO should be set to 1 in ~abinit/config.h).
        Many MPI libraries, nowadays, support the MPI-2 standard so it's very likely that your MPI supports
        parallel IO. If you encounter problems, please ask your sysadmin to install a MPI library
        with MPI-IO capabilities.
        </p>
        <p>
        There are cases, however, in which you would like to change the default behaviour.
        For example, you may want to generate WFK or DEN files in etsf-io format because you need
        data in this format.
        In this case, you have to use iomode==3 in the input file to override the default behaviour.
        Note however that you still need parallel IO capabilities enabled in the netcdf library
        if you want to produce netcdf files in parallel with [[paral_kgb]]=1 (i.e. netcdf4 + hdf5 + MPI-IO).
        At present, the internal fallbacks provided by Abinit do not support netcdf4 so you
        have to link against an external netcdf library that supports hdf5+MPI-IO and
        is compatible with the mpif90 used to compile Abinit.
        See ~abinit/doc/build/config-examples/ubu_gnu_4.9_mpich.ac for a typical configuration file.
        </p>

        <p>
        References:
        <ul>
         <li>
         "Specification of an extensible and portable file format for electronic structure and crystallographic data",
        X. Gonze, C.-O. Almbladh, A. Cucca, D. Caliste, C. Freysoldt, M. Marques, V. Olevano, Y. Pouillon,
        M.J. Verstraete, Comput. Mat. Science 43, 1056 (2008)
          </li>
          <li>
           "Sharing electronic structure and crystallographic data with ETSF_IO",
        D. Caliste, Y. Pouillon, M.J. Verstraete, V. Olevano, X. Gonze,
        Comput. Physics Communications 179, 748 (2008)
          </li>
          <li>
           see also
           <a href="http://www.etsf.eu/fileformats">
            http://www.etsf.eu/fileformats
           </a>
           .
          </li>
         </ul>
        </p>
    topics: parallelism_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: ionmov
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: IONic MOVEs
    requires: null
    text: |-
        <p>
        Choice of algorithm to control the displacements of ions, and eventually (see [[optcell]])
        changes of cell shape and size.
         <ul>
          <li> 0=&gt; Do not move ions; <br /> <br /> </li>
          <li>
           1=&gt; Move atoms using molecular dynamics with
        optional viscous damping (friction linearly proportional
        to velocity). The viscous damping is controlled by the
        parameter "[[vis]]".  If actual undamped molecular dynamics is desired,
        set [[vis]] to 0. The implemented algorithm is the generalisation
        of the Numerov technique (6th order), but is NOT invariant
        upon time-reversal, so that the energy is not conserved.
        The value [[ionmov]]=6 will usually be preferred, although the
        algorithm that is implemented is lower-order. The time step is governed by [[dtion]].  <br />
           <b> Purpose: </b>
           Molecular dynamics (if [[vis]]=0), Structural optimization (if [[vis]]&gt;0) <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           Viscous parameter [[vis]], time step [[dtion]], index of atoms fixed [[iatfix]] <br /> <br /> </li>
          <li>
           2=&gt; Conduct structural optimization using the Broyden-Fletcher-Goldfarb-Shanno minimization (BFGS).
        This is much more efficient for structural optimization than viscous damping, when there are less than
        about 10 degrees of freedom to optimize.  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           3=&gt; Conduct structural optimization using the Broyden-Fletcher-Goldfarb-Shanno minimization (BFGS),
        modified to take into account the total energy as well as the gradients (as in usual BFGS).  <br />
           See the paper by [Schlegel, J. Comp. Chem. 3, 214 (1982)].
        Might be better than [[ionmov]]=2 for few degrees of freedom
        (less than 3 or 4). Can be very unstable - use with caution! <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           4=&gt; Conjugate gradient algorithm for simultaneous optimization of potential and ionic degrees of freedom.
        It can be used with [[iscf]]=2 and [[iscf]]  =5 or 6 (WARNING : this is under development, and does not work very well in many cases).  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           5=&gt; Simple relaxation of ionic positions according to (converged) forces. Equivalent to [[ionmov]]=1 with
        zero masses, albeit the relaxation coefficient is not [[vis]], but [[iprcfc]].  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           6=&gt; Molecular dynamics using the Verlet algorithm, see [Allen &amp; Tildesley "Computer simulation of liquids" 1987, p 81].
        The only related parameter is the time step ([[dtion]]).  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]], index of atoms fixed [[iatfix]] <br /> <br />
          </li>
          <li>
           7=&gt; Quenched Molecular dynamics using the Verlet algorithm, and stopping each atom for which the scalar product
        of velocity and force is negative.  The only related parameter is the time step ([[dtion]]).  The goal is not
        to produce a realistic dynamics, but to go as fast as possible to the minimum. For this purpose, it is advised to set
        all the masses to the same value (for example, use the Carbon mass, i.e. set [[amu]] to 12 for all type of atoms).  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]], index of atoms fixed [[iatfix]] <br /> <br />
          </li>
          <li>
           8=&gt; Molecular dynamics with Nose-Hoover thermostat, using the Verlet algorithm.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step ([[dtion]]), Temperatures ([[mdtemp]]), and thermostat mass ([[noseinert]]).  <br /> <br />
          </li>
          <li>
           9=&gt; Langevin molecular dynamics.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step ([[dtion]]), temperatures ([[mdtemp]]) and friction coefficient ([[friction]]).  <br /> <br />
          </li>
          <li>
           10=&gt; Delocalized internal coordinates. with BFGS simple <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           11=&gt; Delocalized internal coordinates. with BFGS using total energy <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           12=&gt; Isokinetic ensemble molecular dynamics.  The equation of motion of the ions in contact with a thermostat
        are solved with the algorithm proposed by Zhang [J. Chem. Phys. 106, 6102 (1997)],
        as worked out by Minary et al [J. Chem. Phys. 188, 2510 (2003)].  The conservation of the kinetic energy is obtained within machine
        precision, at each step.  <br />
           <s> Related parameters : the time step ([[dtion]]), the temperatures ([[mdtemp]]), and the friction coefficient ([[friction]]).
           </s> <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           13=&gt; Isothermal/isenthalpic ensemble.
        The equation of motion of the ions in contact with a thermostat
        and a barostat are solved with the algorithm proposed by Martyna,
        Tuckermann Tobias and Klein [Mol. Phys., 1996, p. 1117].  <br />
           If optcell=1 or 2, the mass of the barostat ([[bmass]]) must be given in addition.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b>
           The time step ([[dtion]]), the temperatures ([[mdtemp]]), the number of thermostats ([[nnos]]), and the masses of thermostats ([[qmass]]).  <br /> <br />
          </li>
          <li>
           14=&gt; Simple molecular dynamics with a symplectic algorithm proposed
        by S.Blanes and P.C.Moans [called SRKNa14 in Practical symplectic partitioned
        Runge--Kutta and Runge--Kutta--Nystr&ouml;m methods, Journal of Computational
        and Applied Mathematics archive, volume 142,  issue 2  (May 2002), pages 313 - 330]
        of the kind first published by H. Yoshida [Construction of higher order symplectic
        integrators, Physics Letters A, volume 150, number 5 to 7, pages 262 - 268].
        This algorithm requires at least 14 evaluation of the forces (actually 15 are done
        within Abinit) per time step. At this cost it usually gives much better
        energy conservation than the verlet algorithm ([[ionmov]] 6) for a 30 times bigger
        value of [[dtion]]. Notice that the potential energy of the initial atomic configuration is never evaluated using this algorithm.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           20=&gt; Direct inversion of the iterative subspace.
        Given a starting point [[xred]] that is a vector of length 3*[[natom]]
        (reduced nuclei coordinates), and unit cell parameters ([[rprimd]])
        this routine uses the DIIS (direct inversion of the iterative
        subspace) to minimize the gradient (forces) on atoms. The preconditioning
        used to compute errors from gradients is using an inverse hessian matrix obtained by a BFGS algorithm.
        This method is known to converge to the nearest point where gradients
        vanish. This is efficient to refine positions around a saddle point for instance.  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           DIIS memory [[diismemory]] <br /> <br />
          </li>
          <li>
          22=&gt; Conduct structural optimization using the Limited-memory Broyden-Fletcher-Goldfarb-Shanno minimization (L-BFGS).
        The working routines were based on the original implementation of J. Nocera available on netlib.org.
        This algorithm can be much better than the native implementation of BFGS in ABINIT ([[ionmov]]=2)
        when one approaches convergence, perhaps because of better treatment of numerical details.<br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           23=&gt; Use of Learn on The Fly method (LOTF) for Molecular Dynamics.
        In the framework of isokinetic MD, the atomic forces and positions are computed
        by using LOTF interpolation.  A SCF computation is performed only any [[lotf_nitex]]
        steps. The results of the SCF are used to compute the parameters of a
        short range classical potential (for the moment only the glue potential for gold is implemented).
        Then these parameters are continuously tuned to compute atomic trajectories.
        LOTF has to be enabled at configure time. If LOTF is not enabled and [[ionmov]]=23,
        abinit will set automatically [[ionmov]]=12.  <br />
           The LOTF cycle is divided in the following steps: <br />
           a) Initialization (SFC at t=0) and computation of potential parameters.  <br />
           b) Extrapolation of the atomic forces and positions for [[lotf_nitex]] time step.
        To perform this extrapolation, the potential computed in a) is used (Verlet algorithm).  <br />
           c) SFC at t=[[lotf_nitex]]. Computation of the potential parameters.  <br />
           d) LOTF interpolation, linear interpolation of the potential parameters and computation of the atomic
        forces and positions between t=0 and t=lotf_nitex.  <br /> <br />
           <b> Purpose: </b>
           Molecular Dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           [[dtion]], [[lotf_classic]], [[lotf_nitex]], [[lotf_nneigx]], [[lotf_version]].  <br /> <br />
          </li>
          <li>
          24=&gt; Simple constant energy molecular dynamics using the velocity Verlet symplectic algorithm (second order), see e.g. [E. Hairer et al. Acta Numerica. 12, 399 (2003)].
        The only related parameter is the time step ([[dtion]]).  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]] <br /> <br />
          </li>
          <li>
          25=&gt; Hybrid Monte Carlo sampling of the ionic positions at fixed temperature and unit cell geometry (NVT ensemle). The underlying molecular dynamics corresponds to ionmov=24.
        The related parameters are the time step ([[dtion]]) and thermostat temperature ([[mdtemp]]).  <br />
           <b> Purpose: </b>
           Monte Carlo sampling <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]], thermostat temperature [[mdtemp]], <br /> <br />
          </li>
          <li>
           30=&gt; Using a supercell, calculate a self consistent phonon structure
        as in PRL 100 095901 (2008). The initial phonon eigenvectors and
        eigenvalues are read in, and then atoms are displaced according
        to the normal modes populated at a given temperature until
        convergence of the vibrational free energy (or so I hope) <br />
           <b> Purpose: </b>
           Phonon structure <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
         </ul>
         <ul>
         </ul>
         <br />
         No meaning for RF calculations.
        </p>
    topics: MolecularDynamics_compulsory, GeoOpt_compulsory
    varset: rlx
    vartype: integer
- !variable
    abivarname: iprcel
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer for PReConditioning of ELectron response
    requires: null
    text: |-
        <p>
         Used when [[iscf]]&gt;0, to define the SCF preconditioning scheme.
        Potential-based preconditioning schemes for the SCF loop
        (electronic part) are still a subject of active research.
        The present parameter (electronic part) describes the way the
        change of potential is derived from the residual.
         <br />
         The possible values of [[iprcel]] correspond to :
         <ul>
          <li>
           0 =&gt; model dielectric function described by [[diemac]],
        [[dielng]]
        and [[diemix]].
          </li>
          <li>
           larger or equal to 21 =&gt; will compute the dielectric matrix
        according to [[diecut]], [[dielam]],
        [[diegap]]. This methodology is described in
        P.-M. Anglade, X. Gonze, Phys. Rev. B 78, 045126 (2008).
          </li>
          <li>
           Between 21 and 29 =&gt; for the first few steps
        uses the same as option 0 then compute RPA dielectric function,
        and use it as such.
          </li>
          <li>
           Between 31 and 39 =&gt; for the first few steps
        uses the same as option 0 then compute RPA dielectric function,
        and use it, with the mixing factor [[diemix]].
          </li>
          <li>
           Between 41 and 49 =&gt; compute the RPA dielectric matrix
        at the first step, and recompute it at a later step,
        and take into account the mixing factor [[diemix]].
          </li>
          <li>
           Between 51 and 59 =&gt; same as between 41 and 49, but compute
        the RPA dielectric matrix by another mean
          </li>
          <li>
           Between 61 and 69 =&gt; same as between 41 and 49, but compute
        the electronic dielectric matrix instead of the RPA one.
          </li>
          <li>
           Between 71 and 78 =&gt; STILL UNDER DEVELOPMENT -- NOT USABLE ; Use the modified Kerker preconditioner with a real-space formulation (basic formulation is shown at [[dielng]]). The dielectric matrix is approximated thanks to  [[diemac]] and [[dielng]].  Note that [[diemix]] is also used.
          </li>
          <li>
           79 =&gt; STILL UNDER DEVELOPMENT -- NOT USABLE ; same as previous but with an alternate algorithm.
          </li>
          <li>
           141 to 169 =&gt; same as Between 41 and 69 (but, the dielectric matrix is also recomputed every iprcel modulo 10 step).
          </li>
         </ul>
         <br />
         The computation of the dielectric matrix (for 0 [100]&lt; [[iprcel]] &lt; 70 [100]) is based on the
         <b>
          extrapolar
         </b>
         approximation. This approximation can be tuned with [[diecut]], [[dielam]],
        and [[diegap]]. Yet its accuracy mainly depends on the number of conduction bands included in the system. Having 2 to 10 empty bands in the calculation is
        usually enough (use [[nband]]).
         <br />
         <br />
         NOTES:
         <ul>
          <li>
           The step at which the dielectric matrix is computed or
        recomputed is determined by modulo([[iprcel]],10). The recomputation happens
        just once in the calculation for [[iprcel]] &lt; 100.
          </li>
          <li>
           For non-homogeneous relatively large cells [[iprcel]]=45
        will likely give a large improvement over [[iprcel]]=0.
          </li>
          <li>
           In case of PAW and [[iprcel]]&gt;0, see [[pawsushat]] input variable. By default,
        an approximation (which can be suppressed) is done for the computation of susceptibility matrix.
          </li>
          <li>
           For extremely large inhomogeneous cells where computation of the full dielectric matrix takes too many weeks, 70 &lt; [[iprcel]] &lt; 80 is advised.
          </li>
          <li>
           For [[nsppol]]=2 or
        [[nspinor]]=2 with metallic [[occopt]],
        only
           <b>
            mod(iprcel,100)
           </b>
           &lt;50 is allowed.
          </li>
          <li>
           No meaning for RF calculations yet.
          </li>
          <li>
           The exchange term in the full dielectric matrix diverges for vanishing densities.
        Therefore the values of [[iprcel]] beyond 60 must not be used for cells containing vacuum,
        unless ones computes this matrix for every step ([[iprcel]]=161).
          </li>
         </ul>
        </p>
    topics: SCFAlgorithms_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: iprcfc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer for PReConditioner of Force Constants
    requires: null
    text: |-
        <p>
         Used when [[iscf]]&gt;0, to define the SCF preconditioning scheme.
        Potential-based preconditioning schemes for the SCF loop
        are still under development.
         <br />
         The present parameter (force constant part)
        describes the way a change of force
        is derived from a change of atomic position.
         <br />
         Supported values :
         <ul>
          <li>
           0 =&gt; hessian is the identity matrix
          </li>
          <li>
           1 =&gt; hessian is 0.5 times the identity matrix
          </li>
          <li>
           2 =&gt; hessian is 0.25 times the identity matrix
          </li>
          <li>
           -1=&gt; hessian is twice the identity matrix
          </li>
          <li>
           ... (simply corresponding power of 2 times the identity matrix)
          </li>
         </ul>
         No meaning for RF calculations.
        </p>
    topics: GeoOpt_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: iqpt
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Index for QPoinT generation
    requires: null
    text: |-
        <p>
         Only used if [[nqpt]]=1, and
        [[qptopt]]=1 to 4.
        </p>
        <p>
         Defines the index of the Q point to be selected in the list of q points generated by
        [[ngqpt]],
        [[qptrlatt]],
        [[nshiftq]],
        and
        [[shiftq]].
        </p>
        <p>
         If [[iqpt]]=0, then the q point is Gamma (0 0 0).
        </p>
        <p>
         The usual working mode is to define a series of values for [[iqpt]],
        starting with [[iqpt]]=0 or 1 (so through the definition of
         <b>
          iqpt:
         </b>
         ),
        and increasing it by one for each dataset (thanks to
         <b>
          iqpt+
         </b>
         ).
        </p>
    topics: q-points_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: irandom
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 3
    dimensions: scalar
    excludes: null
    mnemonics: Integer for the choice of the RANDOM number generator
    requires: null
    text: |-
        <p>
         For the time being, only used when [[imgmov]]=9
        (Langevin Path-Integral Molecular Dynamics).
         <br />
         [[irandom]] defines the random number generator.
         <br />
         <br />
         Supported values :
         <ul>
          <li>
           1 =&gt; "uniformrandom", delivered with ABINIT package (initially comes from numerical recipes).
          </li>
          <li>
           2 =&gt; intrinsic Fortran 90 random number generator.
          </li>
          <li>
           3 =&gt; "ZBQ" non-deterministic random number generator by R. Chandler and P. Northrop.
          (Available at <a href="http://www.ucl.ac.uk/~ucakarc/work/index.html#code">).
          </li>
         </ul>
         [[irandom]]=3 is strongly advised when performing Molecular Dynamics restarts (avoids bias).
        </p>
    topics: PIMD_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: ird1den
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[iscf]] < 0': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of 1st-order DEN file
    requires: null
    text: |-
        If first order density is needed in single dataset mode
        (for example in nonlinear optical response),
        use [[ird1den]]=1 to read first-order densities from _DENx files produced in
        other calculations. In multi-dataset mode use
        [[get1den]].
        </p>
        When iscf &#60; 0, the reading of a DEN file is always enforced.
        </p>
        <p>
         A non-zero value of
         <b>
          ird1den
         </b>
         is treated in the same way
        as other "ird" variables,
        see the
         <a href="../../users/generated_files/help_abinit.html#4">
          section 4
         </a>
         of the [[help_abinit]].
         <br />
        </p>
    topics: nonlinear_useful
    varset: files
    vartype: integer
- !variable
    abivarname: ird1wf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Integer that governs the ReaDing of _1WF files '
    requires: null
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only
           <b>
            irdwfk
           </b>
           and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] can be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           only one of
           <b>
            irdwfq
           </b>
           or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
           <b>
            irdwfk
           </b>
           and/or [[getwfk]]
          </li>
          <li>
           if
           <b>
            irdwfq
           </b>
           = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of [[ird1wf]] or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions to zeroes
          </li>
          <li>
           if [[ird1wf]] = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of
           <b>
            irdddk
           </b>
           or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if
           <b>
            irdddk
           </b>
           = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
        </p>
    topics: DFPT_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdbscoup
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of COUPling block
    requires: null
    text: |-
        <p>
         Start the Bethe-Salpeter calculation from the BSC file containing the coupling block produced in a previous run.
        </p>
    topics: BSE_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdbseig
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of BS_EIG file
    requires: null
    text: |-
        <p>
         Start the Bethe-Salpeter calculation from the BS_EIG contining the exciton eigenvectors produced in a previous run.
        </p>
    topics: BSE_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdbsreso
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of RESOnant block
    requires: null
    text: |-
        <p>
         Start the Bethe-Salpeter calculation from the BSR file containing the resonat block produced in a previous run.
        </p>
    topics: BSE_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[iscf]] < 0': '1'
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of DDB file
    requires: null
    text: |-
        <p>
        This variable should be used when performing electron-phonon
        or temperature-dependence calculations.
        The Born effective charge
        as well as the dielectric tensor will be read from a previous
        DFPT calculations of the electric field at q=Gamma.

        The use of this variable will trigger the cancellation of a
        residual dipole that leads to an unphysical divergence of the
        GKK with vanishing q-points.

        The use of this variable greatly improves the k-point convergence
        speed as the density of the k-point grid required to obtain the
        fulfillment of the charge neutrality sum rule is usually prohibitively
        large.
        </p>
        <p>
         A non-zero value of [[irdddb]] is treated in the same way
        as other "ird" variables,
        see the
         <a href="../../users/generated_files/help_abinit.html#4">
          section 4
         </a>
         of the [[help_abinit]].
         <br />
         <br />
        </p>
    topics: ElPhonInt_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdddk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of DDK wavefunctions, in _1WF files
    requires: null
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only
           <b>
            irdwfk
           </b>
           and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] can be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           only one of
           <b>
            irdwfq
           </b>
           or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
           <b>
            irdwfk
           </b>
           and/or [[getwfk]]
          </li>
          <li>
           if
           <b>
            irdwfq
           </b>
           = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of
           <b>
            ird1wf
           </b>
           or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions
        to zeroes
          </li>
          <li>
           if
           <b>
            ird1wf
           </b>
           = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of [[irdddk]] or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if [[irdddk]] = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
        </p>
    topics: DFPT_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[iscf]] < 0': '1'
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of DEN file
    requires: null
    text: |-
        <p>
        Start the ground-state calculation from the density file of a previous run.
        When iscf &#60; 0, the reading of a DEN file is always enforced.
        </p>
        <p>
         A non-zero value of [[irdden]] is treated in the same way
        as other "ird" variables,
        see the
         <a href="../../users/generated_files/help_abinit.html#4">
          section 4
         </a>
         of the [[help_abinit]].
         <br />
         <br />
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdhaydock
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of the HAYDOCK restart file
    requires: null
    text: |-
        <p>
         Used to re-start the Haydock iterative technique from the HAYDR_SAVE file produced in a previous run.
        </p>
    topics: BSE_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdqps
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of QuasiParticle Structure
    requires: null
    text: |-
        <p>
         Relevant only when [[optdriver]]=3 or 4.
        Indicate the file from which the eigenvalues and possibly the wavefunctions must be obtained,
        in order to achieve a self-consistent quasiparticle calculations.
        See also [[getqps]]
        </p>
    topics: GW_useful, multidtset_useful, Susceptibility_useful, SelfEnergy_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdscr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of the SCReening
    requires: null
    text: |-
        <p>
         Relevant only when [[optdriver]]=4.
        Indicate the file from which the dielectric matrix must be obtained.
        As alternative, one can use the input variable
        [[getscr]].
         <br />
         When [[optdriver]]=4, at least one of
        [[irdscr]] or [[getscr]]
        (alternatively, [[irdsuscep]] or [[getsuscep]])
        must be non-zero.
        </p>
        <p>
         A non-zero value of [[irdscr]] is treated in the same way as other "ird" variables,
        see the
         <a href="../../users/generated_files/help_abinit.html#4">
          section 4
         </a>
         of the [[help_abinit]].
        </p>
    topics: GW_useful, multidtset_useful, SelfEnergy_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdsuscep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of the SUSCEPtibility
    requires: null
    text: |-
        <p>
         Relevant only when [[optdriver]]=4.
        Indicate the file from which the irreducible polarizability must be obtained.
        As alternative, one can use the input variable
        [[getsuscep]].
         <br />
         When [[optdriver]]=4, at least one of
        [[irdsuscep]] or [[getsuscep]]
        (alternatively, [[irdscr]] or [[getscr]])
        must be non-zero.
        </p>
        <p>
         A non-zero value of [[irdsuscep]] is treated in the same way as other "ird" variables,
        see the
         <a href="../../users/generated_files/help_abinit.html#4">
          section 4
         </a>
         of the [[help_abinit]].
        </p>
    topics: GW_useful, multidtset_useful, SelfEnergy_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdvdw
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of _VDW files
    requires: null
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to read previously calculated vdW-DF variables.
        <br />
        Supported values:
        <ul>
         <li>
          0 =&gt; do not read vdW-DF variables
         </li>
         <li>
          1 =&gt; read vdW-DF variables
         </li>
        </ul>
    topics: vdw_useful
    varset: vdw
    vartype: integer
- !variable
    abivarname: irdwfk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of _WFK files
    requires: null
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only [[irdwfk]] and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of [[irdwfk]] or [[getwfk]] can be non-zero
          </li>
          <li>
           if [[irdwfk]] and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if [[irdwfk]] = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of [[irdwfk]] or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if [[irdwfk]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           only one of
           <b>
            irdwfq
           </b>
           or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
        [[irdwfk]] and/or [[getwfk]]
          </li>
          <li>
           if
           <b>
            irdwfq
           </b>
           = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of
           <b>
            ird1wf
           </b>
           or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions
        to 0's.
          </li>
          <li>
           if
           <b>
            ird1wf
           </b>
           = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of
           <b>
            irdddk
           </b>
           or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if
           <b>
            irdddk
           </b>
           = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
        </p>
    topics: multidtset_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irdwfkfine
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of the grid _WFK file on the FINE grid
    requires: null
    text: |-
        Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfkfine]].
        <br />
        <br />
        Ground-state calculation :
        <ul>
         <li>
          only [[irdwfkfine]] and [[getwfkfine]] have a meaning
         </li>
         <li>
          at most one of [[irdwfkfine]] or [[getwfkfine]] can be non-zero
         </li>
         <li>
          if [[irdwfkfine]] = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state fine grid calculation (see the
          <a href="../../users/generated_files/help_abinit.html#4">
           section 4
          </a>
          of the [[help_abinit]]).
         </li>
        </ul>
        Response-function calculation :
        <ul>
         <li>
          one and only one of [[irdwfkfine]] or [[getwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[irdwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/generated_files/help_abinit.html#4">
           section 4
          </a>
          of the [[help_abinit]]).
         </li>
         <li>
          Reading the fine grid wavefunction will trigger the k-points interpolation technique of the temperature dependent
        calculations.
         </li>
        </ul>
        Bethe-Salpeter calculation :
        <ul>
         <li>
          one and only one of [[irdwfkfine]] or [[getwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[irdwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/generated_files/help_abinit.html#4">
           section 4
          </a>
          of the [[help_abinit]]).
         </li>
         <li>
          This variable or [[getwfkfine]] is mandatory when [[bs_interp_mode]] = 1
         </li>
        </ul>
        <b>
         This variable is experimental. In development.
        </b>
    topics: multidtset_useful, TDepES_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: irdwfq
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer that governs the ReaDing of _WFQ files
    requires: null
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only
           <b>
            irdwfk
           </b>
           and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] can be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           only one of [[irdwfq]] or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
           <b>
            irdwfk
           </b>
           and/or [[getwfk]]
          </li>
          <li>
           if [[irdwfq]] = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of
           <b>
            ird1wf
           </b>
           or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions
        to 0's.
          </li>
          <li>
           if
           <b>
            ird1wf
           </b>
           = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
          <li>
           at most one of
           <b>
            irdddk
           </b>
           or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if
           <b>
            irdddk
           </b>
           = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of the [[help_abinit]]).
          </li>
         </ul>
        </p>
    topics: DFPT_useful
    varset: files
    vartype: integer
- !variable
    abivarname: irho@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integration of the charge density RHO
    requires: null
    text: |-
        Drives the integration of the charge of the Bader atom.
          <ul>
           <li>0, not calculated
           <li>1, calculated (usual mode)
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: iscf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==1': 17
        '[[usewvl]]==1': 0
        defaultval: 7
    dimensions: scalar
    excludes: null
    mnemonics: Integer for Self-Consistent-Field cycles
    requires: null
    text: |-
        <p>
         Controls the self-consistency.
         <br />
         Positive values =&gt;
        this is the usual choice for doing the usual ground state (GS)
        calculations or for structural relaxation, where
        the potential has to be determined self-consistently.
        The choice between different algorithms for SCF is possible :
         <ul>
          <li>
           =0 =&gt; SCF cycle, direct minimization scheme on the gradient of the wavefunctions. This algorithm is faster than diagonalisation and mixing but is working only for systems with a gap. It is implemented only on the wavelet basis set, when [[usewvl]]=1.
          </li>
          <li>
           =1 =&gt; get the largest eigenvalue of the SCF cycle
           <br />
           ([[DEVELOP]] option, used with
        [[irdwfk]]=1 or
           [[irdwfq]]=1)
          </li>
          <li>
           =2 =&gt; SCF cycle, simple mixing of the potential
          </li>
          <li>
           =3 =&gt; SCF cycle, Anderson mixing of the potential
          </li>
          <li>
           =4 =&gt; SCF cycle, Anderson mixing of the potential based on the two previous iterations
          </li>
          <li>
           =5 =&gt; SCF cycle, CG based on the minim. of the energy with respect to the potential
          </li>
          <li>
           =7 =&gt; SCF cycle, Pulay mixing of the potential based on the [[npulayit]] previous iterations
          </li>
          <li>
           =12 =&gt; SCF cycle, simple mixing of the density
          </li>
          <li>
           =13 =&gt; SCF cycle, Anderson mixing of the density
          </li>
          <li>
           =14 =&gt; SCF cycle, Anderson mixing of the density based on the two previous iterations
          </li>
          <li>
           =15 =&gt; SCF cycle, CG based on the minim. of the energy with respect to the density
          </li>
          <li>
           =17 =&gt; SCF cycle, Pulay mixing of the density based on the [[npulayit]] previous iterations
          </li>
          <li>
           Other positive values, including zero ones, are not allowed.
          </li>
         </ul>
        </p>
        <p>
         Such algorithms for treating the "SCF iteration history" should be coupled with accompanying algorithms
        for the SCF "preconditioning". See the input variable [[iprcel]].
        The default value [[iprcel]]=0 is often a good choice, but
        for inhomogeneous systems, you might gain a lot with [[iprcel]]=45.
        </p>
        <p>
         (Warning : if [[iscf]]&gt;10, at present (v4.6), the energy printed at each SCF cycle is not variational -
        this should not affect the other properties, and at convergence, all values are OK)
        </p>
        <p>
         - In the norm-conserving case,
        the default option is [[iscf]]=7, which is a compromise between speed and reliability.
        The value [[iscf]]= 2 is safer but slower.
         <br />
         - In the PAW case, default option is [[iscf]]=17.
        In PAW you have the possibility to mix density/potential on the fine or coarse FFT grid (see [[pawmixdg]]).
         <br />
         - Note that a Pulay mixing ([[iscf]]=7 or 17) with [[npulayit]]
        =1 (resp. 2) is equivalent to an Anderson mixing with [[iscf]]=3 or 13 (resp. 4 or 14).
         <br />
         - Also note that:
         <br />
         * when mixing is done on potential (iscf
         &lt;10), total energy is computed by "direct" decomposition.
         <br />
         * when mixing is done on density (iscf
         &gt;=10), total energy is computed by "double counting" decomposition.
         <br />
         "Direct" and "double counting" decomposition of energy are equal when SCF cycle is converged. Note that,
        when using GGA XC functionals, these decompositions of energy can be slightly different due
        to imprecise computation of density gradients on FFT grid (difference decreases as size of FFT grid increases -
        see [[ecut]] for NC pseudopotentials, [[pawecutdg]] for PAW).
         <br />
         <br />
         Other (negative) options:
         <ul>
          <li>
           = -2 =&gt;
        a non-self-consistent calculation is to be done;
        in this case an electron density rho(r) on a real space grid
        (produced in a previous calculation) will be read from a
        disk file (automatically if [[ndtset]]=0, or
        according to the value of [[getden]]
        if [[ndtset]]/=0).
           <br />
           The name of the density file must be given as indicated
        in the
           <a href="../../users/generated_files/help_abinit.html#4">
            section 4
           </a>
           of [[help_abinit]].
        [[iscf]]=-2 would be used for
        band structure calculations, to permit computation of
        the eigenvalues of occupied and unoccupied states at
        arbitrary k points in the fixed self consistent potential
        produced by some integration grid of k points.
        Due to this typical use, ABINIT insist that either
        [[prtvol]]&gt;2 or
        [[prteig]] does not vanish
        when there are more than 50 k points.
           <br />
           To compute the eigenvalues
        (and wavefunctions) of unoccupied states in a separate
        (non-selfconsistent) run, the user should
        save the self-consistent rho(r)
        and then run [[iscf]]=-2 for the intended set of k-points and bands.
           <br />
           To prepare a run with [[iscf]]=-2, a density file
        can be produced using the
        parameter [[prtden]] (see its description).
        When a self-consistent set of wavefunctions is already available,
        abinit can be used with
        [[nstep]]=0 (see Test_v2/t47.in),
        and the adequate value of [[prtden]].
          </li>
          <li>
           = -3 =&gt;
        like -2, but initialize [[occ]] and [[wtk]],
        directly or indirectly (using [[ngkpt]] or
        [[kptrlatt]])
        depending on the value of [[occopt]].
           <br />
           For GS, this option
        might be used to generate Density-of-states
        (thanks to [[prtdos]]),
        or to produce STM charge density map (thanks to [[prtstm]]).
           <br />
           For RF, this option is needed to compute the response to ddk perturbation.
          </li>
          <li>
           = -1 =&gt; like -2, but the non-self-consistent calculation
        is followed by the determination of excited states
        within TDDFT. This is only possible for [[nkpt]]=1,
        with [[kpt]]=0 0 0.
        Note that the oscillator strength needs to be defined with respect to
        an origin of coordinate, thanks to the input variable
        [[boxcenter]]. The maximal
        number of Kohn-Sham excitations to be used to build the
        excited state TDDFT matrix can be defined by [[td_mexcit]],
        or indirectly by the maximum Kohn-Sham excitation energy
        [[td_maxene]].
          </li>
         </ul>
        </p>
    topics: SCFAlgorithms_basic, TDDFT_compulsory, ElecBandStructure_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: isecur
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer for level of SECURity choice
    requires: null
    text: |-
        <p>
         In the presently used algorithms, there is a compromise
        between speed and robustness, that can be tuned by
        using [[isecur]].
         <br />
         If [[isecur]] =0, an extrapolation of out-of-line
        data is allowed, and might save one non-SCF calculation every
        two line minimisation when some stability conditions
        are fulfilled (since there are 2 non-SCF calculations
        per line minimisation, 1 out of 4 is saved)
         <br />
         Using [[isecur]]=1 or higher integers will raise gradually
        the threshold to make extrapolation.
         <br />
         Using [[isecur]]=-2 will allow to save 2 non-SCF calculations
        every three line minimisation, but this can make the
        algorithm unstable. Lower values of [[isecur]] allows
        for more (tentative) savings. In any case, there must
        be one non-SCF computation per line minimisation.
         <br />
         No meaning for RF calculations yet.
        </p>
    topics: SCFAlgorithms_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: istatimg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Integer governing the computation of STATic IMaGes
    requires: null
    text: |-
        <p>
         This input variable is relevant when sets of images are activated (see
        [[imgmov]]).
         <br />
         Not all images might be required to evolve from one time step to the other
        (see[[dynimage]]): these are static images.
         <br />
         If [[istatimg]]=0, the total energy of static images is not computed (but static images are
        used to make the dynamic images evolve). This can be useful to save CPU time.
         <br />
         If [[istatimg]]=1, the total energy of static images is computed.
        </p>
    topics: PIMD_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: istatr
    characteristics:
    - '[[DEVELOP]]'
    - '[[NO_MULTI]]'
    commentdefault: Values lower than 10 may not work on some machines.
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integer for STATus file rate
    requires: null
    text: |-
        <p>
        Govern the rate of output of the status file.
        This status file is written when the number of the
        call to the status subroutine is equal to '
         <b>
          istatshft
         </b>
         ' modulo '[[istatr]]', so that
        it is written once every '[[istatr]]' call.
        When '[[istatr]]'=0, there is no writing of a status file (which is the default).
        </p>
    topics: printing_prmisc
    varset: dev
    vartype: integer
- !variable
    abivarname: istatshft
    characteristics:
    - '[[DEVELOP]]'
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Integer for STATus file SHiFT
    requires: null
    text: |-
        <p>
         Govern the rate of output of the status file.
        This status file is written when the number of the
        call to the status
        subroutine is equal to '[[istatshft]]' modulo '
         <b>
          istatr
         </b>
         ', so that
        it is written once every '
         <b>
          istatr
         </b>
         ' call.
        There is also a writing for each of the 5 first calls,
        and the 10th call.
        </p>
    topics: printing_prmisc
    varset: dev
    vartype: integer
- !variable
    abivarname: istrfix@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[anaddb:nstrfix]]'
    excludes: null
    mnemonics: Index of STRain FIXed
    requires: null
    text: |-
        <p>Indices of the elements of the strain tensor that are fixed during a structural relaxation at constrained polarisation:

        <ul>
        <li>0 =&gt; No elastic or compliance tensor will be calculated.</li>
        <li>1 =&gt; Only clamped-ion elastic and compliance tensors will be
        calculated. Requirements for preceding response-function DDB generation
        run: Strain perturbation. Set [[rfstrs]] to 1, 2, or 3.
        Note that [[rfstrs]]>=3
        is recommended so that responses to both uniaxial and shear strains
        will be computed. </li>
          <li>2 =&gt; Both relaxed- and clamped-ion elastic and compliance
        tensor will be calculated, but only the relaxed-ion quantities will be
        printed. The input variable [[anaddb:instrflag]]
        should also be set to 1, because the internal-strain tensor is needed
        to compute the relaxed-ion corrections. Requirements for preceding
        response-function DDB generation run: Strain and atomic-displacement
        responses at Q=0. Set [[rfstrs]] = 1, 2, or 3 (preferably 3). Set
         [[rfatpol]] and [[rfdir]] to do a full
        calculation of phonons at Q=0 (needed because the inverse of
        force-constant tensor is required). </li>
          <li>3 =&gt; Both relaxed and clamped-ion elastic and compliance
        tensors will be printed out. The input variable [[anaddb:instrflag]] should also be set to
        1. Requirements for preceding response-function DDB generation run:
        Same as for [[anaddb:elaflag]]=2'. </li>
          <li>4 =&gt; Calculate the elastic and compliance tensors (relaxed
        ion) at fixed displacement field, the relaxed-ion tensors at fixed
        electric field will be printed out too, for comparison. When [[anaddb:elaflag]]=4,
        we need the information of internal strain and relaxed-ion dielectric
        tensor to build the whole tensor, so we need set [[anaddb:instrflag]]=1 and [[anaddb:dieflag]]=3 or 4 . </li>
          <li>5 =&gt; Calculate the relaxed ion elastic and compliance tensors,
        considering the stress left inside cell. At the same time, bare relaxed
        ion tensors will still be printed out for comparison. In this
        calculation, stress tensor is needed to compute the correction term, so
        one supposed to merge the first order derivative data base (DDB file)
        with the second order derivative data base (DDB file) into a new DDB
        file, which can contain both information. And the program will also
        check for the users. </li>
        </ul>
        See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: istwfk
    characteristics: null
    commentdefault: 'For RF calculations, the Default is not used : <b>istwfk</b>
        is forced to be 1 deep inside the code, for all k points. For spin-orbit
        calculations ([[nspinor]]=2), <b>istwfk</b> is also forced to be 1,
        for all k points.'
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - '[[nkpt]]'
    excludes: null
    mnemonics: Integer for choice of STorage of WaveFunction at each k point
    requires: null
    text: |-
        <p>
         Control the way the
        wavefunction for each k-point is stored inside ABINIT,
        in reciprocal space.
         <br />
         For the GS calculations, in the "cg" array containing the
        wavefunction coefficients, there is for each k-point
        and each band, a segment cg(1:2,1:npw). The 'full' number
        of plane wave is determined by [[ecut]].
        However, if the k-point coordinates are build
        only from zeroes and halves (see list below),
        the use of time-reversal symmetry (that connects coefficients)
        has been implemented, in order to use real-to-complex
        FFTs (see [[fftalg]]), and to treat explicitly only half
        of the number of plane waves (this being used as 'npw').
         <br />
         For the RF calculations, there is not only the "cg"
        array, but also the "cgq" and "cg1" arrays. For the
        time-reversal symmetry to decrease the number of
        plane waves of these arrays, the q vector MUST be (0 0 0).
        Then, for each k point, the same rule as for the
        RF can be applied.
         <br />
         WARNING (991018) : for the time being, the time-reversal
        symmetry cannot be used in the RF calculations.
         <ul>
          <li>
           1=&gt; do NOT take advantage of the time-reversal symmetry
          </li>
          <li>
           2=&gt; use time-reversal symmetry for k=( 0   0   0 )
          </li>
          <li>
           3=&gt; use time-reversal symmetry for k=(1/2  0   0 )
          </li>
          <li>
           4=&gt; use time-reversal symmetry for k=( 0   0  1/2)
          </li>
          <li>
           5=&gt; use time-reversal symmetry for k=(1/2  0  1/2)
          </li>
          <li>
           6=&gt; use time-reversal symmetry for k=( 0  1/2  0 )
          </li>
          <li>
           7=&gt; use time-reversal symmetry for k=(1/2 1/2  0 )
          </li>
          <li>
           8=&gt; use time-reversal symmetry for k=( 0  1/2 1/2)
          </li>
          <li>
           9=&gt; use time-reversal symmetry for k=(1/2 1/2 1/2)
          </li>
          <li>
           0=&gt; (preprocessed) for each k point, choose automatically
        the appropriate time-reversal option when it is allowed,
        and chose [[istwfk]]=1 for all the other k points.
          </li>
         </ul>
        </p>
    topics: k-points_useful, TuningSpeed_basic
    varset: dev
    vartype: integer
- !variable
    abivarname: ivol@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Integration of the VOLume
    requires: null
    text: |-
        Drives the integration of the volume of the Bader atom.
          <ul>
           <li>0, not calculated
           <li>1, calculated
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: ixc
    characteristics: null
    commentdefault: Default corresponds to Teter parametrization. However, if all the pseudopotentials have the same value of pspxc, the initial value of ixc will be that common value
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Index of eXchange-Correlation functional
    requires: null
    text: |-
        <p>
         Controls the choice of exchange and correlation (xc). The list of XC functionals is given
        below. Positive values are for ABINIT native library of XC functionals, while negative values are for calling
        the much wider set of functionals from the ETSF LibXC library (by M. Marques), also available at the
         <a href="http://www.etsf.eu/resources/software/libraries_and_tools">
          ETSF library Web page
         </a>
         <br />
         Note that the choice made here should agree with the choice
        made in generating the original pseudopotential, except
        for [[ixc]]=0 (usually only used for debugging).
        A warning is issued if this is not the case.
        However, the choices [[ixc]]=1, 2, 3 and 7 are fits to the same data, from
        Ceperley-Alder, and are rather similar, at least for spin-unpolarized systems.
         <br />
         The choice between the non-spin-polarized and spin-polarized case
        is governed by the value of [[nsppol]] (see below).
        </p>
        <p>
        </p>
        <p>
         <b>
          Native ABINIT XC functionals
         </b>
        </p>
        <p>
         <br />
         NOTE : in the implementation of the spin-dependence of these
        functionals, and in order to avoid divergences in their
        derivatives, the interpolating function between spin-unpolarized
        and fully-spin-polarized function has been slightly modified,
        by including a zeta rescaled by 1.d0-1.d-6. This should affect
        total energy at the level of 1.d-6Ha, and should
        have an even smaller effect on differences of energies, or derivatives.
         <br />
         The value [[ixc]]=10 is used internally : gives the difference between [[ixc]]=7 and
        [[ixc]]=9, for use with an accurate RPA correlation energy.
        </p>
        <p>
         <ul>
          <li>
           0=&gt; NO xc;
          </li>
         </ul>
         <ul>
          <li>
           1=&gt; LDA or LSD, Teter Pade parametrization (4/93, published in [[Goedecker1996]], which
        reproduces Perdew-Wang (which reproduces Ceperley-Alder!).
          </li>
          <li>
           2=&gt; LDA, Perdew-Zunger-Ceperley-Alder (no spin-polarization) [[Perdew1981]]
          </li>
          <li>
           3=&gt; LDA, old Teter rational polynomial parametrization (4/91)
        fit to Ceperley-Alder data (no spin-polarization)
          </li>
          <li>
           4=&gt; LDA, Wigner functional (no spin-polarization)
          </li>
          <li>
           5=&gt; LDA, Hedin-Lundqvist functional (no spin-polarization)
          </li>
          <li>
           6=&gt; LDA, "X-alpha" functional (no spin-polarization)
          </li>
          <li>
           7=&gt; LDA or LSD, Perdew-Wang 92 functional
          </li>
          <li>
           8=&gt; LDA or LSD, x-only part of the Perdew-Wang 92 functional
          </li>
          <li>
           9=&gt; LDA or LSD, x- and RPA correlation part of the Perdew-Wang 92 functional
          </li>
         </ul>
         <ul>
          <li>
           11=&gt; GGA, Perdew-Burke-Ernzerhof GGA functional
          </li>
          <li>
           12=&gt; GGA, x-only part of Perdew-Burke-Ernzerhof GGA functional
          </li>
          <li>
           13=&gt; GGA potential of van Leeuwen-Baerends, while for energy, Perdew-Wang 92 functional
          </li>
          <li>
           14=&gt; GGA, revPBE of Y. Zhang and W. Yang, Phys. Rev. Lett. 80, 890 (1998)
          </li>
          <li>
           15=&gt; GGA, RPBE of B. Hammer, L.B. Hansen and J.K. Norskov, Phys. Rev. B 59, 7413 (1999)
          </li>
          <li>
           16=&gt; GGA, HTCH93 of F.A. Hamprecht, A.J. Cohen, D.J. Tozer, N.C. Handy, J. Chem. Phys. 109, 6264 (1998)
          </li>
          <li>
           17=&gt; GGA, HTCH120 of A.D. Boese, N.L. Doltsinis, N.C. Handy, and M. Sprik, J. Chem. Phys 112, 1670 (1998) - The usual HCTH functional.
          </li>
          <li>
           18=&gt; (NOT AVAILABLE : used internally for GGA BLYP pseudopotentials from
        M. Krack, see Theor. Chem. Acc. 114, 145 (2005),
        available from the
           <a href="https://github.com/cp2k/cp2k/tree/master/potentials/Goedecker/abinit/blyp">
            CP2K repository
           </a>
           - use the LibXC instead, with [[ixc]]=-106131.
          </li>
          <li>
           19=&gt; (NOT AVAILABLE : used internally for GGA BP86 pseudopotentials from
        M. Krack, see Theor. Chem. Acc. 114, 145 (2005),
        available from the
           <a href="https://github.com/cp2k/cp2k/tree/master/potentials/Goedecker/abinit/bp">
            CP2K repository
           </a>
           - use the LibXC instead, with [[ixc]]=-106132.
          </li>
         </ul>
         <ul>
          <li>
           20=&gt; Fermi-Amaldi xc ( -1/N Hartree energy, where N is the
        number of electrons per cell ; G=0 is not taken
        into account however), for TDDFT tests.
        No spin-pol. Does not work for RF.
          </li>
          <li>
           21=&gt; same as 20, except that the xc-kernel is the LDA ([[ixc]]=1) one,
        for TDDFT tests.
          </li>
          <li>
           22=&gt; same as 20, except that the xc-kernel is the Burke-Petersilka-Gross
        hybrid, for TDDFT tests.
          </li>
          <li>
           23=&gt; GGA of Z. Wu and R.E. Cohen, Phys. Rev. 73, 235116 (2006).
          </li>
          <li>
           24=&gt; GGA, C09x exchange of V. R. Cooper, PRB 81, 161104(R) (2010).
          </li>
          <li>
           26=&gt; GGA, HTCH147 of A.D. Boese, N.L. Doltsinis, N.C. Handy, and M. Sprik, J. Chem. Phys 112, 1670 (1998).
          </li>
          <li>
           27=&gt; GGA, HTCH407 of A.D. Boese, and N.C. Handy, J. Chem. Phys 114, 5497 (2001).
          </li>
          <li>
           28=&gt; (NOT AVAILABLE : used internally for GGA OLYP pseudopotentials from
        M. Krack, see Theor. Chem. Acc. 114, 145 (2005),
        available from the
           <a href="https://github.com/cp2k/cp2k/tree/master/potentials/Goedecker/abinit/olyp">
            CP2K repository
           </a>
           - use the LibXC instead, with [[ixc]]=-110131.
          </li>
         </ul>
         <ul>
          <li>
           40=&gt; Hartree-Fock
          </li>
          <li>
           41=&gt; PBE0, J.P. Perdew, M. Ernzerhof and K. Burke, J. Chem. Phys. 105, 9982 (1996)
          </li>
          <li>
           42=&gt; PBE0-1/3, C.A. Guido, E. Bremond, C. Adamo and P. Cortona, J. Chem. Phys. 138, 021104 (2013)
          </li>
         </ul>
        </p>
        <p>
         <b>
          ETSF Lib XC functionals
         </b>
        </p>
        <p>
         Note that you must compile ABINIT with the LibXC plug-in in order to be able to access these functionals.
         <br />
         The LibXC functionals are accessed by
         <b>
          negative values
         </b>
         of [[ixc]].
        The LibXC contains functional forms for either exchange-only functionals, correlation-only functionals,
        or combined exchange and correlation functionals. Each of them is to be specified by a three-digit number.
        In case of a combined exchange and correlation functional, only one such three-digit number has to be specified as value of [[ixc]],
        with a minus sign (to indicate that it comes from the LibXC).
        In the case of separate exchange functional (let us represent its identifier by XXX) and
        correlation functional (let us represent its identified by CCC),
        a six-digit number will have to be specified for [[ixc]], by concatenation, be it XXXCCC or CCCXXX.
        As an example, [[ixc]]=-020 gives access to the Teter93 LDA, while
        [[ixc]]=-101130 gives access to the PBE GGA.
        In version 0.9 of LibXC (December 2008), there are 16 three-dimensional (S)LDA functionals (1 for X, 14 for C, 1 for combined XC),
        and there are 41 three-dimensional GGA (23 for X, 8 for C, 10 for combined XC).
        Note that for a meta-GGA, the kinetic energy density is needed. This means having [[usekden]]=1 .
        </p>
        <p>
        </p>
        <p>
         (S)LDA functionals (do not forget to add a minus sign, as discussed above)
        </p>
        <p>
         <ul>
          <li>
           001=&gt; XC_LDA_X
        [PAM Dirac, Proceedings of the Cambridge Philosophical Society 26, 376 (1930);
        F Bloch, Zeitschrift fuer Physik 57, 545 (1929)
        ]
          </li>
          <li>
           002=&gt; XC_LDA_C_WIGNER Wigner parametrization
        [EP Wigner, Trans. Faraday Soc. 34, 678 (1938)
        ]
          </li>
          <li>
           003=&gt; XC_LDA_C_RPA Random Phase Approximation
        [M Gell-Mann and KA Brueckner, Phys. Rev. 106, 364 (1957)
        ]
          </li>
          <li>
           004=&gt; XC_LDA_C_HL Hedin &amp; Lundqvist
        [L Hedin and BI Lundqvist, J. Phys. C 4, 2064 (1971)
        ]
          </li>
          <li>
           005=&gt; XC_LDA_C_GL !  Gunnarson &amp; Lundqvist
        [O Gunnarsson and BI Lundqvist, PRB 13, 4274 (1976)
        ]
          </li>
          <li>
           006=&gt; XC_LDA_C_XALPHA  !  Slater's Xalpha
        ]
          </li>
          <li>
           007=&gt; XC_LDA_C_VWN !  Vosko, Wilk, &amp; Nussair
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           008=&gt; XC_LDA_C_VWN_RPA !  Vosko, Wilk, &amp; Nussair (RPA)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           009=&gt; XC_LDA_C_PZ !  Perdew &amp; Zunger
        [[Perdew1981]]
          </li>
          <li>
           010=&gt; XC_LDA_C_PZ_MOD !  Perdew &amp; Zunger (Modified)
        [[Perdew1981]]
        Modified to improve the matching between the low and high rs part
        ]
          </li>
          <li>
           011=&gt; XC_LDA_C_OB_PZ !  Ortiz &amp; Ballone (PZ)
        [G Ortiz and P Ballone, Phys. Rev. B 50, 1391 (1994) ;
        G Ortiz and P Ballone, Phys. Rev. B 56, 9970(E) (1997) ;
        [[Perdew1981]]
        ]
          </li>
          <li>
           012=&gt; XC_LDA_C_PW !  Perdew &amp; Wang
        [JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992)
        ]
          </li>
          <li>
           013=&gt; XC_LDA_C_PW_MOD !  Perdew &amp; Wang (Modified)
        [JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992) ;
        Added extra digits to some constants as in the PBE routine
        see
           <a href="https://www.chem.uci.edu/~kieron/dftold2/pbe.php">
            https://www.chem.uci.edu/~kieron/dftold2/pbe.php
           </a>
           (at some point it was available at http://dft.uci.edu/pbe.php)
        ]
          </li>
          <li>
           014=&gt; XC_LDA_C_OB_PW !  Ortiz &amp; Ballone (PW)
        [G Ortiz and P Ballone, Phys. Rev. B 50, 1391 (1994) ;
        G Ortiz and P Ballone, Phys. Rev. B 56, 9970(E) (1997) ;
        JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992)
        ]
          </li>
          <li>
           017=&gt; XC_LDA_C_vBH !  von Barth &amp; Hedin
        [U von Barth and L Hedin, J. Phys. C: Solid State Phys. 5, 1629 (1972)
        ]
          </li>
          <li>
           020=&gt; XC_LDA_XC_TETER93 !  Teter 93 parametrization
        [S Goedecker, M Teter, J Hutter, PRB 54, 1703 (1996)
        ]
          </li>
          <li>
           022=&gt; XC_LDA_C_ML1 !  Modified LSD (version 1) of Proynov and Salahub
        [EI Proynov and D Salahub, Phys. Rev. B 49, 7874 (1994)
        ]
          </li>
          <li>
           023=&gt; XC_LDA_C_ML2 !  Modified LSD (version 2) of Proynov and Salahub
        [EI Proynov and D Salahub, Phys. Rev. B 49, 7874 (1994)
        ]
          </li>
          <li>
           024=&gt; XC_LDA_C_GOMBAS !  Gombas parametrization
        [P. Gombas, Pseudopotentials (Springer-Verlag, New York, 1967)
        ]
          </li>
          <li>
           025=&gt; XC_LDA_C_PW_RPA !  Perdew &amp; Wang fit of the RPA
        [JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992)
        ]
          </li>
          <li>
           027=&gt; XC_LDA_C_RC04 !  Ragot-Cortona
        [S Ragot and P Cortona, J. Chem. Phys. 121, 7671 (2004)
        ]
          </li>
          <li>
           028=&gt; XC_LDA_C_VWN_1 !  Vosko, Wilk, &amp; Nussair (1)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           029=&gt; XC_LDA_C_VWN_2 !  Vosko, Wilk, &amp; Nussair (2)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           030=&gt; XC_LDA_C_VWN_3 !  Vosko, Wilk, &amp; Nussair (3)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           031=&gt; XC_LDA_C_VWN_4 !  Vosko, Wilk, &amp; Nussair (4)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
         </ul>
        </p>
        <p>
         GGA functionals (do not forget to add a minus sign, as discussed above)
        </p>
        <p>
         <ul>
          <li>
           84=&gt; XC_GGA_C_OP_XALPHA !  one-parameter progressive functional (G96 version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           85=&gt; XC_GGA_C_OP_G96 !  one-parameter progressive functional (G96 version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           86=&gt; XC_GGA_C_OP_PBE !  one-parameter progressive functional (PBE version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           87=&gt; XC_GGA_C_OP_B88 !  one-parameter progressive functional (B88 version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           88=&gt; XC_GGA_C_FT97 !  Filatov &amp; Thiel correlation
        [M Filatov &amp; W Thiel, Int. J. Quant. Chem. 62, 603-616 (1997) ; M Filatov &amp; W Thiel, Mol Phys 91, 847 (1997)
        ]  WARNING : this functional is not tested. Use at your own risks.
          </li>
          <li>
           89=&gt; XC_GGA_C_SPBE !  PBE correlation to be used with the SSB exchange
        [M Swart, M Sola, and FM Bickelhaupt, J. Chem. Phys. 131, 094103 (2009)
        ]
          </li>
          <li>
           90=&gt; XC_GGA_X_SSB_SW  !  Swarta, Sola and Bickelhaupt correction to PBE
        [M Swart, M Sola, and FM Bickelhaupt, J. Comp. Meth. Sci. Engin. 9, 69 (2009)
        ]
          </li>
          <li>
           91=&gt; XC_GGA_X_SSB   !  WARNING : This functional gives NaN on IBM (XG20130608).  Swarta, Sola and Bickelhaupt
        [M Swart, M Sola, and FM Bickelhaupt, J. Chem. Phys. 131, 094103 (2009)
        ]
          </li>
          <li>
           92=&gt; XC_GGA_X_SSB_D  !  WARNING : This functional gives NaN on IBM (XG20130608).  Swarta, Sola and Bickelhaupt dispersion
        [M Swart, M Sola, and FM Bickelhaupt, J. Chem. Phys. 131, 094103 (2009)
        ]
          </li>
          <li>
           93=&gt; XC_GGA_XC_HCTH_407P  !   HCTH/407+
        [AD Boese, A Chandra, JML Martin, and Dominik Marx, J. Chem. Phys. 119, 5965 (2003)
        ]
          </li>
          <li>
           94=&gt; XC_GGA_XC_HCTH_P76  !   HCTH p=7/6
        [G Menconi, PJ Wilson, and DJ Tozer, J. Chem. Phys. 114, 3958 (2001)
        ]
          </li>
          <li>
           95=&gt; XC_GGA_XC_HCTH_P14  !   HCTH p=1/4
        [G Menconi, PJ Wilson, and DJ Tozer, J. Chem. Phys. 114, 3958 (2001)
        ]
          </li>
          <li>
           96=&gt; XC_GGA_XC_B97_GGA1  !  Becke 97 GGA-1
        [AJ Cohen and NC Handy, Chem. Phys. Lett. 316, 160-166 (2000)
        ]
          </li>
          <li>
           97=&gt; XC_GGA_XC_HCTH_A  !  HCTH-A
        [FA Hamprecht, AJ Cohen, DJ Tozer, and NC Handy, J. Chem. Phys. 109, 6264 (1998)
        ]
          </li>
          <li>
           98=&gt; XC_GGA_X_BPCCAC  !  BPCCAC (GRAC for the energy)
        [E Bremond, D Pilard, I Ciofini, H Chermette, C Adamo, and P Cortona, Theor Chem Acc 131, 1184 (2012)
        ]
          </li>
          <li>
           99=&gt; XC_GGA_C_REVTCA  !  Tognetti, Cortona, Adamo (revised)
        [V Tognetti, P Cortona, and C Adamo, Chem. Phys. Lett. 460, 536-539 (2008)
        ]
          </li>
          <li>
           100=&gt; XC_GGA_C_TCA  ! Tognetti, Cortona, Adamo
        [V Tognetti, P Cortona, and C Adamo, J. Chem. Phys. 128, 034101 (2008)
        ]
          </li>
          <li>
           101=&gt; XC_GGA_X_PBE !  Perdew, Burke &amp; Ernzerhof exchange
        [JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 77, 3865 (1996) ;
        JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 78, 1396(E) (1997)
        ]
          </li>
          <li>
           102=&gt; XC_GGA_X_PBE_R !  Perdew, Burke &amp; Ernzerhof exchange (revised)
        [Y Zhang and W Yang, Phys. Rev. Lett 80, 890 (1998)
        ]
          </li>
          <li>
           103=&gt; XC_GGA_X_B86 !  Becke 86 Xalfa,beta,gamma
        [AD Becke, J. Chem. Phys 84, 4524 (1986)
        ]
          </li>
          <li>
           104=&gt; XC_GGA_X_HERMAN !  Herman Xalphabeta GGA
        [F Herman, JP Van Dyke, and IB Ortenburger, Phys. Rev. Lett. 22, 807 (1969) ;
        F Herman, IB Ortenburger, and JP Van Dyke, Int. J. Quantum Chem. Symp. 3, 827 (1970)
        ]
          </li>
          <li>
           105=&gt; XC_GGA_X_B86_MGC !  Becke 86 Xalfa,beta,gamma (with mod. grad. correction)
        [AD Becke, J. Chem. Phys 84, 4524 (1986) ;
        AD Becke, J. Chem. Phys 85, 7184 (1986)
        ]
          </li>
          <li>
           106=&gt; XC_GGA_X_B88 !  Becke 88
        [AD Becke, Phys. Rev. A 38, 3098 (1988)
        ]
          </li>
          <li>
           107=&gt; XC_GGA_X_G96 !  Gill 96
        [PMW Gill, Mol. Phys. 89, 433 (1996)
        ]
          </li>
          <li>
           108=&gt; XC_GGA_X_PW86 !  Perdew &amp; Wang 86
        [JP Perdew and Y Wang, Phys. Rev. B 33, 8800 (1986)
        ]
          </li>
          <li>
           109=&gt; XC_GGA_X_PW91 !  Perdew &amp; Wang 91
        [JP Perdew, in Proceedings of the 21st Annual International Symposium on the Electronic Structure of Solids, ed. by P Ziesche and H
        Eschrig (Akademie Verlag, Berlin, 1991), p. 11. ;
        JP Perdew, JA Chevary, SH Vosko, KA Jackson, MR Pederson, DJ Singh, and C Fiolhais, Phys. Rev. B 46, 6671 (1992) ;
        JP Perdew, JA Chevary, SH Vosko, KA Jackson, MR Pederson, DJ Singh, and C Fiolhais, Phys. Rev. B 48, 4978(E) (1993)
        ]
          </li>
          <li>
           110=&gt; XC_GGA_X_OPTX !  Handy &amp; Cohen OPTX 01
        [NC Handy and AJ Cohen, Mol. Phys. 99, 403 (2001)
        ]
          </li>
          <li>
           111=&gt; XC_GGA_X_DK87_R1 !  dePristo &amp; Kress 87 (version R1)
        [AE DePristo and JD Kress, J. Chem. Phys. 86, 1425 (1987)
        ]
          </li>
          <li>
           112=&gt; XC_GGA_X_DK87_R2 !  dePristo &amp; Kress 87 (version R2)
        [AE DePristo and JD Kress, J. Chem. Phys. 86, 1425 (1987)
        ]
          </li>
          <li>
           113=&gt; XC_GGA_X_LG93 !  Lacks &amp; Gordon 93
        [DJ Lacks and RG Gordon, Phys. Rev. A 47, 4681 (1993)
        ]
          </li>
          <li>
           114=&gt; XC_GGA_X_FT97_A !  Filatov &amp; Thiel 97 (version A)
        [M Filatov and W Thiel, Mol. Phys 91, 847 (1997)
        ]
          </li>
          <li>
           115=&gt; XC_GGA_X_FT97_B !  Filatov &amp; Thiel 97 (version B)
        [M Filatov and W Thiel, Mol. Phys 91, 847 (1997)
        ]
          </li>
          <li>
           116=&gt; XC_GGA_X_PBE_SOL !  Perdew, Burke &amp; Ernzerhof exchange (solids)
        [JP Perdew, et al, Phys. Rev. Lett. 100, 136406 (2008)
        ]
          </li>
          <li>
           117=&gt; XC_GGA_X_RPBE !  Hammer, Hansen &amp; Norskov (PBE-like)
        [B Hammer, LB Hansen and JK Norskov, Phys. Rev. B 59, 7413 (1999)
        ]
          </li>
          <li>
           118=&gt; XC_GGA_X_WC !  Wu &amp; Cohen
        [Z Wu and RE Cohen, Phys. Rev. B 73, 235116 (2006)
        ]
          </li>
          <li>
           119=&gt; XC_GGA_X_mPW91 !  Modified form of PW91 by Adamo &amp; Barone
        [C Adamo and V Barone, J. Chem. Phys. 108, 664 (1998)
        ]
          </li>
          <li>
           120=&gt; XC_GGA_X_AM05 !  Armiento &amp; Mattsson 05 exchange
        [R Armiento and AE Mattsson, Phys. Rev. B 72, 085108 (2005) ;
        AE Mattsson, R Armiento, J Paier, G Kresse, JM Wills, and TR Mattsson, J. Chem. Phys. 128, 084714 (2008)
        ]
          </li>
          <li>
           121=&gt; XC_GGA_X_PBEA !  Madsen (PBE-like)
        [G Madsen, Phys. Rev. B 75, 195108 (2007)
        ]
          </li>
          <li>
           122=&gt; XC_GGA_X_MPBE !  Adamo &amp; Barone modification to PBE
        [C Adamo and V Barone, J. Chem. Phys. 116, 5933 (2002)
        ]
          </li>
          <li>
           123=&gt; XC_GGA_X_XPBE !  xPBE reparametrization by Xu &amp; Goddard
        [X Xu and WA Goddard III, J. Chem. Phys. 121, 4068 (2004)
        ]
          </li>
          <li>
           125=&gt; XC_GGA_X_BAYESIAN !  Bayesian best fit for the enhancement factor
        [JJ Mortensen, K Kaasbjerg, SL Frederiksen, JK Norskov, JP Sethna, and KW Jacobsen, Phys. Rev. Lett. 95, 216401 (2005)
        ]
          </li>
          <li>
           126=&gt; XC_GGA_X_PBE_JSJR !  PBE JSJR reparametrization by Pedroza, Silva &amp; Capelle
        [LS Pedroza, AJR da Silva, and K. Capelle, Phys. Rev. B 79, 201106(R) (2009)
        ]
          </li>
          <li>
           130=&gt; XC_GGA_C_PBE !  Perdew, Burke &amp; Ernzerhof correlation
        [JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 77, 3865 (1996) ;
        JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 78, 1396(E) (1997)
        ]
          </li>
          <li>
           131=&gt; XC_GGA_C_LYP !  Lee, Yang &amp; Parr
        [C Lee, W Yang and RG Parr, Phys. Rev. B 37, 785 (1988)
        B Miehlich, A Savin, H Stoll and H Preuss, Chem. Phys. Lett. 157, 200 (1989)
        ]
          </li>
          <li>
           132=&gt; XC_GGA_C_P86 !  Perdew 86
        [JP Perdew, Phys. Rev. B 33, 8822 (1986)
        ]
          </li>
          <li>
           133=&gt; XC_GGA_C_PBE_SOL !  Perdew, Burke &amp; Ernzerhof correlation SOL
        [JP Perdew, et al, Phys. Rev. Lett. 100, 136406 (2008)
        ]
          </li>
          <li>
           134=&gt; XC_GGA_C_PW91 !  Perdew &amp; Wang 91
        [JP Perdew, JA Chevary, SH Vosko, KA Jackson, MR Pederson, DJ Singh, and C Fiolhais, Phys. Rev. B 46, 6671 (1992)
        ]
          </li>
          <li>
           135=&gt; XC_GGA_C_AM05 !  Armiento &amp; Mattsson 05 correlation
        [ R Armiento and AE Mattsson, Phys. Rev. B 72, 085108 (2005) ;
        AE Mattsson, R Armiento, J Paier, G Kresse, JM Wills, and TR Mattsson, J. Chem. Phys. 128, 084714 (2008)
        ]
          </li>
          <li>
           136=&gt; XC_GGA_C_XPBE !  xPBE reparametrization by Xu &amp; Goddard
        [X Xu and WA Goddard III, J. Chem. Phys. 121, 4068 (2004)
        ]
          </li>
          <li>
           137=&gt; XC_GGA_C_LM !  Langreth and Mehl correlation
        [DC Langreth and MJ Mehl, Phys. Rev. Lett. 47, 446 (1981)
        ]
          </li>
          <li>
           138=&gt; XC_GGA_C_PBE_JRGX !  JRGX reparametrization by Pedroza, Silva &amp; Capelle
        [LS Pedroza, AJR da Silva, and K. Capelle, Phys. Rev. B 79, 201106(R) (2009)
        ]
          </li>
          <li>
           139=&gt; XC_GGA_X_OPTB88_VDW !  Becke 88 reoptimized to be used with vdW functional of Dion et al
        [J Klimes, DR Bowler, and A Michaelides, J. Phys.: Condens. Matter 22, 022201 (2010)
        ]
          </li>
          <li>
           140=&gt; XC_GGA_X_PBEK1_VDW !  PBE reparametrization for vdW
        [J Klimes, DR Bowler, and A Michaelides, J. Phys.: Condens. Matter 22, 022201 (2010)
        ]
          </li>
          <li>
           141=&gt; XC_GGA_X_OPTPBE_VDW !  PBE reparametrization for vdW
        [J Klimes, DR Bowler, and A Michaelides, J. Phys.: Condens. Matter 22, 022201 (2010)
        ]
          </li>
          <li>
           142=&gt; XC_GGA_X_RGE2 !  Regularized PBE
        [A Ruzsinszky, GI Csonka, and G Scuseria, J. Chem. Theory Comput. 5, 763 (2009)
        ]
          </li>
          <li>
           143=&gt; XC_GGA_C_RGE2 !  Regularized PBE
        [A Ruzsinszky, GI Csonka, and G Scuseria, J. Chem. Theory Comput. 5, 763 (2009)
        ]
          </li>
          <li>
           144=&gt; XC_GGA_X_RPW86 !  refitted Perdew &amp; Wang 86
        [ED Murray, K Lee and DC Langreth, J. Chem. Theory Comput. 5, 2754-2762 (2009)
        ]
          </li>
          <li>
           145=&gt; XC_GGA_X_KT1 !  Keal and Tozer version 1
        [TW Keal and DJ Tozer, J. Chem. Phys. 119, 3015 (2003)
        ]
          </li>
          <li>
           146=&gt; XC_GGA_XC_KT2 !  WARNING : This functional gives NaN on IBM (XG20130608).  Keal and Tozer version 2
        [TW Keal and DJ Tozer, J. Chem. Phys. 119, 3015 (2003)
        ]
          </li>
          <li>
           147=&gt; XC_GGA_C_WL !  Wilson &amp; Levy
        [LC Wilson and M Levy, Phys. Rev. B 41, 12930 (1990)
        ]
          </li>
          <li>
           148=&gt; XC_GGA_C_WI !  Wilson &amp; Ivanov
        [LC Wilson &amp; S Ivanov, Int. J. Quantum Chem. 69, 523-532 (1998)
        ]
          </li>
          <li>
           149=&gt; XC_GGA_X_MB88 !  Modified Becke 88 for proton transfer
        [V Tognetti and C Adamo, J. Phys. Chem. A 113, 14415-14419 (2009)
        ]
          </li>
          <li>
           150=&gt; XC_GGA_X_SOGGA ! Second-order generalized gradient approximation
        [Y Zhao and DG Truhlar, J. Chem. Phys. 128, 184109 (2008) ; http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <li>
           151=&gt; XC_GGA_X_SOGGA11 !  Second-order generalized gradient approximation 2011
        [R Peverati, Y Zhao, and DG Truhlar, J. Phys. Chem. Lett. 2, 1911-1997 (2011); http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <li>
           152=&gt; XC_GGA_C_SOGGA11 ! Second-order generalized gradient approximation 2011
        [R Peverati, Y Zhao, and DG Truhlar, J. Phys. Chem. Lett. 2, 1911-1997 (2011); http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <li>
           153=&gt; XC_GGA_C_WI0 !  Wilson &amp; Ivanov initial version
        [LC Wilson &amp; S Ivanov, Int. J. Quantum Chem. 69, 523-532 (1998)
        ]
          </li>
          <li>
           154=&gt; XC_GGA_XC_TH1 !  Tozer and Handy v. 1
        [DJ Tozer and NC Handy, J. Chem. Phys. 108, 2545 (1998)
        ]  WARNING : this functional is not tested. Use at your own risks.
          </li>
          <li>
           155=&gt; XC_GGA_XC_TH2 ! Tozer and Handy v. 2
        [DJ Tozer and NC Handy, J. Phys. Chem. A 102, 3162 (1998)
        ]
          </li>
          <li>
           156=&gt; XC_GGA_XC_TH3 !  Tozer and Handy v. 3
        [DJ Tozer and NC Handy, Mol. Phys. 94, 707 (1998)
        ]
          </li>
          <li>
           157=&gt; XC_GGA_XC_TH4 !  Tozer and Handy v. 4
        [DJ Tozer and NC Handy, Mol. Phys. 94, 707 (1998)
        ]
          </li>
          <li>
           158=&gt; XC_GGA_X_C09X !  C09x to be used with the VdW of Rutgers-Chalmers
        [VR Cooper, PRB 81, 161104(R) (2010)
        ]
          </li>
          <li>
           159=&gt; XC_GGA_C_SOGGA11_X !  To be used with hyb_gga_x_SOGGA11-X
        [R Peverati and DG Truhlar, J. Chem. Phys. 135, 191102 (2011); http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <!-- The following functional is untested in ABINIT
        &lt;li&gt;160=&gt; XC_GGA_XC_LB !  van Leeuwen &amp; Baerends
        [R van Leeuwen and EJ Baerends, Phys. Rev. A. 49, 2421 (1994)
        ]&lt;/li&gt;
        -->
          <li>
           161=&gt; XC_GGA_XC_HCTH_93 !  HCTH functional fitted to  93 molecules
        [FA Hamprecht, AJ Cohen, DJ Tozer, and NC Handy, J. Chem. Phys. 109, 6264 (1998)
        ]
          </li>
          <li>
           162=&gt; XC_GGA_XC_HCTH_120 !  HCTH functional fitted to 120 molecules
        [AD Boese, NL Doltsinis, NC Handy, and M Sprik, J. Chem. Phys. 112, 1670 (2000)
        ]
          </li>
          <li>
           163=&gt; XC_GGA_XC_HCTH_147 !  HCTH functional fitted to 147 molecules
        [AD Boese, NL Doltsinis, NC Handy, and M Sprik, J. Chem. Phys. 112, 1670 (2000)
        ]
          </li>
          <li>
           164=&gt; XC_GGA_XC_HCTH_407 !  HCTH functional fitted to 407 molecules
        [AD Boese, and NC Handy, J. Chem. Phys. 114, 5497 (2001)
        ]
          </li>
          <li>
           165=&gt; XC_GGA_XC_EDF1 !  Empirical functionals from Adamson, Gill, and Pople
        [RD Adamson, PMW Gill, and JA Pople, Chem. Phys. Lett. 284 6 (1998)
        ]
          </li>
          <li>
           166=&gt; XC_GGA_XC_XLYP !  XLYP functional
        [X Xu and WA Goddard, III, PNAS 101, 2673 (2004)
        ]
          </li>
          <li>
           167=&gt; XC_GGA_XC_B97 !  Becke 97
        [AD Becke, J. Chem. Phys. 107, 8554-8560 (1997)
        ]
          </li>
          <li>
           168=&gt; XC_GGA_XC_B97_1 !  Becke 97-1
        [FA Hamprecht, AJ Cohen, DJ Tozer, and NC Handy, J. Chem. Phys. 109, 6264 (1998);
        AD Becke, J. Chem. Phys. 107, 8554-8560 (1997)
        ]
          </li>
          <li>
           169=&gt; XC_GGA_XC_B97_2 !  Becke 97-2
        [AD Becke, J. Chem. Phys. 107, 8554-8560 (1997)
        ]
          </li>
          <li>
           170=&gt; XC_GGA_XC_B97_D !  Grimme functional to be used with C6 vdW term
        [S Grimme, J. Comput. Chem. 27, 1787 (2006)
        ]
          </li>
          <li>
           171=&gt; XC_GGA_XC_B97_K !  Boese-Martin for Kinetics
        [AD Boese and JML Martin, J. Chem. Phys., Vol. 121, 3405 (2004)
        ]
          </li>
          <li>
           172=&gt; XC_GGA_XC_B97_3 !  Becke 97-3
        [TW Keal and DJ Tozer, J. Chem. Phys. 123, 121103 (2005)
        ]
          </li>
          <li>
           173=&gt; XC_GGA_XC_PBE1W !  Functionals fitted for water
        [EE Dahlke and DG Truhlar, J. Phys. Chem. B 109, 15677 (2005)
        ]
          </li>
          <li>
           174=&gt; XC_GGA_XC_MPWLYP1W !  Functionals fitted for water
        [EE Dahlke and DG Truhlar, J. Phys. Chem. B 109, 15677 (2005)
        ]
          </li>
          <li>
           175=&gt; XC_GGA_XC_PBELYP1W !  Functionals fitted for water
        [EE Dahlke and DG Truhlar, J. Phys. Chem. B 109, 15677 (2005)
        ]
          </li>
          <li>
           176=&gt; XC_GGA_XC_SB98_1a !  Schmider-Becke 98 parameterization 1a
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           177=&gt; XC_GGA_XC_SB98_1b !  Schmider-Becke 98 parameterization 1b
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           178=&gt; XC_GGA_XC_SB98_1c !  Schmider-Becke 98 parameterization 1c
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           179=&gt; XC_GGA_XC_SB98_2a !  Schmider-Becke 98 parameterization 2a
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           180=&gt; XC_GGA_XC_SB98_2b !  Schmider-Becke 98 parameterization 2b
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           181=&gt; XC_GGA_XC_SB98_2c !  Schmider-Becke 98 parameterization 2c
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           183=&gt; XC_GGA_X_OL2 !  Exchange form based on Ou-Yang and Levy v.2
        [P Fuentealba and O Reyes, Chem. Phys. Lett. 232, 31-34 (1995) ; H Ou-Yang, M Levy, Int. J. of Quant. Chem. 40, 379-388 (1991)
        ]
          </li>
          <li>
           184=&gt; XC_GGA_X_APBE !  mu fixed from the semiclassical neutral atom
        [LA Constantin, E Fabiano, S Laricchia, and F Della Sala, Phys. Rev. Lett. 106, 186406 (2011)
        ]
          </li>
          <li>
           186=&gt; XC_GGA_C_APBE !  mu fixed from the semiclassical neutral atom
        [LA Constantin, E Fabiano, S Laricchia, and F Della Sala, Phys. Rev. Lett. 106, 186406 (2011)
        ]
          </li>
          <li>
           191=&gt; XC_GGA_X_HTBS!  Haas, Tran, Blaha, and Schwarz
        [P Haas, F Tran, P Blaha, and K Schwarz, Phys. Rev. B 83, 205117 (2011)
        ]
          </li>
          <li>
           192=&gt; XC_GGA_X_AIRY !  Constantin et al based on the Airy gas
        [LA Constantin, A Ruzsinszky, and JP Perdew, Phys. Rev. B 80, 035125 (2009)
        ]
          </li>
          <li>
           193=&gt; XC_GGA_X_LAG !  Local Airy Gas
        [L Vitos, B Johansson, J Kollar, and HL Skriver, Phys. Rev. B 62, 10046-10050 (2000)
        ]
          </li>
          <li>
           194=&gt; XC_GGA_XC_MOHLYP  ! Functional for organometallic chemistry
        [NE Schultz, Y Zhao, DGJ Truhlar, Phys. Chem. A, 109, 11127 (2005)
        ]
          </li>
          <li>
           195=&gt; XC_GGA_XC_MOHLYP2 !  Functional for barrier heights
        [J Zheng, Y Zhao, DGJ Truhlar, Chem. Theory. Comput. 5, 808 (2009)
        ]
          </li>
          <li>
           196=&gt; XC_GGA_XC_TH_FL !  Tozer and Handy v. FL
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           197=&gt; XC_GGA_XC_TH_FC !  Tozer and Handy v. FC
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           198=&gt; XC_GGA_XC_TH_FCFO  !  Tozer and Handy v. FCFO
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           199=&gt; XC_GGA_XC_TH_FCO  !  Tozer and Handy v. FCO
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           200=&gt; XC_GGA_C_OPTC  !  Optimized correlation functional of Cohen and Handy
        [AJ Cohen and NC Handy, Mol. Phys. 99, 607-615 (2001)
        ]
          </li>
          <li>
           524=&gt; XC_GGA_X_WPBEH  !  short-range version of the PBE
        [J Heyd, GE Scuseria, and M Ernzerhof, J. Chem. Phys. 118, 8207 (2003)
        ]
          </li>
          <li>
           525=&gt; XC_GGA_X_HJS_PBE  !  HJS screened exchange PBE version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]
          </li>
          <li>
           526=&gt; XC_GGA_X_HJS_PBE_SOL !  HJS screened exchange PBE_SOL version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]
          </li>
          <li>
           527=&gt; XC_GGA_X_HJS_B88 ! HJS screened exchange B88 version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]   WARNING : this functional is not tested. Use at your own risks.
          </li>
          <li>
           528=&gt; XC_GGA_X_HJS_B97X  !  HJS screened exchange B97x version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]
          </li>
          <li>
           529=&gt; XC_GGA_X_ITYH  ! short-range recipe for exchange GGA functionals
        [H Iikura, T Tsuneda, T Yanai, and K Hirao, J. Chem. Phys. 115, 3540 (2001)
        ]  WARNING : this functional is not tested. Use at your own risks.
          </li>
         </ul>
        </p>
        <p>
         MetaGGA functionals (do not forget to add a minus sign, as discussed above). See Sun et al, PRB 84, 035117 (2011) for the formulas.
        </p>
        <p>
         <ul>
          <li>
           202=&gt; XC_MGGA_X_TPSS !  Tao, Perdew, Staroverov &amp; Scuseria
        [J Tao, JP Perdew, VN Staroverov, and G Scuseria, Phys. Rev. Lett. 91, 146401 (2003) ;
        JP Perdew, J Tao, VN Staroverov, and G Scuseria, J. Chem. Phys. 120, 6898 (2004)
        ]
          </li>
          <li>
           203=&gt; XC_MGGA_X_M06L !  Zhao, Truhlar exchange
        [Y Zhao and DG Truhlar, JCP 125, 194101 (2006);
        Y Zhao and DG Truhlar, Theor. Chem. Account 120, 215 (2008)
        ]
          </li>
          <li>
           204=&gt; XC_MGGA_X_GVT4 !  GVT4 (X part of VSXC) from van Voorhis and Scuseria
        [T Van Voorhis and GE Scuseria, JCP 109, 400 (1998)
        ]
          </li>
          <li>
           205=&gt; XC_MGGA_X_TAU_HCTH ! tau-HCTH from Boese and Handy
        [AD Boese and NC Handy, JCP 116, 9559 (2002)
        ]
          </li>
          <li>
           207=&gt; XC_MGGA_X_BJ06 !  Becke &amp; Johnson correction to Becke-Roussel 89
        [AD Becke and ER Johnson, J. Chem. Phys. 124, 221101 (2006)
        ] WARNING : this Vxc-only mGGA can only be used with a LDA correlation, typically Perdew-Wang 92.
          </li>
          <li>
           208=&gt; XC_MGGA_X_TB09 !  Tran-blaha - correction to Becke &amp; Johnson correction to Becke-Roussel 89
        [F Tran and P Blaha, Phys. Rev. Lett. 102, 226401 (2009)
        ] WARNING : this Vxc-only mGGA can only be used with a LDA correlation, typically Perdew-Wang 92.
          </li>
          <li>
           209=&gt; XC_MGGA_X_RPP09 !  Rasanen, Pittalis, and Proetto correction to Becke &amp; Johnson
        [E Rasanen, S Pittalis &amp; C Proetto, arXiv:0909.1477 (2009)
        ] WARNING : this Vxc-only mGGA can only be used with a LDA correlation, typically Perdew-Wang 92.
          </li>
          <li>
           232=&gt; XC_MGGA_C_VSXC !  VSxc from Van Voorhis and Scuseria (correlation part)
        [T Van Voorhis and GE Scuseria, JCP 109, 400 (1998)
        ]
          </li>
         </ul>
        </p>
        <p>
         Hybrid functionals (do not forget to add a minus sign, as discussed above).
        </p>
        <p>
         <ul>
          <li>
           402=&gt; XC_HYB_GGA_XC_B3LYP !  The (in)famous B3LYP
        [PJ Stephens, FJ Devlin, CF Chabalowski, MJ Frisch, J. Phys. Chem. 98 11623 (1994)
        ]
          </li>
          <li>
           406=&gt; XC_HYB_GGA_XC_PBEH !  PBEH (PBE0)
        [C Adamo and V Barone, J. Chem. Phys. 110, 6158 (1999);
         M. Ernzerhof, G. E. Scuseria, J. Chem. Phys. 110, 5029 (1999)
        ]
          </li>
          <li>
           427=&gt; XC_HYB_GGA_XC_HSE03 !  The 2003 version of the screened hybrid HSE (in this case one should use omega^HF = 0.15/sqrt(2) and omega^PBE = 0.15*(2.0)**1/3)
           <br>
           428=&gt; XC_HYB_GGA_XC_HSE06 !  The 2006 version of the screened hybrid HSE (in this case one should use omega^HF = omega^PBE = 0.11)
           <br>
           (The following section is taken from the LibXC sources. In ABINIT, we stick to the LibXC choice.)
           Note that there is an enormous mess in the literature concerning the values of omega in HSE. This is due to an error in the original paper that stated that they had used omega=0.15. This was in fact not true, and the real value used was omega^HF = 0.15/sqrt(2) ~ 0.1061 and omega^PBE = 0.15*(2.0)**1/3 ~ 0.1890. In 2006 Krukau et al [JCP 125, 224106 (2006)] tried to clarify the situation, and called HSE03 to the above choice of parameters, and called HSE06 to the functional where omega^HF=omega^PBE. By testing several properties for atoms they reached the conclusion that the best value for omega=0.11.  Of course, codes are just as messy as the papers. In espresso HSE06 has the value omega=0.106. VASP, on the other hand, uses for HSE03 the same value omega^HF = omega^PBE = 0.3 (A^-1) ~ 0.1587 and for HSE06 omega^HF = omega^PBE = 0.2 (A^-1) ~ 0.1058.  [J Heyd, GE Scuseria, and M Ernzerhof, J. Chem. Phys. 118, 8207 (2003); J Heyd, GE Scuseria, and M Ernzerhof, J. Chem. Phys. 124, 219906 (2006); AV Krukau, OA Vydrov, AF Izmaylov, and GE Scuseria, J. Chem. Phys. 125, 224106 (2006)
        ]
          </li>
          <li>
           456=&gt; XC_HYB_GGA_XC_PBE0_13 !  PBE0-1/3
        [P Cortona, J. Chem. Phys. 136, 086101 (2012)
        ]
          </li>
         </ul>
        </p>
    topics: xc_basic, Hybrids_compulsory, TDDFT_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: ixcpositron
    characteristics: null
    commentdefault: (Teter parameterization). However, if all the pseudopotentials have the same value of pspxc, the initial value of ixc will be that common value
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Integer for the eXchange-Correlation applied to the electron-POSITRON interaction
    requires: null
    text: |-
        <p>
         Relevant only when [[positron]]/=0.
         <br />
         Define the type of electron-positron correlation that is used in case
        of a electron-positron two-component DFT calculation.
         <br />
         Define also the analytical formula of the enhancement factor used to compute the electron-positron annhilation rate:
         <br />
         <br />
         Electron-positron correlation functional:
         <br />
         <ul>
          <b>
           ixcpositron=1
          </b>
          :
        LDA zero positron density limit parametrized by Arponen &amp; Pajanne and provided by Boronski &amp; Nieminen [1,2]
          <br />
          <b>
           ixcpositron=11
          </b>
          :
        LDA zero positron density limit parametrized by Arponen &amp; Pajanne and fitted by Sterne &amp; Kaiser [1,3]
          <br />
          <b>
           ixcpositron=2
          </b>
          :
        LDA electron-positron correlation provided by Puska, Seitsonen, and Nieminen [1,4]
          <br />
          <b>
           ixcpositron=3
          </b>
          :
        GGA zero positron density limit parametrized by Arponen &amp; Pajanne and provided by Boronski &amp; Nieminen [1,2,5]
          <br />
          <b>
           ixcpositron=31
          </b>
          :
        GGA zero positron density limit parametrized by Arponen &amp; Pajanne and fitted by Sterne &amp; Kaiser [1,3,5]
         </ul>
         Annihilation rate enhancement factor:
         <br />
         <ul>
          <b>
           ixcpositron=1
          </b>
          :
        Boronski and Nieminen full modelisation and RPA limit [1]
          <br />
          <b>
           ixcpositron=11
          </b>
          :
        Sterne and Kaiser [2]
          <br />
          <b>
           ixcpositron=2
          </b>
          :
        Puska, Seitsonen and Nieminen [3]
          <br />
          <b>
           ixcpositron=3
          </b>
          :
        Boronski and Nieminen full modelisation and RPA limit [1], with GGA corrections
          <br />
          <b>
           ixcpositron=31
          </b>
          :
        Sterne and Kaiser [2], with GGA corrections
          <br />
         </ul>
         References:
         <ul>
          <b>
           [1]
          </b>
          J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).
          <br />
          <b>
           [2]
          </b>
          Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).
          <br />
          <b>
           [3]
          </b>
          P.A. Sterne and J.H. Kaiser, Phys. Rev. B 43, 13892 (1991).
          <br />
          <b>
           [4]
          </b>
          M.J. Puska, A.P. Seitsonen and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).
          <br />
          <b>
           [5]
          </b>
          B. Barbiellini, M.J. Puska, T. Torsti and R.M.Nieminen, Phys. Rev. B 51, 7341 (1994)
          <br />
         </ul>
        </p>
    topics: positron_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: jdtset
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: !range
        start: 1
        stop: '[[ndtset]]'
    dimensions:
    - '[[ndtset]]'
    excludes: null
    mnemonics: index -J- for DaTaSETs
    requires: null
    text: |-
        <p>
         Gives the dataset index
        of each of the datasets. This index will be used :
         <ul>
          <li>
           to determine which input variables are specific to each
        dataset, since the variable names for this
        dataset will be made from the bare variable
        name concatenated with this index, and only if
        such a composite variable name does not exist,
        the code will consider the bare variable name,
        or even, the Default;
          </li>
          <li>
           to characterize output variable names, if their
        content differs from dataset to dataset;
          </li>
          <li>
           to characterize output files ( root names appended with _DSx
        where 'x' is the dataset index ).
          </li>
         </ul>
         The allowed index values are between 1 and 9999.
         <br />
         An input variable name appended with 0 is not allowed.
         <br />
         When [[ndtset]]==0, this array is not used, and moreover,
        no input variable name appended with a digit is allowed.
        This array might be initialized thanks to the use of
        the input variable [[udtset]]. In this case, [[jdtset]] cannot
        be used.
        </p>
    topics: multidtset_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: jellslab
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: include a JELLium SLAB in the cell
    requires: null
    text: |-
        <p>
         If set to 1, a slab of uniform positive background charge density,
        that is, a jellium slab, is included in the calculation cell.
        A portion of the unit cell is filled with such positive charge density distribution
        which is equal to a bulk-mean value n
         <sub>
          bulk
         </sub>
         between two edges
        and zero in the vacuum region if present.
         <br />
         For the sake of convenience the unit cell is supposed
        to have the third crystal primitive lattice vector orthogonal
        to the other ones so that the portion of the cell filled by the jellium slab can be defined through its edges along z.
         <br />
         The bulk-mean positive charge density is fixed by the input variable [[slabwsrad]],
        while the position of the slab edges along z is defined through
        the input variables [[slabzbeg]] and [[slabzend]].
        </p>
    topics: Artificial_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: jfielddir
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: electric/displacement FIELD DIRection
    requires: '[[berryopt]] = 17'
    text: |-
        <p>
         When specifying mixed electric field boundary conditions ( [[berryopt]]=17),
        jfielddir controls whether reduced electric field ([[jfielddir]]=1)
        or reduced electric displacement field ([[jfielddir]]=2) is chosen to be fixed,
        in each of the three lattice directions (i.e., in the reduced, not the Cartesian, frame).
        For example, [[jfielddir]]=(1 1 2) tells the code to use fixed ebar_1 and ebar_2
        along the first two lattice directions and fixed d_3 along the third.
         <br />
         For the case of mixed electric field boundary conditions,
        [[red_efieldbar]] and [[red_dfield]]
        are used to control ebar and d, respectively.
        For example, for electric boundary conditions corresponding to a material
        in a parallel-plate capacitor, if you want to control d_3=d0,
        while fixing ebar_1=ebar_2=0, then the input files should have
        [[berryopt]]=17, [[jfielddir]]=(1 1 2), [[red_efieldbar]]=(0.0 0.0 a),
        and [[red_dfield]]=(b c d0).
        Here a, b, and c are the starting values.
        They can be chosen in this way: do a single run for fixed d calculation ([[red_dfield]]=0,0,d0),
        from the final results you will have ebar_3, which is a good guess for a.
        Then do another single run for fixed ebar calculation ([[red_efieldbar]]=(0 0 0)),
        from the final results you will have d_1,d_2, these are good guesses for b, c.
        </p>
    topics: Berry_basic
    varset: ffield
    vartype: integer
- !variable
    abivarname: jpawu
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: value of J for PAW+U
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    text: |-
        <p>
         Gives the value of the screened exchange interaction between correlated
        electrons corresponding to [[lpawu]]
        for each species.
         <br />
         In the case where [[lpawu]] =-1,
        the value is not used.
        </p>
    topics: DFT+U_compulsory
    varset: paw
    vartype: real
- !variable
    abivarname: kberry
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - 3
    - '[[nberry]]'
    excludes: null
    mnemonics: K wavevectors for BERRY phase computation
    requires: '[[berryopt]] = 1, 2, or 3'
    text: |-
        <p>
         Used for values of [[berryopt]] = 1, 2, or 3.
        </p>
        <p>
         This array defines, for each Berry phase calculation
        (the number of such calculations is defined by
        [[nberry]]), the
        difference of wavevector between k points for which
        the overlap matrix must be computed.
        The polarisation vector will be projected
        on the direction of that wavevector,
        and the result of the computation will be the magnitude of this
        projection.
        Doing more than one wavevector, with different independent
        direction, allows to find the full polarisation vector.
        However, note that converged results need oriented grids,
        denser along the difference wavevector than usual Monkhorst-Pack
        grids.
        </p>
        <p>
         The difference of wavevector is computed in the coordinate
        system defined by the k-points grid
        (see [[ngkpt]]
        and [[kptrlatt]]), so that
        the values of [[kberry]] are integers.
        Of course, such a k point grid must exist, and all the
        corresponding wavefunctions must be available, so that the
        computation is allowed only when [[kptopt]]
        is equal to 3. In order to save computing time, it is suggested
        to make a preliminary calculation of the wavefunctions on the
        irreducible part of the grid, with [[kptopt]]
        equal to 1, and then use these converged wavefunctions
        in the entire Brillouin zone, by reading them to initialize
        the [[kptopt]]=3 computation.
        </p>
    topics: Berry_basic
    varset: ffield
    vartype: integer
- !variable
    abivarname: kpt
    characteristics: null
    commentdefault: Adequate for one molecule in a supercell
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    - '[[nkpt]]'
    excludes: null
    mnemonics: K - PoinTs
    requires: null
    text: |-
        <p>
         Contains the k points in terms
        of reciprocal space primitive translations (NOT in
        cartesian coordinates!).
         <br />
         Needed ONLY
        if [[kptopt]]=0, otherwise
        deduced from other input variables.
        </p>
        <p>
         It contains dimensionless numbers in terms of which
        the cartesian coordinates would be:
         <br />
         <tele>
          k_cartesian = k1*G1+k2*G2+k3*G3
         </tele>
         <br />
         where
         <tele>
          (k1,k2,k3)
         </tele>
         represent the dimensionless "reduced
        coordinates" and
         <tele>
          G1, G2, G3
         </tele>
         are the cartesian coordinates
        of the primitive translation vectors.  G1,G2,G3 are related
        to the choice of direct space primitive translation vectors
        made in [[rprim]].
        Note that an overall norm for the k
        points is supplied by [[kptnrm]].  This allows
        one to avoid supplying many digits for the k points to
        represent such points as (1,1,1)/3.
         <br />
         Note: one of the algorithms used to set up the sphere
        of G vectors for the basis needs components of k-points
        in the range [-1,1], so the
        remapping is easily done by adding or subtracting 1 from
        each component until it is in the range [-1,1].  That is,
        given the k point normalization [[kptnrm]] described below,
        each component must lie in [ -[[kptnrm]], [[kptnrm]] ].
         <br />
         Note: a global shift can be provided by [[qptn]]
         <br />
         Not read if [[kptopt]]/=0 .
        </p>
    topics: k-points_useful
    varset: basic
    vartype: real
- !variable
    abivarname: kptbounds
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    - abs([[kptopt]])+1)
    excludes: null
    mnemonics: K PoinT BOUNDarieS
    requires: null
    text: |-
        <p>
         It is used to generate the circuit to be followed by the band structure,
        when [[kptopt]] is negative (it is
        not read if [[kptopt]] is zero or positive).
        </p>
        <p>
         There are abs([[kptopt]])
        segments to be defined, each of which starting from
        the end point of the preceeding one. Thus,
        the number of points to be input is
        abs([[kptopt]])+1.
        They form a circuit starting
        at [[kptbounds]](1:3,1)/[[kptnrm]]
        and ending at
        [[kptbounds]](1:3,abs([[kptopt]])+1)/[[kptnrm]].
        The number of divisions of each segment can be defined either using the array [[ndivk]]
        or the variable [[ndivsm]] that just defines the number of divisions for the smallest segment
        </p>
        <p>
         As for [[kpt]], [[kptbounds]] is specified
        using the primitive vectors in reciprocal space. If your Bravais lattice is simple,
        then it should be quite easy to find the coordinates of the end points.
        On the other hand, for centered, body-centered, face-centered, hexagonal, and rhombohedral
        Bravais lattice,
        the conversion might be more difficult. See the description of [[kpt]]
        for an explanation of how to convert data from the "conventional" cartesian coordinates to
        the primitive vectors in the reciprocal space. In order to help a bit, we list below a series
        of typical values, for the FCC, BCC, hexagonal and rhombohedral Bravais lattices. Note : all the data below
        are given in dimensionless units ; they have to be rescaled by the actual lengths defined by the
        [[acell]] values. However, [[kptbounds]] values can be used as such,
        if the values of [[rprim]] given below are adopted.
        </p>
        <p>
         A.
         <b>
          FCC lattice
         </b>
        </p>
        <p>
         Suppose the primitive vectors in real space are given by
         <br />
         <pre>
          rprim   0 1 1    1 0 1    1 1 0
         </pre>
         or
         <pre>
          rprim   0 1/2 1/2    1/2 0 1/2    1/2 1/2 0
         </pre>
         (these two possibilities only differ by a scaling factor, irrelevant for the definition
        of the k points in the primitive vectors in reciprocal space).

        Then, the reciprocal primitive vectors (in conventional cartesian coordinates) are
         <pre>
          (-1/2 1/2 1/2), (1/2 -1/2 1/2), (1/2 1/2 -1/2)
         </pre>
         or
         <pre>
          (-1 1 1), (1 -1 1), (1 1 -1)
         </pre>
         and, in both cases, the coordinates of several special points with respect to primitive vectors in reciprocal space are
         <pre>
          X (0   1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
          X'(1/2 1/2 1  )   (conventional cartesian coordinate 1/2 1/2 0)  (an other instance of X, in another Brillouin zone)
          L (1/2 1/2 1/2)   (conventional cartesian coordinate  1/4 1/4 1/4)
          L'(1/2 0   0  )   (conventional cartesian coordinate -1/4 1/4 1/4) (an other instance of L, on another face of the BZ)
          W (1/4 1/2 3/4)   (conventional cartesian coordinate 1/2 1/4 0)
          U (1/4 5/8 5/8)   (conventional cartesian coordinate 1/2 1/8 1/8)
          K (3/8 3/8 3/4)   (conventional cartesian coordinate 3/8 3/8 0)
         </pre>
         Note that K is actually equivalent to U, by spatial and translational symmetry.
        So, if you want to specify a typical circuit, the following might do the work :
        L-Gamma-X-W-K,U-L-W-X-K,U-Gamma with
         <br />
         <pre>
          kptbounds  1/2 0 0  0 0 0  0 1/2 1/2  1/4 1/2 3/4  3/8 3/8 3/4  1/2 1/2 1/2  1/4 1/2 3/4  1/2 1/2 1  3/8 3/8 3/4  0 0 0
         </pre>
        </p>
        <p>
         The lengths of segments (this information is useful to draw the band structure, with the correct relative
        scale between special points)
        can be found using
        the conventional cartesian coordinates :
        l(L-Gamma)=sqrt(3)/4=0.433... ;
        l(Gamma-X)=1/2=0.5 ;
        l(X-W)=1/4=0.25 ;
        l(W-K)=sqrt(2)/8=0.177... ;
        l(K-L)=sqrt(6)/8=0.306... ;
        l(L-W)=sqrt(2)/4=0.354... ;
        l(W-X)=1/4=0.25 ;
        l(X-K)=sqrt(2)/8=0.177... ;
        l(K-Gamma)=sqrt(2).3/8=0.530...
        </p>
        <p>
        </p>
        <p>
         B.
         <b>
          BCC lattice
         </b>
        </p>
        <p>
         Suppose the primitive vectors in real space are given by
         <br />
         <pre>
          rprim  -1 1 1    1 -1 1    1 1 -1
         </pre>
         (as for the FCC lattice, there is a scale invariance).
        Then, the reciprocal primitive vectors (in conventional cartesian coordinates) are
        (0 1/2 1/2), (1/2 0 1/2), and (1/2 1/2 0)
        and the coordinates of several special points with respect to primitive vectors in reciprocal space are
         <pre>
          H (-1/2 1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
          N ( 0   0   1/2)   (conventional cartesian coordinate 1/4 1/4 0)
          P ( 1/4 1/4 1/4)   (conventional cartesian coordinate 1/4 1/4 1/4)
         </pre>
         So, if you want to specify a typical circuit, the following might do the work :
        Gamma-H-N-Gamma-P-N-P-H
         <br />
         <pre>
          kptbounds  0 0 0  -1/2 1/2 1/2  0 0 1/2  0 0 0   1/4 1/4 1/4  0 0 1/2  1/4 1/4 1/4  -1/2 1/2 1/2
         </pre>
        </p>
        <p>
         The lengths of segments (this information is useful to draw the band structure, with the correct relative scale between special points)
        can be found using the conventional cartesian coordinates :
        l(Gamma-H)=1/2=0.5 ;
        l(H-N)=sqrt(2)/4=0.354... ;
        l(N-Gamma)=sqrt(2)/4=0.354... ;
        l(Gamma-P)=sqrt(3)/4=0.433... ;
        l(P-N)=1/4=0.25 ;
        l(N-P)=1/4=0.25 ;
        l(P-H)=sqrt(3)/4=0.433...
        </p>
        <p>
        </p>
        <p>
         C.
         <b>
          Hexagonal lattices
         </b>
        </p>
        <p>
         Suppose the primitive vectors in real space are given by
         <br />
         <pre>
          rprim  1 0 0    -1/2 sqrt(0.75) 0    0 0 1
         </pre>
         The coordinates of several special points with respect to primitive vectors in reciprocal space are
         <pre>
          M (1/2 0 0) or (0 1/2 0) or (-1/2 1/2 0)
          L (1/2 0 1/2) or (0 1/2 1/2) or (-1/2 1/2 1/2)
          K (1/3 1/3 0) or (2/3 -1/3 0) or (-1/3 2/3 0)
          H (1/3 1/3 1/2) or (2/3 -1/3 1/2) or (-1/3 2/3 1/2)
          A (0 0 1/2)
         </pre>
         So, if you want to specify a typical circuit, the following might do the work :
        K-Gamma-M-K-H-A-L-H-L-M-Gamma-A
         <br />
         <pre>
          kptbounds  1/3 1/3 0  0 0 0  1/2 0 0  1/3 1/3 0  1/3 1/3 1/2  0 0 1/2  1/2 0 1/2  1/3 1/3 1/2  1/2 0 1/2  1/2 0 0  0 0 0  0 0 1/2
         </pre>
        </p>
        <p>
         In order to find the lengths of segments
        (this information is useful to draw the band structure,
        with the correct relative scale between special points)
        one needs to know the a and c lattice parameters. Also, in what follows, we omit the 2*pi factor sometimes
        present in the definition of the reciprocal space vectors.
        The reciprocal vectors are (1/a 1/(sqrt(3)*a) 0) , (0 2/(sqrt(3)*a) 0), (0 0 1/c). The lengths of
        the above-mentioned segments can be computed as :
        l(K-Gamma)=2/(3*a)=0.666.../a ;
        l(Gamma-M)=1/(sqrt(3)*a)=0.577.../a ;
        l(M-K)=1/(3*a)=0.333.../a ;
        l(K-H)=1/(2*c)=0.5.../c ;
        l(H-A)=2/(3*a)=0.666.../a ;
        l(A-L)=1/(sqrt(3)*a)=0.577.../a ;
        l(L-H)=1/(3*a)=0.333.../a ;
        l(H-L)=1/(3*a)=0.333.../a ;
        l(L-M)=1/(2*c)=0.5.../c ;
        l(M-Gamma)=-1/(sqrt(3)*a)=0.577.../a ;
        l(Gamma-A)=1/(2*c)=0.5.../c
        </p>
        <p>
        </p>
        <p>
         D.
         <b>
          Rhombohedral lattices
         </b>
        </p>
        <p>
         Rhombohedral lattices are characterised by two parameters, the length of the primitive
        vectors, that we will denote a0, and the angle they form, alpha.
        These can be directly input of ABINIT, as
        [[acell]] and [[angdeg]]
        </p>
        <p>
         This will generate the primitive vectors in real space , with
         <pre>
          [[acell]] a0 a0 a0    and      [[rprim]]  a 0 c    -a/2 a*sqrt(0.75) c    -a/2 -a*sqrt(0.75) c
         </pre>
         with a^2+c^2=1, a^2=(1-cos(alpha))*2/3, c^2=(1+2*cos(alpha))*1/3, (a/c)^2=2*(1-cos(alpha))/(1+2*cos(alpha))
        and also cos(alpha)=(1-(a/c)^2/2)/(1+(a/c)^2).
        Alternatively, these values of rprim might directly be the input of ABINIT (then, the balance
        of the scaling factor might be adjusted between
        [[acell]] and [[rprim]]).
        </p>
        <p>
         Unlike for the simple cubic, FCC, BCC, hexagonal (and some other) Bravais lattice,
        the topology of the Brillouin zone will depend on the alpha (or a/c) value. We give below
        information concerning the case when cos(alpha) is positive, that is, (a/c)^2 lower than 2.
        </p>
        <p>
         The coordinates of several special points with respect to primitive vectors in reciprocal space will
        not depend on the a/c ratio, but some others will depend on it. So, some care has to be exercised.
        Notations for the Brillouin Zone special points are the same as in Phys. Rev. B 41, 11827 (1990).
         <pre>
          L (1/2 0 0) or (0 1/2 0) or (0 0 1/2) (or with negative signs)
          T (1/2 1/2 1/2)
          X (1/2 1/2 0) or (1/2 0 1/2) or (0 1/2 1/2) (or with separate negative signs)
          W (5/6 - (a/c)^2/6 , 1/2 , 1/6 + (a/c)^2/6 ) = (1 0 -1)*(1-(a/c)^2/2)/3 + (1 1 1)/2
          U ( (1+(a/c)^2)/6 , (8-(a/c)^2)/12 , (8-(a/c)^2)/12 ) = (-1 1/2 1/2)*(1-(a/c)^2/2)/3 + (1 1 1)/2
          K (1 0 -1)*(1+(a/c)^2/4)/3
         </pre>
         So, if you want to specify a typical circuit, the following might do the work (the representative points on lines of symmetry are indicated - there are sometimes more than one way to go from one point to another) :
        X-V-K-Sigma-Gamma-Lambda-T-Q-W-Y-L-sigma-Gamma-sigma-X . The suggestion is to sample this path
        with the following coordinates
        for the special points X, Gamma, T, L, Gamma, X :
         <br />
         <pre>
          kptbounds  1/2 0 -1/2   0 0 0    1/2 1/2 1/2  1 1/2 0   1 0 0  1 1/2 1/2
         </pre>
        </p>
        <p>
         In order to find the lengths of segments
        (this information is useful to draw the band structure,
        with the correct relative scale between special points)
        one needs to know the a and c lattice parameters. Also, in what follows, we omit the 2*pi factor sometimes
        present in the definition of the reciprocal space vectors.
        The reciprocal vectors are (2/(3*a) 0 1/(3*c)) , -(1/(3*a) 1/(sqrt(3)*a) 1/(3*c), -(1/(3*a) -1/(sqrt(3)*a) 1/(3*c) ). The lengths of
        the above-mentioned segments can be computed as :
        l(X-Gamma)=2/(sqrt(3)*a)=1.155.../a , with l(K-Gamma)=(1+(a/c)^2/4)*4/(3*sqrt(3)*a);
        l(Gamma-T)=1/(2*c) ;
        l(T-L)=2/(sqrt(3)*a)=1.155.../a , with l(T-W)=(1-(a/c)^2/2)*4/(3*sqrt(3)*a);
        l(L-Gamma)=sqrt(4/(a^2)+1/(c^2))/3
        l(Gamma-X)=sqrt(1/(a^2)+1/(c^2))*2/3
        </p>
        <p>
        </p>
    topics: k-points_useful, ElecBandStructure_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: kptgw
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0
    dimensions:
    - 3
    - '[[nkptgw]]'
    excludes: null
    mnemonics: K-PoinTs for GW calculations
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         For each k-point with number igwpt in the range (1:[[nkptgw]]),
        [[kptgw]](1,igwpt)
         is the reduced coordinate of the k-point where GW corrections are required.
        while [[bdgw]] (1:2,igwpt) specifies the range of bands to be considered.
        </p>
        <p>
         At present, not all k-points are possible. Only those corresponding to the k-point
        grid defined with the same repetition parameters (
        [[kptrlatt]], or [[ngkpt]]
         ) than the GS one, but WITHOUT any shift, are allowed.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: kptnrm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: K - PoinTs NoRMalization
    requires: null
    text: |-
        <p>
         Establishes a normalizing denominator
        for each k point.
        Needed only
        if [[kptopt]]&lt;=0, otherwise
        deduced from other input variables.
         <br />
         The k point coordinates as fractions
        of reciprocal lattice translations are therefore
        [[kpt]](mu,ikpt)/[[kptnrm]].  [[kptnrm]] defaults to 1 and can
        be ignored by the user.  It is introduced to avoid
        the need for many digits in representing numbers such as 1/3.
         <br />
         It cannot be smaller than 1.0d0
        </p>
    topics: k-points_useful
    varset: basic
    vartype: real
- !variable
    abivarname: kptns
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    - '[[nkpt]]'
    excludes: null
    mnemonics: K-PoinTs re-Normalized and Shifted
    requires: null
    text: |-
        <p>
         If [[nqpt]]=0, or if one is
        doing a reponse calculation,
        this internal variable is derived from
        [[kpt]] and [[kptnrm]]:
        [[kptns]](1:3,:)=
        [[kpt]](1:3,:)/
        [[kptnrm]], so that
        it is [[kpt]] renormalized by
        [[kptnrm]].
         <br />
         If [[nqpt]]=1 and one is
        not doing a ground-state calculation,
        this internal variable is derived from
        [[kpt]],[[kptnrm]]
        and [[qptn]]
        [[kptns]](1:3,:)=
        [[kpt]](1:3,:)/
        [[kptnrm]]+
        [[qptn]](1:3), so that
        it is [[kpt]] renormalized by
        [[kptnrm]], then shifted
        by [[qptn]](1:3).
        </p>
    topics: k-points_internal
    varset: internal
    vartype: real
- !variable
    abivarname: kptopt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nspden]]==4': 4
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: KPoinTs OPTion
    requires: null
    text: |-
        <p>
         Controls the set up of the k-points list.
        The aim will be to initialize, by straight reading
        or by a preprocessing approach based on other input variables,
        the following input variables, giving the k points, their number,
        and their weight:
        [[kpt]],
        [[kptnrm]],
        [[nkpt]],
        and, for [[iscf]]/=-2,
        [[wtk]].
        </p>
        <p>
         Often, the k points will form a lattice in reciprocal space. In this case,
        one will also aim at initializing input variables that give
        the reciprocal of this k-point lattice, as well as its shift with respect
        to the origin:
        [[ngkpt]] or
        [[kptrlatt]],
        as well as on [[nshiftk]] and
        [[shiftk]].
        </p>
        <p>
         A global additional shift can be provided by [[qptn]]
         <ul>
          <li>
           0=&gt; read directly [[nkpt]], [[kpt]],
        [[kptnrm]] and [[wtk]].
          </li>
          <li>
           1=&gt; rely on [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Take fully into account the symmetry to generate the
        k points in the Irreducible Brillouin Zone only, with the appropriate weights.
           <br />
           (This is the usual mode for GS calculations)
          </li>
          <li>
           2=&gt; rely on
        [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Take into account only the time-reversal symmetry :
        k points will be generated in half the Brillouin zone, with the appropriate weights.
           <br />
           (This is to be used when preparing or executing a
        RF calculation at q=(0 0 0) )
          </li>
          <li>
           3=&gt; rely on [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Do not take into account any symmetry :
        k points will be generated in the full Brillouin zone, with the appropriate weights.
           <br />
           (This is to be used when preparing or executing a
        RF calculation at non-zero q )
          </li>
          <li>
           4=&gt; rely on [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Take into account all the symmetries EXCEPT the time-reversal symmetry
        to generate the k points in the Irreducible Brillouin Zone, with the appropriate weights.
           <br />
           This has to be used when performing calculations with non-collinear magnetism allowed
           ([[nspden]]=4)
          </li>
          <li>
           A negative value =&gt;
        rely on [[kptbounds]],
        and [[ndivk]]
        to set up a band structure calculation along different lines
        (allowed only for [[iscf]]==-2).
        The absolute value of [[kptopt]] gives the number of segments
        of the band structure. Weights are usually irrelevant with this option, and will be left to their default value.
          </li>
         </ul>
         In the case of a grid of k points, the auxiliary variables
        [[kptrlen]],
        [[ngkpt]]  and
        [[prtkpt]] might help
        you to select the optimal grid.
        </p>
    topics: k-points_basic, ElecBandStructure_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: kptrlatt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - 3
    - 3
    excludes: specified([[ngkpt]])
    mnemonics: 'K - PoinTs grid : Real space LATTice'
    requires: null
    text: |-
        <p>
         This input variable is used only when [[kptopt]]
        is positive. It partially defines the k point grid.
        The other piece of information is contained in
        [[shiftk]].
        [[kptrlatt]] cannot be used together with [[ngkpt]].
        </p>
        <p>
         The values kptrlatt(1:3,1), kptrlatt(1:3,2), kptrlatt(1:3,3)
        are the coordinates of three vectors in real space, expressed
        in the [[rprimd]] coordinate system (reduced coordinates).
        They defines a super-lattice in real space.
        The k point lattice is the reciprocal of this super-lattice,
        possibly shifted (see [[shiftk]]).
        </p>
        <p>
         If neither [[ngkpt]] nor [[kptrlatt]]
        are defined, ABINIT will automatically generate a set
        of k point grids, and select the best combination
        of [[kptrlatt]] and [[shiftk]]
        that allows to reach a sufficient value of [[kptrlen]].
        See this latter variable for a complete description of this
        procedure.
        </p>
    topics: k-points_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: kptrlatt@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 9*0
    dimensions:
    - 3
    - 3
    excludes: null
    mnemonics: K PoinT Reciprocal LATTice
    requires: null
    text: |-
        <p>Unnormalized lattice vectors for the k-point grid in reciprocal space
        (see [[kptrlatt]] abinit variable definitionas well).
        Input needed in electron-phonon calculations
        using nesting functions or tetrahedron integration.
    topics: ElPhonTransport_basic, PhononWidth_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: kptrlatt_fine@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 9*0
    dimensions:
    - 3
    - 3
    excludes: null
    mnemonics: K PoinT Reciprocal LATTice for FINE grid
    requires: null
    text: |-
        <p>As kptrlatt above, but for a finer grid of k-points. Under development. Does not work yet, as of June 2010.
    topics: ElPhonTransport_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: kptrlen
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30.0
    dimensions: scalar
    excludes: null
    mnemonics: 'K - PoinTs grid : Real space LENgth'
    requires: null
    text: |-
        <p>
         This input variable is used only when [[kptopt]]
        is positive and non-zero.
        </p>
        <p>
         Preliminary explanation :
         <br />
         The k point lattice defined by [[ngkpt]]
        or [[kptrlatt]] is used to perform integrations
        of periodic quantities in the Brillouin Zone, like
        the density or the kinetic energy. One can relate the
        error made by replacing the continuous integral by a sum
        over k point lattice to the Fourier transform of the
        periodic quantity. Erroneous contributions will appear
        only for the vectors in real space that belong to the reciprocal
        of the k point lattice, except the origin.
        Moreover, the expected size of these
        contributions usually decreases exponentially with the distance.
        So, the length of the smallest of these real space vectors
        is a measure of the accuracy of the k point grid.
        </p>
        <p>
         When either [[ngkpt]] or
        [[kptrlatt]] is defined, [[kptrlen]] is not
        used as an input variable, but the length of the
        smallest vector will be placed in this variable, and echoed
        in the output file.
        </p>
        <p>
         On the other hand, when neither [[ngkpt]] nor
        [[kptrlatt]] are defined, ABINIT will
        automatically generate a large set of possible k point grids,
        and select among this set, the grids that give
        a length of smallest vector LARGER than [[kptrlen]],
        and among these grids, the one that, when used with
        [[kptopt]]=1, reduces to the smallest number
        of k points. Note that this procedure can be time-consuming.
        It is worth doing it once for a given unit cell
        and set of symmetries, but not use this procedure by default.
        The best is then to set [[prtkpt]]=1, in order
        to get a detailed analysis of the set of grids.
        </p>
        <p>
         If some layer of vacuum is detected in the unit cell
        (see the input variable [[vacuum]]), the
        computation of [[kptrlen]] will ignore the
        dimension related to the direction perpendicular
        to the vacuum layer, and generate a bi-dimensional k point grid.
        If the system is confined in a tube,
        a one-dimensional k point grid will be generated.
        For a cluster, this procedure will only generate the Gamma point.
        </p>
    topics: k-points_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: kssform
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Kohn Sham Structure file FORMat
    requires: null
    text: |-
        <p>
         Governs the choice of the format for the file that
        contains the Kohn-Sham electronic structure information,
        for use in GW calculations, see the input variables
        [[optdriver]] and
        [[nbandkss]].
         <ul>
          <li>
           [[kssform]]=1, a single file .kss (double precision) containing
        complete information on the Kohn Sham Structure (eigenstates and the
        pseudopotentials used) will be generated through full diagonalization
        of the complete Hamiltonian matrix.
        The file has at the beginning the standard abinit header.
          </li>
          <li>
           [[kssform]]=3, a single file .kss (double precision) containing
        complete information on the Kohn Sham Structure (eigenstates and the
        pseudopotentials used) will be generated through the usual conjugate gradient
        algorithm (so, a restricted number of states).
        The file has at the beginning the standard abinit header.
          </li>
         </ul>
        </p>
        <p>
         Very important : for the time being, [[istwfk]]
        must be 1 for all the k-points.
        </p>
    topics: Susceptibility_expert, SelfEnergy_expert
    varset: files
    vartype: integer
- !variable
    abivarname: lapout@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: electronic density LAPlacian OUTput
    requires: null
    text: |-
        Output of
          the laplacian of electronic density. The specification of the
          line (plane) in the real space must be given in the input variable
         [[aim:vpts]] and grid in
          [[aim:ngrid]].
          It is also possible to get only the
          valence density or the core density (see [[aim:dltyp]]).
          <ul>
           <li>0, no output
           <li>1, 1D distribution
           <li>2, 2D distribution
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: lexexch
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -1
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: value of angular momentum L for EXact EXCHange
    requires: '[[useexexch]]==1'
    text: |-
        <p>
         Give for each species the value of the angular momentum (only values 2 or 3 are allowed)
        on which to apply the exact exchange correction.
        </p>
    topics: xc_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: lgrad2@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-5
    dimensions: scalar
    excludes: null
    mnemonics: Low GRADient criterion 2
    requires: null
    text: |-
        Determines the criterion for deciding that a CP has been found. See
          [[aim:lgrad]] for more details.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: lgrad@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-12
    dimensions: scalar
    excludes: null
    mnemonics: Low GRADient criterion
    requires: null
    text: |-
        The search for one particular CP is decided to be successful when either
          the norm of the gradient of the electron density is smaller
          than <b>lgrad</b> or when the length of the planned search step
          is smaller than [[aim:lstep]]. If
          the number of search step becomes larger than an internal limit
          (presently set to 100), one will allow a weaker criteria for
          satisfaction, based on [[aim:lgrad2]]
          and [[aim:lstep2]]. If the internal limit
          is reached, and the criteria on [[aim:lgrad2]]
          and [[aim:lstep2]] are not satisfied, then
          the searching procedure continues with the next seed.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: lin_comp@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    -   - num_lin_comp
    excludes: null
    mnemonics: LINear COMPonents
    requires: null
    text: |-
        This tells which component of the dielectric tensor you want to calculate.
          These numbers are called a and b Eqs. 46 in <a href="../../users/generated_files/help_optic.html#Ref1">Ref. 1</a>. 1 2 3 represent x y
          and z respectively. For example 11 would be xx and 32 would mean zy.
    topics: Optic_basic
    varset: optic
    vartype: integer
- !variable
    abivarname: localrdwf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: LOCAL ReaD WaveFunctions
    requires: null
    text: |-
        <p>
         This input variable is used only when running abinit in parallel.
        If [[localrdwf]]=1, the input wavefunction disk file or the KSS/SCR file in case of GW
        calculations, is read locally by each processor, while
        if [[localrdwf]]=0, only one processor reads it, and
        broadcast the data to the other processors.
        </p>
        <p>
         The option [[localrdwf]]=0 is NOT allowed when parallel I/O are activated (MPI-IO access),
        i.e. when [[iomode]]==1.
        </p>
        <p>
         In the case of a parallel computer with a unique file system,
        both options are as convenient for the user. However, if the I/O
        are slow compared to communications between processors,
        , [[localrdwf]]=0 should be much more
        efficient;
        if you really need temporary disk storage, switch to localrdwf=1 ).
        </p>
        <p>
         In the case of a cluster of nodes, with a different file system for
        each machine, the input wavefunction file must be available on all
        nodes if [[localrdwf]]=1, while it is needed only for the
        master node if [[localrdwf]]=0.
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: integer
- !variable
    abivarname: lotf_classic
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    dimensions: scalar
    excludes: null
    mnemonics: LOTF CLASSIC model for glue model
    requires: null
    text: |-
        <p>
         Glue model used in LOTF.
         <br />
         For the moment it is imposed to be 5.
        </p>
    topics: LOTF_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: lotf_nitex
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: LOTF Number of ITerations
    requires: null
    text: |-
        <p>
         Set the number of Molecular Dynamics iterations which are computed by LOTF.
        </p>
    topics: LOTF_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: lotf_nneigx
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    dimensions: scalar
    excludes: null
    mnemonics: LOTF max Number of NEIGhbours
    requires: null
    text: |-
        <p>
         Set the max number of Neighbours used in the LOTF method.
         <br />
         For the moment it is imposed to be 40.
        </p>
    topics: LOTF_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: lotf_version
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: LOTF VERSION of MD algorithm
    requires: null
    text: |-
        <p>
         Set the MD algorithm in the LOTF method.
         <br />
         For the moment it is imposed to be 2.
        </p>
    topics: LOTF_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: lpawu
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: -1
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: value of angular momentum L for PAW+U
    requires: '[[usepawu]]==1 or [[usepawu]]== 2'
    text: |-
        <p>
         Give for each species the value of the angular momentum (only
        values 2 or 3 are allowed)&nbsp; on which to apply the LDA+U correction.
         <br />
         <ul>
          <li>
           If equal to 2 (d-orbitals)&nbsp; or 3 (f-orbitals), values of
        [[upawu]] and&nbsp;
        [[jpawu]] are used in the calculation.
          </li>
          <li>
           If equal to -1: do not apply LDA+U correction on the species.
          </li>
         </ul>
        </p>
    topics: DFT+U_compulsory
    varset: paw
    vartype: integer
- !variable
    abivarname: lstep2@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-5
    dimensions: scalar
    excludes: null
    mnemonics: Length of the planned search STEP 2
    requires: null
    text: |-
        Determines the criterion for deciding that a CP has been found. See
          [[aim:lgrad]] for more details.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: lstep@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-10
    dimensions: scalar
    excludes: null
    mnemonics: Length of the planned search STEP
    requires: null
    text: |-
        Determines the criterion for deciding a CP has been found. See
          [[aim:lgrad]] for more details.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: macro_uj
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: MACRO variable that activates the determination of the U and J parameter (for the PAW+U calculations)
    requires: null
    text: |-
        <p>
         Sets proper input values for the determination of U and J i.e.
        for [[pawujat]] (first atom treated with PAW+U),
        [[irdwfk]] (=1),
        [[tolvrs]] (=10^(-8)),
        [[nstep]] (=255),
        [[diemix]] (=0.45),
        [[atvshift]] ([[pawujat]]) [[pawujv]]). Do not overwrite these variables manually unless you know what you do.
         <ul>
          <li>
           [[macro_uj]]=1 (and [[nsppol]]=2) Standard procedure to determine U on atom pawujat through a shift of the potential on both spin channels.
          </li>
          <li>
           [[macro_uj]]=1 (and [[nsppol]]=1) Non standard procedure to determine U from potential shift on atom pawujat (experimental).
          </li>
          <li>
           [[macro_uj]]=2 (and [[nsppol]]=2) Non standard procedure to determine U from potential shift on atom pawujat through a shift on spin channel 1 on this atom and the response on this channel (experimental).
          </li>
          <li>
           [[macro_uj]]=3 (and [[nsppol]]=2) Standard procedure to determine J from potential shift on spin channel 1 on atom pawujat and response on spin channel 2 (experimental).
          </li>
         </ul>
         Determination of U and J can be done only if the symmetry of the atomic arrangement is reduced and the atom pawujat is not connected to any other atom by symmetry relations (either input reduced symmetries manually, define concerned atom as a separate atomic species or shift concerned atom from ideal position).
        </p>
    topics: DFT+U_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: magcon_lambda
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    dimensions: scalar
    excludes: null
    mnemonics: MAGnetization CONstraint LAMBDA parameter
    requires: null
    text: |-
        <p>
         This variable gives the amplitude of the constraint imposed on the magnetization vectors on each atom (turned on with flag variable [[magconon]]). Typical values for lambda are 10 to a few hundred. The energy will vary strongly and convergence will be difficult if lambda is too large. The constraint will be weak and the magnetization will not be close to [[spinat]] if lambda is too small. See variable [[magconon]] for more details.
        </p>
    topics: MagMom_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: magconon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: turn MAGnetization CONstraint ON
    requires: null
    text: |-
        <p>
         Turns on the imposition of a Lagrangian constraint on the magnetization. For each atom, the magnetization is calculated in a sphere (radius [[ratsph]]) and a constraint is applied to bring it closer to the input values of [[spinat]]. The constraint can be either on the direction only (magconon 1) or on the full vector (magconon 2). The Lagrangian constraint has an amplitude [[magcon_lambda]] which should be neither too big (bad or impossible convergence) nor too small (no effect).
        </p>
    topics: MagMom_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: max_ncpus
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: MAXimum Number of CPUS
    requires: null
    text: |-
        <p>
         If [[autoparal]] &gt; 1 and [[max_ncpus]] is greater than 0,
        ABINIT analyzes the efficiency of the process distribution for each possible number of processors
        from 2 to [[max_ncpus]].
        After having printed out the efficiency, the code stops.
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: maxatd@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    dimensions: scalar
    excludes: null
    mnemonics: MAXimal ATomic Distance
    requires: null
    text: |-
        Atoms within this maximal distance are considered in order
          to start the search of a CP.
          <p>Note that the supercell,
          determined by
          [[aim:nsa]],
          [[aim:nsb]], and
         [[aim:nsc]] might
          be too small to actually lead to the consideration of all the
          desired atoms.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: maxcpd@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5.0
    dimensions: scalar
    excludes: null
    mnemonics: MAXimal CP Distance
    requires: null
    text: |-
        The CPs are searched for within this maximal distance.
          <p>Note that the supercell,
          determined by
          [[aim:nsa]],
          [[aim:nsb]], and
          [[aim:nsc]] might
          be too small to actually lead to the consideration of all the
          critical points.
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: maxestep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.005
    dimensions: scalar
    excludes: null
    mnemonics: MAXimum Electric field STEP
    requires: '[[berryopt]] = 6, 16, or 17'
    text: |-
        <p>
         This variable controls the maximum change of electric field when updating the electric field after each SCF iteration.
        When the calculation is difficult to converge, try reducing this value or reducing [[ddamp]].
        This variable is used in finite electric displacement field calculations ([[berryopt]]=6,16,17).
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: maxnsym
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 384
    dimensions: scalar
    excludes: null
    mnemonics: MAXimum Number of SYMetries
    requires: null
    text: |-
        <p>
         Gives the maximum number of spatial symetries allowed in the memory.
         <br />
         The default value is sufficient for most applications. It might have to be increased in the case of the use of a supercell (unit cell identically repeated).
        </p>
    topics: crystal_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: maxomega@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1 Ha
    dimensions: scalar
    excludes: null
    mnemonics: MAXimum value of OMEGA
    requires: null
    text: |-
        The step and maximum sets your energy grid for the calculation using the formula
          number of energy mesh points=maximum/step (zero excluded). So  in order to capture more
          features you can decrease the step size to get a finer energy grid. In order
          to go to higher frequency, increase the maximum.
    topics: Optic_basic
    varset: optic
    vartype: real
- !variable
    abivarname: mband
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Maximum number of BANDs
    requires: null
    text: |-
        <p>
         This internal variable derives
        the maximum number of bands
        over all k-points and spin-polarisation from
        [[nband]](1:nkpt*nsppol).
        </p>
    topics: BandOcc_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: mbpt_sciss
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Many Body Perturbation Theory SCISSor operator
    requires: '[[optdriver]] in [3,4,99]'
    text: |-
        <p>
         The Scissors operator energy added to the conductions states.
        In some cases, it mimics a second iteration self-consistent GW calculation.
        </p>
    topics: GW_useful, Susceptibility_useful, SelfEnergy_useful
    varset: gw
    vartype: real
- !variable
    abivarname: mdf_epsinf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Model Dielectric Function, EPSilon INFinity
    requires: '[[optdriver]]==99 and [[bs_coulomb_term]] in [20,21] (Bethe-Salpeter
        calculas with a model dielectric function'
    text: |-
        <p>
         [[mdf_epsinf]] specifies the value of the macroscopic dielectric function used
        to model the screening function (see Solid State Commun. <b>84</b>, 765 (1992)).
        The proper spatial symmetry of the screening W(r,r_prime) is enforced using Eq. (7) of Phys. Rev. B <b>37</b>, (1988)
         <br />
        </p>
    topics: BSE_useful
    varset: gw
    vartype: real
- !variable
    abivarname: mdtemp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 300
    - 300
    dimensions:
    - 2
    excludes: null
    mnemonics: Molecular Dynamics TEMPeratures
    requires: null
    text: |-
        <p>
         Give the initial and final temperature
        of the Nose-Hoover thermostat ([[ionmov]]=8)
        and Langevin dynamics ([[ionmov]]=9), in
        Kelvin.
        This temperature will change linearly from the initial temperature
         <b>
          mdtemp(1)
         </b>
         at itime=1 to
        the final temperature
         <b>
          mdtemp(2)
         </b>
         at the end of the
        [[ntime]] timesteps.
        </p>
    topics: PIMD_compulsory, MolecularDynamics_compulsory
    varset: rlx
    vartype: real
- !variable
    abivarname: mdwall
    characteristics: null
    commentdefault: the walls are extremely far away
    commentdims: null
    defaultval: 10000.0
    dimensions: scalar
    excludes: null
    mnemonics: Molecular Dynamics WALL location
    requires: null
    text: |-
        <p>
         Gives the location (atomic units) of walls
        on which the atoms will bounce back.
        when [[ionmov]]=6, 7, 8 or 9. For each
        cartesian direction idir=1, 2 or 3, there is a pair of walls with
        coordinates xcart(idir)=-wall and xcart(idir)=rprimd(idir,idir)+wall .
        Supposing the particle will cross the wall, its velocity normal to the
        wall is reversed, so that it bounces back.
         <br />
         By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[mdwall]] has the
        '[[LENGTH]]'
        characteristics.
        </p>
    topics: MolecularDynamics_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: mem_test
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: MEMory TEST
    requires: null
    text: |-
        <p>
         This variable controls the memory test done in the memana routine.
        Possible values:
         <ul>
          <li>
           0 no test on the available memory is performed
          </li>
          <li>
           1 the routine tries to allocate the estimated memory, for testing
        purposes, and if a failure occurs, the routine stops.
          </li>
          <li>
           2 like 1, but before stopping, the routine will provide
        an estimation of the available memory.
          </li>
         </ul>
        </p>
    topics: Control_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: mep_mxstep
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[imgmov]]==5': 0.4
        defaultval: 100.0
    dimensions: scalar
    excludes: null
    mnemonics: 'Minimal Energy Path search: MaXimum allowed STEP size'
    requires: null
    text: |-
        <p>
         Relevant only when [[imgmov]]=1 (Steepest-Descent), 2 (String Method) or 5 (Nudged Elastic Band).
         <br />
         The optimizer used to solve the Ordinary Differential Equation (ODE) can be constrained with a maximum allowed step size for each image. By default this feature is only activated for Nudged Elastic Band (NEB) and the value is inspired by
         <i>
          J. Chem. Phys. 128, 134106 (2008)
         </i>
         .
         <br />
         Note that the step size is defined for each image as
         <i>
          step = SQRT[SUM(R_i dot R_i)]
         </i>
         where the
         <i>
          R_i
         </i>
         are the positions of
        the atoms in the cell.
        </p>
    topics: TransPath_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: mep_solver
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Minimal Energy Path ordinary differential equation SOLVER
    requires: null
    text: |-
        <p>
         Relevant only when [[imgmov]]=2 (String Method) or 5 (Nudged Elastic Band).
         <br />
         Gives the algorithm used to solve the Ordinary Differential Equation (ODE) when searching for
        a Minimal Energy Path (MEP).
         <br />
         Possible values can be:
         <br />
         <ul>
          <li>
           0=&gt;
           <b>
            Steepest-Descent algorithm
           </b>
           following the (scaled) forces,
        the scaling factor being [[fxcartfactor]]
        (forward Euler method).
           <br />
           Compatible with all MEP search methods.
          </li>
          <br />
          <li>
           1=&gt;
           <b>
            Quick-min optimizer
           </b>
           following the (scaled) forces,
        the scaling factor being [[fxcartfactor]].
        The "quick minimizer" improves upon the steepest-descent method by
        accelerating the system in the direction of the forces. The velocity (of the image) is
        projected long the force and cancelled if antiparallel to it.
           <br />
           Compatible only with Nudged Elastic Band ([[imgmov]]=5).
           <br />
           <i>
            See, for instance: J. Chem. Phys. 128, 134106 (2008).
           </i>
           <br />
          </li>
          <br />
          <li>
           2=&gt;
           <b>
            Local Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) algorithm
           </b>
           ; each image along the
        band is minimized with a different instance of the BFGS optimizer.
           <br />
           Compatible only with Nudged Elastic Band ([[imgmov]]=5).
           <br />
           <i>
            See, for instance: J. Chem. Phys. 128, 134106 (2008).
           </i>
           <br />
           IN [[DEVELOP]]PMENT - NOT RELIABLE
          </li>
          <br />
          <li>
           3=&gt;
           <b>
            Global Broyden-Fletcher-Goldfarb-Shanno (GL-BFGS) algorithm
           </b>
           ; all images along the
        band are minimized with a single instance of the BFGS optimizer.
           <br />
           Compatible only with Nudged Elastic Band ([[imgmov]]=5).
           <br />
           <i>
            See, for instance: J. Chem. Phys. 128, 134106 (2008).
           </i>
           <br />
           IN [[DEVELOP]]PMENT - NOT RELIABLE
          </li>
          <br />
          <li>
           4=&gt;
           <b>
            Fourth-order Runge-Kutta method
           </b>
           ; the images along the band are moved
        every four steps (1&lt;=istep&lt;=[[ntimimage]])
        following the Runge-Kutta algorithm,
        the time step being [[fxcartfactor]].
           <br />
           Compatible only with Simplified String Method ([[imgmov]]=2
        and [[string_algo]]=1 or 2).
           <br />
           <i>
            See: J. Chem. Phys. 126, 164103 (2007).
           </i>
          </li>
         </ul>
         All of the optimizers can be constrained with a maximum allowed step size for each image; see [[mep_mxstep]]. This is by default the case of the Nudged Elastic Band ([[imgmov]]=5).
        </p>
    topics: TransPath_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: mgfft
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Maximum of nGFFT
    requires: null
    text: |-
        <p>
         This internal variable contains the maximum of
        [[ngfft]](1:3).
        </p>
    topics: Planewaves_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: mgfftdg
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Maximum of nGFFT for the Double Grid
    requires: null
    text: |-
        <p>
         This internal variable contains the maximum of
        [[ngfftdg]](1:3).
        </p>
    topics: Planewaves_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: mixalch
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[npspalch]]'
    - '[[ntypalch]]'
    excludes: null
    mnemonics: MIXing coefficients for ALCHemical potentials
    requires: null
    text: |-
        <p>
         Used for the generation of alchemical pseudoatoms, that is,
        when [[ntypalch]] is non-zero.
        </p>
        <p>
         This array gives, for each type of alchemical pseudatom (there are
        [[ntypalch]] such pseudoatoms), the mixing coefficients
        of the basic [[npspalch]] pseudopotentials for
        alchemical use. For each type of alchemical pseudoatom, the sum of the
        mixing coefficients must equal 1.
        </p>
        <p>
         The actual use of the mixing coefficients is defined by the input
        variable [[algalch]]. Note that the masses of the atoms,
        [[amu]]
        are also mixed according to the value of [[mixalch]], by default.
        </p>
        <p>
         Example 1. Suppose that we want to describe Ba(0.25) Sr(0.75) Ti O3.
         <br />
         The input variables related to the construction of the alchemical Ba(0.25) Sr(0.75)
        potential will be :
         <pre>
          npsp   4                 ! 4 pseudopotentials should be read.
          znucl  8 40 56 38        ! The nuclear charges. Note that the two
                                   ! atoms whose pseudopotentials are to be mixed
                                   ! are mentioned at the end of the series.
          ntypat  3                ! There will be three types of atoms.
          ntypalch   1             ! One pseudoatom will be alchemical.
                                   ! Hence, there will be ntyppure=2 pure pseudoatoms,
                                   ! with znucl 8 (O) and 40 (Ti), corresponding to
                                   ! the two first pseudopotentials. Out of the
                                   ! four pseudopotentials, npspalch=2 are left
                                   ! for alchemical purposes, with znucl 56 (Ba)
                                   ! and 38 (Sr).
          mixalch    0.25  0.75    ! For that unique pseudoatom to be
                                   ! generated, here are the mixing coeeficients,
                                   ! to be used to combine the Ba and Sr pseudopotentials.
         </pre>
        </p>
        <p>
         Example 2. More complicated, and illustrate some minor drawback of the
        design of input variables.
        Suppose that one wants to generate Al(0.25)Ga(0.75) As(0.10)Sb(0.90).
         <br />
         The input variables will be :
         <pre>
          npsp  4                  ! 4 pseudopotentials should be read
          znucl  13 31 33 51       ! The atomic numbers. All pseudopotentials
                                   ! will be used for some alchemical purpose
          ntypat  2                ! There will be two types of atoms.
          ntypalch   2             ! None of the atoms will be "pure".
                                   ! Hence, there will be npspalch=4 pseudopotentials
                                   !  to be used for alchemical purposes.
          mixalch    0.25  0.75 0.0  0.0   ! This array is a (4,2) array, arranged in the
                     0.0   0.0  0.1  0.9   ! usual Fortran order.
         </pre>
         Minor drawback : one should not forget to fill [[mixalch]] with the needed zero's, in this later case.
        </p>
        <p>
         In most cases, the use of [[mixalch]]
        will be as a static (non-evolving) variable. However, the possibility to have
        different values of [[mixalch]] for different images has been coded. A population of
        cells with different atomic characteristics can thus be considered,
        and can be made to evolve, e.g. with a genetic algorithm (not coded in v7.0.0 though).
        There is one restriction to this possibility : the value of [[ziontypat]] for the atoms that are mixed should be
        identical.
        </p>
    topics: AtomTypes_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: mpw
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Maximum number of Plane Waves
    requires: null
    text: |-
        <p>
         This internal variable gives the maximum of the number of
        plane waves over all k-points. It is computed
        from [[ecut]] and the description
        of the cell, provided by
        [[acell]],
        [[rprim]], and/or
        [[angdeg]].
        </p>
    topics: Planewaves_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: mqgrid
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 3001
    dimensions: scalar
    excludes: null
    mnemonics: Maximum number of Q-space GRID points for pseudopotentials
    requires: null
    text: |-
        <p>
         Govern the size of the one-dimensional information
        related to pseudopotentials, in reciprocal space :
        potentials, or projector functions.
        </p>
    topics: Planewaves_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: mqgriddg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 3001
    dimensions: scalar
    excludes: null
    mnemonics: Maximum number of Q-wavevectors for the 1-dimensional GRID  for the Double Grid in PAW
    requires: null
    text: |-
        <p>
         Maximum number of wavevectors used to sample the local part of the potential, in PAW.
        Actually referred to as mqgrid_vl internally. Should change name to the latter ...
        See also [[mqgrid]]
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: mustar@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    dimensions: scalar
    excludes: null
    mnemonics: MU STAR
    requires: null
    text: |-
        <p>Average electron-electron interaction strength, for the computation of the superconducting Tc using Mc-Millan's formula.
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: natcon
    characteristics:
    - '[[NO_MULTI]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[nconeq]]'
    excludes: null
    mnemonics: Number of AToms in CONstraint equations
    requires: null
    text: |-
        <p>
         Gives the number of atoms appearing in each of the
        [[nconeq]]
         independent equations constraining the motion of
        atoms during structural optimization or molecular dynamics (see
        [[nconeq]]
         , [[iatcon]],
        and [[wtatcon]]).
        </p>
    topics: GeoConstraints_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: natfix
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: (no atoms held fixed)
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Atoms that are FIXed
    requires: null
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held fixed
        during a structural
        optimization or molecular dynamics.
        <br />
         When
        [[natfix]]
        &gt; 0,
        [[natfix]]
         entries should be provided in array
        [[iatfix]]
         .
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: natfix@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of AToms FIXed
    requires: null
    text: |-
        <p>Number of atoms that are fixed during a structural optimisation at constrained polarization.
        See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: natfixx
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Atoms that are FIXed along the X direction
    requires: null
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held  fixed along the X direction
        during a structural
        optimization or molecular dynamics.
         <br />
         When [[natfixx]] &gt; 0, [[natfixx]] entries should be provided
        in array [[iatfixx]].
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: natfixy
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Atoms that are FIXed along the Y direction
    requires: null
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held fixed along the Y direction
        during a structural
        optimization or molecular dynamics.
         <br />
         When [[natfixy]] &gt; 0, [[natfixy]] entries should be provided in array [[iatfixy]]
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: natfixz
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Atoms that are FIXed along the Z direction
    requires: null
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held fixed along the Z direction
        during a structural
        optimization or molecular dynamics.
         <br />
         When [[natfixz]] &gt; 0, [[natfixz]] entries should be provided in array [[iatfixz]].
        </p>
    topics: GeoConstraints_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: natifc@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of AToms for IFC analysis
    requires: null
    text: |-
        <p> Give the number of atoms for which IFCs are written and eventually analysed. The list of these atoms is provided
        by [[anaddb:atifc]].
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: natom
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of ATOMs
    requires: null
    text: |-
        <p>
         Gives the total number of atoms in the unit cell.
        Default is 1 but you will obviously want to input this
        value explicitly.
         <br />
         Note that [[natom]] refers to all atoms in the unit cell, not
        only to the irreducible set of atoms in the unit cell (using symmetry operations,
        this set allows to recover all atoms). If you want
        to specify only the irreducible set of atoms, use the
        symmetriser, see the input variable [[natrd]].
        </p>
    topics: crystal_basic, SmartSymm_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: natpawu
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of AToms on which PAW+U is applied
    requires: '[[usepawu]]==1'
    text: |-
        <p>
         This internal variable gives the number of atoms on which the LDA/GGA+U method
        is applied. This value is determined from [[lpawu]].
        </p>
    topics: DFT+U_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: natprj_bs@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of AToms for PRoJection of the Band Structure
    requires: null
    text: |-
        <p>Give the number of atoms for which atomic-projected phonon
        band structures will be output. The list of these atoms is provided
        by [[iatprj_bs@anaddb]].
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: natrd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[natom]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of AToms ReaD
    requires: null
    text: |-
        <p>
         Gives the number of atoms to be
        read from the input file, in the case the atom manipulator
        or the smart symmetriser is used. In this case,
        [[natrd]] is also used to dimension
        the array [[typat]],
        and the arrays [[xred]],
        [[xangst]] and [[xcart]].
         <br />
         Must take into account the vacancies (see [[vacnum]] and
        [[vaclst]]).
         <br />
         Despite possible vacancies, cannot be bigger than [[natom]].
        </p>
    topics: AtomManipulator_basic, SmartSymm_basic
    varset: geo
    vartype: integer
- !variable
    abivarname: natsph
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[natom]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of ATomic SPHeres for the atom-projected density-of-states
    requires: '[[prtdos]] == 3 or [[pawfatbnd]] in [1,2]'
    text: |-
        <p>
        [[natsph]] gives the number of atoms around which the sphere
        for atom-projected density-of-states will be built,
        in the [[prtdos]]=3 case.
        The indices of these atoms are given by [[iatsph]].
        The radius of these spheres is given by [[ratsph]].
         <br />
         If [[pawfatbnd]]=1 or 2, it gives the number of atoms around which atom-projected band structure will be
        built (the indices of these atoms are given by  [[iatsph]]).
        </p>
    topics: printing_prdos, ElecBandStructure_useful, ElecDOS_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: natsph_extra
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of ATomic SPHeres for the l-projected density-of-states in EXTRA set
    requires: '[[prtdos]] == 3 or [[pawfatbnd]] in [1,2]'
    text: |-
        <p>
        [[natsph_extra]] gives the number of extra spheres
        for which the angular-momentum-projected density-of-states will be built,
        in the [[prtdos]]=3 case.
        The radius of these spheres is given by [[ratsph_extra]].
        This simulates the STS signal for an STM tip atom placed at the sphere position, according to the chemical nature of the tip (s- p- d- wave etc...).
         <br />
         If [[pawfatbnd]]=1 or 2, it gives the number of spheres in which l-projected band structure will be
        built.
         <br />
         The position of the spheres is given by the
         [[xredsph_extra]]
         variable.
        </p>
    topics: printing_prdos
    varset: gstate
    vartype: integer
- !variable
    abivarname: natvshift
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of ATomic potential (V) energy SHIFTs (per atom)
    requires: '[[usepawu]] /= 0, [[atvshift]]'
    text: |-
        <p>
         Number of atomic potential energy shifts (per atom), to be used to define the
        array [[atvshift]].
        If non-zero, only two possibilities exist : 5 for d states
        (with [[lpawu]]=2),
        and 7 for f states (with [[lpawu]]=3).
        If non-zero, one should define
        [[usepawu]],
        [[lpawu]] and
        [[atvshift]].
        </p>
    topics: DFT+U_expert
    varset: ffield
    vartype: integer
- !variable
    abivarname: nband
    characteristics: null
    commentdefault: ' the estimated number of occupied bands +1 (TODO provide
        the mathematical formulation)'
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of BANDs
    requires: null
    text: |-
        <p>
         Gives number of bands, occupied plus
        possibly unoccupied, for which wavefunctions are being computed
        along with eigenvalues.
         <br />
         Note : if the parameter
        [[occopt]] (see below) is not set to 2,
        [[nband]] is a scalar integer, but
        if the parameter [[occopt]] is set to 2,
        then [[nband]] must be an array [[nband]]([[nkpt]]*
        [[nsppol]]) giving the
        number of bands explicitly for each k point.  This
        option is provided in order to allow the number of
        bands treated to vary from k point to k point.
         <br />
         For the values of [[occopt]] not equal to 0 or 2, [[nband]]
        can be omitted. The number of bands will be set up
        thanks to the use of the variable [[fband]]. The present Default
        will not be used.
        </p>
        <p>
         If [[nspinor]] is 2, nband must be even for
        each k point.
        </p>
        <p>
         In the case of a GW calculation ([[optdriver]]=3 or 4),
        [[nband]] gives the number of bands to be treated to generate the screening (susceptibility
        and dielectric matrix), as well as the self-energy. However, to generate the _KSS
        file (see [[kssform]])
        the relevant number of bands is given by [[nbandkss]].
        </p>
    topics: BandOcc_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: nbandhf
    characteristics: null
    commentdefault: 'the estimated number of occupied bands (TODO : provide
        the mathematical formulation)'
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of BANDs for (Hartree)-Fock exact exchange
    requires: null
    text: |-
        <p>
         Gives the maximum number of occupied bands with which Fock exact exchange is being computed for the wavefunctions.
        </p>
    topics: Hybrids_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: nbandkss
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of BANDs in the KSS file
    requires: null
    text: |-
        <p>
         This input variable is used for the preparation of a GW calculation :
        it is used in a GS run (where [[optdriver]]=0) to generate a _KSS file.
        In this run, [[nbandkss]] should be non-zero.
        The generated _KSS file can be subsequently used to calculate the irreducible polarizabilty
        $\chi^{(0)}_{KS}$ using [[optdriver]]=3
        or to calculate GW corrections setting [[optdriver]]=4.
        </p>
        <p>
         <ul>
          <li>
           If [[nbandkss]]=0, no _KSS file is created
          </li>
          <li>
           If [[nbandkss]]=-1, all the available eigenstates (energies and eigenfunctions) are stored in the
        abo_KSS file at the end of the ground state calculation. The number of states is forced to be
        the same for all k-points : it will be the minimum of the number of plane waves over all k-points.
          </li>
          <li>
           If [[nbandkss]] is greater than 0, abinit stores (about) [[nbandkss]] eigenstates in the abo_KSS file.
        This number of states is forced to be the same for all k-points.
          </li>
         </ul>
        </p>
        <p>
         See [[npwkss]] for the selection of the number of the planewave components of
        the eigenstates to be stored.
         <br />
         The input variable [[iomode]] can be used
        to read and write KSS files according to different fileformat
        (presently only [[iomode]]=0 and 3 are available in the GW part).
         <br />
         The precision of the KSS file can be tuned through the input variable [[kssform]].
         <br />
         For more details about the format of the abo_KSS file, see the routine outkss.F90.
        </p>
        <p>
         Very important : for the time being, [[istwfk]] must be 1 for all the k-points
        in order to generate a _KSS file.
        </p>
    topics: GW_useful, Susceptibility_useful, SelfEnergy_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: nbdblock
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of BanDs in a BLOCK
    requires: null
    text: |-
        <p>
         In case of non-standard, blocked algorithms for the
        optimization of the wavefunctions (that is, if
        [[wfoptalg]]=4):
         <ul>
          <li>
           if [[wfoptalg]]=4,
        [[nbdblock]] defines the number of blocks (the number of bands in the block is
        then [[nband]]/[[nbdblock]] ).
          </li>
         </ul>
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nbdbuf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[optdriver]]==0 and [[iscf]]<0': 2*[[nspinor]]
        '[[optdriver]]==1 and 3<=[[occopt]] and [[occopt]]<= 8': 2*[[nspinor]]
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of BanDs for the BUFfer
    requires: null
    text: |-
        <p>
         [[nbdbuf]] gives the number of bands, the highest in energy, that,
        among the
        [[nband]] bands, are to be considered
        as part of a buffer. This concept is useful in three situations:
        in non-self-consistent
        calculations, for the determination of the convergence tolerance ;
        for response functions of metals, to avoid instabilities,
        and also when finite electric fields or non-linear responses (with electric field
        perturbations) are considered.
        For the two first, the need of a buffer is a natural requirement
        of the problem, so that the default value is changed to 2 automatically,
        as explained in the following.
        The third case is only for implementation convenience.
        </p>
        <p>
         In non-self-consistent GS calculations ([[iscf]]&lt;0),
        the highest levels might be
        difficult to converge, if they are degenerate with another level,
        that does not belong to the set of bands treated. Then, it might
        take extremely long to reach [[tolwfr]], although
        the other bands are already extremely well-converged, and the energy
        of the highest bands (whose residual are not yet good enough), is
        also rather well converged.
         <br />
         In response to this problem, for non-zero [[nbdbuf]], the
        largest residual (residm), to be later compared with [[tolwfr]],
        will be computed only in the set of non-buffer bands (this modification
        applies for non-self-consistent as well as self-consistent calculation,
        for GS as well as RF calculations).
         <br />
         For a GS calculation, with [[iscf]]&lt;0, supposing
        [[nbdbuf]] is not initialized in the input file,
        then ABINIT will overcome the default [[nbdbuf]] value,
        and automatically set [[nbdbuf]] to 2.
        </p>
        <p>
         In metallic RF calculations, in the conjugate gradient optimisation
        of first-order wavefunctions, there is an instability situation
        when the q wavevector of the perturbation brings the eigenenergy of the
        highest treated band at some k point higher than the lowest
        untreated eigenenergy at some k+q point.
        If one accepts a buffer of frozen states, this instability can be made to
        disappear. Frozen states receive automatically a residual value of -0.1d0.
         <br />
         For a RF calculation, with 3&lt;=[[occopt]]&lt;=7,
        supposing
        [[nbdbuf]] is not initialized in the input file, then
        ABINIT will overcome the default [[nbdbuf]] value,
        and automatically set [[nbdbuf]] to 2. This value might be too low
        in some cases.
        </p>
        <p>
         Also, the number of active bands, in all cases, is imposed
        to be at least 1, irrespective of the value of [[nbdbuf]].
        </p>
    topics: SCFControl_useful, BandOcc_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: nberry
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of BERRY phase computations
    requires: '[[berryopt]] = 1, 2, or 3'
    text: |-
        <p>
         Gives the number of Berry phase computations of polarisation,
        or finite-difference estimations of the derivative of wavefunctions
        with respect to the wavevector,
        each of which might be characterized by a different change of
        wavevector [[kberry]].
        </p>
        <p>
         When equal to 0, no Berry phase calculation of polarisation
        is performed. The maximal value of [[nberry]] is 20.
        </p>
        <p>
         Note that the computation of the polarisation for a set of bands
        having different occupation numbers is meaningless (although
        in the case of spin-polarized calculations, the spin up bands
        might have an identical occupation number, that might differ
        from the identical occupation number of spin down bands).
        Although meaningless, ABINIT will perform such computation,
        if required by the user. The input variable
        [[bdberry]] governs the set of bands
        for which a Berry phase is computed.
        </p>
        <p>
         For the [[berryopt]] = 1, 2, and 3 cases, spinor wavefunctions are not allowed, nor are parallel computations.
        </p>
    topics: Berry_basic
    varset: ffield
    vartype: integer
- !variable
    abivarname: nc_xccc_gspace
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: 0 when [[usepaw]]=0, 1 when [[usepaw]]=1
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==0': 0
        '[[usepaw]]==1': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Norm-Conserving pseudopotentials - use XC Core-Correction in G-SPACE
    requires: null
    text: |-
        Historically, Abinit treats the model core charge used for the non-linear core
        correction in real space. Alternatively, it is possible to instruct the code to compute the core charge in G-space following the same approach used in
        the PAW code. The G-space formalism is more accurate than the interpolation in real space, especially when derivatives of the model core charge are
        needed, e.g. DFPT. Preliminary tests showed that the violation of the acoustic sum rule is reduced when [[nc_xccc_gspace]]==1 , especially for LDA.
        It is worth stressing, however, that [[nc_xccc_gspace]]==1
        should be used only in conjunction with NC pseudos whose model core charge that decays quickly in
        G-space. Several NC pseudos available in the Abinit table are not optimized for the G-space formalism and users are strongly invited to perform
        convergence studies with respect to ecut before using this option.
    topics: Planewaves_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nchan@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 800
    dimensions: scalar
    excludes: null
    mnemonics: Number of CHANnels
    requires: null
    text: |-
        <p>The number of channels of width 1 cm-1 used in calculating the phonon density of states through the histogram method,
        or, equivalently, the largest frequency sampled. The first channel begins at 0.
    topics: PhononBands_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nconeq
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of CONstraint EQuations
    requires: null
    text: |-
        <p>
         Gives the number of independent equations constraining
        the motion of
        atoms during structural optimization or molecular dynamics (see
        [[natcon]]
         , [[iatcon]],
        and [[wtatcon]]).
        </p>
    topics: GeoConstraints_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: nctime
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: NetCdf TIME between output of molecular dynamics informations
    requires: null
    text: |-
        <p>
         When [[nctime]] is non-zero, the molecular dynamics information
        is output in NetCDF format, every [[nctime]] time step. Here is the content of an example file :
         <pre>
        netcdf md32.outH_moldyn1 {
        dimensions:
           time = UNLIMITED ; // (11 currently)
           DimTensor = 6 ;
           DimCoord = 3 ;
           NbAtoms = 32 ;
           DimVector = 3 ;
           DimScalar = 1 ;
        variables:
           double E_pot(time) ;
              E_pot:units = "hartree" ;
           double E_kin(time) ;
              E_kin:units = "hartree" ;
           double Stress(time, DimTensor) ;
              Stress:units = "hartree/Bohr^3" ;
           double Position(time, DimCoord, NbAtoms) ;
              Position:units = "Bohr" ;
           double Celerity(time, DimCoord, NbAtoms) ;
              Celerity:units = "Bohr/(atomic time unit)" ;
           double PrimitiveVector1(DimVector) ;
           double PrimitiveVector2(DimVector) ;
           double PrimitiveVector3(DimVector) ;
           double Cell_Volume(DimScalar) ;
              Cell_Volume:units = "Bohr^3" ;
        }
         </pre>
        </p>
    topics: MolecularDynamics_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: ndivk
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: Will be generated automatically from [[ndivsm]] if the latter is defined.
    commentdims: null
    defaultval: null
    dimensions:
    - abs([[kptopt]])
    excludes: specified([[ndivsm]])
    mnemonics: Number of DIVisions of K lines
    requires: '[[kptopt]] < 0'
    text: |-
        <p>
         Gives the number of divisions of each of the segments
        of the band structure, whose path is determined by
        [[kptopt]]
        and
        [[kptbounds]].
        In this case, the absolute value of
        [[kptopt]] is the number of such segments.
        </p>
        <p>
         For example, suppose that the number of segment is just one
        ([[kptopt]]=-1),
        a value [[ndivk]]=4 will lead to the computation
        of points with relative coordinates 0.0, 0.25, 0.5, 0.75 and 1.0 , along
        the segment in consideration.
        </p>
        <p>
         Now, suppose that there are two segments
        ([[kptopt]]=-2), with
        [[ndivk]](1)=4 and [[ndivk]](2)=2, the computation of the
        eigenvalues will be done at 7 points, 5 belonging to the
        first segment, with relative coordinates 0.0, 0.25, 0.5, 0.75 and 1.0,
        the last one being also the starting point of the next segment,
        for which two other points must be computed, with relative coordinates
        0.5 and 1.0 .
        </p>
        <p>
         It is easy to compute disconnected circuits (non-chained segments),
        by separating
        the circuits with the value [[ndivk]]=1 for the intermediate
        segment connecting the end of one circuit with the
        beginning of the next one (in which case no intermediate
        point is computed along this segment).
        </p>
        <p>
         Alternatively it is possible to generate automatically the array [[ndivk]]
        by just specifying the number of divisions for the smallest segment.
        See the related input variable [[ndivsm]].
        </p>
    topics: k-points_useful, ElecBandStructure_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: ndivsm
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of DIVisions for the SMallest segment
    requires: null
    text: |-
        <p>
        This variable defines the number of divisions used to sample the smallest segment of the circuit employed in a band structure calculations
        (see related input variables
        [[kptopt]]
        and
        [[kptbounds]]).
        If [[ndivsm]] is given in the input file, there is no need to specify the number of divisions
        to be used for the other segments.
        Indeed [[ndivk]] is automatically calculated inside the
        code in order to generate a path where the number of divisions in each segment is proportional
        to the length of the segment itself.
        This option is activated only when [[kptopt]] is negative.
        In this case, the absolute value of
        [[kptopt]] is the number of such segments.
        </p>
    topics: k-points_useful, ElecBandStructure_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: ndivsm@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 20
    dimensions: scalar
    excludes: null
    mnemonics: Number of DIVisions for the SMallest segment
    requires: null
    text: |-
        <p>This variable defines the number of divisions used to sample the smallest segment of the q-path used
        for the phonon band structure. If ndivsm is specified in the input file, the code will automatically generate the points along the path using the coordinates given in the array [[anaddb:qpath]].
    topics: PhononBands_basic, PhononWidth_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ndtset
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of DaTaSETs
    requires: null
    text: |-
        <p>
         Gives the number of data sets to be
        treated.
         <br />
         If 0, means that the multi-data set treatment is not used,
        so that the root filenames will not be appended with _DSx,
        where 'x' is the dataset index defined
        by the input variable [[jdtset]],
        and also that input names with a dataset index are not allowed.
        Otherwise, [[ndtset]]=0 is equivalent to [[ndtset]]=1.
        </p>
    topics: multidtset_compulsory
    varset: basic
    vartype: integer
- !variable
    abivarname: ndynimage
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of DYNamical IMAGEs
    requires: null
    text: |-
        <p>
         This internal variable gives the number of dynamical images,
        immediately deduced from the number of non-zero values present in
        [[dynimage]].
        It is used to dimension many memory-consuming arrays (one copy for each image),
        e.g. the wavefunction array (cg), the density array (rho), etc .
        </p>
    topics: PIMD_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: neb_algo
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Nudged Elastic Band ALGOrithm
    requires: '[[imgmov]]==5'
    text: |-
        <p>
         Gives the variant of the NEB method used.
         <br />
         Possible values can be:
         <br />
         <ul>
          <li>
           0=&gt;
           <b>
            Original NEB method
           </b>
           .
           <br />
           <i>
            See: Classical and Quantum Dynamics in Condensed Phase Simulations, edited by
        Berne, Ciccotti, Coker (World Scientific, Singapore, 1998), pp. 385-404
           </i>
          </li>
          <br />
          <li>
           1=&gt;
           <b>
            NEB + improved tangent
           </b>
           .
           <br />
           The Improved Tangent Method builds on the NEB with an improved estimate of the
        tangent direction and a resulting change of the component of the spring force acting
        on the images.
           <br />
           <i>
            See: J. Chem. Phys. 113, 9978 (2000).
           </i>
          </li>
          <br />
          <li>
           2=&gt;
           <b>
            Climbing-Image NEB (CI-NEB)
           </b>
           .
           <br />
           The CI-NEB method constitutes a small modification to the NEB method.
        Information about the shape of the MEP is retained, but a rigorous
        convergence to a saddle point is also obtained.
        By default the spring constants are variable (see [[neb_spring]]).
        As the image with the highest energy has to be identified,
        the calculation begins with several iterations of the standard NEB
        algorithm. The effective CI-NEB begins at the [[cineb_start]] iteration.
           <br />
           <i>
            See: J. Chem. Phys. 113, 9901 (2000).
           </i>
          </li>
         </ul>
         Note that, in all cases, it is possible to define the value of the spring constant connecting images with
        [[neb_spring]], keeping it constant or allowing it
        to vary between 2 values (to have higher resolution close to the saddle point).
        </p>
    topics: TransPath_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: neb_spring
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[neb_algo]]==2':
        - 0.02
        - 0.15
        defaultval:
        - 0.05
        - 0.05
    dimensions:
    - 2
    excludes: null
    mnemonics: 'Nudged Elastic Band: SPRING constant'
    requires: '[[imgmov]]==5'
    text: |-
        <p>
         Gives the minimal and maximal values of the spring constant connecting images for the NEB method.
         <br />
         In the standard "Nudged Elastic Band" method, the spring constant is constant along the path,
        but, in order to have higher resolution close to the saddle point, it can be better
        to have stronger springs close to it.
         <br />
         <i>
          See: J. Chem. Phys. 113, 9901 (2000).
         </i>
        </p>
    topics: TransPath_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: nelect
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of ELECTrons
    requires: null
    text: |-
        <p>
         This internal variable gives the number of electrons per unit
        cell, as computed from the sum of the valence electrons
        related to each atom (given in the pseudopotential, where it is called
        "zion"), and the input variable
        [[charge]]:
         <br />
         [[nelect]]=zion-[[charge]].
        </p>
    topics: BandOcc_internal
    varset: internal
    vartype: real
- !variable
    abivarname: nfft
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of FFT points
    requires: null
    text: |-
        <p>
         If space parallelisation is not used (that is, if [[paral_kgb]]==0),
        this internal variable gives the number of Fast Fourier Transform
        points in the grid generated by
        [[ngfft]](1:3). It is simply the
        product of the three components of [[ngfft]].
         <br />
         If space parallelisation is used (that is, if [[paral_kgb]]==1), then it becomes the
        number of Fast Fourier Transform points attributed to the
        particular processor. It is no longer the above-mentioned simple product,
        but a number usually close to this product divided by the
        number of processors on which the space is shared.
        </p>
    topics: Planewaves_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: nfftdg
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of FFT points for the Double Grid
    requires: null
    text: |-
        <p>
         If space parallelisation is not used (that is, if [[paral_kgb]]==0),
        this internal variable gives the number of Fast Fourier Transform
        points in the (double) grid generated by
        [[ngfftdg]](1:3). It is simply the
        product of the three components of [[ngfftdg]].
         <br />
         If space parallelisation is used (that is, if [[paral_kgb]]==1), then it becomes the
        number of Fast Fourier Transform points attributed to the
        particular processor. It is no longer the above-mentioned simple product,
        but a number usually close to this product divided by the
        number of processors on which the space is shared.
        </p>
    topics: Planewaves_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: nfreq@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of FREQuencies
    requires: null
    text: |-
        <p>Number of frequencies wanted for the frequency-dependent dielectric tensor. Should be positive.
        See [[anaddb:dieflag]].

        The code will take <b>nfreq</b> equidistant values from [[anaddb:frmin]] to [[anaddb:frmax]].
    topics: Phonons_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nfreqim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of FREQuencies along the IMaginary axis
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,12,22,9,19,29]'
    text: |-
        <p>
         [[nfreqim]] sets the number of pure imaginary frequencies used to calculate
        the dielectric matrix in order to perform the numerical integration of the GW self-energy.
        </p>
    topics: FrequencyMeshMBPT_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: nfreqmidm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Nth FREQuency Moment of the Imaginary part of the Dielectric Matrix
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         depending on the value of
         [[nfreqmidm]]
         will calculate the frequency moment of the Dielectric matrix or its inverse,

        <ul>
        <li>if [[nfreqmidm]] is positive : calculate (nth=[[nfreqmidm]]) frequency moment of the Dielectric matrix</li>
        <li>if [[nfreqmidm]] is negative : calculate (nth=[[nfreqmidm]]) frequency moment of the inverse Dielectric matrix</li>
        <li>if [[nfreqmidm]] = 0 : calculate first frequency moment of the full polarizability</li>
        </ul>

        see M. Taut, J. Phys. C: Solid State Phys. 18 (1985) 2677-2690.
        </p>
    topics: FrequencyMeshMBPT_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: nfreqre
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of FREQuencies along the REal axis
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,12,22,9,19,29]'
    text: |-
        <p>
         [[nfreqre]] sets the number of real frequencies used to calculate
        the dielectric matrix in order to perform the numerical integration of the GW self-energy.
        </p>
        <p>
         It can be used also in case of GW calculations with plasmon-pole models,
         <i>
          i.e
         </i>
         [[gwcalctyp]]&lt;10,
        to reduce the number of frequencies used to evaluate the dielectric matrix from the (default) two to
        one frequency (omega=0) by setting [[nfreqre]]=1.
        This might be a good idea in case one is planning to use ppmodel&gt;1.
        This will force the calculation of the screening on a single frequency (omega=0) and hence
        reduce memory and disk space requirement.
        The only draw back is that the user will not be able to perform self energy calculation using
        [[ppmodel]]=1,
        since in the last case the dielectric matrix calculated on two frequencies is required.
        If the user is not sure which ppmodel to use, then s/he is not advised
        to use this input variable.
        Using the default values, one must be able to get a screening file that can be used with any ppmodel.
        </p>
    topics: FrequencyMeshMBPT_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: nfreqsp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of FREQuencies for the SPectral function
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[nfreqsp]] defines the number of real frequencies used to calculate the spectral function
        of the GW Green's function.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: ng2qpt@anaddb
    characteristics: null
    commentdefault: (will not work)
    commentdims: null
    defaultval: 3*0
    dimensions:
    - 3
    excludes: null
    mnemonics: Number of Grids points for Q PoinTs (grid 2)
    requires: null
    text: |-
        <p>The Monkhorst-Pack grid linear dimensions, for the finer of the
        series of fine grids. Used for the integration
        of thermodynamical functions (Bose-Einstein distribution)
        or for the DOS.
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ngfft
    characteristics: null
    commentdefault: (automatic selection of optimal values)
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Number of Grid points for Fast Fourier Transform
    requires: null
    text: |-
        <p>
         gives the size of fast Fourier transform
        (fft) grid in three dimensions.  Each number must be
        composed of the factors 2, 3, and 5 to be consistent with
        the radices available in our fft.  If no [[ngfft]] is provided or
        if [[ngfft]] is set to 0 0 0, the code will automatically provide
        an optimal set of [[ngfft]] values, based on [[acell]],
        [[rprim]] and [[ecut]]
        (see also [[boxcutmin]] for speed/accuracy concerns).
        This is the recommended procedure, of course.
         <br />
         The total number of FFT points
        is the product:
         <br />
         <tele>
          [[ngfft]](1)*[[ngfft]](2)*[[ngfft]](3)=nfft
         </tele>
         .
         <br />
         When [[ngfft]] is made smaller
        than recommended values (e.g. by setting [[boxcutmin]]
        to a value smaller than 2.0 or by setting [[ngfft]] manually), the code runs faster and the
        equations in effect are approximated by a low pass Fourier
        filter.  The code reports to standard output (unit 06) a
        parameter "boxcut" which is the smallest ratio of the fft
        box side to the G vector basis sphere diameter.  When
        boxcut is less than 2 the Fourier filter approximation is being
        used.  When boxcut gets less than about 1.5 the
        approximation may be too severe for realistic results
        and should be tested against larger values of [[ngfft]].
        When boxcut is larger than 2, [[ngfft]] could be reduced without
        loss of accuracy. In this case, the small variations
        that are observed are solely due to the
        xc quadrature, that may be handled with [[intxc]]=1
        to even reduce this effect.
        </p>
        <p>
         Internally, [[ngfft]] is an array of size 18. The present
        components are stored in [[ngfft]](1:3), while
         <ul>
          <li>
           [[ngfft]](4:6) contains slightly different (larger) values,
        modified for efficiency of the FFT
          </li>
          <li>
           [[ngfft]](7) is [[fftalg]]
          </li>
          <li>
           [[ngfft]](8) is [[fftcache]]
          </li>
          <li>
           [[ngfft]](9) is set to 0 if the parallelization of the FFT is not activated,
        while it is set to 1 if it is activated.
          </li>
          <li>
           [[ngfft]](10) is the number of processors of the FFT group
          </li>
          <li>
           [[ngfft]](11) is the index of the processor in the group of processors
          </li>
          <li>
           [[ngfft]](12) is n2proc, the number of x-z planes, in reciprocal space, treated by the processor
          </li>
          <li>
           [[ngfft]](13) is n3proc, the number of x-y planes, in real space, treated by the processor
          </li>
          <li>
           [[ngfft]](14) is mpi_comm_fft, the handle on the MPI communicator in charge of the FFT parallelisation
          </li>
          <li>
           [[ngfft]](15:18) are not yet used
          </li>
         </ul>
         <br />
         The number of points stored by this processor in real space is n1*n2*n3proc, while in reciprocal
        space, it is n1*n2proc*n3.
        </p>
    topics: Planewaves_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: ngfftdg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: 'Number of Grid points for Fast Fourier Transform : Double
        Grid'
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         This variable has the same meaning as ngfft (gives the size of fast Fourier
        transform (fft) grid in three dimensions) but concerns the "double
        grid" only used for PAW calculations.
        </p>
    topics: PAW_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: ngkpt
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: specified([[kptrlatt]])
    mnemonics: Number of Grid points for K PoinTs generation
    requires: '[[kptopt]] >=0, '
    text: |-
        <p>
         Used when [[kptopt]]&gt;=0,
        if [[kptrlatt]]
        has not been defined ([[kptrlatt]]
        and [[ngkpt]] are exclusive of each other).
         <br />
         Its three positive components
        give the number of k points of Monkhorst-Pack grids
        (defined with respect to primitive axis in reciprocal space)
        in each of the three dimensions.
        [[ngkpt]] will be used to generate the
        corresponding [[kptrlatt]]
        input variable.
        The use of [[nshiftk]]
        and [[shiftk]], allows to generate
        shifted grids, or Monkhorst-Pack grids defined
        with respect to conventional unit cells.
        </p>
        <p>
         When [[nshiftk]]=1,
        [[kptrlatt]] is initialized
        as a diagonal (3x3) matrix, whose diagonal elements
        are the three values [[ngkpt]](1:3). When
        [[nshiftk]] is greater than 1,
        ABINIT will try to generate [[kptrlatt]]
        on the basis of the primitive vectors of the k-lattice:
        the number of shifts might be reduced, in which case
        [[kptrlatt]] will not be diagonal
        anymore.
        </p>
        <p>
         Monkhorst-Pack grids are usually the most efficient when
        their defining integer numbers are even.
        For a measure of the efficiency, see the input variable
        [[kptrlen]].
        </p>
    topics: k-points_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: ngqpt
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: specified([[qptrlatt]])
    mnemonics: Number of Grid pointsfor Q PoinTs generation
    requires: '[[nqpt]]==1 and [[kptopt]]>=0'
    text: |-
        <p>
         At variance with [[ngkpt]], note that only one q point
        is selected per dataset (see [[iqpt]]).
         <br />
         Its three positive components
        give the number of q points of Monkhorst-Pack grids
        (defined with respect to primitive axis in reciprocal space)
        in each of the three dimensions.
        The use of [[nshiftq]]
        and [[shiftq]], allows to generate
        shifted grids, or Monkhorst-Pack grids defined
        with respect to conventional unit cells.
        </p>
        <p>
         For more information on Monkhorst-Pack grids, see [[ngkpt]].
        </p>
    topics: q-points_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: ngqpt@anaddb
    characteristics: null
    commentdefault: (will not work)
    commentdims: null
    defaultval: 3*0
    dimensions:
    - 3
    excludes: null
    mnemonics: Number of Grids points for Q PoinTs
    requires: null
    text: |-
        <p>The Monkhorst-Pack grid linear dimensions, for the DDB (coarse grid).
    topics: Phonons_basic, PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ngrid@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 2
        value: 30
    dimensions:
    - 2
    excludes: null
    mnemonics: Number of GRID points
    requires: null
    text: |-
        Defines the grid in real space, for the density
          and laplacian outputs, governed by
          [[aim:denout]] and
          [[aim:lapout]].
    topics: Bader_expert
    varset: aim
    vartype: integer
- !variable
    abivarname: ngrids@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 4
    dimensions: scalar
    excludes: null
    mnemonics: Number of GRIDS
    requires: null
    text: |-
        <p>This number define the series of grids that will be used
        for the estimation of the phonon DOS. The coarsest will be
        tried first, then the next, ... then the one described by
        [[anaddb:ng2qpt]].
        The intermediate grids are defined
        for igrid=1... <b>ngrids</b>,
        by the numbers ngqpt_igrid(ii)=(ng2qpt(ii)*igrid)/<b>ngrids</b>
    topics: PhononBands_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nimage
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of IMAGEs
    requires: null
    text: |-
        <p>
         Give the number of images (or replicas) of the system,
        for which the forces and stresses might be computed independently,
        in the context of the string method, the genetic algorithm, hyperdynamics or Path-Integral Molecular Dynamics
        depending on the value of [[imgmov]]).
        Related input variables : [[dynimage]],
        [[npimage]], [[ntimimage]]
        and [[prtvolimg]].
         <br />
         Images might differ by the position of atoms in the unit cell, their
        velocity, as well as by their cell geometry. The following input variables might be used to define
        the images :
         <ul>
          <li>
           [[acell]]
          </li>
          <li>
           [[amu]]
          </li>
          <li>
           [[angdeg]]
          </li>
          <li>
           [[dmatpawu]]
          </li>
          <li>
           [[jpawu]]
          </li>
         <li>
           [[mixalch]]
          </li>
          <li>
           [[rprim]]
          </li>
          <li>
           [[upawu]]
          </li>
         <li>
           [[vel]]
          </li>
         <li>
           [[vel_cell]]
          </li>
          <li>
           [[xangst]]
          </li>
          <li>
           [[xcart]]
          </li>
          <li>
           [[xred]]
          </li>
         </ul>
         These input variables, non-modified, will be used to define the image with index 1.
        For the image with the last index, the input file might specify the values
        of such input variables, appended with "_lastimg", e.g. :
         <ul>
          <li>
            acell_lastimg
          </li>
           <li>
            rprim_lastimg
          </li>
           <li>
            xcart_lastimg
          </li>
          <li>
            ...
          </li>
          </ul>
         By default, these values will be interpolated linearly to define values for the other images, unless
        there exist specific values for some images, for which the string "last" has to be replaced by the
        index of the image, e.g. for the image number 4 :
         <ul>
          <li>
            acell_4img
          </li>
           <li>
            rprim_4img
          </li>
           <li>
            xcart_4img
          </li>
          <li>
           ...
          </li>
         </ul>
         It is notably possible to specify the starting point and the end point of the path (of images), while specifying intermediate points.
         <br />
         <br />
         It usually happen that the images do not have the same symmetries and space group.
        ABINIT has not been designed to use different set of symmetries for different images.
        ABINIT will use the symmetry and space group of the image number 2, that
        is expected to have a low number of symmetries.
        This might lead to erroneous calculations, in case some image has even less
        symmetry. By contrast, there is no problem if some other image has more symmetries
        than those of the second image.
        </p>
    topics: PIMD_compulsory, TransPath_compulsory
    varset: rlx
    vartype: integer
- !variable
    abivarname: nkpath
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of K-points defining the PATH
    requires: null
    text: |-
        This variable is used to define the number of high-symmetry k-points in the [[kptbounds]] array when [[kptopt]] > 0.
        Historically, [[kptbounds]] is used in conjuction with a negative
        value of [[kptopt]] when performing a NSCF band structure calculation. In this case, the number of k-points in kptbounds
        is given by abs(kptopt) + 1.

        There are, however, other cases in which one has to specify a k-path in the input file in order to activate some kind of post-processing tool.
        Typical examples are the interpolation of
        the GW corrections at the end of the sigma run or the interpolation
        of the KS eigenvalues along a path at the end of the SCF run (see
        also [[einterp]])
        In a nutshell, nkpath replaces [[kptopt]] when we are not performing a NSCF calculation.
        Note that, unlike [[kptopt]], nkpath represents the total number of points in the [[kptbounds]] array.
    topics: k-points_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: nkpt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[kptopt]]==0': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of K - Points
    requires: null
    text: |-
        <p>
         If non-zero,
        [[nkpt]]
        gives the number of k points in the k point array
        [[kpt]]. These points
        are used either to sample the Brillouin zone, or to
        build a band structure along specified lines.
        </p>
        <p>
         If [[nkpt]] is zero, the code deduces from other input variables
        (see the list in the description of [[kptopt]])
        the number of k points, which is possible only
        when [[kptopt]]/=0.
        If [[kptopt]]/=0 and
        the input value of [[nkpt]]/=0,
        then ABINIT will check that the number of k points
        generated from the other input variables
        is exactly the same than [[nkpt]].
        </p>
        <p>
         If [[kptopt]] is positive,
        [[nkpt]] must be coherent with the values
        of [[kptrlatt]],
        [[nshiftk]]
        and [[shiftk]].
         <br />
         For ground state calculations, one should select the
        k point in the irreducible Brillouin Zone (obtained
        by taking into account point symmetries and the time-reversal
        symmetry).
         <br />
         For response function calculations, one should
        select k points in the full Brillouin zone, if the wavevector
        of the perturbation does not vanish, or in a half of
        the Brillouin Zone if q=0. The code will automatically decrease
        the number of k points to the minimal set needed for
        each particular perturbation.
        </p>
        <p>
         If [[kptopt]] is negative,
        [[nkpt]] will be the sum of the number of points on
        the different lines of the band structure.
        For example,
        if [[kptopt]]=-3, one
        will have three segments; supposing
        [[ndivk]] is 10 12 17,
        the total number of k points of the circuit will be
        10+12+17+1(for the final point)=40.
        </p>
    topics: k-points_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: nkptgw
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of K-PoinTs for GW corrections
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         [[nkptgw]] gives the number of k-points for which the GW calculation must be done.
        It is used to dimension [[kptgw]]
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: nkpthf
    characteristics: null
    commentdefault: ' the total number of k-point in the full Brillouin zone
        (TODO : provide the mathematical formulation)'
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of K - Points for (Hartree) Fock exact exchange
    requires: null
    text: |-
        <p>
         [[nkpthf]] gives the number of k points used to sample the full Brillouin zone for the Fock exact exchange contribution.
        </p>
    topics: Hybrids_expert
    varset: basic
    vartype: integer
- !variable
    abivarname: nlflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Non-Linear FLAG
    requires: null
    text: |-
        <p>Non-linear properties flag.
        <ul>
          <li>0 => do not compute non-linear properties ;</li>
          <li>1 => the electrooptic tensor, Raman susceptibilities and non-linear optical
            susceptibilities are calculated;</li>
          <li>2 => only the non-linear optical susceptibilities and first-order
            changes of the dielectric tensor induced by an atomic displacement are calculated;</li>
          <li>3 => only the non-linear optical susceptibility is calculated.</li>
        </ul>
    topics: nonlinear_compulsory
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nline
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 4
    dimensions: scalar
    excludes: null
    mnemonics: Number of LINE minimisations
    requires: null
    text: |-
        <p>
         Gives maximum number of line minimizations
        allowed in preconditioned conjugate gradient minimization
        for each band. The Default, 4, is fine.
         <br />
         Special cases, with degeneracies or near-degeneracies
        of levels at the Fermi energy may require a larger value of
        [[nline]] (5 or 6 ?)
        Line minimizations will be stopped anyway when improvement
        gets small (governed by [[tolrde]]). With the input variable [[nnsclo]],
        governs the convergence of the wavefunctions
        for fixed potential.
         <br />
         Note that [[nline]]=0 can be used to diagonalize the Hamiltonian
        matrix in the subspace spanned by the input wavefunctions.
        </p>
    topics: SCFControl_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: nloc_alg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 4
    dimensions: scalar
    excludes: null
    mnemonics: Non LOCal ALGorithm
    requires: null
    text: |-
        <p>
        Allows to choose the algorithm for non-local operator application.
        On super-scalar architectures, the default [[nloc_alg]]=4 is the best.
         <br />
         More detailed explanations:
         <br />
         <div style="margin-left: 40px;">
          - [[nloc_alg]]=2 : Should be efficient on vector machines. It is
        indeed the fastest algorithm for the NEC, but
        actual tests on Fujitsu machine did not gave better
        performances than the other options.
          <br />
          - [[nloc_alg]]=3 : same as [[nloc_alg]]==2, but the loop order is inverted.
          <br />
          - [[nloc_alg]]=4 : same as [[nloc_alg]]==3, but maximal use of registers
        has been coded. This should be especially efficient on
        scalar and super-scalar machines. This has been confirmed by tests.
          <br />
         </div>
         Note: internally, [[nloc_alg]] is stored in
         <i>
          nloalg(1)
         </i>
         . See also [[nloc_mem]] for the tuning of the memory used in the non-local operator application.
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nloc_mem
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==1': 2
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Non LOCal MEMOry
    requires: null
    text: |-
        <p>
        Controls the memory use for the application of the non-local operator.
         <br />
         More detailed explanations:
         <br />
         <div style="margin-left: 40px;">
          - [[nloc_mem]]==1 : (k+G) vectors are not precomputed, in order to save memory space.
          <br />
          - [[nloc_mem]]==2 : (k+G) vectors are precomputed, once per k-point.
          <br />
          - [[nloc_mem]]==-1 or -2 : Negative values of [[nloc_mem]] correspond positive ones,
        where the phase precomputation has been suppressed, in order to save memory space, as an array
          <i>
           double precision :: ph3d(2,npw,[[natom]])
          </i>
          is saved (typically half the space needed
        for the wavefunctions at 1 k point - this corresponds
        to the silicon case). However, the computation of phases
        inside nonlop is somehow time-consuming.
          <br />
         </div>
         <br />
         Note: internally, sign([[nloc_mem]]) is stored in
         <i>
          nloalg(2)
         </i>
         and abs([[nloc_mem]])-1 is stored in
         <i>
          nloalg(3)
         </i>
         . See also [[nloc_alg]] for the algorithm for the non-local operator application.
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nnos
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of NOSe masses
    requires: null
    text: |-
        <p>
         Gives the number of thermostats in the Martyna et al. chain of oscillators thermostats.
         The thermostat chains can be used either to perform Molecular Dynamics (MD) ([[ionmov]]=13) or to perform Path Integral Molecular Dynamics (PIMD) ([[imgmov]]=13). <br />
         The mass of these thermostats is given by [[qmass]].  <br />
        </p>
    topics: PIMD_basic, MolecularDynamics_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: nnsclo
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Non-Self Consistent LOops
    requires: null
    text: |-
        <p>
         Gives the maximum number of
        non-self-consistent loops of [[nline]] line minimisations,
        in the SCF case (when [[iscf]] &gt;0).  In the case [[iscf]] &lt;=0 ,
        the number of non-self-consistent loops is determined
        by [[nstep]].
         <br />
         The Default value of 0 -- for standard plane-wave calculations -- corresponds to make
        the two first fixed potential determinations
        of wavefunctions have 2 non-self consistent loops,
        and the next ones to have only 1 non-self consistent loop.
         <br />
         The Default value of 0 -- for wavelets calculations ([[usewvl]]=1) -- corresponds to make
        2 steps with 3 non-self consistent loops , 2 steps with 2 non-self consistent loops,
        then the next ones with 1 non-self consistent loop.
        </p>
    topics: SCFControl_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nnsclohf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usefock]]==1': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Non-Self Consistent LOops for (Hartree)-Fock exact exchange
    requires: null
    text: |-
        <p>
         Gives the maximum number of loops with non-self-consistent occupied states used to calculate Fock exact exchange,
        in the SCF case.
         <br />
         The Default value is 0 when [[usefock]] = 0.
        Default value is 1 when [[usefock]] = 1 and correspond to update occupied
        wavefunctions at each self-consistent loop.
        </p>
    topics: Hybrids_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nobj
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of OBJects
    requires: null
    text: |-
        <p>
         Gives the number of 'objects'
        to be used by the atom manipulator in order to find the full
        set of atoms. At present, only one or two objects
        can be defined, identified as objects 'a' and 'b'.
         <br />
         Related variables for object 'a' are : [[objan]],
        [[objaat]],
        [[objarf]], [[objatr]],
        [[objaro]], [[objaax]]. Related variables
        for object 'b' are :
          [[objbn]]
         ,
          [[objbat]]
         ,
          [[objbrf]]
         ,
          [[objbtr]]
         ,
          [[objbro]]
         ,
          [[objbax]]
         .
         <br />
         <p>More detailed explanation : when the atom manipulator
        is used (i.e. when [[nobj]]==1 or [[nobj]]==2), the code
        will be given a primitive set of atoms, from which it
        will have to deduce the full set of atoms.
         <br />
         An object will be specified by the number of
        atoms it includes ([[objan]] or
          [[objbn]]
         ),
        and the list of these atoms ([[objaat]] or
          [[objbat]]
         ).
         <br />
         Examples of physical realisation of an object can be a molecule,
        or a group of atom to be repeated, or a part of a molecule
        to be rotated.
        The atom amnipulator can indeed repeat these objects ([[objarf]]
        or
          [[objbrf]]
         ), rotate them ([[objaro]] or
          [[objbro]]
         ) with respect
        to an axis ([[objaax]] or
          [[objbax]]
         ), and translate them
        ([[objatr]] or
          [[objbtr]]
         ).
        After having generated a geometry
        thanks to rotation, translation and repetition of objects,
        it is possible to remove some atoms, in order to create
        vacancies ([[vacnum]] and [[vaclst]]).
        The number of atoms in the primitive
        set, those that will be read from the input file, is
        specified by the variable [[natrd]]. It will be always smaller
        than the final number of atoms, given by the variable [[natom]].
        The code checks whether the primitive number of atoms
        plus those obtained by the repetition operation is
        coherent with the variable [[natom]], taking into
        account possible vacancies.
         <br />
         You should look
        at the other variables for more information.
        Go to [[objan]], for example.
         <br />
        </p>
    topics: AtomManipulator_compulsory
    varset: geo
    vartype: integer
- !variable
    abivarname: nomegasf
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of OMEGA to evaluate the Spectral Function
    requires: '[[optdriver]]==3 and [[spmeth]]!=0'
    text: |-
        <p>
         [[nomegasf]] defines the number of real frequencies used to describe the spectral function
        associated to the irreducible polarizability $\chi^{(0)}_{KS}$.
        The frequency mesh will cover the interval between 0 and the maximum (positive) transition
        energy between occupied and empty states.
        The delta function entering the expression defining the spectral function is approximated using two
        different methods according to the value of the [[spmeth]] input variable.
        </p>
        <p>
         It is important to notice that an accurate description of the imaginary part of $\chi^{(0)}_{KS}$
        requires an extremely dense frequency mesh. It should be kept in mind, however, that the memory required
        grows fast with the value of [[nomegasf]].
        </p>
    topics: Susceptibility_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: nomegasi
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 12
    dimensions: scalar
    excludes: null
    mnemonics: Number of OMEGA(S) along the Imaginary axis
    requires: '[[optdriver]]==4 and [[gwcalctyp]]==1'
    text: |-
        <p>
         [[nomegasi]] defines the number of frequency points used to sample the self-energy along the
        imaginary axis. The frequency mesh is linear and covers the interval between OMEGASIMIN=0.01 Hartree and
        [[omegasimax]].
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: nomegasrd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 9
    dimensions: scalar
    excludes: null
    mnemonics: Number of OMEGA to evaluate the Sigma Real axis Derivative
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         The number of real frequencies around the KS energy where the self-energy Sigma is evaluated.
        From these values, the derivative of Sigma at the KS energy is numerically estimated through linear interpolation.
        </p>
    topics: SelfEnergy_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: nonlin_comp@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    -   - num_nonlin_comp
    excludes: null
    mnemonics: NON-LINear COMPonents
    requires: null
    text: |-
        This tells which component of the dielectric tensor you want to calculate.
          These numbers are called a, b and c in <a href="../../users/generated_files/help_optic.html#Ref1">Ref. 1</a>. 1 2 3 represent x y
          and z respectively. For example 111 would be xxx and 321 would mean zyx.
    topics: Optic_basic
    varset: optic
    vartype: integer
- !variable
    abivarname: normpawu
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: NORMalize atomic PAW+U projector
    requires: null
    text: |-
        <p>
         Defines whether the atomic wave function (used as projectors in PAW+U) should be renormalized to 1
        within PAW sphere.
         <ul>
          <li>
           [[normpawu]]=0 : leave projector
          </li>
          <li>
           [[normpawu]]=1 : renormalize
          </li>
         </ul>
        </p>
    topics: DFT+U_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: noseinert
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100000
    dimensions: scalar
    excludes: null
    mnemonics: NOSE thermostat INERTia factor
    requires: '[[ionmov]]==8'
    text: |-
        <p>
        Give the inertia factor WT of the Nose-Hoover thermostat (when [[ionmov]]=8), in atomic units of weight*length2, that is (electron mass)*(Bohr)2. The equations of motion are :
        MI d2RI/dt2= FI - dX/dt MI dRI/dt
        and
        WT d2X/dt2= Sum(I) MI (dRI/dt)2 - 3NkBT
        where I represent each nucleus, MI is the mass of each nucleus (see [[amu]]), RI is the coordinate of each nucleus (see [[xcart]]), dX/dt is a dynamical friction coefficient, and T is the temperature of the thermostat (see [[mdtemp]]).
        </p>
    topics: MolecularDynamics_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: np_slk
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1000000
    dimensions: scalar
    excludes: null
    mnemonics: Number of mpi Processors used for ScaLapacK calls
    requires: '[[optdriver]]==1 and [[paral_kgb]]==1 (Ground-state calculations
        with LOBPCG algorithm)'
    text: |-
        <p>
         When using Scalapack (or any similar Matrix Algebra library), the efficiency of the eigenproblem resolution saturates as the number of CPU cores
        increases. It is better to use a smaller number of CPU cores for the LINALG calls.
         <br />
         This maximum number of cores can be set with [[np_slk]].
         <br />
         A large number for [[np_slk]] (i.e. 1000000) means that all cores are used for the
        Linear Algebra calls.
         <br />
         np_slk must divide the number of processors involved in diagonalizations ([[npband]]*[[npfft]]*[[npspinor]]).
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: integer
- !variable
    abivarname: npband
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors at the BAND level
    requires: '[[paral_kgb]]==1'
    text: |-
        <p>
         Relevant only for the band/FFT parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npband]] gives the number of processors among which the work load over the band level is shared.
        [[npband]], [[npfft]],
        [[npkpt]] and [[npspinor]]
        are combined to give the total number
        of processors (nproc) working on the band/FFT/k-point parallelisation.
         <br />
         See [[npfft]], [[npkpt]],
        [[npspinor]] and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.
        [[npband]] has to be a divisor or equal to [[nband]]
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: npfft
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors at the FFT level
    requires: '[[paral_kgb]]==1'
    text: |-
        <p>
         Relevant only for the band/FFT/k-point parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npfft]] gives the number of processors among
        which the work load over the FFT level is shared.
        [[npfft]], [[npkpt]],
        [[npband]] and [[npspinor]]
        are combined to give the total number
        of processors (nproc) working on the band/FFT/k-point parallelisation.
         <br />
         See [[npband]], [[npkpt]],
        [[npspinor]], and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.
        </p>
        <p>
         Note : [[ngfft]] is automatically adjusted to [[npfft]].
        If the number of processor is changed from a calculation to another one,
        [[npfft]] may change, and then [[ngfft]] also.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: nph1l@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of PHonons in List 1
    requires: null
    text: |-
        <p>The number of wavevectors in phonon list 1, used for interpolation of the phonon frequencies. The
        values of these wavevectors will be specified by [[anaddb:qph1l]].
        The dynamical matrix for these wavevectors, obtained
        either directly from the DDB - if
        [[anaddb:ifcflag]]=0 - or through
        the interatomic forces interpolation - if
        [[anaddb:ifcflag]]=1 -),
        will be diagonalized, and the corresponding eigenfrequencies
        will be printed.
    topics: PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nph2l@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of PHonons in List 2
    requires: null
    text: |-
        <p>The number of wavevectors in phonon list 2, defining the directions
        along which the non-analytical splitting of phonon frequencies
        at Gamma will be calculated. The actual
        values of the wavevector directions will be specified
        by [[anaddb:qph2l]].
        These are actually all wavectors at Gamma, but obtained
        by a limit along a different direction in the Brillouin-zone.
        It is important to note that non-analyticities in the
        dynamical matrices are present at Gamma, due to the
        long-range Coulomb forces. So, going to Gamma along different
        directions can give different results.
        <p>
        The wavevectors in list 2 will be used to:
        <br>

        - generate and diagonalize a dynamical matrix, and print the
             corresponding eigenvalues.

        <br>

        - calculate the generalized Lyddane-Sachs-Teller relation.
           Note that if the three first numbers are zero, then
           the code will do a calculation at Gamma without
           non-analyticities.
    topics: PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nphf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors for (Hartree)-Fock exact exchange
    requires: null
    text: |-
        <p>
         Relevant only for the k-point/fock parallelisation
        (option [[paral_kgb]] input variable).
         <br />
         [[nphf]] gives the number of processors among
        which the work load over the occupied states level is shared.
        [[nphf]] and [[npkpt]] are combined to give the total number
        of processors (nproc) working on the parallelisation.
         <br />
        </p>
        <p>
         Note : [[nphf]] should be a divisor or equal to the number of k-point times the number of bands for
        exact exchange ([[nkpthf]]*[[nbandhf]])
        in order to have the better load-balancing and efficiency.
         <br />
        </p>
    topics: Hybrids_useful, parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: nphi@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 48
    dimensions: scalar
    excludes: null
    mnemonics: Number of PHI angle
    requires: null
    text: |-
        With [[aim:ntheta]], this
          variable defines the angular grid for the integration
          within the Bader volume, in particular, the number
          of phi angles, to be used between
          [[aim:phimin]] and
          [[aim:phimax]].
          When the difference between these two variables
          is 2 pi, the recommended value of <b>nphi</b> is 48.
          When it is pi (for symmetry reasons), the recommended
          value is 32. When it is pi/2 (for symmetry reasons),
          the recommended value is 20.
    topics: Bader_basic
    varset: aim
    vartype: integer
- !variable
    abivarname: npimage
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors at the IMAGE level
    requires: null
    text: |-
        <p>
         Relevant only
        when sets of images are activated (see [[imgmov]]
        and [[nimage]] ).
         <br />
         [[npimage]] gives the number of processors among
        which the work load over the image level is shared. It is compatible with all other parallelization
        levels available for ground-state calculations.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
         <br ><br>
        <i>See [[paral_kgb]], [[npkpt]], [[npband]], [[npfft]]
        and [[npspinor]] for the additional information on the use of k-point/band/FFT parallelisation.
         </i>
        </p>
    topics: parallelism_useful, PIMD_useful, TransPath_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: npkpt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors at the K-Point Level
    requires: '[[paral_kgb]]==1'
    text: |-
        <p>
         Relevant only for the band/FFT/k-point parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npkpt]] gives the number of processors among
        which the work load over the k-point/spin-component level is shared.
        [[npkpt]], [[npfft]], [[npband]] and
        [[npspinor]] are combined to give the total number
        of processors (nproc) working on the band/FFT/k-point parallelisation.
         <br />
         See [[npband]], [[npfft]],
        [[npspinor]] and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.
        </p>
        [[npkpt]] should be a divisor or equal to with the number of k-point/spin-components
        ([[nkpt]]*[[nsppol]])
        in order to have the better load-balancing and efficiency.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: nppert
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors at the PERTurbation level
    requires: '[[paral_rf]]==1'
    text: |-
        <p>
         This parameter is used in connection to the parallelization over perturbations(see [[paral_rf]] ),
        for a linear response calculation.
        [[nppert]] gives the number of processors among which the work load over the perturbation level is shared.
        It can even be specified separately for each dataset.
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: npsp
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[ntypat]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of PSeudoPotentials
    requires: null
    text: |-
        <p>
         Usually, the number of pseudopotentials to be read is equal
        to the number of type of atoms. However,
        in the case an alchemical mixing of pseudopotential is to be used,
        often the number of pseudopotentials to be read will not equal the number of types of atoms.
        </p>
        <p>
         Alchemical pseudopotentials will be present
        when [[ntypalch]] is non-zero.
        See [[ntypalch]]
        to understand how
        to use alchemical potentials in ABINIT.
        The input variables
        ([[ntypalch]],
        [[algalch]],[[mixalch]])
        are active, and generate alchemical potentials from the available
        pseudopotentials. Also, the inner variables
        ([[ntyppure]],[[npspalch]])
        become active. See these input variables, especially
        [[mixalch]], to understand how
        to use alchemical potentials in ABINIT.
        </p>
    topics: AtomTypes_useful, PseudosPAW_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: npspalch
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[npsp]]-[[ntyppure]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of PSeudoPotentials that are "ALCHemical"
    requires: '[[ntypalch]]/=0'
    text: |-
        <p>
         Gives the number of pseudopotentials that are used for alchemical mixing (when [[ntypalch]] is non-zero) :
        </p>
        <p>
         [[npspalch]]=[[npsp]]-[[ntyppure]]
        </p>
    topics: AtomTypes_internal
    varset: gstate
    vartype: integer
- !variable
    abivarname: npspinor
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Processors at the SPINOR level
    requires: '[[paral_kgb]]==1'
    text: |-
        <p>
         Can be 1 or 2 (if [[nspinor]]=2).
         <br />
         Relevant only for the band/FFT/k-point parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npspinor]] gives the number of processors among
        which the work load over the spinorial components of wave-functions is shared.
        [[npspinor]], [[npfft]],
        [[npband]] and [[npkpt]]
        are combined to give the total number of processors (nproc)
        working on the band/FFT/k-point parallelisation.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
         <br><br>
        <i>See [[npkpt]], [[npband]],
        [[npfft]], and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.</i>
         <br />
        </p>
    topics: parallelism_useful
    varset: paral
    vartype: integer
- !variable
    abivarname: npulayit
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 7
    dimensions: scalar
    excludes: null
    mnemonics: Number of PULAY ITerations for SC mixing
    requires: '[[iscf]] in [7,17]'
    text: |-
        <p>
         Gives the  number of previous iterations involved in Pulay mixing (mixing
        during electronic SC iterations).
        </p>
    topics: SCFAlgorithms_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: npvel
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Particle VELocities
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         In the context of the electronic stopping power of impinging ion in matter,
        [[npvel]] sets the number of the ion velocities to be calculated via linear response.
         <br />
         When [[npvel]]=0, no stopping power calculation is performed.
         <br />
         The direction and the velocity maximum are set with the input variable [[pvelmax]].
        Note that the results are output for a Z=1 impinging ion, i.e. a proton.
        </p>
    topics: RandStopPow_compulsory
    varset: gw
    vartype: integer
- !variable
    abivarname: npweps
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of PlaneWaves for EPSilon (the dielectric matrix)
    requires: null
    text: |-
        <p>
         [[npweps]] determines the size of the planewave set used to represent the independent-particle
        susceptibility $\chi^{(0)}_{KS}$, the dielectric matrix $\epsilon$ and its inverse.
         <br />
        It is an internal variable, determined from [[ecuteps]].
        </p>
    topics: Susceptibility_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: npwkss
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of PlaneWaves in the KSS file
    requires: null
    text: |-
        <p>
         This input variable is used for the preparation of a GW calculation:
        the GS run (where [[optdriver]]=1 and
         <b>
          nbandkss
         </b>
         /=0) should be followed
        with a run where [[optdriver]]=3.
        Also, if [[nbandkss]]=0, no use of [[npwkss]].
        </p>
        <p>
         [[npwkss]] defines the number of planewave components of the Kohn-Sham states
        to build the Hamiltonian, in the routine outkss.F90, and so, the size of the matrix, the size of eigenvectors,
        and the number of available states, to be stored in the abo_KSS file.
        If it is set to 0, then, the planewave basis set defined by the usual Ground State input variable
        [[ecut]] is used to generate the superset of all planewaves used for all k-points.
        Note that this (large) planewave basis is the same for all k-points.
        </p>
        <p>
         Very important : for the time being, [[istwfk]] must be 1 for all the k-points.
        </p>
    topics: Susceptibility_expert, SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: npwsigx
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of PlaneWaves for SIGma eXchange
    requires: null
    text: |-
        <p>
         [[npwsigx]] determines the cut-off energy of the planewave set used to generate the
        exchange part of the self-energy operator.
         <br />
        It is an internal variable, determed from [[ecutsigx]].
        </p>
    topics: SelfEnergy_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: npwwfn
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of PlaneWaves for WaveFunctioNs
    requires: null
    text: |-
        <p>
         [[npwwfn]] is the size of the planewave set used to represent the wavefunctions
        in the formula that generates the independent-particle susceptibility $\chi^{(0)}_{KS}$.
        It is an internal variable, determined from [[ecutwfn]].
        </p>
    topics: Susceptibility_internal, SelfEnergy_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: nqpath@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Q wavevectors defining a PATH
    requires: null
    text: |-
        <p>Number of q-points in the array [[anaddb:qpath]]
        defining the path along which the phonon band structure and phonon linewidths
        are interpolated.
    topics: PhononBands_basic, PhononWidth_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nqpt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Q - POINTs
    requires: null
    text: |-
        <p>
         Determines whether one q point
        must be read (See the variable [[qptn]]).
         <br />
         Can be either 0 or 1.
         <br />
         If 1 and used in ground-state calculation,
        a global shift of all the k-points is applied, to give
        calculation at k+q.
        In this case, the output wavefunction will be appended
        by _WFQ instead of _WFK (see the
         <a href="../../users/generated_files/help_abinit.html">
          section 4
         </a>
         of the [[help_abinit]])
        Also, if 1 and a RF calculation is done, defines the
        wavevector of the perturbation.
        </p>
    topics: q-points_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: nqptdm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of Q-PoinTs for the Dielectric Matrix
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         If [[nqptdm]] is equal to 0, the set of q-points for computing the dielectric matrix is
        determined automatically considering all the possible differences between the k-points contained
        in the _KSS file. When [[nqptdm]] is non-zero, the list of q points is read from [[qptdm]].
        This allows one to split the big calculation of all the dielectric matrices into smaller
        calculations that can be performed independently. The _SCR files generated in different runs
        can be merged thanks to the
         <b>
          Mrgscr
         </b>
         utility.
        If [[nqptdm]] is equal to -1, the code reports the list of q-points in the log file (YAML format) and then stops.
        </p>
    topics: Susceptibility_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: nqshft@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of Q SHiFTs
    requires: null
    text: |-
        <p>The number of vector shifts of the simple Monkhorst and
        Pack grid, needed to generate the coarse grid of q points
        (for the series of fine grids, the number of shifts it is always taken to be 1).
        Usually, put it to 1.
        Use 2 if BCC sampling (Warning: not BCC lattice, BCC *sampling*),
        and 4 for FCC sampling (Warning: not FCC lattice, FCC *sampling*).
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nsa@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 3
    dimensions: scalar
    excludes: null
    mnemonics: Number of Supercell points in direction A
    requires: null
    text: |-
        These variables define a "supercell", from the primitive
          cell repeated along each primitive direction. This
          supercell is build as follows :
          <pre>
          do isa=-nsa,nsa
           do isb=-nsb,nsb
            do isc=-nsc,nsc
              -> here, the cell is translated by the vector
              -> (isa,isb,isc) in crystallographic coordinates
              -> and accumulated, to give the supercell
            enddo
           enddo
          enddo
          </pre>
    topics: Bader_expert
    varset: aim
    vartype: integer
- !variable
    abivarname: nsb@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 3
    dimensions: scalar
    excludes: null
    mnemonics: Number of Supercell points in direction B
    requires: null
    text: |-
        These variables define a "supercell", from the primitive
          cell repeated along each primitive direction. This
          supercell is build as follows :
          <pre>
          do isa=-nsa,nsa
           do isb=-nsb,nsb
            do isc=-nsc,nsc
              -> here, the cell is translated by the vector
              -> (isa,isb,isc) in crystallographic coordinates
              -> and accumulated, to give the supercell
            enddo
           enddo
          enddo
          </pre>
    topics: Bader_expert
    varset: aim
    vartype: integer
- !variable
    abivarname: nsc@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 3
    dimensions: scalar
    excludes: null
    mnemonics: Number of Supercell points in direction C
    requires: null
    text: |-
        These variables define a "supercell", from the primitive
          cell repeated along each primitive direction. This
          supercell is build as follows :
          <pre>
          do isa=-nsa,nsa
           do isb=-nsb,nsb
            do isc=-nsc,nsc
              -> here, the cell is translated by the vector
              -> (isa,isb,isc) in crystallographic coordinates
              -> and accumulated, to give the supercell
            enddo
           enddo
          enddo
          </pre>
    topics: Bader_expert
    varset: aim
    vartype: integer
- !variable
    abivarname: nscforder
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 16
    dimensions: scalar
    excludes: null
    mnemonics: Nth - SCaling Function ORDER
    requires: null
    text: |-
        <p>
         This variable controls the order of used scaling functions when the Hartree potential is computed using the Poisson solver (see [[icoulomb]] imput variable). This variable is of seldom use since the default value is large enough. Nonetheless, possible values are 8, 14, 16, 20, 24, 30, 40, 50, 60, 100. Values greater than 20 are included in ABINIT for test purposes only.
        </p>
    topics: Coulomb_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: nshiftk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of SHIFTs for K point grids
    requires: null
    text: |-
        <p>
         This parameter
        gives the number of shifted grids
        to be used concurrently to generate the full grid of k points.
        It can be used with primitive grids defined either from
        [[ngkpt]]
        or
        [[kptrlatt]].
        The maximum allowed value of [[nshiftk]] is 8.
        The values of the shifts are given by [[shiftk]].
        </p>
    topics: k-points_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: nshiftq
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of SHIFTs for Q point grids
    requires: null
    text: |-
        <p>
         This parameter
        gives the number of shifted grids
        to be used concurrently to generate the full grid of q points.
        It can be used with primitive grids defined either from
        [[ngqpt]]
        or
        [[qptrlatt]].
        The maximum allowed value of [[nshiftq]] is 8.
        The values of the shifts are given by [[shiftq]].
        </p>
    topics: q-points_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: nspden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[nsppol]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of SPin-DENsity components
    requires: null
    text: |-
        <p>
         If [[nspden]]=1, no spin-magnetization : the density matrix is
        diagonal, with same values spin-up and spin-down
        (compatible with [[nsppol]]=1 only,
        for both [[nspinor]]=1 or 2)
        </p>
        <p>
         If [[nspden]]=2, scalar magnetization (the axis is arbitrarily
        fixed in the z direction) : the density matrix is
        diagonal, with different values for spin-up and spin-down
        (compatible with [[nspinor]]=1,
        either with [[nsppol]]=2 -general
        collinear magnetization- or
        [[nsppol]]=1 -antiferromagnetism)
        </p>
        <p>
         If [[nspden]]=4, vector magnetization : the density matrix is full,
        with allowed x, y and z magnetization
        (useful only with [[nspinor]]=2 and
        [[nsppol]]=1, either
        because there is spin-orbit without time-reversal
        symmetry - and thus spontaneous magnetization, or
        with spin-orbit, if one allows for spontaneous
        non-collinear magnetism). Not yet available for response functions. Also note
        that, with [[nspden]]=4, time-reversal symmetry is not taken into account
        (at present ; this has to be checked) and thus [[kptopt]]
        has to be different from 1 or 2.
        </p>
        <p>
         The default ([[nspden]]=[[nsppol]])
        does not suit the case of vector magnetization.
        </p>
    topics: spinpolarisation_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: nsphere@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of atoms in SPHERe
    requires: null
    text: |-
        <p>Number of atoms included in the cut-off sphere for
        interatomic force constant, see also the alternative [[anaddb:rifcsph]].
        If <b>nsphere</b>= 0: maximum extent allowed by the grid.
        If <b>nsphere</b>= -1: the code analyzes different values of nsphere and
        find the value that does not lead to unstable frequencies in a small sphere around Gamma.
        The truncated IFCs are then used for further post-processing.
        The results of the test are reported in the main output file.
        This option is useful to obtain a initial guess of nsphere: the value that
        leads to stable frequencies and gives linear dispersion for the acoustic modes around Gamma
        is usually smaller that the one reported by nsphere -1.

        <p>This number defines the atoms for which the
        short range part of the interatomic force constants, after
        imposition of the acoustic sum rule, will not be put to zero.
        This option is available for testing purposes
        (evaluate the range of the interatomic force constants), because
        the acoustic sum rule will be violated if some atoms are no more
        included in the inverse Fourier Transform.
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nspinor
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[pawspnorb]]==1': 2
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of SPINORial components of the wavefunctions
    requires: null
    text: |-
        <p>
         If [[nspinor]]=1, usual case : scalar wavefunction
        (compatible with ([[nsppol]]=1,
        [[nspden]]=1) as well
        as ([[nsppol]]=2, [[nspden]]=2) )
        </p>
        <p>
         If [[nspinor]]=2, the wavefunction is a spinor
        (compatible with [[nsppol]]=1, with
        [[nspden]]=1 or 4,
        but not with [[nsppol]]=2)
        </p>
        <p>
         When [[nspinor]] is 2, the values of [[istwfk]]
        are automatically set to 1. Also, the number of bands, for each k-point,
        should be even.
        </p>
    topics: spinpolarisation_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: nsppol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of SPin POLarization
    requires: null
    text: |-
        <p>
         Give the number of INDEPENDENT
        spin polarisations, for which there are non-related wavefunctions. Can take the values
        1 or 2.
        </p>
        <p>
         If [[nsppol]]=1, one has an unpolarized calculation
        ([[nspinor]]=1,
        [[nspden]]=1) or
        an antiferromagnetic system
        ([[nspinor]]=1,
        [[nspden]]=2), or
        a calculation in which spin up and spin down cannot be disentangled
        ([[nspinor]]=2), that is, either
        non-collinear magnetism or presence of spin-orbit coupling,
        for which one needs spinor wavefunctions.
        </p>
        <p>
         If [[nsppol]]=2, one has a spin-polarized (collinear) calculation
        with separate and different wavefunctions for up and
        down spin electrons for each band and k point.
        Compatible only with [[nspinor]]=1,
        [[nspden]]=2. If [[nsppol]]=2, one usually uses a metallic value for [[occopt]], in order to let ABINIT find the magnetization.
        On the contrary, if [[occopt]]==1 is used, the user has to impose the magnetization, using [[spinmagntarget]],
        except for the case of a single isolated Hydrogen atom.
        </p>
        <p>
         In the present status of development,
        with [[nsppol]]=1,
        all values of [[ixc]] are allowed, while
        with [[nsppol]]=2,
        some values of [[ixc]] might not be allowed (e.g. 2, 3, 4, 5, 6, 20, 21, 22 are not allowed).
        </p>
        <p>
         See also the input variable [[nspden]]
        for the components of the density matrix with respect to
        the spin-polarization.
        </p>
    topics: spinpolarisation_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: nstep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: Number of (non-)self-consistent field STEPS
    requires: null
    text: |-
        <p>
         Gives the maximum number of cycles (or "iterations") in a SCF or non-SCF run.
         <br />
         Full convergence from random numbers is usually achieved in
        12-20 SCF iterations. Each can take from minutes to hours.
        In certain difficult cases, usually related to a small or
        zero bandgap or magnetism, convergence performance may be much worse.
        When the convergence tolerance [[tolwfr]] on the wavefunctions
        is satisfied, iterations will stop, so for well converged
        calculations you should set [[nstep]] to a value larger than
        you think will be needed for full convergence, e.g.
        if using 20 steps usually converges the system, set [[nstep]] to 30.
         <br />
         For non-self-consistent runs (
         [[iscf]] &lt; 0) nstep governs
        the number of cycles of convergence for the wavefunctions for a fixed density
        and Hamiltonian.
        </p>
        <p>
         NOTE that a choice of [[nstep]]=0 is permitted; this will
        either read wavefunctions from disk (with [[irdwfk]]=1
        or  [[irdwfq]]=1,
        or non-zero [[getwfk]]
        or [[getwfq]] in the case
        of multi-dataset) and
        compute the density, the total energy and stop, or else
        (with all of the above vanishing) will initialize
        randomly the wavefunctions and
        compute the resulting density and total energy.
        This is provided for testing purposes.
         <br />
         Also NOTE that [[nstep]]=0
        with [[irdwfk]]=1 will exactly give the same result as
        the previous run only if the latter is done with [[iscf]]&lt;10
        (potential mixing).
         <br />
         One can output the density by using [[prtden]].
         <br />
         The forces and stress tensor are computed with [[nstep]]=0.
        </p>
    topics: SCFControl_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: nstrfix@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of STRain components FIXed
    requires: null
    text: |-
        <p> Number of strain component that are fixed during a
        structural optimisation at constrained polarization.
        See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nsym
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of SYMmetry operations
    requires: null
    text: |-
        <p>
         Gives number of space group symmetries
        to be applied in this problem.  Symmetries will be input in
        array "[[symrel]]" and (nonsymmorphic) translations vectors
        will be input
        in array "[[tnons]]".  If there is no symmetry in the problem
        then set [[nsym]] to 1, because the identity is still a symmetry.
         <br />
         In case of a RF calculation, the code is able to use
        the symmetries of the system to decrease the number of
        perturbations to be calculated, and to decrease of the
        number of special k points to be used for the sampling of
        the Brillouin zone.
        After the response to the perturbations have been calculated,
        the symmetries are used to generate as many as
        possible elements of the 2DTE from those already
        computed.
        </p>
        <p>
         <b>Symmetry finder mode</b> (Default mode).
        <br>
        If [[nsym]] is 0, all the atomic coordinates must be
        explicitely given (one cannot use the atom manipulator
        neither the smart symmetrizer): the code will then find automatically
        the symmetry operations that leave the lattice and each
        atomic sublattice invariant. It also checks whether the
        cell is primitive (see [[chkprim]]).
         <br />
         Note that the tolerance on symmetric atomic positions and
        lattice is rather stringent :
        for a symmetry operation to be admitted,
        the lattice and atomic positions must map on themselves
        within 1.0e-8 .
        </p>
        <p>
         The user is allowed to set up systems with non-primitive unit cells (i.e.
        conventional FCC or BCC cells, or supercells without any distortion).
        In this case, pure translations will be identified as symmetries
        of the system by the symmetry finder.
        Then, the combined "pure translation + usual rotation and inversion" symmetry
        operations can be very numerous. For example, a conventional FCC cell
        has 192 symmetry operations, instead of the 48 ones of the primitive cell.
        A maximum limit of 384 symmetry operations is hard-coded. This
        corresponds to the maximum number of symmetry operations of a 2x2x2
        undistorted supercell. Going beyond
        that number will make the code stop very rapidly. If you want
        nevertheless, for testing purposes, to treat a larger number of symmetries,
        change [[maxnsym]].
        </p>
        <p>
         For GW calculation, the user might want to select only the symmetry operations whose
        non-symmorphic translation vector [[tnons]]
        is zero. This can be done with the help of the input variable
        [[symmorphi]]
        </p>
    topics: crystal_useful, GW_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: ntemper@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: Number of TEMPERatures
    requires: null
    text: |-
        <p>Number of temperatures at which the thermodynamical
        quantities have to be evaluated. Now also used for the output of transport
        quantities in electron-phonon calculations. The full grid is specified
        with the [[anaddb:tempermin]] and
        [[anaddb:temperinc]] variables.
        The default temperature grid goes from 100K to 1000K by step of 100K. For the largest temperatures, for most solids, anharmonic effects not accounted in the harmonic approximation implemented in anaddb will be important. For weakly bounded systems (e.g. Van der Waals solids), such anharmonic effects might be important already at room temperature.
    topics: Temperature_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: ntheta@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 32
    dimensions: scalar
    excludes: null
    mnemonics: Number of THETA angles
    requires: null
    text: |-
        With [[aim:nphi]], this
          variable defines the angular grid for the integration
          within the Bader volume, in particular, the number
          of theta angles, to be used between
          [[aim:thetamin]] and
          [[aim:thetamax]].
          When the difference between these two variables
          is pi, the recommended value of <b>ntheta</b> is 32.
          When it is pi/2 (for symmetry reasons),
          the recommended value is 20.
    topics: Bader_basic
    varset: aim
    vartype: integer
- !variable
    abivarname: ntime
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of TIME steps
    requires: null
    text: |-
        <p>
         Gives the number of molecular dynamics time steps or
        Broyden
        structural optimization steps to be done if
        [[ionmov]]
         is non-zero.
         <br />
         Note that at the present
        the option [[ionmov]]=1 is initialized
        with four
        Runge-Kutta steps which costs some overhead in the startup.
        By contrast, the initialisation of
        other [[ionmov]] values is only one
        SCF call.
         <br />
         [[ntime]] is ignored if [[ionmov]]=0.
        </p>
    topics: MolecularDynamics_basic, GeoOpt_basic
    varset: rlx
    vartype: integer
- !variable
    abivarname: ntimimage
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of TIME steps for IMAGE propagation
    requires: null
    text: |-
        <p>
         Gives the maximal number of molecular dynamics time steps or
        structural optimization steps to be done
        for the set of images, referred to as 'image-timesteps'. At each image-timestep,
        all the images are propagated simultaneously, each according to the algorithm
        determined by [[imgmov]] and the usual accompanying
        input variables, and then the next positions and velocities for each image
        are determined from the set of results obtained for all images.
        </p>
    topics: PIMD_compulsory, TransPath_compulsory
    varset: rlx
    vartype: integer
- !variable
    abivarname: ntypalch
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of TYPe of atoms that are "ALCHemical"
    requires: null
    text: |-
        <p>
         Used for the generation of alchemical pseudopotentials :
        when [[ntypalch]] is non-zero, alchemical mixing
        will be used.
        </p>
        <p>
         Among the [[ntypat]] types of atoms, the
        last [[ntypalch]] will be "alchemical" pseudoatoms, while only
        the first
         <b>
          ntyppure
         </b>
         will be uniquely associated with a pseudopotential
        (the
         <b>
          ntyppure
         </b>
         first of these, actually). The
        [[ntypalch]] types of alchemical
        pseudoatoms are to be made
        from the remaining [[npspalch]] pseudopotentials.
        </p>
        <p>
         In this case,
        the input variables
        [[algalch]],[[mixalch]]
        are active, and generate alchemical potentials from the available
        pseudopotentials.  See these input variables, especially
        [[mixalch]], to understand how
        to use alchemical potentials in ABINIT.
        </p>
    topics: AtomTypes_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: ntypat
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Number of TYPes of AToms
    requires: null
    text: |-
        <p>
         Gives the number of types of atoms.
        <br />
        E.g. for
        a homopolar system (e.g. pure Si) [[ntypat]] is 1.
         <p>
         The code tries to read the same number of pseudopotential files.
         The first pseudopotential is assigned type number 1, and so
        on ...
        </p>
        <p> There is an exception in the case of alchemical mixing of potentials, for which there is a different number of pseudopotentials atomic types. See [[mixalch]].
    topics: AtomTypes_compulsory, PseudosPAW_compulsory, crystal_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: ntyppure
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[ntypat]]-[[ntypalch]]'
    dimensions: scalar
    excludes: null
    mnemonics: Number of TYPe of atoms that are "PURe"
    requires: null
    text: |-
        <p>
         Gives the number of type of atoms that are "pure" when alchemical mixing is used ([[ntypalch]] /= 0) :
        </p>
        <p>
         [[ntyppure]]=[[ntypat]]-[[ntypalch]]
        </p>
    topics: AtomTypes_internal
    varset: gstate
    vartype: integer
- !variable
    abivarname: nucdipmom
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions:
    - 3
    - '[[natom]]'
    excludes: null
    mnemonics: NUClear DIPole MOMents
    requires: '[[usepaw]] = 1; [[pawcpxocc]] = 2; [[kptopt]] > 2'
    text: |-
        Places an array of nuclear magnetic dipole moments on the atomic positions, useful for computing the magnetization in the presence of nuclear dipoles and thus the chemical shielding by the converse method. The presence of these dipoles breaks time reversal symmetry and lowers the overall spatial symmetry.
    topics: MagField_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: num_lin_comp@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: NUMber of LINear COMPonents
    requires: null
    text: |-
        How many components out of 9 of the linear optical dielectric tensor do you
          want to calculate. Most of these are either equal or zero depending upon the
          symmetry of the material (for detail see <a href="../../users/generated_files/help_optic.html#Ref3">Ref. 3</a>).
          <br>Note that the directions are along the Cartesian axis.
    topics: Optic_basic
    varset: optic
    vartype: integer
- !variable
    abivarname: num_nonlin_comp@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: NUMber of NON-LINear COMPonents
    requires: null
    text: |-
        How many components out of 27 of the non-linear optical dielectric tensor do you
          want to calculate. Most of these are either equal or zero depending upon the
          symmetry of the material (for detail see <a href="../../users/generated_files/help_optic.html#Ref3">Ref. 3</a>).
          <br>Note that the directions are along the Cartesian axis.
    topics: Optic_basic
    varset: optic
    vartype: integer
- !variable
    abivarname: nwchan@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: Number of Widths of CHANnels
    requires: null
    text: |-
        <p> Integer. The width of the largest channel
        used to sample the frequencies.
        The code will generate different sets of channels,
        with decreasing widths (by step of 1 cm-1), from
        this channel width to 1, eventually. It considers to
        have converged when the convergence criterion based on [[anaddb:dostol]] and [[anaddb:thmtol]] have been fulfilled.
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: nwfshist
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Number of WaveFunctionS HISTory
    requires: null
    text: |-
        <p>
         In the wavelet basis set, the ground state is found by direct
        minimisation. The algorithm used can be either the steepest
        descent or the DIIS (Direct Inversion of Iteration
        Space). When [[nwfshist]] = 0, the steepest descent is used
        (
         <i>
          i.e.
         </i>
         there is no history storage of the previous
        iterations). If [[nwfshist]] is strictly positive, a DIIS
        is used. A typical value is 6. Using a DIIS increases the
        memory required by the program since N previous wavefunctions
        are stored during the electronic minimisation.
        </p>
    topics: Wavelets_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: nzchempot
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: Number of Z reduced coordinates that define the spatial CHEMical POTential
    requires: null
    text: |-
        Defines the number of z reduced coordinates that defines the spatially varying chemical potential. See the input variable [[chempot]], of which [[nzchempot]] is the second dimension.
    topics: Artificial_expert
    varset: geo
    vartype: integer
- !variable
    abivarname: objaat
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[objan]]'
    excludes: null
    mnemonics: 'OBJect A : list of AToms'
    requires: |
        '[[nobj]]==1'
    text: |-
        <p>
        Gives the list of atoms in object a. This list is specified by giving, for each atom, its index in the list of coordinates ([[xred]], [[xangst]] or [[xcart]]), that also corresponds to a type of atom (given by the array type).
        These objects can be thought as molecules, or groups
        of atoms, or parts of molecules, to be repeated,
        rotated and translated to generate the full set
        of atoms.
        <br />
         Look at [[objarf]] for further explanations.
        <br />
        </p>
    topics: AtomManipulator_basic
    varset: geo
    vartype: integer
- !variable
    abivarname: objaax
    characteristics:
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: |-
        [[objaax]] must be provided if ([[nobj]]==1 and one component of [[objaro]] != 0). Moreover,
        [[objaax]] AND [[objbax]] must be provided if ( [[nobj]] == 2 and one component of [[objbro]] != 0 ).
    commentdims: null
    defaultval: null
    dimensions:
    - 6
    excludes: null
    mnemonics: 'OBJect A : AXis'
    requires: null
    text: |-
        <p>
         Gives, for each object, the cartesian coordinates of
        two points (first point :  [[objaax]](1:3)
        second point : [[objaax]](4:6).
         By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The two points define an axis of rotation
        of the corresponding object.
         <br />
         Note that the rotation of
        the object is done BEFORE the object is translated.
         <br />
         The sign of the rotation angle is positive if the
        object is to be rotated clockwise when looking to it
        along the axis, from point 1 (coordinates 1:3)
        toward point 2 (coordinates 4:6).
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: real
- !variable
    abivarname: objan
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: |4-
         [[objan]] MUST be provided if [[nobj]]==1.
         [[objan]] and [[objbn]] MUST be provided if [[nobj]]==2.
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: 'OBJect A : Number of atoms'
    requires: null
    text: |-
        <p>
         Gives the number of atoms in object a. The list of atoms is given by the
        variables [[objaat]].
         <br />
        </p>
    topics: AtomManipulator_basic
    varset: geo
    vartype: integer
- !variable
    abivarname: objarf
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    - 1
    dimensions:
    - 3
    excludes: null
    mnemonics: 'OBJect A : Repetition Factors'
    requires: null
    text: |-
        <p>
         Gives three repetition factors of the objects a.
         <br />
         This gives the opportunity to generate a three-dimensional
        set of repeated objects, although a simple one-dimensional
        repetition will be easily obtained through the specification of
         <br />
         'nrep' 1 1
        <br>
        where 'nrep' is the 1D repetition factor.
         <br />
         The initial rotation and translation of the object,
        as well as the increment of rotation or translation
        from one object to the next are specified by
        the variables [[objaro]] and [[objatr]], for object a,
         <br />
         Note that the atom manipulator will generate the full set
        of atoms from the primitive set of atoms using the
        following order : it will process each atom in the
        primitive list one by one, determine whether it belongs
        to either object a or object b, and then repeat it
        taking into account the proper rotation and translation,
        with the fastest varying repetition factor being the first,
        then the second, then the third.
         <br />
         In the final list of atoms, one will first
        find the atoms generated from atom 1 in the primitive list,
        then those generated from atom 2 in the primitive list, and
        so on.
         <br />
         If the atom manipulator is only used to rotate
        or translate an object, without repeating it,
        simply use 1 1 1, which is also the Default value.
         <br />
        </p>
    topics: AtomManipulator_basic
    varset: geo
    vartype: integer
- !variable
    abivarname: objaro
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: (no rotation)
    commentdims: null
    defaultval: !multiplevalue
        number: 4
        value: 0.0d0
    dimensions:
    - 4
    excludes: null
    mnemonics: 'OBJect A : ROtations'
    requires: null
    text: |-
        <p>
         Give, for each object, the angles of rotation in degrees
        to be applied to the corresponding object.
         <br />
         The rotation is applied before the translation,
        and the axis is defined by the variables [[objaax]] and [[objbax]].
        See the latter variables for the definition of the sign
        of the rotation.
         <br />
         The first component [[objaro]](1) and
         <b>
          objbro
         </b>
         (1) gives
        the angle of rotation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of rotation angle
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules with
        different rotation angles.
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: real
- !variable
    abivarname: objatr
    characteristics:
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: (no translation)
    commentdims: null
    defaultval: !multiplevalue
        number: 12
        value: 0.0d0
    dimensions:
    - 12
    excludes: null
    mnemonics: 'OBJect A : TRanslations'
    requires: null
    text: |-
        <p>
         Give, for each object, the vectors of translations,
        in cartesian coordinates,
        to be applied to the corresponding object.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The translation is applied after the rotation.
         <br />
         The first vector [[objatr]](3,1) and [[objbtr]](3,1) gives
        the translation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of translation
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules.
         <br />
         In general, when the objects are repeated, a translation
        vector must be given, since otherwise, the repeated objects
        pack in the same region of space. As an exception, one can
        have a set of molecules regularly spaced on a circle, in
        which case, only rotations are needed.
         <br />
         Not present in the dtset array (no internal).
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: real
- !variable
    abivarname: objbat
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[objbn]]'
    excludes: null
    mnemonics: 'OBJect B : list of AToms'
    requires: '[[nobj]]==2'
    text: |-
        <p>
         Gives the list of atoms in object b. This list is specified
        by giving, for each atom, its index in the list
        of coordinates ([[xred]], [[xangst]]
        or [[xcart]]), that also
        corresponds to a type of atom (given by the array type).
        These objects can be thought as molecules, or groups
        of atoms, or parts of molecules, to be repeated,
        rotated and translated to generate the full set
        of atoms.
         <br />
         Look at [[objbrf]] for further explanations.
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: objbax
    characteristics:
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: |-
        [[objbax]] must be provided if ([[nobj]]==1 and one component of [[objaro]] != 0). Moreover,
        [[objaax]] AND [[objbax]] must be provided if ( [[nobj]] == 2 and one component of [[objbro]] != 0 ).
    commentdims: null
    defaultval: null
    dimensions:
    - 6
    excludes: null
    mnemonics: 'OBJect B : AXis'
    requires: null
    text: |-
        <p>
         Gives, for each object, the cartesian coordinates of
        two points (first point :  [[objbax]](1:3)
        second point : [[objbax]](4:6).
         By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The two points define an axis of rotation
        of the corresponding object.
         <br />
         Note that the rotation of
        the object is done BEFORE the object is translated.
         <br />
         The sign of the rotation angle is positive if the
        object is to be rotated clockwise when looking to it
        along the axis, from point 1 (coordinates 1:3)
        toward point 2 (coordinates 4:6).
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: real
- !variable
    abivarname: objbn
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: ' [[objan]] and [[objbn]] MUST be provided if [[nobj]]==2.'
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: 'OBJect B : Number of atoms'
    requires: null
    text: |-
        <p>
         Gives the number of atoms in either
        object b. The list of atoms is given by the
        variables [[objbat]].
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: objbrf
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    - 1
    dimensions:
    - 3
    excludes: null
    mnemonics: 'OBJect B : Repetition Factors'
    requires: null
    text: |-
        <p>
         Gives three repetition factors of the objects a or b.
         <br />
         This gives the opportunity to generate a three-dimensional
        set of repeated objects, although a simple one-dimensional
        repetition will be easily obtained through the specification of
         <br />
         nrep 1 1  &lt;r&gt;
        where nrep is the 1D repetition factor.
         <br />
         The initial rotation and translation of the object,
        as well as the increment of rotation or translation
        from one object to the next are specified by
        the variables [[objbro]] and [[objbtr]], for object b.
         <br />
         Note that the atom manipulator will generate the full set
        of atoms from the primitive set of atoms using the
        following order : it will process each atom in the
        primitive list one by one, determine whether it belongs
        to either object a or object b, and then repeat it
        taking into account the proper rotation and translation,
        with the fastest varying repetition factor being the first,
        then the second, then the third.
         <br />
         In the final list of atoms, one will first
        find the atoms generated from atom 1 in the primitive list,
        then those generated from atom 2 in the primitive list, and
        so on.
         <br />
         If the atom manipulator is only used to rotate
        or translate an object, without repeating it,
        simply use 1 1 1, which is also the Default value.
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: objbro
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: (no rotation)
    commentdims: null
    defaultval: !multiplevalue
        number: 4
        value: 0.0d0
    dimensions:
    - 4
    excludes: null
    mnemonics: 'OBJect B : ROtations'
    requires: null
    text: |-
        <p>
         Give, for each object, the angles of rotation in degrees
        to be applied to the corresponding object.
         <br />
         The rotation is applied before the translation,
        and the axis is defined by the variables [[objaax]] and [[objbax]].
        See the latter variables for the definition of the sign
        of the rotation.
         <br />
         The first component [[objaro]](1) and
         <b>
          objbro
         </b>
         (1) gives
        the angle of rotation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of rotation angle
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules with
        different rotation angles.
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: real
- !variable
    abivarname: objbtr
    characteristics:
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: (no translation)
    commentdims: null
    defaultval: !multiplevalue
        number: 12
        value: 0.0d0
    dimensions:
    - 12
    excludes: null
    mnemonics: 'OBJect B : TRanslations'
    requires: null
    text: |-
        <p>
         Give, for each object, the vectors of translations,
        in cartesian coordinates,
        to be applied to the corresponding object.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The translation is applied after the rotation.
         <br />
         The first vector [[objatr]](3,1) and [[objbtr]](3,1) gives
        the translation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of translation
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules.
         <br />
         In general, when the objects are repeated, a translation
        vector must be given, since otherwise, the repeated objects
        pack in the same region of space. As an exception, one can
        have a set of molecules regularly spaced on a circle, in
        which case, only rotations are needed.
         <br />
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: real
- !variable
    abivarname: occ
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - '[[nband]]'
    excludes: null
    mnemonics: OCCupation numbers
    requires: null
    text: |-
        <p>
         Gives occupation numbers for all
        bands in the problem. Needed if [[occopt]]==0 or
        [[occopt]]==2.
        Ignored otherwise. Also ignored when [[iscf]]=-2.
         <br />
         Typical band occupancy is either
        2 or 0, but can be 1 for half-occupied band or other
        choices in special circumstances.
         <br />
         If [[occopt]] is not 2,
        then the occupancies must be the same for each k point.
         <br />
         If [[occopt]]=2, then the band occupancies must be
        provided explicitly for each band, EACH k POINT,
        and EACH SPIN-POLARIZATION, in an
        array which runs over all bands, k points,
        and spin-polarizations.
         <br />
         The order of entries in the array would correspond to
        all bands at the first k point (spin up), then all bands at the
        second k point (spin up), etc, then all k-points spin down.
         <br />
         The total number of array elements
        which must be provided is
         <br />
         ( [[nband]](1)+[[nband]](2)+...+
        [[nband]]([[nkpt]]) ) *
        [[nsppol]] .
         <br />
         The occupation numbers evolve only for metallic occupations,
        that is, [[occopt]] &ge; 3 .
        </p>
    topics: BandOcc_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: occopt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: OCCupation OPTion
    requires: null
    text: |-
        <p>
         Controls how input
        parameters [[nband]], [[occ]],
        and [[wtk]] are handled.
         <ul>
          <li>
           [[occopt]]=0:
           <br />
           All k points have the same number of bands
        and the same occupancies of bands.  [[nband]] is given as a
        single number, and [[occ]]([[nband]])
        is an array of [[nband]]
        elements, read in by the code.
           <br />
           The k point weights in array [[wtk]]([[nkpt]]) are
        automatically normalized by the code to add to 1.
          </li>
          <li>
           [[occopt]]=1:
           <br />
           Same as [[occopt]]=0, except that the array [[occ]] is
        automatically generated by the code, to give a semiconductor.
           <br />
           An error occurs when filling cannot be done with
        occupation numbers equal to 2 or 0 in each k-point (non-spin-polarized case),
        or with occupation numbers equal to 1 or 0 in each k-point (spin-polarized case).
        If [[nsppol]]=2  and [[occopt]]==1 is used, the user has to impose the magnetization, using [[spinmagntarget]],
        except for the case of a single isolated Hydrogen atom.
          </li>
          <li>
           [[occopt]]=2:
           <br />
           k points may optionally have different numbers of
        bands and different occupancies.  [[nband]]([[nkpt]]*[[nsppol]]) is given
        explicitly as an array of [[nkpt]]*[[nsppol]] elements.
        [[occ]]() is given explicitly for all bands at each k point,
        and eventually for each spin --
        the total number of elements is the sum of [[nband]](ikpt)
        over all k points and spins. The k point weights [[wtk]]
        ([[nkpt]]) are
        NOT automatically normalized under this option.
          </li>
          <li>
           [[occopt]]=3, 4, 5, 6 and 7
           <br />
           Metallic occupation of levels, using different occupation
        schemes (see below). The corresponding thermal
        broadening, or cold smearing, is defined by
        the input variable [[tsmear]] (see below : the variable
        xx is the energy in Ha, divided by [[tsmear]])
           <br />
           Like for [[occopt]]=1, the variable [[occ]] is not read
           <br />
           All k points have the same number of bands,
        [[nband]] is given as a single number, read by the code.
           <br />
           The k point weights in array [[wtk]]([[nkpt]]) are
        automatically normalized by the code to add to 1.
          </li>
          <ul>
           <li>
            [[occopt]]=3:
            <br />
            Fermi-Dirac smearing (finite-temperature metal)
        Smeared delta function : 0.25d0/(cosh(xx/2.0d0)**2)
           </li>
           <li>
            [[occopt]]=4:
            <br />
            "Cold smearing" of N. Marzari (see his thesis work),
        with a=-.5634 (minimization of the bump)
            <br />
            Smeared delta function :
            <br />
            exp(-xx
            <sup>
             2
            </sup>
            )/sqrt(pi) * (1.5d0+xx*(-a*1.5d0+xx*(-1.0d0+a*xx)))
           </li>
           <li>
            [[occopt]]=5:
            <br />
            "Cold smearing" of N. Marzari (see his thesis work),
        with a=-.8165 (monotonic function in the tail)
            <br />
            Same smeared delta function as [[occopt]]=4, with different a.
           </li>
           <li>
            [[occopt]]=6:
            <br />
            Smearing of Methfessel and Paxton [[Methfessel1989]]
        with Hermite polynomial of degree 2, corresponding
        to "Cold smearing" of N. Marzari with a=0
        (so, same smeared delta function as [[occopt]]=4, with different a).
           </li>
           <li>
            [[occopt]]=7:
            <br />
            Gaussian smearing, corresponding to the 0 order
        Hermite polynomial of Methfessel and Paxton.
            <br />
            Smeared delta function : 1.0d0*exp(-xx**2)/sqrt(pi)
           </li>
           <li>
            [[occopt]]=8:
            <br />
            Uniform smearing (the delta function is replaced by a constant function of value one
        over ]-1/2,1/2[ (with one-half value at the boundaries). Used for testing purposes only.
           </li>
          </ul>
         </ul>
         WARNING : one can use metallic occupation of levels in the
        case of a molecule, in order to avoid any problem with
        degenerate levels. However, it is advised NOT to use
        [[occopt]]=6 (and to a lesser extent [[occopt]]=4 and 5),
        since the associated number of electron
        versus the Fermi energy is NOT guaranteed to be
        a monotonic function. For true metals, AND a sufficiently
        dense sampling of the Brillouin zone, this should not happen,
        but be cautious ! As an indication of this problem,
        a small variation of input parameters might lead to
        a jump of total energy, because there might be two or even
        three possible values of the Fermi energy, and the
        bissection algorithm find one or the other.
        </p>
    topics: BandOcc_basic, STM_compulsory
    varset: basic
    vartype: integer
- !variable
    abivarname: omegasimax
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 50
    dimensions: scalar
    excludes: null
    mnemonics: 'OMEGA to evaluate Sigma along the Imaginary axis D: MAXimal
        value'
    requires: '[[optdriver]]==4 and [[gwcalctyp]]==1'
    text: |-
        <p>
         [[omegasimax]] defines the maximum frequency along the imaginary the axis.
        In conjunction with [[nomegasi]],
        [[omegasimax]] uniquely defines the linear mesh employed to sample the self-energy along the imaginary axis.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: omegasrdmax
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: 'OMEGA to evaluate the Sigma Real axis Derivative : MAXimal
        value'
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         The maximum distance from the KS energy where to evaluate Sigma. Sigma is evaluated at
        [ KS_energy - [[omegasrdmax]], KS_energy + [[omegasrdmax]] ] sampled [[nomegasrd]] times.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: optcell
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: OPTimize the CELL shape and dimensions
    requires: null
    text: |-
        Allows to optimize the unit cell shape and dimensions, when [[ionmov]]>=2 or 3.  The configuration for which the stress almost vanishes
        is iteratively determined, by using the same algorithms as for the nuclei positions. Will eventually modify [[acell]]
        and/or [[rprim]].  The ionic positions are ALWAYS updated, according to the forces.
        A target stress tensor might be defined, see [[strtarget]].
        <ul>
          <li>[[optcell]]=0 : modify nuclear positions, since [[ionmov]]=2 or 3, but no cell shape and dimension optimisation.</li>
          <li>[[optcell]]=1 : optimisation of volume only (do not modify [[rprim]], and allow an homogeneous dilatation of the three components of [[acell]])</li>
          <li>[[optcell]]=2 : full optimization of cell geometry (modify [[acell]] and [[rprim]]
               - normalize the vectors of [[rprim]] to generate the [[acell]]).
               This is the usual mode for cell shape and volume optimization. It takes into account the symmetry of the system,
               so that only the effectively relevant degrees of freedom are optimized.</li>
          <li>[[optcell]]=3 : constant-volume optimization of cell geometry (modify [[acell]] and [[rprim]] under constraint
               - normalize the vectors of [[rprim]] to generate the [[acell]])</li>
          <li>[[optcell]]=4, 5 or 6 : optimize [[acell]](1), [[acell]](2), or [[acell]](3), respectively
               (only works if the two other vectors are orthogonal to the optimized one, the latter being along its cartesian axis).</li>
          <li>[[optcell]]=7, 8 or 9 : optimize the cell geometry while keeping the first, second or third vector unchanged
               (only works if the two other vectors are orthogonal to the one left unchanged, the latter being along its cartesian axis).</li>
        </ul>
        A few details require attention when performing unit cell optimisation :
        <ul>
          <li> one has to get rid of the discontinuities due to discrete changes of plane wave number with cell size, by using a suitable value of [[ecutsm]];</li>
          <li> one has to allow for the possibility of a larger sphere of plane waves, by using [[dilatmx]];</li>
          <li> one might have to adjust the scale of stresses to the scale of forces, by using [[strfact]].</li>
          <li> if all the reduced coordinates of atoms are fixed by symmetry, one cannot use [[toldff]] to stop the SCF cycle.
              (Suggestion : use [[toldfe]] with a small value, like 1.0d-10)</li>
        </ul>
        It is STRONGLY suggested first to optimize the ionic positions without cell shape and size optimization ([[optcell]]=0), then start the cell shape and size optimization from the cell with relaxed ionic positions.
        Presently (v3.1), one cannot restart ([[restartxf]])
        a calculation with a non-zero [[optcell]] value from the
        (x,f) history of another run with a different non-zero [[optcell]]
        value. There
        are still a few problems at that level.
    topics: PIMD_basic, GeoOpt_compulsory
    varset: rlx
    vartype: integer
- !variable
    abivarname: optdriver
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: OPTions for the DRIVER
    requires: null
    text: |-
        <p>
         For each dataset, choose
        the task to be done, at the level of the "driver" routine.
        </p>
        <p>
         The choice is among :
         <br />
         [[optdriver]]=0 : ground-state calculation (GS), routine "gstate"
         <br />
         [[optdriver]]=1 : response-function calculation (RF), routine "respfn"
         <br />
         [[optdriver]]=2 : susceptibility calculation (SUS), routine "suscep"
         <br />
         [[optdriver]]=3 : susceptibility and dielectric matrix calculation (SCR), routine "screening"
         <br />
         (see the input variables [[ecutwfn]],
        [[ecuteps]],
        [[ppmfrq]],
        [[getwfk]],
        as well as [[nbandkss]] and [[nband]])
         <br />
         [[optdriver]]=4 : self-energy calculation (SIG), routine "sigma"
         <br />
         [[optdriver]]=5 : non-linear response functions (NONLINEAR), using the 2n+1 theorem, routine "nonlinear"
        <br />
        [[optdriver]] =7: electron-phonon coupling (EPH)
         <br />
        [[optdriver]] =66: GW using Lanczos-Sternheimer, see input variables whose name start with gwls_* .
         <br />
         [[optdriver]]=99 : Bethe-Salpeter calculation (BSE), routine "bethe_salpeter"
        </p>
        <p>
         If one of [[rfphon]], [[rfddk]],
        [[rfelfd]],
        or [[rfstrs]] is non-zero, while [[optdriver]]
        is not defined in the input file, ABINIT will set [[optdriver]] to 1
        automatically. These input variables ([[rfphon]],
        [[rfddk]], [[rfelfd]],
        and [[rfstrs]]) must be
        zero if [[optdriver]] is not set to 1.
        </p>
    topics: nonlinear_compulsory, GWls_compulsory, ElPhonInt_compulsory, GW_compulsory, BSE_compulsory, DFPT_compulsory, Susceptibility_compulsory, SelfEnergy_compulsory
    varset: gstate
    vartype: integer
- !variable
    abivarname: optforces
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[toldff]] or [[tolrff]] != 0': 1
        defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: OPTions for the calculation of FORCES
    requires: null
    text: |-
        <p>
         Allows to choose options for the calculation of forces.
         <ul>
          <li>
           [[optforces]]=0 : the forces are set to zero, and many steps of the
        computation of forces are skipped
          </li>
          <li>
           [[optforces]]=1 : calculation of forces at each SCF iteration, allowing
        to use forces as criterion to stop the SCF cycles
          </li>
          <li>
           [[optforces]]=2 : calculation of forces at the end of the SCF iterations
        (like the stresses)
          </li>
         </ul>
        </p>
    topics: ForcesStresses_basic
    varset: dev
    vartype: integer
- !variable
    abivarname: optnlxccc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: OPTion for the calculation of Non-Linear eXchange-Correlation Core Correction
    requires: null
    text: |-
        <p>
         Allows to choose options for the calculation of non-linear XC correction.
        At present, only relevant for the FHI type of pseudopotentials, with pspcod=6 .
         <ul>
          <li>
           [[optnlxccc]]=1 : uses the old psp6cc.f routine, with inconsistent treatment of real-space derivatives of the core function (computed in this routine, while splined in the other parts of the code)
          </li>
          <li>
           [[optnlxccc]]=2 : consistent calculation derivatives, in the psp6cc_dhr.f routine from DHamann.
          </li>
         </ul>
        </p>
    topics: xc_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: optstress
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: OPTion for the computation of STRESS
    requires: null
    text: |-
        <p>
         If set to 1, the computation of stresses is done,
        in the SCF case
        (under the conditions [[iscf]] &gt; 0 , [[prtstm]]==0 ,
        [[positron]]==0,
        and either  [[nstep]] &gt;0 , or
        [[usepaw]]==0 or [[irdwfk]]==1).
         <br />
         Otherwise, to save CPU time, if no optimization of the cell is required,
        one can skip the computation of stresses. The CPU time saving might be interesting
        for some PAW calculations.
        </p>
    topics: ForcesStresses_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: ortalg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[wfoptalg]] >= 10 ': -2
        defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: ORThogonalisation ALGorithm
    requires: null
    text: |-
        <p>
         Allows to choose the algorithm
        for orthogonalisation.
         <br />
         Positive or zero values make two projections per
        line minimisation, one before the preconditioning, one
        after. This is the clean application of the band-by-band
        CG gradient for finding eigenfunctions.
         <br />
         Negative values make only one projection per line minimisation.
         <br />
         The orthogonalisation step is twice faster, but the
        convergence is less good. This actually calls to
        a better understanding of this effect.
         <br />
         [[ortalg]]=0, 1 or -1 is the conventional coding.
         <br />
         [[ortalg]]=2 or -2 try to make better use of existing registers
        on the particular machine one is running.
         <br />
         More demanding use of registers
        is provided by [[ortalg]]=3 or -3, and so on.
         <br />
         The maximal value is presently 4 and -4.
         <br />
         Tests have shown that [[ortalg]]=2 or -2 is suitable for
        use on the available platforms.
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: outboltztrap@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: OUTput files for BOLTZTRAP code
    requires: null
    text: |-
        <p> If set to 1, the phonon frequencies on the ngqpt grid are output in a format legible by the BoltzTrap code,
        which does band interpolation and gets group velocities. The output file will be appended _BTRAP
    topics: PhononBands_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: outscphon@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: OUTput files for Self Consistent PHONons
    requires: null
    text: |-
        <p>If set to 1, the phonon frequency and eigenvector files needed for a Self Consistent
        phonon run (as in Souvatzis PRL <b>100</b> 095901) will be output to files appended _PHFRQ and _PHVEC.
        The third file needed is appended _PCINFO for Primitive Cell INFOrmation.
    topics: PhononBands_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: papiopt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAPI OPTion
    requires: null
    text: |-
        <p>
         <a href="http://icl.cs.utk.edu/papi/index.html">
          PAPI
         </a>
         aims to
        provide the tool designer and application engineer with a
        consistent interface and methodology for use of the
        performance counter hardware found in most major
        microprocessors. PAPI enables software engineers to see, in
        near real time, the relation between software performance and
        processor events.
         <br />
         This option can be used only when ABINIT has been compiled with the
         <code>
          --enable-papi
         </code>
         configure option.
         <br />
         If [[papiopt]]=1, then PAPI counters are used instead of
        the usual time() routine. All the timing output of ABINIT is
        then done with PAPI values. The measurements are more accurate and
        give also access to the flops of the calculation.
        </p>
    topics: Control_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: paral_atom
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: activate PARALelization over (paw) ATOMic sites
    requires: null
    text: |-
        <p>
         Relevant only for PAW calculations.
         <br />
         This keyword controls the parallel distribution of memory over atomic sites. Calculations are
        also distributed using the "kpt-band" communicator.
          Compatible with ground-state calculations and response function calculations
         <br />
        </p>
    topics: parallelism_basic
    varset: paral
    vartype: integer
- !variable
    abivarname: paral_kgb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: activate PARALelization over K-point, G-vectors and Bands
    requires: null
    text: |-
        <p>
         <b>
          If paral_kgb is not explicitely put in the input file
         </b>
         ,
        ABINIT automatically detects if the job has been sent in sequential or in parallel.
        In this last case, it detects the number of processors on which the job has been sent and calculates values of
        [[npkpt]], [[npfft]],
        [[npband]], [[bandpp]] , [[npimage]] and [[npspinor]] that are compatible with the number of processors. It then set
        paral_kgb to 0 or 1 (see hereunder) and launches the job.
        </p>
        <b>
         If paral_kgb=0
        </b>
        ,
        the parallelization over k-points only is activated. In this case,
        [[npkpt]], [[npspinor]], [[npfft]] and
        [[npband]] are ignored. Require compilation option --enable-mpi="yes".
        <p>
         <b>
          If paral_kgb=1
         </b>
         ,
        the parallelization over bands, FFTs, and k-point/spin-components is activated
        (see [[npkpt]], [[npfft]]
        [[npband]] and eventually [[npspinor]]). With this parallelization, the work load is split over
        four levels of parallelization (three level of parallelisation (kpt-band-fft )+ spin) The different communications almost occur
        along one dimension only. Require compilation option --enable-mpi="yes".
        </p>
        HOWTO fix the number of processors along one level of parallelisation:
        <br />
        At first, try to parallelise over the k point and spin
        (see [[npkpt]],[[npspinor]]).
        Otherwise, for unpolarized calculation at the gamma point, parallelise over the
        two other levels: the band and FFT ones. For nproc&lt;=50,
        the best speed-up is achieved for
        [[npband]]=nproc and
        [[npfft]]=1 (which is not yet the default).
        For nproc&gt;=50, the best speed-up is achieved for
        [[npband]] &gt;=4*[[npfft]].
        <p>
         For additional information,
        download F. Bottin presentation at the
         <a href="https://www.abinit.org/sites/default/files/oldsites/workshop_07/program.html">
          ABINIT workshop 2007
         </a>
        </p>
        <p>
         Suggested acknowledgments :
         <br />
         F. Bottin, S. Leroux, A. Knyazev and G. Zerah,
         <i>
          Large scale ab initio calculations based on three levels of parallelization
         </i>
         ,
        Comput. Mat. Science
         <b>
          42
         </b>
         , 329 (2008),
        also available on arXiv, http://arxiv.org/abs/0707.3405 .
        </p>
        <p>
         If the total number of processors used is compatible with the four levels of parallelization, the values for [[npkpt]], [[npspinor]], [[npfft]], [[npband]] and [[bandpp]] will be filled automatically, although the repartition may not be optimal. To optimize the repartition use:
        </p>
        <p>
         <b>
          If paral_kgb=1
         </b>
         and
         <b>
          max_ncpus = n /= 0
         </b>
         ABINIT will test automatically if all the processor numbers between 2 and n are convenient
        for a parallel calculation and print the possible values in the log file.
        A weight is attributed to each possible processors repartition. It is adviced to select a processor repartition for which the weight is high
        (as closed to the number of processors as possible). The code will then stop after the printing.
        This test can be done as well with a sequential as with a parallel version of the code.
        The user can then choose the adequate number of processor on which he can run his job.
        He must put again paral_kgb=1 in the input file and put the corresponding values for
        [[npkpt]], [[npfft]], [[npband]],[[bandpp]] and eventually [[npspinor]] in the input file.
        </p>
    topics: parallelism_basic
    varset: paral
    vartype: integer
- !variable
    abivarname: paral_rf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: activate PARALlelization over Response Function perturbations
    requires: null
    text: |-
        <p>
         This parameter activates the parallelization over perturbations which can be used during
        RF-Calculation. It is possible to use this type of parallelization in combination to the
        parallelization over k-points.
        </p>
        <p>
         Currently total energies calculated by groups, where the master process is not in, are saved
        in .status_LOGxxxx files.
        </p>
        <p>
         If [[paral_rf]] is set to -1, the code reports the list of irreducible perturbations for the specified
        q-point in the log file (YAML format) and then stops.
        </p>
        <p> [[paral_rf]] can be specified separately for each dataset. </p>
    topics: parallelism_basic
    varset: paral
    vartype: integer
- !variable
    abivarname: pawcpxocc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        ? '[[optdriver]]==0 and [[ionmov]]<6 and [[pawspnorb]]==1 and [[iscf]]>=10
            and ([[kptopt]] !=1 or [[kptopt]]!=2) and [[usepaw]]==1'
        : 2
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - use ComPleX rhoij OCCupancies
    requires: '[[usepaw]]==1'
    text: |-
        <p>
        The only possible values for [[pawcpxocc]] are 1 or 2.
         <br />
        When
         <b>
          [[pawcpxocc]]==1
         </b>
         , "direct" decomposition of total energy cannot be printed out.
         <br />
         When
         <b>
          [[pawcpxocc]]==2
         </b>
         , PAW augmentation occupancies are treated as COMPLEX; else they are considered as REAL.
         <br />
         This is needed when time-reversal symmetry is broken (typically when spin-orbit coupling is activated).
         <br />
         <br />
         Note for ground-state calculations ([[optdriver]]=0):
         <br />
         The imaginary part of PAW augmentation occupancies is only used for the computation of the total energy by "direct scheme";
        this is only necessary when SCF mixing on potential is chosen ([[iscf]]&lt;10).
         <br />
         When SCF mixing on density is chosen ([[iscf]]&gt;=10), the "direct" decomposition
        of energy is only printed out without being used. It is thus possible to use [[pawcpxocc]]=1 in the latter case.
         <br />
         In order to save CPU time, when molecular dynamics is selected ([[ionmov]]&gt;=6) and
        SCF mixing done on density ([[iscf]]&gt;=10), [[pawcpxocc]]=2 is (by default) set to
         <b>
          1
         </b>
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawcross
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW - add CROSS term in oscillator strengths
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[usepaw]]==1
    text: |-
        <p>
         When
         <b>
          pawcross=1
         </b>
         , the overlap between the plane-wave part of one band and the on-site part of an other
        is taken into account in the computation of the oscillator strengths. Hence, the completeness of the on-site basis is no longer assumed.
        </p>
    topics: DFPT_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawecutdg
    characteristics:
    - '[[ENERGY]]'
    commentdefault: pawecutdg MUST be specified for PAW calculations.
    commentdims: null
    defaultval: -1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - Energy CUToff for the Double Grid
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Define the energy cut-off for the fine FFT grid
        (the "double grid", that allows to transfer data from the normal, coarse, FFT grid to the
        spherical grid around each atom).
         <br />
         [[pawecutdg]] must be larger or equal to
        [[ecut]]. If it is equal to it, then no fine
        grid is used. The results are not very accurate, but the computations
        proceed quite fast.
         <br />
         For typical PAW computations, where [[ecut]]
        is on the order of 15 Ha, [[pawecutdg]] must be tested according to what you want to do. For calculations that do not require a high accuracy (molecular dynamics for instance) a value of 20 Ha is enough. For calculations that require a high accuracy (response fonctions for instance) it should be on the order of 30 Ha.
        Choosing a larger value should not increase the accuracy, but does not slow down the
        computation either, only the memory. The choice made for this variable DOES have a bearing
        on the numerical accuracy of the results, and, as such, should be the object
        of a convergence study. The convergence test might be made on the total energy
        or derived quantities, like forces, but also on the two values of the
        "Compensation charge inside spheres", a quantity written in the log file.
        </p>
    topics: Planewaves_compulsory, PAW_compulsory
    varset: paw
    vartype: real
- !variable
    abivarname: pawfatbnd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'PAW: print band structure in the FAT-BaND representation'
    requires: '[[usepaw]]==1 '
    text: |-
        <p>
        For Ground-State calculations and non self-consistent calculations only.
         <br />
         This option can be used to plot band structure. For each atom (specified by
        [[natsph]] and [[iatsph]]), each angular momentum, and each
        spin polarisation, the band structure is written in files (such as e.g. FATBANDS_at0001_Ni_is2_l2_m-1). Each file
        contains the eigenvalue, and the contribution of angular momentum L, and projection of angular momentum M,
        (for the corresponding wavefunction) to the PAW density inside the PAW sphere
        as a function of the index of the k-point.
        The output can be readily plotted with the software
         <a href="http://plasma-gate.weizmann.ac.il/Grace/">
          xmgrace
         </a>
         (e.g xmgrace FATBANDS_at0001_Ni_is2_l2_m-1).
        Relevant values are:
         <br />
         <ul>
          <li>
           0: desactivated.
          </li>
          <li>
           1: The fatbands are only resolved in L.
          </li>
          <li>
           2: The fatbands are resolved in L and M.
          </li>
         </ul>
        </p>
    topics: PAW_useful, ElecBandStructure_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: pawlcutd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: PAW - L angular momentum used to CUT the development in moments of the Densitites
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         The expansion of the densities in angular momenta is
        performed up to l=[[pawlcutd]].
         <br />
         Note that, for a given system, the maximum value of [[pawlcutd]] is
         <b>
          2*l_max
         </b>
         ,
        where l_max is the maximum l of the PAW partial waves basis.
         <br />
         <br />
         The choice made for this variable DOES have a bearing
        on the numerical accuracy of the results, and, as such, should be the object
        of a convergence study. The convergence test might be made on the total energy
        or derived quantities, like forces, but also on the two values of the
        "Compensation charge inside spheres", a quantity written in the log file.
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawlmix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: PAW - maximum L used in the spherical part MIXing
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         The choice made for this variable determine how the spherical part of the
        density is mixed during electronic iterations.
         <br />
         <br />
         Only parts of rhoij quantities associated with
        l angular momenta up to l=pawlmix are mixed.
        Other parts of augmentation occupancies are not included in the mixing process.
         <br />
         This option is useful to save CPU time but DOES have a bearing on the numerical accuracy of the results.
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawmixdg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[npfft]]==1': 0
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - MIXing is done (or not) on the (fine) Double Grid
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         The choice made for this variable determines the grid on which the density (or potential) is mixed during the SCF cycle.
         <br />
         <br />
         - If
         <b>
          pawmixdg=1
         </b>
         the density/potential is mixed in REAL space using the fine FFT grid
        (defined by [[pawecutdg]] or [[ngfftdg]]).
         <br />
         - If
         <b>
          pawmixdg=0
         </b>
         the density/potential is mixed in RECIPROCAL space using the coarse FFT grid
        (defined by [[ecut]] or [[ngfft]]).
        Only components of the coarse grid are mixed using the scheme defined by [[iscf]];
        other components are only precondionned by [[diemix]] and simply mixed.
         <br />
         This option is useful to save memory and does not affect numerical accuracy of converged results.
        If
         <b>
          pawmixdg=1
         </b>
         , density and corresponding residual are stored for previous iterations and are
        REAL arrays of size [[nfftdg]].
        If
         <b>
          pawmixdg=0
         </b>
         , density and corresponding residual are stored
        for previous iterations and are COMPLEX arrays of size [[nfft]].
        The memory saving is particularly efficient when using the Pulay mixing
        ([[iscf]]=7 or 17).
         <br />
         <br />
         In
         <b>
          wavelet
         </b>
         calculations [[usewvl]]=1:
         <br />
         - pawmixdg is set to 1 by default.
         <br />
         - A value of 0 is not allowed.
         <br />
         - Density/potential is mixed in REAL space (Here only one grid is used).
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawnhatxc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - Flag for exact computation of gradients of NHAT density in eXchange-Correlation.
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Relevant only when a GGA exchange-correlation functional is used.
         <br />
         When this flag is activated, the gradients of compensation charge density (n_hat) are exactly
        computed (i.e. analytically); when it is deactivated, they are computed with a numerical scheme in
        reciprocal space (which can produce inaccurate results if the compensation charge density
        is highly localized).
         <br />
         As analytical treatment of compensation charge density gradients is CPU time demanding,
        it is possible to bypass it with [[pawnhatxc]]=0; but the numerical accuracy can be affected
        by this choice. It is recommended to test the validity of this approximation before use.
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawnphi
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 13
    dimensions: scalar
    excludes: null
    mnemonics: PAW - Number of PHI angles used to discretize the sphere around each atom.
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Number of phi angles (longitude) used to discretize the
        data on the atomic spheres. This discretization is completely
        defined by [[pawnphi]]
        and [[pawntheta]].
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawntheta
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 12
    dimensions: scalar
    excludes: null
    mnemonics: PAW - Number of THETA angles used to discretize the sphere around each atom.
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Number of theta angles (latitude) used to discretize the
        data on the atomic spheres. This discretization is completely
        defined by [[pawntheta]]
        and [[pawnphi]].
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawnzlm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - only compute Non-Zero LM-moments of the contributions to the density from the spheres
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Concerns the computation of the contributions to the density from the spheres (named rho_1 -
        rho_tild_1).
         <br />
         If set to 0, all lm-moments of the sphere contributions to the density are computed at each
        electronic iteration.
         <br />
         If set to 1, only non-zero lm-moments of the sphere contributions to the density are computed
        at each electronic iteration (they are all computed at the first iteration then only
        those found to be non-zero will be computed ; thus the first iteration is more cpu intensive)
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawoptmix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW - OPTion for the MIXing of the spherical part
    requires: '[[usepaw]]==1'
    text: |-
        <p>
        In the case of PAW computations, during the self-consistent cycle,
        ABINIT mixes the density
        &rho;(r)=
         <span style="position: relative; top: -5pt; left: 6pt;">&sim;</span>&rho;(r)
        +<span style="position: relative; top: -5pt; left: 6pt;">&and;</span>&rho;(r)
        and the occupancy matrix &rho;<sub>ij</sub>.
        (<span style="position: relative; top: -5pt; left: 6pt;">&sim;</span>&rho;(r)
        is the pseudo density,
        <span style="position: relative; top: -5pt; left: 6pt;">&and;</span>&rho;(r)
        is the compensation charge density).
        It can be redundant as &rho;<sub>ij</sub> is contained in
        <span style="position: relative; top: -5pt; left: 6pt;">&and;</span>&rho;(r).
        <br>
        <ul>
          <li>If <b>pawoptmix</b>=0:<br>
          ABINIT mixes &rho;(r) and &rho;<sub>ij</sub> but the residual used
          to control the mixing algorithm is only based on &rho;(r).
          </li>
          <li>If <b>pawoptmix</b>=1:<br>
          ABINIT mixes &rho;(r) and &rho;<sub>ij</sub> and the residual used
          to control the mixing algorithm is based on &rho;(r) and &rho;<sub>ij</sub>.
          </li>
        </ul>
        This has only an influence on the efficiency of the mixing algorithm.<br>
        In cas of mixing problems, the first suggestion is to increase the size of the history
        (see [[npulayit]]). Then it is also possible to play with the parameters of
        the Kerker mixing: [[diemix]], [[diemac]], etc...
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawoptosc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW - OPTion for the computation of the OSCillator matrix elements
    requires: null
    text: |-
        <p>
        Only relevant for GW or Bethe-Salpeter calculations with PAW.
         <br />
         This variable defines the approach used for the evaluation of the oscillator matrix elements within the PAW formalism.
        Possible values are 0,1,2.
         <br />
         If [[pawoptosc]]=0 the code uses its internal
         default value (2 for SCREENING calculations, 1 for SIGMA calculations, 2 for Bethe-Salpeter
         <br />
         If [[pawoptosc]]=1 the matrix elements are computed with the expression given by Arnaud and Alouani in PRB 62. 4464
        The equation is exact provided that the set of PAW partial waves is complete.
         <br />
         If [[pawoptosc]]=2  the matrix elements are computed with the approximated expression proposed by Shishkin and
        Kresse in PRB 74. 035101
        </p>
    topics: Susceptibility_expert, BSE_expert, SelfEnergy_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawovlp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5.0
    dimensions: scalar
    excludes: null
    mnemonics: PAW - spheres OVerLaP allowed (in percentage)
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         When PAW is activated, a localized atomic basis is added to describe wave functions.
        Spheres around atoms are defined and they are IN PRINCIPLE not allowed to overlap. However,
        a small overlap can be allowed without compromising the accuracy of results. Be aware that
        too high overlaps can lead to unphysical results.
         <br />
         With the [[pawovlp]] variable, the user can control the (voluminal) overlap percentage
        allowed without stopping the execution.
         <br />
         [[pawovlp]] is the value (in percentage: 0...100%) obtained by dividing
        the volume of the overlap of two spheres by the volume of the smallest sphere.
         <br />
         The following values are permitted for [[pawovlp]]:
         <br />
         <div style="margin-left: 40px;">
          - [[pawovlp]]&lt;0. : overlap is always allowed
          <br />
          - [[pawovlp]]=0. : no overlap is allowed
          <br />
          - [[pawovlp]]&gt;0. and &lt;100. : overlap is allowed only if it is less than [[pawovlp]] %
         </div>
        </p>
    topics: PAW_useful
    varset: paw
    vartype: real
- !variable
    abivarname: pawprt_b
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW PRinT band
    requires: null
    text: |-
        <p>
         Forces the output of the all-electron wavefunction for
        only a single band. To be used in conjuction with:
         <b>
          <br />
          [[pawprtwf]]=1
         </b>
         and
        [[pawprt_k]].
        The indexing of the bands start with one for the lowest occupied band
        and goes up from there.
        </p>
    topics: PAW_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: pawprt_k
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW PRinT K-point
    requires: null
    text: |-
        <p>
         Forces the output of the all-electron wavefunction for
        only a single k-point. To be used in conjuction with:
         <b>
          <br />
          [[pawprtwf]]=1
         </b>
         and
        [[pawprt_b]].
        The indexing follows the order in ouptput of the internal
        variable
         <b>
          kpt
         </b>
         in the beginning of the run.
        </p>
    topics: PAW_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: pawprtden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'PAW: PRinT total physical electron DENsity'
    requires: '[[usepaw]]==1'
    text: |-
        <b>
         Deprecated :
        </b>
        See the [[prtden]].
        <p>
        </p>
    topics: PAW_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: pawprtdos
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'PAW: PRinT partial DOS contributions'
    requires: '[[usepaw]]==1 and [[prtdos]]==3'
    text: |-
        <p>
         This input variable controls the computation and/or printing of contributions to the PAW partial DOS in _DOS file(s):
         <br />
         <div style="margin-left: 40px;">
          + Plane-waves contribution
          <br />
          + "on-site" all-electron contribution (phi)
          <br />
          - "on-site" pseudo contribution (phi_tild).
          <br />
         </div>
         If
         <b>
          pawprtdos=0:
         </b>
         <br />
         - The 3 contributions are computed; only the total partial DOS is output in _DOS file.
         <br />
         If
         <b>
          pawprtdos=1:
         </b>
         <br />
         - The 3 contributions are computed and output in _DOS file.
         <br />
         - In that case, integrated DOS is not output.
         <br />
         If
         <b>
          pawprtdos=2:
         </b>
         <br />
         - Only "on-site" all-electron contribution is computed and output in _DOS file.
         <br />
         - This a (very) good approximation of total DOS, provided that (1) the PAW local basis is complete, (2) the electronic charge is mostly contained in PAW spheres.
         <br />
         - In that case, the [[ratsph]] variable is automatically set to the PAW radius.
        </p>
    topics: PAW_useful, ElecDOS_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: pawprtvol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'PAW: PRinT VOLume'
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Control print volume and debugging output for PAW in log file or standard output.
        If set to 0, the print volume is at its minimum.
         <br />
         [[pawprtvol]] can have values from -3 to 3:
         <br />
         - [[pawprtvol]]=-1 or 1: matrices rho_ij (atomic occupancies) and D_ij (psp strength)
        are printed at each SCF cycle with details about their contributions.
         <br />
         - [[pawprtvol]]=-2 or 2: like -1 or 1 plus additional printing: moments of "on-site" densities,
        details about local exact exchange.
         <br />
         - [[pawprtvol]]=-3 or 3: like -2 or 2 plus additional printing: details about
        PAW+U, rotation matrices of sphercal harmonics.
         <br />
         When [[pawprtvol]]&gt;=0, up to 12 components of rho_ij and D_ij matrices for the 1st and last atom are printed.
         <br />
         When [[pawprtvol]]&lt;0, all components of rho_ij and D_ij matrices for all atoms are printed.
         <br />
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawprtwf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'PAW: PRinT WaveFunctions'
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         This input variable controls the output of the full PAW wave functions including the on-site
        contribution inside each PAW sphere needed to reconstruct the correct nodal shape in the augmentation region.
         <b>
          pawprtwf=1
         </b>
         causes the generation of a file  _AE_WFK that contains the full
        wavefunctions in real space on the fine FFT grid defined by
        [[pawecutdg]] or [[ngfftdg]].
        Limitations: At present (v6.0),
         <b>
          pawprtwf=1
         </b>
         is not compatible neither with the k-point parallelism
        nor with the parallelism over G-vectors. Therefore the output of the _AE_WFK has to be done in sequential.
        Moreover, in order to use this feature, one has to enable the support for ETSF-IO at configure-time
        as the _AW_WFK file is written using the NETCDF file format following the ETSF-IO specification for
        wavefunctions in real space. If the code is run entirely in serial, additional output is made of various
        contributions to the all-electron wavefunction. By default the full available set of bands and k-points are
        ouput, but a single band and k-point index can be requested by using the variables
        [[pawprt_b]] and [[pawprt_k]].
        </p>
    topics: PAW_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: pawspnorb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nspinor]]==2': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW - option for SPiN-ORBit coupling
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         When PAW is activated, the
         <b>
          spin-orbit coupling
         </b>
         can be added without the use of specific PAW datasets (pseudopotentials).
         <br />
         If [[pawspnorb]]=1, spin-orbit will be added.
         <br />
         If the wavefunction is spinorial (that is, if [[nspinor]]=2),
         there is no reason not to include the spin-orbit interaction, so that the default value of [[pawspnorb]]
         becomes 1 when [[nspinor]]=2.
         <br />
         Note that only the all-electron "on-site" contribution to the Hamiltonian is taken into account;
        this is a very good approximation but requires the
        following conditions to be fullfilled:
         <br />
         <div style="margin-left: 20px;">
          1- the
          <span style="position: relative; top: -8pt; left: 8pt;">
          </span>
          <span style="position: relative; top: -5pt; left: 6pt;">
           ~
          </span>
          &#966;
          <sub>
           i
          </sub>
          basis is complete enough
          <br />
          2- the electronic density is mainly
        contained in the PAW sphere
          <br />
         </div>
         <br />
         Also note that, when spin-orbit coupling is activated and there is some magnetization [[nspden]]=4, the time-reversal symmetry is broken.
         <br />
         The use of [[kptopt]]=1 or [[kptopt]]=2 is thus
        forbidden. It is advised to use [[kptopt]]=3 (no symmetry used to generate k-points)
        or [[kptopt]]=4 (only spatial symmetries used to generate k-points).
         <br />
         Be careful if you choose to use [[kptopt]]=0 (k-points given by hand); Time-reversal symmetry
        has to be avoided.
         <br />
         An artificial scaling of the spin-orbit can be introduced thanks to the [[spnorbscl]] input variable.
        </p>
    topics: PAW_useful, spinpolarisation_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: pawstgylm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - option for the STorage of G_l(r).YLM(r)
    requires: '[[usepaw]]=1'
    text: |-
        <p>
         When PAW is activated, the computation of compensation charge density (so called
        "hat" density) requires the computation of g_l(r).Y_lm(r) factors (and cartesian derivatives) at each point
        of real space contained in PAW spheres. The number of atoms, of (l,m) quantum numbers
        and the sharpness of the real FFT grid can lead to a very big {g_l.Y_lm} datastructure.
        One can save memory by putting [[pawstgylm]]=0; but, in that case, g_l(r).Y_lm(r) factors
        a re-computed each time they are needed and CPU time increases.
         <br />
         <br />
         <div style="margin-left: 20px;">
          Possible choices:
          <br />
          - [[pawstgylm]]=0 : g_l(r).Y_lm(r) are not stored in memory and recomputed.
          <br />
          - [[pawstgylm]]=1 : g_l(r).Y_lm(r) are stored in memory.
          <br />
         </div>
         <br />
         <div style="margin-left: 40px;">
          Note:
          <br />
          g_l(r) are shape functions (analytically known)
          <br />
          Y_lm(r) are real spherical harmonics
         </div>
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawsushat
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PAW - SUSceptibility, inclusion of HAT (compensation charge) contribution
    requires: '[[usepaw]]==1 and [[optdriver]]==0 '
    text: |-
        <p>
        Ground-State calculation only.
         <br />
         When a sophisticated preconditioning scheme is selected for the SCF cycle of a Ground-State calculation
        ([[iprcel]]&gt;0), the computation of the susceptibility matrix
        is required several times during the cycle. This computation is computer time consuming, especially
        -- within PAW -- because of the inclusion of additional terms due to the compensation charge density.
        As only a crude valuation of the susceptibilty matrix is needed (to evaluate a preconditioning matrix),
        the compensation charge contribution can be neglected to save CPU time (select [[pawsushat]]=0).
        This approximation could be unfavourable in some cases; in the latter, we advise to put [[pawsushat]]=1.
         <br />
         <br />
         <div style="margin-left: 20px;">
          Possible choices:
          <br />
          - [[pawsushat]]=0 : only plane-wave contribution to suscep. matrix is computed.
          <br />
          - [[pawsushat]]=1 : the whole suscep. matrix (PW + PAW on-site) is computed.
          <br />
         </div>
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawujat
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: ' i.e. the first atom treated with PAW+U.'
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW+macro_UJ, ATom number
    requires: null
    text: |-
        <p>
         Determines the atom for which U (or J) should be determined. See also [[macro_uj]].
        </p>
    topics: DFT+U_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: pawujrad
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: a.u.
        value: 20
    dimensions: scalar
    excludes: null
    mnemonics: PAW+macro_UJ, sphere RADius
    requires: null
    text: |-
        <p>
         The sphere radius serves to extrapolate the U value calculated at r_paw to a larger sphere radius.
        See also [[macro_uj]].
        As most projector functions are localized within r_paw to &asymp;80%,
        20 a.u. contains &asymp;100% of the wavefunction and corresponds to r_paw &rarr; &infin;.
        </p>
    topics: DFT+U_expert
    varset: dev
    vartype: real
- !variable
    abivarname: pawujv
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 0.1
    dimensions: scalar
    excludes: null
    mnemonics: PAW+macro_UJ, potential shift (V)
    requires: null
    text: |-
        <p>
         Amplitude of the potential shift for the determination of U (or J). See also [[macro_uj]].
        </p>
    topics: DFT+U_expert
    varset: dev
    vartype: real
- !variable
    abivarname: pawusecp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - option for the USE of CPrj in memory (cprj=WF projected with NL projector)
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         <br />
         When PAW is activated, the computation of cprj arrays is memory and time consuming.
         <br />
         When [[pawusecp]]=0, then the cprj are never kept in memory, they are recomputed when needed (this is CPU-time consuming).
        When [[pawusecp]]=1, then the cprj are computed once and then kept in memory.
         <br />
         Change the value of the keyword only if you are an experienced user (developper).
         <br />
         Remember: cprj = (WF_n .dot. p_i) (WF_n=wave function, p_i=non-local projector).
         <br />
         <br />
         For the time being, only activated for RF calculations.
         <br />
        </p>
    topics: PAW_expert
    varset: paw
    vartype: integer
- !variable
    abivarname: pawxcdev
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PAW - choice for eXchange-Correlation DEVelopment (spherical part)
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         <ul>
          <li>
           If set to 0, the exchange-correlation term in the spherical part of energy is
        totally computed on the angular mesh
          </li>
          <li>
           If set to 1, the exchange-correlation term in the spherical part of energy is
        developed onto lm-moments at order 1
          </li>
          <li>
           If set to 2, the exchange-correlation term in the spherical part of energy is
        developed onto lm-moments at order 2 (can be memory/CPU consuming)
          </li>
         </ul>
         <br />
         Be careful: GGA requires [[pawxcdev]] &gt; 0
        </p>
    topics: PAW_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: ph_intmeth
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    dimensions: scalar
    excludes: null
    mnemonics: 'PHonons: INTegration METHod'
    requires: null
    text: |-
        Select the integration technique for computing the phonon DOS and the Eliashberg function a2fF(w).
        <p>
        <br>
        1 for Gaussian scheme (see also [[ph_smear]]).
        <br/>
        <br>
        2 for tetrahedron method (no other input is needed but requires at least 4 q-points in the BZ)
        </br>
        </p>
    topics: q-points_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: ph_ndivsm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 20
    dimensions: scalar
    excludes: null
    mnemonics: 'PHonons: Number of DIVisions for sampling the SMallest segment'
    requires: null
    text: |-
        This variable is used in conjunction with [[ph_nqpath]] and [[ph_qpath]] to define the q-path used for phonon band structures and phonon linewidths. It gives the number of points used to sample the smallest segment in the q-path specified by [[ph_qpath]].
    topics: q-points_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: ph_ngqpt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 20
    - 20
    - 20
    dimensions:
    - 3
    excludes: null
    mnemonics: 'PHonons: Number of Grid points for Q-PoinT mesh.'
    requires: null
    text: |-
        This variable defines the q-mesh used to compute the phonon DOS and the Eliashberg function via Fourier interpolation.
        Related input variables: [[ph_qshift]] and [[ph_nqshift]].
    topics: q-points_useful
    varset: dfpt
    vartype: integer
- !variable
    abivarname: ph_nqpath
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'PHonons: Number of Q-points defining the PATH'
    requires: null
    text: |-
        This integer defines the number of points in the [[ph_qpath]] array.
    topics: q-points_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: ph_nqshift
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'PHonons: Number of Q-SHIFTs'
    requires: null
    text: |-
        This variable defines the number of shifts in the q-mesh used
        for the phonon DOS and for the Eliashberg functions (see [[ph_ngqpt]]).
        If not given, the code assumes a Gamma-centered mesh. The shifts
        are specified by [[ph_qshift]].
    topics: q-points_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: ph_qpath
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: None
    dimensions:
    - 3
    - ph_nqpath
    excludes: null
    mnemonics: 'Phonons: Q-PATH'
    requires: specified([[ph_nqpath]])
    text: |-
        This array contains the list of special q-points used to construct the q-path for phonon band structures and phonon linewidths.
        See also [[ph_nqpath]] and [[[ph_ndivsm]].
    topics: q-points_useful
    varset: dfpt
    vartype: real
- !variable
    abivarname: ph_qshift
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    - ph_nqshift
    excludes: null
    mnemonics: 'PHonons: Q-SHIFTs for mesh.'
    requires: '[[ph_nqshift]]'
    text: |-
        This array gives the shifts to be used to construct the q-mesh for
        computing the phonon DOS and the Eliashberg functions (see also [[ph_nqshift]]. If not given, a Gamma-centered mesh is used.
    topics: q-points_useful
    varset: eph
    vartype: real
- !variable
    abivarname: ph_smear
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.00002 Hartree
    dimensions: scalar
    excludes: null
    mnemonics: 'PHonons: SMEARing factor'
    requires: '[[ph_intmeth]]==1'
    text: |-
        The gaussian broadening used for the integration of the phonon
        DOS and the Eliashberg function. See also [[ph_intmeth]] and [[ph_ngqpt]].
    topics: q-points_useful
    varset: eph
    vartype: real
- !variable
    abivarname: ph_wstep
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.1 meV
    dimensions: scalar
    excludes: null
    mnemonics: 'PHonons: frequency(W)  STEP.'
    requires: null
    text: |-
        The step used to generate the (linear) frequency mesh for the phonon DOS and the Eliashberg function.
        The extrema of the mesh are automatically computed by the code.
    topics: q-points_useful
    varset: eph
    vartype: real
- !variable
    abivarname: phimax@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    dimensions: scalar
    excludes: null
    mnemonics: PHI MAXimal angle
    requires: null
    text: |-
        Angular limits of integration of the Bader volume
          for the phi variables. The number
          of integration points is given by
          [[aim:nphi]].
          The range of integration can be decreased if there are
          symmetry reasons for doing this.
    topics: Bader_basic
    varset: aim
    vartype: real
- !variable
    abivarname: phimin@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: PHI MINimal angle
    requires: null
    text: |-
        Angular limits of integration of the Bader volume
          for the phi variables. The number
          of integration points is given by
          [[aim:nphi]].
          The range of integration can be decreased if there are
          symmetry reasons for doing this.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: piezoflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PIEZOelectric tensor FLAG
    requires: null
    text: |-
        <p>Flag for calculation of piezoelectric tensors
        <ul>
          <li>0 =&gt; No piezoelectric tensor will be calculated.</li>
          <li>1 =&gt; Only the clamped-ion piezoelectric tensor is computed and
        printed. Requirements for preceding response-function DDB generation
        run: Strain and electric-field responses. For the electric-field part,
        one needs results from a prior 'ddk perturbation' run. Note that even
        if only a limited number of piezoelectric tensor terms are wanted (as
        determined by rfstrs and rfdir in this calculation) it is necessary to
        set rfdir = 1 1 1 in the d/dk calculation for most structures. The only
        obvious exception to this requirement is cases in which the primitive
        lattice vectors are all aligned with the cartesian axes. The code will
        omit terms in the output piezoelectric tensor for which the available
        d/dk set is incomplete. Thus: Set [[rfstrs]] to 1, 2, or 3i
        (preferably 3) </li>
          <li>2 =&gt; Both relaxed- and clamped-ion elastic and compliance
        tensor will be calculated, but only the relaxed-ion quantities will be
        printed. The input variable [[anaddb:instrflag]]
        should also be set to 1, because the internal-strain tensor is needed
        to compute the relaxed-ion corrections. Requirements for preceding
        response-function DDB generation run: Strain, electric-field and full
        atomic-displacement responses at Q=0. Set [[rfstrs]] = 1, 2, or 3
        (preferably 3). Set [[rfelfd]] = 3. Set [[rfatpol]] and <[[rfdir]] to do a
        full calculation of phonons at Q=0 (needed because the inverse of
        force-constant tensor is required). </li>
          <li>3 =&gt; Both relaxed and clamped-ion piezoelectric tensors will
        be printed out. The input variable [[anaddb:instrflag]]
        should also be set to 1. Requirements for preceding response-function
        DDB generation run: Same as for <b>piezoflag</b>=2. </li>
          <li>4 =&gt; Calculate the piezoelectric d tensor (relaxed ion). In
        order to calculate the piezoelectric d tensor, we need information of
        internal strain and elastic tensor (relaxed ion). So we should set [[anaddb:elaflag]]= 2,3,4, or 5 and [[anaddb:instrflag]]=1. The subroutine will
        also do a check for you, and print warning message without stopping
        even if flags were not correctly set. </li>
          <li>5 =&gt; Calculate the piezoelectric g tensor (relaxed ion). In
        this computation, we need information of internal strain, elastic
        tensor (relaxed ion) and dielectric tensor (relaxed ion). So we should
        set: [[anaddb:instrflag]]=1, [[anaddb:elaflag]]=2,3,4 or 5, [[anaddb:dieflag]]=3 or 4. The subroutine
        will also do a check for you, and print warning message without
        stopping even if flags were not correctly set. </li>
          <li>6 =&gt; Calculate the piezoelectric h tensor (relaxed ion). In
        this calculation, we need information of internal strain and dielectric
        tensor (relaxed ion). So we need set: [[anaddb:instrflag]]=1 and [[anaddb:dieflag]]=3 or 4. The subroutine
        will also do a check for you, and print warning message without
        stopping even if flags were not correctly set. </li>
          <li>7 =&gt; calculate all the possible piezoelectric tensors,
        including e (clamped and relaxed ion), d, g and h tensors. The flags
        should be set to satisfy the above rules from 1 to 6.</li>
        </ul>
    topics: Elastic_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: pimass
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[ntypat]]'
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: Path Integral fictitious MASSes
    requires: '[[imgmov]]=9 or 13'
    text: |-
        <p>
         Only relevant if [[imgmov]]=9 or 13 (Path-Integral Molecular Dynamics).
         <br />
         Gives the fictitious masses (
         <i>
          D. Marx and M. Parrinello, J. Chem. Phys. 104, 4077 (1996)
         </i>
         )
        in atomic mass units for each kind of atom in cell. These masses are the inertial masses used
        in performing Path Integral Molecular Dynamics (PIMD), they are different from the true masses ([[amu]]) used to define the quantum spring that relates the different beads in PIMD. They can be chosen arbitrarily, but an appropriate choice will lead the different variables to move on the same time scale in order to optimize the sampling efficiency of the PIMD trajectory.
         <br />
         If [[pitransform]]=1 (normal mode transformation), or [[pitransform]]=2 (staging transformation), [[pimass]] is automatically set to its optimal value.
         <br />
        </p>
    topics: PIMD_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: pimd_constraint
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Path-Integral Molecular Dynamics: CONSTRAINT to be applied
        on a reaction coordinate'
    requires: '[[imgmov]]=9 or 13'
    text: |-
        Only relevant for Path-Integral Molecular Dynamics.<br/>
        Selects a constraint to be applied during the PIMD trajectory. The constraint is holonomic (it is a relation between the position variables).In practice, the total forces applied to the atomic positions are modified so as to respect the constraint.<br/>
        To date, the available constraints are:<br/>
        <ul>
        <li><b>0</b>: no constraint</li>
        <li><b>1</b>: <i>"Blue Moon Ensemble" method</i>.<br/>
        The constraint is a linear combination of the positions of atomic centroids (this linear combination is kept constant during the simulation). <br/>
        Sum[W_i * X_i]=constant<br/>
        The X_i are the coordinates of the atomic centroids. The weights W_i have to be specified with the [[wtatcon]](3,[[natcon]],[[nconeq]]), [[iatcon]]([[natcon]]) and [[natcon]] input parameters (where [[nconeq]] is fixed to 1).<br/>
        More details on the implementation in: <a href="http://doi.org/10.1273/cbij.7.12">Y. Komeiji,Chem-Bio Informatics Journal 7, 12-23 (2007)</a>.
        </li>
        </ul>
    topics: PIMD_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: pitransform
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Path Integral coordinate TRANSFORMation
    requires: null
    text: |-
        <p>
         Only relevant if [[imgmov]]=9 or 13 (Path-Integral Molecular Dynamics).
        Coordinate transformation used in the integration of the Path Integral Molecular Dynamics equations of motion. The transformation, with an appropriate choice of fictitious masses ([[pimass]]), is used to force the different modes to move on the same time scale, and thus optimize the efficiency of the statistical sampling in the corresponding statistical ensemble.
        Available with a Langevin thermostat ([[imgmov]]=9) or with Nose-Hoover chains ([[imgmov]]=13).
        See M. Tuckerman et al, J. Chem. Phys. 104, 5579 (1996).
        </p>
        <p>
         If equal to 0, no transformation is applied (primitive coordinates).
         <br />
         If equal to 1, normal mode transformation (in that case, [[nimage]] must be absolutely EVEN).
         <br />
         If equal to 2, staging transformation.
        </p>
    topics: PIMD_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: plowan_bandf
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions BAND Final
    requires: null
    text: |-
        <p>
         <br />
         Gives the upper band to include in the calculation of Wannier functions
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_bandi
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions BAND Initial
    requires: null
    text: |-
        <p>
         <br />
         Gives the lower band to include in the calculation of Wannier functions
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_compute
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions COMPUTATION
    requires: null
    text: |-
        <p>
         <br />
         Activate computation of Projected Local Orbital Wannier functions (PLO Wannier) and  corresponding band structure.
        Variables [[plowan_bandi]],
        [[plowan_bandf]],
        [[plowan_natom]],
        [[plowan_nbl]],
        [[plowan_iatom]],
        [[plowan_lcalc]],
        [[plowan_projcalc]] are mandatory to precise the nature of the projections.
         <ul>
          <li>
           0=&gt; Default value: do not activate calculation of PLO Wannier.
          </li>
          <li>
           1=&gt; Compute PLO Wannier and band structure
          </li>
          <li>
           2=&gt; Compute PLO Wannier and band structure. In this case, the coupling in k-space between blocks of Wannier functions belonging to different
        angular momenta or atoms is removed.
          </li>
         </ul>
         Other related variables are
        [[plowan_realspace]],
        [[plowan_nt]],
        [[plowan_it]].

        The implementation is not symetrized over k-point and not parallelized.

        (The calculation of projections is
        detailed in
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">
          Phys. Rev. B 77, 205112, (2008)
         </a>
         )
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_iatom
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions, Index of ATOM
    requires: null
    text: |-
        <p>
         <br />
         Gives the indices of the [[plowan_natom]] atoms on which the projections will be done.
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_it
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 3
    - '[[plowan_nt]]'
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions,  Index of Translation.
    requires: null
    text: |-
        <p>
         <br />
         Requires [[plowan_realspace]]  to be greater than 0 and
        [[plowan_nt]]  to be greater than 0.
        Precise a given set of selected real space translation by using the real space vectors basis.
        These atoms are used to define Wannier functions in real space. These real space
        Wannier functions are used as a basis to compute the Hamiltonian.
        </p>
    topics: Wannier_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_lcalc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    dimensions:
    - sum([[plowan_nbl]])
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions,  L values to use for CALCulation
    requires: null
    text: |-
        <p>
         <br />
         Gives the [[plowan_nbl]] values of angular momenta for each atom, in the order of the atoms
        as given in [[plowan_iatom]].
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_natom
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions, Number of ATOMs
    requires: null
    text: |-
        <p>
         <br />
         Gives the number of atoms on which the projection will be done
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_nbl
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[plowan_natom]]'
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions,  NumBer of L values
    requires: null
    text: |-
        <p>
         <br />
         Gives the total number of angular momenta (over all atoms) to compute the projections.
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_nt
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: |-
        Projected Local Orbital WANnier functions,  Number of Translation on which the real space values of
        energy are computed
    requires: null
    text: |-
        <p>
         <br />
         Requires [[plowan_realspace]]  to be greater than 0.
        Gives a number of selected atoms. These atoms are used to define Wannier functions in real space. These real space
        Wannier functions are used as a basis to compute the Hamiltonian.
        </p>
    topics: Wannier_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_projcalc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    dimensions:
    - sum([[plowan_nbl]])
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions,  PROJectors values to use for CALCulation
    requires: null
    text: |-
        <p>
         <br />
         Gives the [[plowan_nbl]] values of projectors for each atom, in the order of the atoms
        as given in [[plowan_iatom]]. The index i for the projectors refers to the  ith number on line
        orbitals of the PAW atomic data file.
        </p>
    topics: Wannier_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: plowan_realspace
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Projected Local Orbital WANnier functions,  activate REAL SPACE calculation.
    requires: null
    text: |-
        <p>
         Can take the following values:
         <ul>
          <li>
           0=&gt; Default value: do not activate calculation of real space Wannier functions.
          </li>
          <li>
           1=&gt; Compute PLO Wannier in real space for analysis. These data can also be used in a following dataset to perform a Wannier interpolation.
          </li>
          <li>
           2=&gt; Do simple Wannier Interpolation for a given k points starting from real space Wannier function Hamiltonian
        computed in a preceding dataset.
          </li>
         </ul>
        </p>
    topics: Wannier_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: polcen
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: POLarization for CENtrosymmetric geometry
    requires: null
    text: |-
        <p>
         When doing a finite electric displacement field calculation,
        if the structure is centrosymmetric but the polarization is non-zero (such as for AlAs),
        this non-zero polarization should be specified as [[polcen]] (in REDUCED coordinates, in atomic units) in the input file.
        See Eq.(24) in the Suppl. of Nat. Phys. (M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009))
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: polflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: POLarization FLAG
    requires: null
    text: |-
        <p>If activated, compute polarization in cartesian coordinates,
        and update lattice constants and atomic positions in order to perform a structural
        optimization at constrained polarization.
        <p>
        More detailed explanation: ANADDB can use the formalism described in
        Na Sai et al, PRB 66, 104108 (2002), to perform structural relaxations
        under the constraint that the polarization is equal to a value specified by the
        input variable [[anaddb:targetpol]].
        The user starts from a given configuration of a crystal and performs
        a ground-state calculation of the Hellman-Feynman forces and stresses
        and the Berry phase polarization as
        well as a linear response calculation of the whole matrix of
        second-order energy derivatives with respect to atomic displacement,
        strains and electric field.
        <br>
        In case <b>polflag</b>=1, ANADDB solves the linear system of equations
        (13)
        of the Na Sai paper, and computes new atomic positions (if [[anaddb:relaxat]]=1) and
        lattice constant (if [[anaddb:relaxstr]]=1).
        Then, the user uses these parameters to perform a new ground-state
        and linear-response calculation. This must be repeated until convergence is
        reached. The user can also fix some atomic positions, or strains, thanks to the input variables
        [[anaddb:natfix]], [[anaddb:nstrfix]],[[anaddb:iatfix]],[[anaddb:istrfix]].
        <br>
        In case both [[anaddb:relaxat]]
        and [[anaddb:relaxstr]] are 0, while
        <b>polflag</b>=1, ANADDB only computes the polarization in cartesian coordinates.
        </p>
        <p><As described in the Na Sai's paper, it is important to use the
        finite difference expression of the ddk ([[berryopt]]=2 or -2)
        in the linear response calculation of the effective charges and the piezoelectric tensor.
    topics: ConstrainedPol_compulsory
    varset: anaddb
    vartype: integer
- !variable
    abivarname: posdoppler
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: POSitron computation of DOPPLER broadening
    requires: null
    text: |-
        <p>
         Relevant only when [[positron]]&lt;&gt;0.<br>
         This input parameter activates the calculation of the Doppler broadening of the electron-positron annihilation radiation.<br>
         An output file containing the momentum distributions
         of annihilating electron-positron pairs is created.<br>
         Such a computation needs a core wave-function file (per atom type) to be provided.
         This core WF file should be named '&lt;psp_file_name&gt;.corewf'
         (where &lt;pspfile_name&gt; is the name of the pseudo-potential (or PAW) file)
         or 'corewf.abinit&lt;ityp&gt;' (where &lt;ityp&gt; is the index of the atom type).
         Core WF files can be obtained with the atompaw tool by the use of 'prtcorewf' keyword.
        </p>
    topics: positron_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: positron
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: POSITRON calculation
    requires: null
    text: |-
        <p>
        This input parameter can be positive or negative.<br>
        Negative values for [[positron]] are only relevant for PAW calculations.<br>
        Electron-positron correlation functional is defined by [[ixcpositron]].<br>
        Other relevant input parameter: [[posocc]] (occupation number for the positron).<br>

        <br><U>Positive values for [[positron]]:</U><br>
        <i>For <b>[[positron]]=1 or 2</b>, will perform the calculation of positron
        lifetime (and annihilation rate).</i><br>
        <ul>
        <li>[[positron]]=1</b>:<br>
        Starting from a previous electronic GS density (with <b>[[positron]]=0</b>),
         a positronic ground-state calculation is performed, considering that the electrons are not perturbed
         by the presence of the positron.<br>
        This is almost correct for a positron in a perfect bulk material.
        But this approximation fails when defects exist in
        the material (for instance: the positron might be trapped by a vacancy).<br>
        The electronic density will be automatically read from a _DEN file (with or without [[irdden]]
        keyword).<br>
        At the end of the SCF cycle, the positron lifetime and annihilation rate
        are printed out.<br><br>
        <i>Additional information for the use of pseudopotentials:<br><ul>
        <li>PAW datasets: nothing to do; simply use usual electronic PAW datasets
        <li>Norm-conserving pseudopotentials: One has to use specific
         pseudopotentials for the positron calculation.
        They must be of the FHI type (pspcod=6), and must contain at their
        end, the all-electrons core density generated with FHI98PP. They must have
        lmax=lloc=0 (check that this works for the electronic GS !! No ghost, etc ...). Otherwise, their are similar to an usual FHI pseudopotential.<br>
        </i></ul><br>

        <li><b>positron=2</b>:<br>
        Starting from a previous positronic GS density (with <b>positron=1</b>),
        an electronic ground-state calculation is performed, keeping the positronic
        density constant.<br>
        The positronic density will be automatically read from a _DEN file (with or without
        [[getden]]/[[irdden]] keyword).<br>
        At the end of the SCF cycle, the positron lifetime and annihilation rate
        are printed out.<br><br>
        <i>Additional information for the use of pseudopotentials:<br><ul>
        <li>PAW datasets: nothing to do; simply use usual electronic PAW datasets
        <li>Norm-conserving pseudopotentials: One has to use specific
         pseudopotentials for the electron calculation.
        They must be of the FHI type (pspcod=6), and must contain at their
        end, the all-electrons core density generated with FHI98PP.<br>
        </i></ul><br>

        <li><b>Typical use</b>:<br>
        The calculation is done in several steps:<br>
        The first one is a normal GS calculation for the electrons, with <b>positron</b>=0.
        The only specific thing to do is to set [[prtden]]=1 (this is the defaut for ABINIT v6.x+).
        This will create the associated _DEN file which will be used as input file for the positronic
        GS calculation.<br>
        The second step is the GS calculation of the positron and subsequently its
        lifetime, with <b>positron</b>=1.
        One has to define also [[ixcpositron]].<br>
        Then, it is possible to perform an additional step, computing
        the GS electronic density in presence of the positron, with <b>positron</b>=2.<br>
        and so on...<br>
        This procedure can be automated (for PAW only) by the use of a negative value for <b>positron</b>.<br>
        At the end, a converged value of the positron lifetime (decomposed in several contributions) is printed. <br>
        See also [[posdoppler]] keyword for the calculation of Doppler broadening.<br>
        </ul>

        <br><U>Negative values for <b>positron</b>:</U><br>
        <i>For <b>positron&lt;0</b>, will perform an automatic calculation of electrons and positron
        densities in the two-component DFT context; then will compute positron lifetime (and annihilation rate).</i><br>

        <ul><li><b>positron=-1</b>:<br>
        Starting from scratch, will first perform an usual electronic ground-state
        calculation until convergence (controlled by the use of one of the <i>tolerance</i> keywords).<br>
        Then will perform a positronic ground state calculation in presence of the electrons
        and ions; then an electronic ground state calculation in presence of the positron and the ions...<br>
        and so on... until the total energy is converged.<br>
        The convergence of the total energy of the ions+electrons+positron system
        is controlled by the use of the [[postoldfe]], [[postoldff]]
        and [[posnstep]] input keywords.<br>
        With <b>positron=-1</b>, at the beginning of each new electronic/positronic step,
        the wave functions are unknown.</ul>

        <ul><li><b>positron=-10</b>:<br>
        Same as <b>positron=-1</b> except that the electronic/positronic wave functions
        are stored in memory.<br>
        Consequently, the total number of iterations to reach the convergence (diff_Etotal<[[postoldfe]]
        or diff_Forces<[[postoldff]]) is smaller.<br>
        But, this can increase the total amount of memory needed by the code.</ul>

        <ul><li><b>positron=-2</b>:<br>
        Same as <b>positron=-1</b> except that the two-component DFT cycle
        is forced to stop at the end of an electronic step.</ul>

        <ul><li><b>positron=-20</b>:<br>
        Same as <b>positron=-10</b> except that the two-component DFT cycle
        is forced to stop at the end of an electronic step.</ul><br>

        <U>Advice for use:</U><br>
        There are two typical cases which have to be differently treated:
        <ul><li><b>A positron in a perfect <U>bulk</U> system</b>:<br>
        In that case, the positron is delocalized in the whole crystal. Its density is almost zero.<br>
        Thus, the "zero density positron limit" has to be used. [[ixcpositron]] has to be choosen accordingly.<br>
        In order to have the zero density positron limit it is adviced to follow these points:<br>
        1- Put a small positronic charge (by setting a [[posocc]] to a small value) <b>OR</b> use a big supercell.<br>
        2- Use only k=gamma wave vector for the positronic calculation.<br>
        3- Use the manual procedure in 2 steps: first <b>positron</b>=0 and then <b>positron</b>=1; avoid the <b>positron=2</b> step and the automatic procedure (<b>positron</b>&lt;0).<br>
        In principle, the positron lifetime should converge with the value of [[posocc]] or the size of the supercell.<br></ul>

        <ul><li><b>A positron trapped in a <U>default</U> (vacancy...)</b>:<br>
        In that case, the positron is localized in the default. Its density can be localized in the simulation cell (provided that the cell is sufficiently large) and influences the electronic density.<br>
        So, it is advised to use the automatic procedure (<b>positron</b>&lt;0) or the manual procedure with several <b>positron</b>=0,1,2,1,... steps.<br>
        K-points can be used as in usual electronic calculations.<br>
        Also note that it is possible to use forces and stresses to perform structural minimization.<br></ul>

        References:<br>
        <ul>
        <b>[1]</b> J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).<br>
        <b>[2]</b> Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).<br>
        <b>[3]</b> P.A. Sterne and J.H. Kaiser, Phys. Rev. B 43, 13892 (1991).<br>
        <b>[4]</b> M.J. Puska, A.P. Seitsonen and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).<br>
        <b>[5]</b> B. Barbiellini, M.J. Puska, T. Torsti and R.M.Nieminen, Phys. Rev. B 51, 7341 (1994)<br>
        </ul>
    topics: positron_compulsory
    varset: gstate
    vartype: integer
- !variable
    abivarname: posnstep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 50
    dimensions: scalar
    excludes: null
    mnemonics: 'POSitron calculation: max. Number of STEPs for the two-component
        DFT'
    requires: null
    text: |-
        <p>
         Relevant only when [[positron]]&lt;0.
         <br />
         Sets the maximum number of electronic/positronic iterations that, when reached, will cause the two-component DFT SCF cycle to stop.
         <br />
         The code will first compute the electronic ground-state, then the positronic ground state in the electronic density, then the electronic ground-state in the positronic density, ...
         <br />
         ...until diff_Etotal&lt;[[postoldfe]] or diff_Forces&lt;[[postoldff]]
        or the number of electronic/positronic steps is [[posnstep]].
         <br />
        </p>
    topics: positron_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: posocc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'POSitron calculation: OCCupation number for the positron'
    requires: null
    text: |-
        <p>
         Relevant only when [[positron]]/=0.
         <br />
         Sets the occupation number for the positron. Has to be &lt;=1.
         <br />
         Changing [[posocc]] is only useful for bulk calculation when one wants to perform lifetime computations using a small simulation cell (can avoid the use of a supercell). It simulates the dispersion of the positron in the whole crystal.
         <br />
        </p>
    topics: positron_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: postoldfe
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[postoldff]]=0': 1.0E-6
        defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: 'POSitron calculation: TOLerance on the DiFference of total
        Energy'
    requires: null
    text: |-
        <p>
         Relevant only when [[positron]]&lt;0.
         <br />
         Sets a tolerance for absolute difference of total energy (of
         <i>
          ions+electrons+positron
         </i>
         system)
        that, when reached, will cause the SCF cycle to stop before the number of
        steps is [[nstep]] or the number of electronic/positronic steps is [[posnstep]].
         <br />
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          toldfe
         </b>
         has the '[[ENERGY]]' characteristics.
        <br />
        Only one and only one of [[postoldfe]] or [[postoldff]] can be set.
        </p>
    topics: positron_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: postoldff
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'POSitron calculation: TOLerance on the DiFference of Forces'
    requires: null
    text: |-
        <p>
         Relevant only when [[positron]]&lt;0.
         <br />
         Sets a tolerance for absolute difference of maximum force acting on ions (due to
         <i>
          ions+electrons+positron
         </i>
         system)
        that, when reached, will cause the SCF cycle to stop before the number of SCF
        steps is [[nstep]] or the number of electronic/positronic steps is [[posnstep]].
         <br />
         Only one and only one of [[postoldfe]] or [[postoldff]] can be set.
         <br />
        </p>
    topics: positron_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: ppmfrq
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: Ha
        value: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Plasmon Pole Model FReQuency
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         <b>
          In plasmon-pole calculations
         </b>
        </p>
        <p>
         Usually only effective if GW corrections are evaluated using the plasmon-pole model of Godby-Needs
        ([[ppmodel]]==1).
         <br />
         <br />
         In the present status of the GW code, the convolution in frequency space
        defining the self-energy operator can be evaluated using two different approaches:
        numerical integration and plasmon-pole models.
         <br />
         Methods based on the numerical integration (contour deformation, analytic continuation) require
        the knowledge of the screened interaction for several frequencies. These approaches give
        the most accurate results but at the price of an increase in the CPU time required.
         <br />
         Alternatively, it is possible to approximate the dynamical behaviour of the screened interaction
        through simple analytical expressions, the so-called plasmon-pole models.
        In the plasmon-pole model proposed by Godby-Needs ([[ppmodel]]=1),
        the screening must be available at zero frequency, as well as at another imaginary frequency,
        of the order of the plasmon frequency (the peak in the EELS spectrum).
        This information is used to model the behaviour of the dielectric matrix
        for all frequencies.
        During the calculation of the screening, [[ppmfrq]] defines the imaginary frequency where the
        dielectric matrix is evaluated, in addition to the zero frequency.
        During the self-energy run, [[ppmfrq]] can be used to define the second frequency to be used
        to calculate the plasmon-pole parameters. This is particularly useful when the
        SCR file contains several frequencies along the imaginary axis.
        In this case the frequency whose value is the closest one to [[ppmfrq]] will be selected.
        Note that, if the plasmon-pole approximation is good, then, the
        choice of [[ppmfrq]] should have no influence on the final result.
        One should check whether this is the case. In general, the plasmon frequencies of bulk solids
        are of the order of 0.5 Hartree.
         <br />
         <br />
         <b>
          In Contour Deformation calculations
         </b>
        </p>
        <p>
         [[ppmfrq]] is here used to
         <b>
          override
         </b>
         the default value calculated from the average electronic
        density per unit cell. This can affect the distribution of gridpoints along the imaginary and
        real frequency axes. See
        [[cd_frqim_method]], [[gw_frqim_inzgrid]] and [[gw_frqre_inzgrid]] for more details.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: ppmodel
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Plasmon Pole MODEL
    requires: '[[optdriver]] in [3,4]'
    text: |-
        <p>
         <ul>
          <li>
           [[ppmodel]]=1 : PP model of Godby and Needs,
        See Phys Rev Lett 62, 1169 (1989)
          </li>
          <li>
           [[ppmodel]]=2 : PP model of Hybertsen and Louie,
        See Phys Rev B 34, 5390 (1986)
          </li>
          <li>
           [[ppmodel]]=3 : PP model of  W. von der Linden
        and P. Horsh see Phys Rev B 37, 8351 (1988)
          </li>
          <li>
           [[ppmodel]]=4 : PP model of Farid and Engel.
        See Phys Rev B47,15931 (1993)
          </li>
          <li>
           [[ppmodel]]=0 : no PP model, numerical integration
        (contour deformation method, see e.g. S. Lebegue  et al. PRB  67, 155208 (2003).)
          </li>
         </ul>
         Please note the difference between [[ppmodel]] 1 and [[ppmodel]] 2,3,4.
        In the first case ([[ppmodel]]=1), the plasmon-pole parameters are determined in order to reproduce
        the behaviour of the dielectric matrix at two calculated frequencies: the static limit (omega=0)
        and the imaginary frequency defined by [[ppmfrq]].
        In the last three cases, instead, the plasmon-pole parameters are found
        by using the dielectric matrix calculated only at omega=0 and enforcing the so-called f-sum rule.
        See also [[nfreqre]].
        </p>
        <p>
         Please note also that in the case of [[ppmodel]] 4, the plasmon energies are not simple mathematical parameters,
        but rather have a physical meaning (at least the lowest ones).
        Thus the calculated plasmon band structure (plasmon energy vs q vector) is reported in the output file for the
        lowest 10 bands.
        </p>
    topics: SelfEnergy_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: prepanl
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PREPAre Non-Linear response calculation
    requires: null
    text: |-
        <p>
         The computation of third-order derivatives from the 2n+1 theorem
        requires the first-order wavefunctions and densities obtained from
        a linear response calculation. The standard approach in a linear
        response calculation is (i) to compute only the
        irreducible perturbations, and (ii) to use symmetries to
        reduce the number of k-points for the k-point integration.
         <br />
         This approach cannot be applied, presently (v4.1),
        if the first-order wavefunctions are to be used to compute third-order derivatives.
        First, for electric fields, the code needs the derivatives
        along the three directions. Still, in case of phonons, only the
        irreducible perturbations are required.
        Second, for both electric fields and phonons, the wavefunctions
        must be available in half the BZ (kptopt=2), or the full BZ (kptopt=3).
         <br />
         During the linear response calculation, in order to prepare a non-linear
        calculation, one should put [[prepanl]] to 1 in order
        to force ABINIT (i) to compute the electric field perturbation
        along the three directions explicitly, and (ii) to keep the full number of k-points.
        </p>
    topics: nonlinear_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: prepgkk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PREPAre GKK calculation
    requires: null
    text: |-
        <p>
         The calculation of electron-phonon coupling quantities requires the presence
        of all the perturbations (all atoms in all directions) for the chosen set
        of (irreducible) q-points. To impose this and prevent ABINIT from using
        symmetry to reduce the number of perturbations, set [[prepgkk]] to 1.
        Use in conjunction with [[prtgkk]].
        </p>
    topics: ElPhonInt_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: prepscphon
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PREPare Self-Consistent PHONon calculation
    requires: null
    text: |-
        <p>
         Print PCINFO, PHFREQ, and PHVEC files, for use with self-consistent phonon runs, after a perturbation
        calculation. Only prints out files for the present q-point, and there is presently no tool to symmetrize
        or merge these files, so use anaddb instead (with prtscphon input variable). The abinit input
        variable is destined to someday bypass the use of anaddb for scphon calculations.
        </p>
    topics: printing_prngs
    varset: dev
    vartype: integer
- !variable
    abivarname: prt1dm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT 1-DiMensional potential and density
    requires: null
    text: |-
        <p>
         If set &gt;= 1, provide one-dimensional projection of
        potential and density, for each of the three axis.
        This corresponds to averaging the potential
        or the density on bi-dimensional slices of the FFT grid.
        </p>
    topics: printing_prgs
    varset: files
    vartype: integer
- !variable
    abivarname: prt_ifc@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Interatomic Force Constants
    requires: null
    text: |-
        <p>Flag to print out the Interatomic Force Constants in real space to a file. The available
        options are:
        <ul>
         <li>0 =&gt; do nothing (IFC are printed to the log file);</li>
         <li>1 =&gt; write out the IFC in file ifcinfo.out (the name is fixed) to be used by AI2PS from John Rehr's group</li>
        </ul>
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtatlist
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[natom]]'
    excludes: null
    mnemonics: PRinT by ATom LIST of ATom
    requires: null
    text: |-
        <p>
         This is an array of the numbers associated to the index atoms that
        the user want to print in the output or log files, this is useful when
        you have a large number of atoms and you are only interested to
        follow specific atoms, the numbers associated should be consistent
        with the list in [[xcart]] or [[xred]].
         This input varible does not affect the contents of the "OUT.nc" or
        "HIST.nc", those are NetCDF files containing the information about
        all the atoms.
        </p>
    topics: printing_prgeo, Output_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: prtbbb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Band-By-Band decomposition
    requires: null
    text: |-
        <p>
         If [[prtbbb]] is 1, print the band-by-band decomposition of
        Born effective charges and localization tensor, in case they are computed.
        See Ph. Ghosez and X. Gonze, J. Phys.: Condens. Matter 12, 9179 (2000).
        </p>
    topics: printing_prngs, Output_useful
    varset: dfpt
    vartype: integer
- !variable
    abivarname: prtbltztrp
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT output for BoLTZTRaP code
    requires: null
    text: |-
        <p>
         Print out geometry (_BLZTRP_GEOM) and eigenenergy (_BLZTRP_EIGEN) files for the
         <a href="https://www.imc.tuwien.ac.at/forschungsbereich_theoretische_chemie/forschungsgruppen/prof_dr_gkh_madsen_theoretical_materials_chemistry/boltztrap/"> BoltzTraP code</a>
         by Georg Madsen.
        </p>
    topics: printing_prgs
    varset: dev
    vartype: integer
- !variable
    abivarname: prtbltztrp@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT input files for BoLTZTRaP code.
    requires: null
    text: |-
        <ul>
          <li>0 =&gt; do not write the BoltzTraP input files;</li>
          <li>1 =&gt; write out the input files for BoLTZTRaP code.</li>
        </ul>
    topics: PhononBands_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtcif
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Crystallographic Information File
    requires: null
    text: |-
        <p>
         If set to 1, a CIF file is output with the crystallographic data for the present run (cell size shape and atomic positions).
        </p>
    topics: printing_prgeo
    varset: dev
    vartype: integer
- !variable
    abivarname: prtddb@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Derivative DataBase files
    requires: null
    text: |-
        <p>
        Flag to print out the DDB file interpolated
        with the Interatomic Force Constants.
        <p>
        The available options are:
        <ul>
          <li>0 =&gt; no output of DDB (default);</li>
          <li>1 =&gt; Interpolate the DDB and write out the DDB and DDB.nc files. </li>
        </ul>
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]]>1': 0
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the DENsity
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value , provide output of electron density
        in real space rho(r), in units of electrons/Bohr^3.
         <br />
         If [[ionmov]]==0, the name of the density file will be
        the root output name, followed by _DEN .
         <br />
         If [[ionmov]]==1 or 2, density files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _DEN
          </li>
         </ul>
         The file structure of the unformatted output file is
        described below, see section 6).
         <br />
         If  [[prtden]] is lower than 0, two files will be printed for restart every [[prtden]]  step,
        with the names being made of
         <ul>
          <li>
           the root temporary name,
          </li>
          <li>
           followed by _DEN_x , where
        x is 0000 or 0001 alternatively.
          </li>
          <li>
           The most recent of the two files should be used for restart, and copied to root input name_DS2_DEN
          </li>
          <li>
           To perform a restart, in a multidataset mode, use ndtset 2 and jdtset 2 3 (that is 2 datasets, numbered 2 and 3)
          </li>
          <li>
           In the dataset 2, get the density you just copied (getden2 -1), perform a non selfconsistent calculation and print the wave function (prtwf2 1)
          </li>
          <li>
           In the dataset 3, get  the previous wf(getwfk3 -1), and continue the calculation
          </li>
          <li>
           This complicated procedure is due to the fact that reading the density is only allowed for a non sc calculation,
        and also for a dataset different of 0 or the previous one, the option we choose here.
          </li>
         </ul>
         Please note that in the case of PAW ([[usepaw]]=1) calculations, the _DEN density output
        is not the full physical electron density. If what is wanted is the full physical electron density, say
        for post-processing with
         <a href="../../users/generated_files/help_aim.html">
          AIM
         </a>
         or visualization, prtden &gt; 1 will produce physical electron
        density or other interesting quantities (see below). Nevertheless, even in the PAW case, when chaining together
        calculations where the density from one calculation is to be used in a subsequent calculation, it is necessary
        to use the _DEN files and
         <b>
          not
         </b>
         one of the other files produced with prtden &gt; 1, i.e. _PAWDEN, ATMDEN_xxx or else.
        Note that the usual _DEN file is always generated as soon as prtden &gt;= 1.

        Options 2 to 6 for prtden are relevant only for [[usepaw]]=1 and control the output of the
        full electron density in the PAW case :
         <br />
         <br />
         <div style="margin-left: 10px; ">
          <b>
           prtden=2
          </b>
          causes generation of a file _PAWDEN that contains the bulk
          <b>
           valence
          </b>
          charge density together with the PAW on-site contributions, and has the same format as the other density files.
          <br />
          <b>
           prtden=3
          </b>
          causes generation of a file _PAWDEN that contains the bulk
          <b>
           full
          </b>
          charge density (valence+core)
          <br />
          <b>
           prtden=4
          </b>
          causes generation of three files _ATMDEN_CORE, _ATMDEN_VAL and _ATMDEN_FULL which respectively contain the core, valence and full atomic protodensity (the density of the individual component atoms in vacuum superposed at the bulk atomic positions). This can be used to generate various visualizations of the bonding density.
          <br />
          <b>
           prtden=5
          </b>
          options 2 and 4 taken together.
          <br />
          <b>
           prtden=6
          </b>
          options 3 and 4 taken together.
          <br />
          <b>
           prtden=7
          </b>
          causes the generation of all the individual contributions to the bulk
          <b>
           valence
          </b>
          charge density : n_tilde-n_hat (_N_TILDE), n_onsite (_N_ONE) and n_tilde_onsite (_NT_ONE). This is for diagnosis purposes only.
          <br />
         </div>
         <br />
         Options 3 to 6 currently require the user to supply the atomic core and valence density in external files in the working directory. The files must be named properly; for example, the files for an atom of type 1 should be named: "core_density_atom_type1.dat" and "valence_density_atom_type1.dat". The file should be a text file, where the first line is assumed to be a comment, and the subsequent lines contain two values each, where the first one is a radial coordinate and the second the value of the density n(r). Please note that it is n(r) which should be supplied,
         <b>
          not
         </b>
         n(r)/r^2. The first coordinate point must be the origin, i.e.
         <b>
          <i>
           r = 0
          </i>
         </b>
         . The atomic densities are spherically averaged, so assumed to be completely spherically symmetric, even for open shells.
         <br />
         <br />
         NOTE: in the PAW case,
         <b>
          DO NOT
         </b>
         use _PAWDEN or _ATMDEN_xxx files produced by prtden &gt; 1 to chain the density output from one
        calculation as the input to another, use the _DEN file for that.
        </p>
    topics: printing_prden
    varset: files
    vartype: integer
- !variable
    abivarname: prtdensph
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT integral of DENsity inside atomic SPHeres
    requires: null
    text: |-
        <p>
         When this flag is activated, values of integral(s) of total density inside sphere(s) around each atom are printed in output file (for each spin component).
        Spheres around atoms are defined by a radius given by [[ratsph]] keyword.
         <br />
         Note: integral of density inside a sphere around an atom
        can be used to determine a rough approximation of the local magnetic moment;
        this is particularly useful for antiferromagnetic systems.
         <br />
         The algorithm to compute this integral is particularly primitive : the points on the FFT grids, belonging
        to the interior of the sphere are determined, and the value of the functions on these points are summed,
        taking into account a fixed volume attributed to each point.
        In particular, the integral as a function of the radius will be a constant, except when
        a new point enters the sphere, in which case a sudden jump occurs.
        However, since the purpose of this output is to get a rough idea of the repartition of the density,
        this is not a real problem. If you are interested in a more accurate estimation
        of the density within a sphere, you should use the cut3d postprocessor.
        </p>
    topics: printing_prden
    varset: gstate
    vartype: integer
- !variable
    abivarname: prtdipole
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT DIPOLE
    requires: null
    text: |-
        <p>
         Print out dipole of unit cell, calculated in real space for the primitive cell only. Under development.
        </p>
    topics: printing_prgs
    varset: dev
    vartype: integer
- !variable
    abivarname: prtdos
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Density Of States
    requires: null
    text: |-
        <p>
         Provide output of Density of States if set to 1, 2 or 3.
        Can either use a smearing technique ([[prtdos]]=1),
        or the tetrahedron method ([[prtdos]]=2).
        If [[prtdos]]=3, provide output of Local Density of States inside a sphere centered on an atom,
        as well as the angular-momentum projected DOS, in the same sphere. The resolution of the linear grid of energies
        for which the DOS is computed can be tuned thanks to [[dosdeltae]].
        </p>
        <p>
         If [[prtdos]]=1, the smeared density of states is obtained
        from the eigenvalues, properly weighted at each k point
        using [[wtk]], and smeared according to [[occopt]]
        and [[tsmear]]. All levels that are present in the calculation
        are taken into account (occupied and unoccupied).
        Note that [[occopt]] must be between 3 and 7 .
        Also note that the sampling of the Brillouin Zone that is needed to get a converged DOS
        is usually much finer than the sampling needed to converge the total energy or the geometry of the system,
        unless [[tsmear]] is very large (hence the DOS is not obtained properly)..
        A separate convergence study is needed.
         <br />
         In order to compute the DOS of an insulator with [[prtdos]]=1, compute its density thanks to
        a self-consistent calculation (with a non-metallic [[occopt]]
        value, 0, 1 or 2), then use [[prtdos]]=1, together
        with [[iscf]]=-3, and a metallic [[occopt]],
        between 3 and 7, providing the needed smearing.
        If [[prtdos]]=1, the name of the DOS file is the root name for the output
        files, followed by "_DOS" .
        </p>
        <p>
         If [[prtdos]]=2, the DOS is computed using the tetrahedron method.
        As in the case of [[prtdos]]=1, all levels that are present in the calculation
        are taken into account (occupied and unoccupied). In this case, the
        k-points must have been defined using the input variable [[ngkpt]]
        or the input variable [[kptrlatt]]. There must be at least
        two non-equivalent points in the Irreducible Brillouin Zone to use  [[prtdos]]=2.
        It is strongly advised to use a non-shifted k-point grid
        ([[shiftk]] 0 0 0): such grids contain naturally
        more extremal points (band minima and maxima at Gamma or at the zone-boundaries) than
        shifted grids, and lead to more non-equivalent points than shifted grids, for the same grid spacing.

        There is no need to take care of
        the [[occopt]] or [[tsmear]] input variables,
        and there is no subtlety to be taken into account for insulators. The computation
        can be done in the self-consistent case as well as in the non-self-consistent case,
        using [[iscf]]=-3. This allows to refine the DOS at fixed
        starting density.
         <br />
         In that case, if [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _DOS (like in the [[prtdos]]=1 case).
         <br />
         However, if [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _DOS.
          </li>
         </ul>
        </p>
        <p>
         If [[prtdos]]=3, the same tetrahedron method as for [[prtdos]]=2 is used, but
        the DOS inside a sphere centered on some atom is delivered, as well as the angular-momentum
        projected (l=0,1,2,3,4) DOS in the same sphere. The preparation of this
        case, the parameters under which the computation is to be done, and the file
        denomination is similar
        to the [[prtdos]]=2 case. However, three additional input variables might be provided,
        describing the atoms that are the center of the sphere (input variables
        [[natsph]] and  [[iatsph]]), as well as the radius of this
        sphere (input variable [[ratsph]]).
         <br />
         In case of PAW, [[ratsph]] radius has to be greater or equal to
        largest PAW radius of the atom types considered (which is read from the PAW atomic data file; see rc_sph or r_paw).
        Additional printing and/or approximations in PAW mode can be controlled with [[pawprtdos]] keyword
        (in particular,[[pawprtdos]]=2 can be used to compute quickly a very good approximation of the DOS).
         <br />
         <br />
         Note 1: when [[prtdos]]=3, it is possible to output m-decomposed LDOS in _DOS file; simply use [[prtdosm]] keyword.
         <br />
         Note 2: the integrated total DOS in spheres around atoms can be obtained when
        [[prtdensph]] flag is activated.
        It can be compared to the integrated DOS provided in _DOS file when [[prtdos]]=3.
        </p>
        <p>
         [[prtdos]]=4 delivers the sphere-projected DOS (like [[prtdos]]=3), on the basis of a smearing approach (like [[prtdos]]=1)
        </p>
        <p>
         [[prtdos]]=5 delivers the spin-spin DOS in the [[nspinor]]==2 case, using the tetrahedron method (as [[prtdos]]=2).
        </p>
    topics: printing_prdos, ElecDOS_basic
    varset: files
    vartype: integer
- !variable
    abivarname: prtdos@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the phonon Density Of States
    requires: null
    text: |-
        <p>The <b>prtdos</b> variable is used to calculate
        the phonon density of states, PHDOS, by Fourier interpolating the interatomic force
        constants on the (dense) q-mesh defined by [[anaddb:ng2qpt]].
        Note that the variable [[anaddb:ifcflag]] must be set to 1
        since the interatomic force constants are supposed to be known.
        <p>
        The available options are:
        <ul>
         <li>0 =&gt; no output of PHDOS (default);</li>
         <li>1 =&gt; calculate PHDOS using the gaussian method and the broadening defined
         by [[anaddb:dossmear]]. </li>
         <!--<li>2 =&gt; use tetrahedron method. </li>-->
         </ul>

        The step of the frequency grid employed to calculate the DOS
        can be defined through the input variable [[anaddb:dosdeltae]].
    topics: PhononBands_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtdosm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Density Of States with M decomposition
    requires: null
    text: |-
        <p>
         Relevant only when [[prtdos]]=3.
         <br />
         If set to 1, the m-decomposed LDOS is delivered in DOS file.
         <br />
         Note that [[prtdosm]] computes the M-resolved partial dos for complex spherical harmonics,giving e.g.
        DOS(L,M) == DOS(L,-M) (without spin-orbit). In the contrary, the LDA+U occupation matrix,
        see [[dmatpawu]] is in the real spherical harmonics basis.
         <br />
         If set to 2, the m-decomposed LDOS is delivered in DOS file.
         <br />
         In this case, [[prtdosm]] computes the M-resolved partial dos for real spherical harmonics
        in the same basis as the LDA+U occupation matrix.
        </p>
    topics: printing_prdos, ElecDOS_basic
    varset: files
    vartype: integer
- !variable
    abivarname: prtebands
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]] > 1': 0
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Electron BANDS
    requires: null
    text: |-
        This option activates the output of the electron eigenvalues.
        Possible values:

        <ul>
        <li>0 Disable the output of the band energies.</li>
        <li>1 Write eigenvalues in xmgrace format.  A file with extension `EBANDS.agr` is produced at the end of the run.
        Use `xmgrace file_EBANDS.agr` to visualize the band energies</li>
        <li>2 Write eigenvalues in gnuplot format. The code produces a `EBANDS.dat` file with the eigenvalues and a `EBANDS.gnuplot` script.
        Use `gnuplot file_EBANDS.gnuplot` to visualize the band energies.</li>
        </ul>
    topics: printing_prden
    varset: gstate
    vartype: integer
- !variable
    abivarname: prtefg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRint Electric Field Gradient
    requires: '[[usepaw]]==1, [[quadmom]]'
    text: |-
        <p>
         <ul>
          <li>
           If nonzero, calculate the electric field gradient at each atomic site in the unit cell. Using
        this option requires [[quadmom]] to be set as well.
        Values will be written to main output file (search for Electric Field Gradient). If prtefg=1,
        only the quadrupole coupling in MHz and asymmetry are reported. If prtefg=2, the full electric field
        gradient tensors in atomic units are also given, showing separate contributions from the valence
        electrons, the ion cores, and the PAW reconstruction. If prtefg=3, then in addition to the prtefg=2 output,
        the EFGs are computed using an ionic point charge model. This is useful for comparing the accurate PAW-based
        results to those of simple ion-only models. Use of prtefg=3 requires that the variable
        [[ptcharge]] be set as well.
           <br />
           The option prtefg is compatible with spin polarized calculations
        (see [[nspden]]) and also LDA+U (see [[usepawu]]).
          </li>
         </ul>
        </p>
    topics: printing_prngs, EFG_basic
    varset: paw
    vartype: integer
- !variable
    abivarname: prteig
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]] > 1': 0
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT EIGenenergies
    requires: null
    text: |-
        <p>
         If set to 1, a file *_EIG, containing the
        k-points and one-electron eigenvalues is printed.
        </p>
    topics: printing_prden
    varset: files
    vartype: integer
- !variable
    abivarname: prtelf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Electron Localization Function (ELF)
    requires: null
    text: |-
        <p>
         If set to 1 or a larger value, provide output of ELF
        in real space elf(r). This is a dimensionless quantity bounded between 0 and 1.
         <br />
         The name of the ELF file will be the root output name, followed by _ELF.
         <br />
         Like a _DEN file, it can be analyzed by cut3d. However unlike densities, in case of spin polarized
        calculations, the spin down component can not be obtained by subtracting the spin up component to
        the total ELF. Hence when spin polarized calculations are performed the code produces also output files with
        _ELF_UP and _ELF_DOWN extensions. (For technical reasons these files contain also two components but the second is zero.
        So to perform analysis of _ELF_UP and _ELF_DOWN files with cut3d you have to answer "ispden= 0 ==&gt; Total density"
        when cut3d ask you which ispden to choose. Also remember that spin down component can not be obtained by using cut3d on the _ELF file.
        Sorry for the inconvenience, this will be fixed in the next release.)
         <br />
         ELF is not yet implemented in non collinear spin case.
         <br />
         If prtelf is set to 2, in the case of spin polarized calculation, the total ELF is computed from an alternative approach which should better take into account the existence of spin dependent densities (see the documentation in /doc/theory/ELF of your ABINIT repository)
         <br />
         <br />
         Please note that ELF is
         <b>
          not
         </b>
         yet implemented in the case of PAW ([[usepaw]]=1) calculations.
        </p>
    topics: printing_prgs
    varset: files
    vartype: integer
- !variable
    abivarname: prtfc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Fermi Contact term
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         <ul>
          <li>
           If set to 1,  print the Fermi contact interaction at each nuclear site, that is,
        the electron density at each site. The result appears in the main output file (search for FC).
        Note that this calculation is different than what is done by cut3d, because it also computes the
        PAW on-site corrections in addition to the contribution from the valence pseudo-wavefunctions.
          </li>
         </ul>
        </p>
    topics: printing_prden, EFG_basic
    varset: paw
    vartype: integer
- !variable
    abivarname: prtfsurf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Fermi SURFace file
    requires: null
    text: |-
        <p>
         If set to 1, provide Fermi surface file in the BXSF format (Xcrysden)
        If [[prtfsurf]]=1, a _BXSF file readable by
         <a href="http://www.xcrysden.org">
          XCrySDen
         </a>
         will
        be produced at the end of the calculation. The file contains information on the band structure
        of the system and can be used to visualize the Fermi surface or any other energy isosurface.
        [[prtfsurf]]=1 is compatible only with SCF calculations
        ([[iscf]] &gt; 1) or NSCF runs in which the
        occupation factors and Fermi level are recalculated once convergence is achieved ([[iscf]] = -3).
        The two methods should produce the same Fermi surface provided that the k-meshes are sufficiently dense.
        The k-mesh used for the sampling of the Fermi surface can be specified using the standard
        variables [[ngkpt]], ([[shiftk]], and [[nshiftk]].
        Note, however, that the mesh must be homogeneous and centered on gamma (multiple shifts are not supported by Xcrysden)
        </p>
    topics: printing_prfermi
    varset: files
    vartype: integer
- !variable
    abivarname: prtfsurf@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Fermi SURFace
    requires: null
    text: |-
        <p>Only for electron-phonon calculations. The available options are:

        <ul>
          <li>0 =&gt; do not write the Fermi Surface;</li>
          <li>1 =&gt; write out the Fermi Surface in the BXSF format used by
          [[www.xcrysden.org|XCrySDen]].</li>

        </ul>
        <p>Further comments:
        <p> a) Only the eigenvalues for k-points inside the
        Irreducible Brillouin zone are required. As a consequence it is
        possible to use [[kptopt]]
        =1 during the GS calculation to reduce
        the computational effort.</font></p>

        <p> b) Only unshifted k-grids that are orthogonal in
        reduced space are supported by <a href="http://www.xcrysden.org">XCrySDen</a>.
        This implies that [[shiftk]]
        must be set to (0,0,0) during the GS calculation
        with [[nshiftk]]=1. Furthermore if [[kptrlatt]]
        is used to generate the k-grid, all the off-diagonal elements of this
        array must be zero.</p>
    topics: ElPhonTransport_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtgden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Gradient of electron DENsity
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value, provide output of gradient of electron density
        in real space grho(r), in units of Bohr^-(5/2).
         <br />
         The names of the gradient of electron density files will be the root output name,
        followed by _GDEN1, _GDEN2, GDEN3 for each principal direction (indeed it is a vector).
         <br />
         Like a _DEN file, it can be analyzed by cut3d. The file structure of the unformatted output file is
        described below, see section 6).
        </p>
    topics: printing_prden
    varset: files
    vartype: integer
- !variable
    abivarname: prtgeo
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the GEOmetry analysis
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value, provide output of geometrical analysis
        (bond lengths and bond angles). The value
        of [[prtgeo]] is taken by the code to be the
        maximum coordination number of atoms in the system.
         <br />
         It will deduce a maximum number of "nearest" and "next-nearest"
        neighbors accordingly , and compute corresponding bond lengths.
         <br />
         It will compute bond angles for the "nearest" neighbours only.
         <br />
         If [[ionmov]]==0, the name of the file will be
        the root output name, followed by _GEO .
         <br />
         If [[ionmov]]==1 or 2, one file will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _GEO
          </li>
         </ul>
         The content of the file should be rather self-explanatory.
         <br />
         No output is provided by [[prtgeo]] is lower than or equal to 0.
         <br />
         If [[prtgeo]]&gt;0, the maximum number of atoms ([[natom]]) is 9999.
        </p>
    topics: printing_prgeo
    varset: files
    vartype: integer
- !variable
    abivarname: prtgkk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the GKK matrix elements file
    requires: null
    text: |-
        <p>
         If set to 1, provide output of electron-phonon "gkk" matrix
        elements, for further treatment by mrggkk utility or anaddb utility. Note that
        symmetry will be disabled for the calculation of the perturbation, forcing the
        inclusion of all k-points and all perturbation directions. Additional
        information on electron-phonon treatment in ABINIT is given in the tutorial
        ~abinit/doc/tutorial/lesson_eph.html and in ~abinit/doc/users/elphon_manual.ps
        </p>
    topics: printing_prngs, ElPhonInt_compulsory
    varset: files
    vartype: integer
- !variable
    abivarname: prtgsr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: prtgsr = 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the GSR file
    requires: null
    text: |-
        <p> If set to 1, ABINIT will produce a GSR file at the end of the GS
        calculation. The GSR file contains the most important GS results
        (band structure, forces, stresses, electronic density). The GSR
        file can be read by AbiPy and used for futher postprocessing.
        <br> Note that, by default, the GSR file contains the electronic density
        unless [[prtden]] is set to 0.
        </p>
    topics: printing_prgs
    varset: files
    vartype: integer
- !variable
    abivarname: prtkden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Kinetic energy DENsity
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value , provide output of kinetic energy density
        in real space tau(r), in units of Bohr^-5.
         <br />
         The name of the kinetic energy density file will be the root output name, followed by _KDEN.
         <br />
         Like a _DEN file, it can be analyzed by cut3d. The file structure of the unformatted output file is
        described below (see  <a href="../../users/generated_files/help_abinit.html#6">
          section 6
         </a>).
         <br />
         Note that the computation of the kinetic energy density must be activate, thanks to the input variable [[usekden]].
         <br />
         Please note that kinetic energy density is
         <b>
          not
         </b>
         yet implemented in the case of PAW ([[usepaw]]=1) calculations.
        </p>
    topics: printing_prden
    varset: files
    vartype: integer
- !variable
    abivarname: prtkpt
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the K-PoinTs sets
    requires: null
    text: |-
        <p>
         If set /= 0 , proceeds to a detailed analysis
        of different k point grids. Works only if
        [[kptopt]] is positive, and neither
        [[kptrlatt]]
        nor
        [[ngkpt]] are defined.
        ABINIT will stop after this analysis.
        </p>
        <p>
         Different sets of k point grids are defined,
        with common values of [[shiftk]].
        In each set, ABINIT increases the length of vectors of the
        supercell (see [[kptrlatt]]) by integer
        steps. The different sets are labelled by "iset".
        For each k point grid,  [[kptrlen]]
        and  [[nkpt]] are computed (the latter always
        invoking  [[kptopt]]=1, that is, full use of
        symmetries). A series is finished when the computed
        [[kptrlen]] is twice larger than the
        input variable [[kptrlen]].
        After the examination of the different sets,
        ABINIT summarizes, for each [[nkpt]], the
        best possible grid, that is, the one with the
        largest computed [[kptrlen]].
        </p>
        <p>
         Note that this analysis is also performed when
        [[prtkpt]]=0, as soon as neither [[kptrlatt]]
        nor
        [[ngkpt]] are defined. But, in this case,
        no analysis report is given, and the code selects the grid
        with the smaller [[ngkpt]]
        for the desired [[kptrlen]]. However,
        this analysis takes some times (well sometimes,
        it is only a few seconds - it depends on the value of
        the input [[kptrlen]]), and it is better
        to examine the full analysis for a given cell and set of symmetries,
        [[shiftk]] for all the production runs.
        </p>

        <p>
        if set to -2, the code stops in invars1 after the computation of the irreducible set and
        a file named kpts.nc with the list of the k-points and the corresponding weights is produced
        </p>
    topics: printing_prden, Output_useful, k-points_useful
    varset: files
    vartype: integer
- !variable
    abivarname: prtlden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Laplacian of electron DENsity
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value, provide output of Laplacian of electron density
        in real space grho(r), in units of Bohr^-(7/2).
         <br />
         The name of the Laplacian of electron density file will be the root output name,
        followed by _LDEN.
         <br />
         Like a _DEN file, it can be analyzed by cut3d. The file structure of the unformatted output file is
        described below (see  <a href="../../users/generated_files/help_abinit.html#6">
          section 6
         </a>).
        </p>
    topics: printing_prden
    varset: files
    vartype: integer
- !variable
    abivarname: prtlammps
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0 0
    dimensions: 2
    excludes: null
    mnemonics: PRinT LAMMPS file
    requires: null
    text: |-
        <p>
         Print out the positions and forces during a AIMD simulation every (x) ion steps in LAMMPS dump format custom style. Note the ouput format for atomic information is fixed as follows:
         <br />
         Atom-ID Atom-Type x(uw/us) y(uw/us) z(uw/us) fx fy fz
        <br />
         Here uw/us indicate unwrapped and unscaled cartesian coordinates in perodic cell. The files can be visualized using VMD/OVITO and can also be used as initial configurations for classical MD simulations. 
        <br />
	 Example:
	 prtlammps 1 1
	 prtlammps 1 10
        <br />
	For more information on the LAMMPS dump style format please see http://lammps.sandia.gov/doc/Section_howto.html#howto-12 and http://lammps.sandia.gov/doc/dump.html. 
        </p>
    topics: MolecularDynamics_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: prtmbm@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Mode-By-Mode decomposition of the electrooptic tensor
    requires: null
    text: |-
        <ul>
        <li>0 =&gt; do not write the mode-by-mode decomposition of the
        electrooptic tensor;</li>
        <li>1 =&gt; write out the contribution of the individual zone-center
        phonon modes to the electrooptic tensor.</li>
        </ul>
    topics: nonlinear_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtnabla
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRint NABLA
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         <ul>
          <li>
           If set to 1, calculate the matrix elements &lt;Psi_n|-inabla|Psi_m&gt; and write it in file _OPT to be read by the code conducti.
          </li>
         </ul>
        </p>
    topics: printing_prgs
    varset: paw
    vartype: integer
- !variable
    abivarname: prtnest
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT NESTing function
    requires: null
    text: |-
        <p>
         If set to 1, the nesting function for the k-point grid is printed. For the moment the path in q space for the nesting function is fixed, but will become an input as well.
        </p>
    topics: printing_prfermi
    varset: dev
    vartype: integer
- !variable
    abivarname: prtnest@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the NESTing function
    requires: null
    text: |-
        <p>Only for electron-phonon calculations.
        This input variable is used to calculate the nesting function defined as:
        \chi_{nm}(q) = \sum_k \delta(\epsilon_{k,n}-epsilon_F) \delta(\epsilon_{k+q,m}-\epsilon_F).
        The nesting factor is calculated for every point of the k-grid
        employed during the previous GS calculation.
        The values are subsequently interpolated along the trajectory in q space
        defined by [[anaddb:qpath]], and written in the _NEST
        file using the X-Y format (<b>prtnest</b>=1).
        It is also possible to analyze the behavior of the function
        in the reciprocal unit cell saving the values in the NEST_XSF file that can be read
        using <a href="http://www.xcrysden.org">XCrySDen</a> (<b>prtnest</b>=2).
        Note that in the present implementation what is really printed to file is
        the "total nesting" defined as \sum_{nm} \chi_{nm}(q).
        Limitations: the k-grid defined by
        [[kptrlatt]]
        must be orthogonal in reciprocal space,
        moreover off-diagonal elements are not allowed, i.e
        kptrlatt 4 0 0  0 4 0  0 0 4 is fine while
        kprtlatt = 1 0 0 0 1 1 0 -1 1 will not work.

        <p>
        <ul>
          <li>0 =&gt; do not write the nesting function;</li>
          <li>1 =&gt; write only the nesting function along the q-path in the X-Y format;</li>
          <li>2 =&gt; write out the nesting function both in the X-Y and in the XSF format.</li>
        </ul>
    topics: PhononWidth_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtphbands
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT PHonon BANDS
    requires: null
    text: |-
        This option activates the output of the phonon frequencies in the EPH code.
        Possible values:

        <ul>
        <li>0 Disable the output of the phonon frequencies.</li>

        <li>1 Write frequencies in xmgrace format.  A file with extension `PHBANDS.agr` is produced.
        Use `xmgrace file_PHBANDS.agr` to visualize the data</li>

        <li>2 Write frequencies in gnuplot format. The code produces a `PHBANDS.dat` file with the eigenvalues and a `PHBANDS.gnuplot` script.
        Use `gnuplot file_PHBANDS.gnuplot` to visualize the phonon band structure.</li>
        </ul>
    topics: printing_prngs
    varset: eph
    vartype: integer
- !variable
    abivarname: prtphbands@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT PHonon BANDS
    requires: null
    text: |-
        <p>Only if [[anaddb:ifcflag]]=1.

        This option specifies the file format for the phonon band structure.
        Possible values:

        <ul>
        <!--
        <li>0 Disable the output of the phonon frequencies.</li>
        -->

        <li>1 Write frequencies in xmgrace format.  A file with extension `PHBANDS.agr` is produced.
        Use `xmgrace file_PHBANDS.agr` to visualize the data</li>

        <li>2 Write frequencies in gnuplot format.
        The code produces a `PHBANDS.dat` file with the eigenvalues and a `PHBANDS.gnuplot` script.
        Use `gnuplot file_PHBANDS.gnuplot` to visualize the phonon band structure.</li>
        </ul>
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtphdos
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the PHonon Density Of States
    requires: null
    text: |-
        <p>
        Print the phonon density of states.
        It is activated by default when [[optdriver]]==7.
        </p>
    topics: printing_prngs, ElPhonInt_expert
    varset: eph
    vartype: integer
- !variable
    abivarname: prtphsurf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT PHonon iso-SURFace
    requires: null
    text: |-
        Print a bxsf file (Xcrysden format) with the (interpolated)
        phonon frequencies computed of the q-mesh determined by [[ph_ngqpt]]. The file can be use to visualize isosurfaces with Xcrysden or other similar tools supporting the bxsf format.
        Note that the (dense) q-mesh must be Gamma-centered, shifted meshs are not supported by Xcrysden.
        This variable requires [[optdriver]]==7.
    topics: printing_prngs, ElPhonInt_expert
    varset: eph
    vartype: integer
- !variable
    abivarname: prtposcar
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT POSCAR file
    requires: null
    text: |-
        <p>
         Print out VASP-style POSCAR and FORCES files, for use with PHON or frophon codes for frozen phonon calculations.
        See the associated script in ~abinit/extras/post_processing/phondisp2abi.py for further details on interfacing
        with PHON, PHONOPY, etc...
        </p>
    topics: printing_prgeo
    varset: dev
    vartype: integer
- !variable
    abivarname: prtpot
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT total POTential
    requires: null
    text: |-
        <p>
         If set &gt;=1 , provide output of the total (Kohn-Sham) potential (sum of local pseudo-potential, Hartree potential, and xc potential).
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _POT.
         <br />
         If [[ionmov]]==1 or 2, potential file will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _POT.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/generated_files/help_abinit.html#localpotfile">
          section 6.6
         </a>
         of the [[help_abinit]].
        No output is provided by a negative value of this variable.
        </p>
    topics: printing_prpot
    varset: files
    vartype: integer
- !variable
    abivarname: prtpsps
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRint the PSPS file
    requires: null
    text: |-
        If set to 1, the code produces a netcdf file (PSPS.nc) with the internal tables used by Abinit to apply the pseudopotential part of the KS Hamiltonian. The data can be visualized with AbiPy.
        if prtpsps is set to -1, the code will exit after the output of the PSPS.nc file.
    topics: printing_prgs
    varset: files
    vartype: integer
- !variable
    abivarname: prtspcur
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the SPin CURrent density
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value, provide output of the current density of
        different direction spins (x,y,z) in the whole unit cell. Should require spinorial wave functions [[nspinor]]
         = 2. Experimental: this does not work yet.
        </p>
    topics: printing_prgs
    varset: files
    vartype: integer
- !variable
    abivarname: prtsrlr@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the Short-Range/Long-Range decomposition of phonon FREQuencies
    requires: null
    text: |-
        <p>Only if [[anaddb:ifcflag]]=1.
        The available options are:
        <ul>
          <li>0 =&gt; do not write the SR/LR decomposition of phonon frequencies;</li>
          <li>1 =&gt; write out the SR/LR decomposition of the square of phonon frequencies at each q-point specified
          in [[anaddb:qph1l]].</li>
        </ul>
        <p> For details see <I>Europhys. Lett., 33 (9), pp. 713-718 (1996)</I>.
        See also [[anaddb:ifcflag]], [[anaddb:ifcflag]] and [[anaddb:dipdip]].
    topics: PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtstm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the STM density
    requires: null
    text: |-
        <p>
         If set to 1  or a larger value, provide output of the electron density
        in real space rho(r), made only from the electrons
        close to the Fermi energy, in a range of energy (positive or negative), determined
        by the (positive or negative, but non-zero) value of the STM bias [[stmbias]].
         <br />
         This is a very approximate way to obtain STM profiles : one can choose an equidensity surface,
        and consider that the STM tip will follow this surface. Such equidensity surface might be determined
        with the help of Cut3D, and further post-processing of it (to be implemented). The big approximations
        of this technique are : neglect of the finite size of the tip, and
        position-independent transfer matrix elements
        between the tip and the surface.
         <br />
         The charge density is provided in units of electrons/Bohr^3.
        The name of the STM density file will be the root output name, followed by _STM .
        Like a _DEN file, it can be analyzed by cut3d.
        The file structure of this unformatted output file is
        described in
         <a href="../../users/generated_files/help_abinit.html#densoutputfile">
          section 6.5
         </a>
         of the [[help_abinit]].
         <br />
         For the STM charge density to be generated, one must give, as an input file, the
        converged wavefunctions obtained from a previous run, at exactly the same k-points and cut-off energy,
        self-consistently determined, using the occupation numbers from [[occopt]]=7.
         <br />
         In the run with positive [[prtstm]], one has to use :
         <ul>
          <li>
           positive [[iscf]]
          </li>
          <li>
           [[occopt]]=7, with specification of [[tsmear]]
          </li>
          <li>
           [[nstep]]=1
          </li>
          <li>
           the [[tolwfr]] convergence criterion
          </li>
          <li>
           [[ionmov]]=0 (this is the default value)
          </li>
          <li>
           [[optdriver]]=0 (this is the default value)
          </li>
         </ul>
         <br />
         Note that you might have to adjust the value of [[nband]]
        as well, for the treatment of unoccupied states, because the automatic determination
        of [[nband]] will often not include enough unoccupied
        states.
         <br />
         When [[prtstm]] is non-zero, the stress tensor is set to zero.
         <br />
         No output of _STM file is provided by [[prtstm]] lower or equal to 0.
         <br />
         No other printing variables for density or potentials should be activated (e.g. [[prtden]] has to be set to zero).
        </p>
    topics: printing_prgs, STM_compulsory
    varset: files
    vartype: integer
- !variable
    abivarname: prtsuscep
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the SUSCEPtibility file (the irreducible polarizability)
    requires: null
    text: |-
        <p>
         If set to 0, no _SUSC file will be produced after the screening calculation,
        only the _SCR file will be output.
        </p>
    topics: printing_prngs
    varset: files
    vartype: integer
- !variable
    abivarname: prtvclmb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT V CouLoMB
    requires: null
    text: |-
        <p>
        If set >= 0 outputs a file with the Coulomb potential, defined as Hartree + local Pseudopotential.
        <p>
        If <b>prtvclmb=1</b> and in case of PAW ([[usepaw]] > 0), the full core potential is added for the Hartree part, with the on-site corrections vh1 - vht1.
        <p>
        If <b>prtvclmb=2</b>, only the smooth part of the Coulomb potential is output.
        <p>
    topics: printing_prpot
    varset: files
    vartype: integer
- !variable
    abivarname: prtvdw
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Van Der Waals file
    requires: null
    text: |-
        Print out a NetCDF file containing a vdW-DF kernel.
        <!-- See the associated script in
        ~abinit/extras/post_processing/vdw_check_kernel for further details. -->
    topics: printing_prgs
    varset: vdw
    vartype: integer
- !variable
    abivarname: prtvha
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT V_HArtree
    requires: null
    text: |-
        <p>
         If set &gt;=1 , provide output of the Hartree potential.
         <br />
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VHA.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VHA.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/generated_files/help_abinit.html#localpotfile">
          section 6.6
         </a>
         of the [[help_abinit]].
        No output is provided by a negative value of this variable.
        </p>
    topics: printing_prpot
    varset: files
    vartype: integer
- !variable
    abivarname: prtvhxc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT V_HXC
    requires: null
    text: |-
        <p>
         If set &gt;=1 , provide output of the
        sum of the Hartree potential and xc potential.
         <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VHXC.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VHXC.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/generated_files/help_abinit.html#localpotfile">
          section 6.6
         </a>
         of the [[help_abinit]].
        No output is provided by a negative value of this variable.
        </p>
    topics: printing_prpot
    varset: files
    vartype: integer
- !variable
    abivarname: prtvol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT VOLume
    requires: null
    text: |-
        <p> Control the volume of printed output. In particular, this
        concerns the explicit echo of eigenenergies and residuals for all
        bands and k points in the main output file.
        Also, the analysis
        of the value and location of the maximal density (and magnetization).
        <br />
        Standard choice is 0. Positive values print more in the
        output and log files, while negative values are
        for debugging (or preprocessing only), and cause
        the code to stop at some point.
        <ul>
          <li> 0 =&gt; The eigenenergies and residuals for all
        bands and k points are not echoed in the main output file.
        There are exceptions: the eigenvalues of the first k point are printed
        at the end of the SCF loop, and also,
        if [[iscf]]=-2 and [[kptopt]]&lt;=0,
        the eigenvalues for all the k points are printed anyway, for a maximum
        of 50 k-points.  Due to some subtlety, if for
         <b>some</b> dataset [[prtvol]] is non-zero, the limit for input
        and output echoes cannot be enforced, so it is like if [[prtvol]]=1
        for <b>all</b> the datasets for which [[prtvol]]
        was set to 0.</li>
           <li> 1 =&gt; the eigenvalues for the
        first 50 k-points are printed in all cases, at the end of the SCF loop.</li>
           <li> 2 =&gt; all the eigenvalues  and the
        residuals are printed at the end of the SCF loop. Also, the analysis
        of the value and location of the maximal density (and magnetization)
        is printed.</li>
           <li> 3 =&gt; Print memory information for lobpcg </li>
           <li> 4 =&gt; Like 3 and prints information of lobpcg algorithm convergence</li>
           <li> 10 =&gt; the eigenvalues are printed for
        every SCF iteration, as well as other additions (to be specified
        in the future...) </li>
        </ul>
        Debugging options :
        <ul>
         <li> = -1 =&gt; stop in abinit (main program), before call
        driver. Useful to see the effect of the preprocessing of input
        variables (memory needed, effect of symmetries, k points ...) without
        going further. Run very fast, on the order of the second.</li>
         <li>  =-2 =&gt; same as -1, except that print only the first
        dataset. All the non default input variables associated to all
        datasets are printed in the output file, but only for the first
        dataset. Also all the input variables are written in the NetCDF
        file \"OUT.nc\", even if the value is the default.</li>
         <li>  = -3 =&gt; stop in gstate, before call scfcv, move or brdmin.
        Useful to debug pseudopotentials</li>
         <li>  = -4 =&gt; stop in move, after completion of all loops</li>
         <li>  = -5 =&gt; stop in brdmin, after completion of all loops</li>
         <li>  = -6 =&gt; stop in scfcv, after completion of all loops </li>
         <li>  = -7 =&gt; stop in vtorho, after the first rho is obtained</li>
         <li>  = -8 =&gt; stop in vtowfk, after the first k point is treated</li>
         <li>  = -9 =&gt; stop in cgwf, after the first wf is optimized</li>
         <li>  = -10 =&gt; stop in getghc, after the Hamiltonian is applied once</li>
        </ul>
        This debugging feature is not yet activated in the RF routines.
        Note that [[fftalg]] offers another option for debugging.</p>
    topics: printing_prgs, Output_basic
    varset: files
    vartype: integer
- !variable
    abivarname: prtvol@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT VOLume
    requires: null
    text: |-
        <p>Control the volume of printed output.
    topics: Phonons_useful, PhononBands_useful, Temperature_useful, PhononWidth_useful, ElPhonTransport_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: prtvolimg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT VOLume for IMaGes
    requires: null
    text: |-
        <p>
         Control the volume of printed output
        when an algorithm using images of the cell is used ([[nimage]]&gt;1).
         <br />
         When such an algorithm is activated, the printing volume (in output file)
        can be large and difficult to read.
         <br />
         Using
         <b>
          prtvolimg=1
         </b>
         , the printing volume, for each image,
        is reduced to unit cell, atomic positions, total energy, forces, stresses, velocities
        and convergence residuals.
         <br />
         Using
         <b>
          prtvolimg=2
         </b>
         , the printing volume, for each image,
        is reduced to total energy and convergence residuals only.
        </p>
    topics: printing_prgs, Output_useful
    varset: files
    vartype: integer
- !variable
    abivarname: prtvpsp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT V_PSeudoPotential
    requires: null
    text: |-
        <p>
         If set &gt;=1 , provide output of the local pseudo potential.
         <br />
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VPSP.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VPSP.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/generated_files/help_abinit.html#localpotfile">
          section 6.6
         </a>
         of the [[help_abinit]].
        No output is provided by a negative value of this variable.
        </p>
    topics: printing_prpot
    varset: files
    vartype: integer
- !variable
    abivarname: prtvxc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT V_XC
    requires: null
    text: |-
        <p>
         If set &gt;=1 , provide output of the exchange-correlation potential.
        </p>
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VXC.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VXC.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/generated_files/help_abinit.html#localpotfile">
          section 6.6
         </a>
         of the [[help_abinit]].
        No output is provided by a negative value of this variable.
        </p>
    topics: printing_prpot
    varset: files
    vartype: integer
- !variable
    abivarname: prtwant
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT WANT file
    requires: null
    text: |-
        <p>
         Flag used to indicate that either the Wannier90 or the WanT interfaces
        will be used.
         <ul>
          <li>
           [[prtwant]]=1 =&gt; Use the
           <b>
            ABINIT- WanT
           </b>
           interface.
           <p>
            Provide an output file that can be used by the WanT postprocessing
        program (see http://www.wannier-transport.org).
        The value of the prtwant indicates the version of the WanT code that
        can read it. Currently only the value [[prtwant]]=1 is implemented,
        corresponding to WanT version 1.0.1, available since Oct. 22, 2004.
           </p>
           <p>
            Notes : Several requirements must be
        fulfilled by the wavefunction. Among them, two are mandatory:
            <br />
            <ul>
             <li>
              1. An uniform grid of k-points, including the GAMMA point must be used.
             </li>
             <li>
              2. The use of time reversal symmetry is not allowed (istwfk=1)
             </li>
             <li>
              3. The list of k-points must be ordered, such that the coordinates,
        namely three-components vectors has the third index varying the most
        rapidly, then the second index, then the first index
             </li>
            </ul>
            If these requirement are not fulfilled, the program will stop and an error message is returned.
           </p>
           <p>
            As an example of k-point grid in case of systems that have some 3D character (1D systems are easy) :
            <pre>
             nkpt 8
        kpt  0   0   0
        0   0   1/2
        0   1/2 0
        0   1/2 1/2
        1/2 0   0
        1/2 0   1/2
        1/2 1/2 0
        1/2 1/2 1/2
        istwfk 8*1
            </pre>
           </p>
           <p>
            Also, in order to use WanT as a postprocessing program for ABINIT you might have to
        recompile it with the appropriate flags (see ABINIT makefile). Up to now only
        the -convert big-endian was found to be mandatory, for machines with little-endian default choice.
           </p>
          </li>
          <li>
           [[prtwant]]=2 =&gt; Use the
           <b>
            ABINIT- Wannier90
           </b>
           interface.
           <p>
            ABINIT will produce the input files required by Wannier90  and it will
        run Wannier90 to produce the Maximally-locallized Wannier functions
        (see
            <a href="http://www.wannier.org">
             http://www.wannier.org
            </a>
            ).
           </p>
           <p>
            Notes:
            <ul>
             <li>
              The files that are created can also be used by Wannier90 in
        stand-alone mode.
             </li>
             <li>
              In order to use Wannier90 as a postprocessing program for ABINIT you
        might have to recompile it with the appropriate flags (see ABINIT
        makefile). You might use ./configure --enable-wannier90
             </li>
             <li>
              There are some other variables related to the interface of Wannier90
        and ABINIT. See [[varset:w90]].
             </li>
            </ul>
           </p>
           <p>
           </p>
          </li>
          <li>
           [[prtwant]]=3 =&gt; Use the
           <b>
            ABINIT- Wannier90
           </b>
           interface after converting the
        input wavefunctions to <b>quasiparticle</b>
           wavefunctions.
           <p>
            ABINIT will produce the input files required by Wannier90  and it will
        run Wannier90 to produce the Maximally-localized Wannier functions
        (see
            <a href="http://www.wannier.org">
             http://www.wannier.org
            </a>
            ).
           </p>
           <p>
            Additional Notes:
            <ul>
             <li>
              An input file of LDA wave functions is required which is completely
        consistent with the _KSS file used in the self-consistent GW calculation.
        This means that [[kssform]] 3 must be used
        to create the _KSS file and the output _WFK file from the same run must
        be used as input here.
             </li>
             <li>
              Wannier90 requires [[nshiftk]]=1, and
        [[shiftk]]= 0 0 0 is recommended.  The k-point
        set used for the GW calculation, typically the irreducible BZ set created
        using [[kptopt]]=1, and that for the Abinit-
        Wannier90 interface must be consistent.
             </li>
             <li>
              Full-BZ wavefunctions should be generated in the run calling the
        interface by setting [[kptopt]]=3,
        [[iscf]]=-2, and
        [[nstep]]=3.  This will simply use symmetry to
        transform the input IBZ wavefunctions to the full BZ set, still consistent
        with the GW _KSS input.
             </li>
             <li>
              The final _QPS file created by the self-consistent GW run is required
        as input.
             </li>
             <li>
              Any value of [[gwcalctyp]] between
        between 20 and 29 should be suitable, so, for example, Hartree-Fock
        maximally-localized Wannier functions could be generated setting
        [[gwcalctyp]]=25.
             </li>
            </ul>
           </p>
          </li>
         </ul>
        </p>
    topics: printing_prgs, Wannier_compulsory
    varset: files
    vartype: integer
- !variable
    abivarname: prtwf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]] > 1': 0
        defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: PRinT the WaveFunction
    requires: null
    text: |-
        <p>
         If [[prtwf]]=1 , provide output of wavefunction
        and eigenvalue file, as described in
         <a href="../../users/generated_files/help_abinit.html#wavefctfile">
          section 6.7
         </a>
         of the main [[help_abinit]].
         <br />
         For a standard ground-state calculation, the name of the wavefunction file will be
        the root output name, followed by _WFK. If [[nqpt]]=1,
        the root name will be followed by _WFQ. For response-function calculations,
        the root name will be followed by _1WFx, where x is the number of the perturbation.
        The dataset information will be added as well, if relevant.
         <br />
         No wavefunction output is provided by [[prtwf]]=0.
         <br />
         If [[prtwf]]=-1, the code writes the wavefunction file only if convergence is not
        achieved in the self-consistent cycle.
        </p>
        <p>
         <br />
         If [[prtwf]]=2, a file pwfn.data is produced, to be used as input for the
        CASINO QMC code. See more explanation at the end of this section.
         <br />
         If [[prtwf]]=3, the file that is created is nearly the same as with [[prtwf]]=1,
        except that the records that should contain the wavefunction is empty (so, such records exist, but store nothing).
        This is useful to generate size-reduced DDK files,
        to perform an optic run. Indeed, in the latter case, only matrix elements are needed [so, no wavefunction], but possibly
        a large number of conduction bands, so that the DDK file might be huge if it contains the wavefunctions.
        </p>
        <p>
         Further explanation for the [[prtwf]]=2 case. To produce a wave function suitable for use as a CASINO trial wave
        function, certain ABINIT parameters must be set correctly. Primarily,
        CASINO (and QMC methods generally) can only take advantage of
        time-reversal symmetry, and not the full set of symmetries of the crystal
        structure. Therefore, ABINIT must be instructed to generate k-points not
        just in the Irreducible Brillouin Zone, but in a full half of the
        Brillouin Zone (using time-reversal symmetry to generate the other half).
        Additionally, unless instructed otherwise, Abinit avoids the need for
        internal storage of many of the coefficients of its wave functions for
        k-points that have the property 2k=G_latt, where G_latt is a reciprocal
        lattice vector, by making use of the property that
        c_k(G)=c^*_k(-G-G_latt). Abinit must be instructed not to do this in order
        to output the full set of coefficients for use in CASINO. See the ABINIT
        theoretical background documents ABINIT/Infos/Theory/geometry.pdf and
        ABINIT/Infos/Theory/1WF.pdf for more information.
         <br />
         The first of these requirements is met by setting the ABINIT input
        variable kptopt to 2 (see ABINIT/Infos/varbas.html#kptopt) and the second
        by setting istwfk to 1 for all the k points (see
        ABINIT/Infos/vardev.html#istwfk). Since CASINO is typically run with
        relatively small numbers of k-points, this is easily done by defining an
        array of "1" in the input file.
         <br />
         For example, for the 8 k-points generated with ngkpt 2 2 2, we add the
        following lines to the input file:
         <pre>
          # Turn off special storage mode for time-reversal k-points
        istwfk 1 1 1 1 1 1 1 1
        # Use only time reversal symmetry, not full set of symmetries.
        kptopt 2
         </pre>
         Other useful input variables of relevance to the plane waves ABINIT will
        produce include ecut, nshiftk, shiftk, nband, occopt, occ, spinat and
        nsppol (see relevant input variable documents in ABINIT/Infos/). If ABINIT
        is run in multiple dataset mode, the different wave functions for the
        various datasets are exported as pwfn1.data, pwfn2.data, ..., pwfnn.data
        where the numbers are the contents of the contents of the input array
        jdtset (defaults to 1,2,...,ndtset).
         <br />
         Once the routine is incorporated into the ABINIT package it is anticipated
        that there will be an input variable to control whether or not a CASINO
        pwfn.data file is written.
        </p>
        <p>
         Other issues related to [[prtwf]]=2.
         <br />
         The exporter does not currently work when ABINIT is used in parallel mode
        on multiple processors if k-point parallelism is
        chosen. ABINIT does not store the full wave function on each processor but
        rather splits the k-points between the processors, so no one processor
        could write out the whole file. Clearly this could be fixed but we have not
        done it yet. The sort of plane wave DFT calculations usually required to
        generate QMC trial wave functions execute very rapidly anyway and will
        generally not require a parallel machines. The outqmc routine currently
        bails out with an error if this combination of modes is selected - this
        will hopefully be fixed later.
         <br />
         There has not been very extensive testing of less common situations such
        as different numbers of bands for different k-points, and more complicated
        spin polarized systems, so care should be taken when using the output in
        these circumstances.
         <br />
         If there is any doubt about the output of this routine, the first place to
        look is the log file produced by ABINIT: if there are any warnings about
        incorrectly normalized orbitals or non-integer occupation numbers there is
        probably something set wrong in the input file.
        </p>
    topics: printing_prden, vdw_useful
    varset: files
    vartype: integer
- !variable
    abivarname: prtwf_full
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT Wavefunction file on the FULL mesh
    requires: '[[prtwf]] == 1'
    text: |-
        If  set to 1 in a ground-state calculation, the code will output another WFK file (with extension FULL_WFK) containing the wavefunctions in the full BZ as well as a text file with the tables used for the tetrahedron method.

        Note that prtwf_full requires [[prtwf]] == 1 and a ground-state
        calculation done on a homogeneous k-mesh (see [[ngkpt]] and [[shiftk]]).
        The tetrahedron table is produced only if the number of k-points in the irreducible zone ([[nkpt]]) is greater than 3.
    topics: printing_prden
    varset: files
    vartype: integer
- !variable
    abivarname: prtxml
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PRinT an XML output
    requires: null
    text: |-
        <p>
         Create an XML output with common values. The corresponding
        DTD is distributed in sources as extras/post_processing/abinitRun.dtd. All the DTD is not
        yet implemented and this one is currently restricted to ground-state computations
        (and derivative such as geometry optimisation).
        </p>
    topics: printing_prgs
    varset: files
    vartype: integer
- !variable
    abivarname: ptcharge
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: PoinT CHARGEs
    requires: '[[usepaw]]==1 and [[prtefg]]>=3 '
    text: |-
        <p>
         <br />
         <ul>
          <li>
           Array of point charges, in atomic units, of the nuclei. In the normal computation of electric field gradients
        (see [[prtefg]]) the ionic contribution is calculated from the core charges of the atomic
        sites. Thus for example in a PAW data set for oxygen where the core is 1s<sup>2</sup>, the core charge is +6 (total nuclear charge
        minus core electron charge). In point charge models, which are much less accurate than PAW calculations, all atomic sites
        are treated as ions with charges determined by their valence states. In such a case oxygen almost always would have a
        point charge of -2. The present variable taken together with [[prtefg]] performs a full
        PAW computation of the electric field gradient and also a simple point charge computation. The user inputs whatever
        point charges he/she wishes for each atom type.
          </li>
         </ul>
        </p>
    topics: EFG_basic
    varset: paw
    vartype: real
- !variable
    abivarname: ptgroupma
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: PoinT GROUP number for the MAgnetic space group
    requires: null
    text: |-
        <p>
         This internal variable characterizes a Shubnikov type III magnetic space group (anti-ferromagnetic
        space group). The user is advised to consult
        "The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford."
         <br />
         A Shubnikov type III magnetic space group might be defined by its Fedorov space group
        (set of all spatial symmetries, irrespective of their magnetic action), and
        the halving space group (only the symmetries that do not change the magnetization).
         <br />
         The specification of the halving space group might be done by specifying, for each
        point symmetry, the magnetic action. See Table 7.1 of the above-mentioned reference.
        Magnetic point groups are numbered from 1 to 58.
        </p>
        <p>
         Related input variables :
        [[spgroup]],
        [[spgroupma]],
        [[genafm]]
        </p>
    topics: spinpolarisation_internal, SmartSymm_internal
    varset: geo
    vartype: integer
- !variable
    abivarname: pvelmax
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 1.0
    dimensions:
    - 3
    excludes: null
    mnemonics: Particle VELocity MAXimum
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         When [[npvel]] is larger than 0, it performs electronic stopping power calculations
        on a velocity grid along the direction determined by [[pvelmax]].
         <br />
         The vector [[pvelmax]] defines both the direction and the maximum velocity.
        [[pvelmax]] is input in Cartesian coordinates.
        </p>
    topics: RandStopPow_basic
    varset: gw
    vartype: real
- !variable
    abivarname: pw_unbal_thresh
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 40%
    dimensions: scalar
    excludes: null
    mnemonics: 'Plane Wave UNBALancing: THRESHold for balancing procedure'
    requires: '[[paral_kgb]]==1'
    text: |-
        <p>
         This parameter (in %) activates a load balancing procedure when the distribution of plane wave components
         over MPI processes is not optimal. The balancing procedure is activated when the ratio between the
         number of plane waves treated by a processor and the ideal one is higher than <i>pw_unbal_thresh</i> %.
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: real
- !variable
    abivarname: q1shft@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - '[[anaddb:nqshft]]'
    excludes: null
    mnemonics: Q shifts for the grid number 1
    requires: null
    text: |-
        <p>This vector gives the shifts needed to define the coarse q-point grid.
        <p>
           a) Case nqshft=1
           In general, 0.5 0.5 0.5 with the ngqpt's even will give
             very economical grids. On the other hand, is it
             sometimes better for phonons to have the Gamma point
             in the grid. In that case, 0.0 0.0 0.0 should be OK.
           For the hexagonal lattice, the above mentioned
             quantities become 0.0 0.0 0.5 and 0.0 0.0 0.0 .
        <p>
           b) Case nqshft=2
           The two q1shft vectors must form a BCC lattice.
           For example, use 0.0 0.0 0.0 and 0.5 0.5 0.5
        <p>
           c) Case nqshft=4
           The four q1shft vectors must form a FCC lattice.
           For example, use 0.0 0.0 0.0 , 0.0 0.5 0.5 ,
                            0.5 0.0 0.5 , 0.5 0.5 0.0
           or   0.5 0.5 0.5  , 0.0 0.0 0.5 ,
                0.0 0.5 0.0  , 0.5 0.0 0.0  (the latter is referred to
                                             as shifted)
        <p>
           Further comments: by using this technique, it is possible
           to increase smoothly the number of q-points, at least
           less abruptly than relying on series of grids like
           (for the full cubic symmetry): <br>
           1x1x1 => (0 0 0) <br>
           2x2x2 (shifted) => (.25 .25 .25) <br>
           2x2x2 => 1x1x1 + (.5 0 0) (.5 .5 0) (.5 .5 0) <br>
           4x4x4 => 2x2x2 + (.25 0 0) (.25 .25 0) (.25 .5 0)
                           (.25 .25 .25) (.25 .25 .5) (.25 .5 .5) <br>
            ... <br> <br>
           with respectively 1, 1, 4 and 10 q-points, corresponding
           to a number of points in the full BZ of 1, 8, 8 and 64.
           Indeed, the following grids are made available: <br>
           1x1x1 with nqshft=2  => (0 0 0) (.5 .5 .5) <br>
           1x1x1 with nqshft=4  => (0 0 0) (.5 .5 0) <br>
           1x1x1 with nqshft=4 (shifted) => (.5 0 0) (.5 .5 .5) <br>
           2x2x2 with nqshft=2  => 2x2x2 + (.25 .25 .25) <br>
           2x2x2 with nqshft=4  => 2x2x2 + (.25 .25 0) (.25 .25 .5) <br>
           2x2x2 with nqshft=4 (shifted) => (.25 0 0) (.25 .25 .25)
                                            (.5 .5 .25) (.25 .5 0) <br>
            ... <br> <br>
           with respectively 2, 2, 2, 5, 6 and 4 q-points, corresponding
           to a number of points in the full BZ of 2, 4, 4, 16, 32 and 32.
        <p>
           For a FCC lattice, it is possible to sample only the Gamma point
           by using a 1x1x1 BCC sampling (nqshft=2).
        <p>
    topics: Phonons_useful, PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: q2shft@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 3* 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Q points SHiFTs for the grids 2
    requires: null
    text: |-
        <p>Similar to [[anaddb:q1shft]],
        but for the series of fine grids.
        <p>Note that [[anaddb:nqshft]]
        for this series of grids corresponds to 1.
    topics: PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: qgrid_type@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Q GRID TYPE
    requires: null
    text: |-
        <p>If <b>qgrid_type</b> is set to 1, the electron-phonon part of anaddb will use
        the [[anaddb:ep_nqpt]] and [[anaddb:ep_qptlist]] variables to determine
        which q-points to calculate the electron-phonon coupling for. This is an alternative
        to a regular grid as in the rest of anaddb (using [[anaddb:ngqpt]]).
    topics: PhononWidth_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: qmass
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 10.0
    dimensions:
    - '[[nnos]]'
    excludes: null
    mnemonics: Q thermostat MASS
    requires: null
    text: |-
        <p>
         This are the masses of the chains of [[nnos]] thermostats to be used when [[ionmov]]=13 (Molecular Dynamics) or [[imgmov]]=13 (Path Integral Molecular Dynamics).
        </p>
        <p>
         If [[ionmov]]=13 (Molecular Dynamics),
        this temperature control can be used with&nbsp;
        [[optcell]] =0, 1 (homogeneous cell deformation) or 2 (full cell deformation).
         <br />
         If [[imgmov]]=13 (Path Integral Molecular Dynamics),
        this temperature control can be used with&nbsp;
        [[optcell]] =0 (NVT ensemble) or 2 (fully flexible NPT ensemble).
        In that case, [[optcell]]=2 iS NOT USABLE yet.
        </p>
    topics: PIMD_basic, MolecularDynamics_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: qpath@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions:
    - 3
    - '[[anaddb:nqpath]]'
    excludes: null
    mnemonics: Q wavevectors defining a PATH
    requires: null
    text: |-
        <p>It is used to generate the path along which the phonon band structure and
        phonon linewidths are interpolated.
        There are [[anaddb:nqpath]]-1 segments to be
        defined, each of which starts from the end point of the previous one.
        The number of divisions in each segment is automatically calculated
        inside the code to respect the proportion between the segments.
        The same circuit is used for the output of the nesting function if
        [[anaddb:prtnest]]=1.
    topics: PhononBands_basic, PhononWidth_basic
    varset: anaddb
    vartype: real
- !variable
    abivarname: qph1l@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 4
    - '[[anaddb:nph1l]]'
    excludes: null
    mnemonics: Q for PHonon List 1
    requires: null
    text: |-
        <p>List of [[anaddb:nph1l]]
        wavevectors, at which the phonon frequencies will be interpolated.
        Defined by 4 numbers:
        the wavevector is made by the three first numbers
        divided by the fourth one (a normalisation factor).
        The coordinates are defined with respect to the unit vectors
        that spans the Brillouin zone. Note that this set of axes
        can be non-orthogonal and not normed.
        The normalisation factor makes easier the input of wavevector
        such as (1/3,1/3,1/3), represented by 1.0 1.0 1.0 3.0 .
        <br>
        The internal representation of this array is as follows:
        for each wavevector, the three first numbers are stored
        in the array qph1l(3,nph1l), while the fourth is stored
        in the array qnrml1(nph1l).
    topics: PhononBands_basic
    varset: anaddb
    vartype: real
- !variable
    abivarname: qph2l@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 4
    - '[[anaddb:nph2l]]'
    excludes: null
    mnemonics: PHonon List 2
    requires: null
    text: |-
        <p>List of phonon wavevector <i>directions</i> along which the
        non-analytical correction to the Gamma-point phonon frequencies
        will be calculated (for insulators).
        Four numbers, as for [[anaddb:qph1l]],
        but where the last one, that correspond to the normalisation factor, is 0.0
        For the anaddb code, this has the meaning that the three previous
        values define a direction. The direction is in CARTESIAN
        COORDINATES, unlike the non-Gamma wavevectors defined in the first list of vectors...
        <p>
        Note that if the three first numbers are zero, then
        the code will do a calculation at Gamma without non-analyticities.
        <p>
        Also note that the code automatically set the imaginary
        part of the dynamical matrix to zero. This is useful to compute
        the phonon frequencies when half of the k-points has been
        used, by the virtue of the time-reversal symmetry (which
        may induce parasitic imaginary parts...).
        <br>
        The internal representation of this array is as follows:
        for each wavevector, the three first numbers are stored
        in the array qph2l(3,nph2l), while the fourth is stored
        in the array qnrml2(nph2l).
    topics: PhononBands_basic
    varset: anaddb
    vartype: real
- !variable
    abivarname: qprtrb
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Q-wavevector of the PERTurbation
    requires: '[[vprtrb]]'
    text: |-
        <p>
         Gives the wavevector,
        in units of reciprocal lattice primitive translations,
        of a perturbing potential of strength [[vprtrb]].  See [[vprtrb]]
        for more explanation.
        </p>
    topics: Artificial_useful
    varset: ffield
    vartype: integer
- !variable
    abivarname: qpt
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Q PoinT
    requires: null
    text: |-
        <p>
         Only used if [[nqpt]]=1.
        </p>
        <p>
         Combined with [[qptnrm]],
        define the q vector [[qptn]](1:3)
        in the case [[qptopt]]=0.
        </p>
        <p>
         This input variable is not internal ([[qptn]](1:3) is used
        instead), but is used to echo the value of [[qptn]](1:3),
        with renormalisation factor one.
        </p>
    topics: q-points_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: qptdm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0
    dimensions:
    - 3
    - '[[nqptdm]]'
    excludes: null
    mnemonics: Q-PoinTs for the Dielectric Matrix
    requires: '[[optdriver]]==3 and [[nqptdm]]!=0'
    text: |-
        <p>
         [[qptdm]] contains the set of q-points used in the screening part of ABINIT,
        instead of the automatic generation of the q points when [[nqptdm]]=0.
        These q points are given in terms of reciprocal space primitive translations (NOT in cartesian coordinates!).
        For further explanation, see the input variable [[nqptdm]].
        </p>
    topics: Susceptibility_useful
    varset: gw
    vartype: real
- !variable
    abivarname: qptn
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Q-PoinT re-Normalized
    requires: '[[nqpt]]==1'
    text: |-
        <p>
         Only used if [[nqpt]]=1.
         <br />
         In ground-state calculation,
        the vector [[qptn]](1:3) is added to
        each renormalized k point (whatever the value of
        [[kptopt]] that was used)
        to generate the normalized, shifted, set of k-points
        [[kptns]](1:3,1:
         <b>
          nkpt
         </b>
         ).
         <br />
         In response-function calculations,
        [[qptn]](1:3)
        is the wavevector of the phonon-type calculation.
         <br />
         [[qptn]](1:3) can be produced on the basis of
        the different methods described in [[qptopt]],
        like using [[qpt]](1:3)
        with renormalisation provided by [[qptnrm]],
        or using the other possibilities defined by
        [[iqpt]],
        [[ngqpt]],
        [[nshiftq]],
        [[qptrlatt]],
        [[shiftq]],
         <br />
         For insulators, there is no restriction on the
        q-points to be used for the perturbations. By contrast,
        for metals, for the time being, it is advised to take
        q points for which the k and k+q grids are the same
        (when the periodicity in reciprocal space is taken
        into account). Tests remain to be done to see whether
        other q points might be allowed (perhaps with some
        modification of the code).
        </p>
    topics: ' DFPT_internal'
    varset: internal
    vartype: real
- !variable
    abivarname: qptnrm
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: Q PoinTs NoRMalization
    requires: null
    text: |-
        <p>
         Only used if [[nqpt]]=1 and [[qptopt]]=0
        </p>
        <p>
         Provides re-normalization
        of [[qpt]].
        Must be positive, non-zero.
        The actual q vector (renormalized) is
        [[qptn]](1:3)=
        [[qpt]](1:3)/[[qptnrm]].
        </p>
    topics: q-points_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: qptopt
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: QPoinTs OPTion
    requires: null
    text: |-
        <p>
         Only used if [[nqpt]]=1.
        </p>
        <p>
         Controls the set up to generate the Q point
        [[qptn]](1:3)
        to be used for the specific dataset,
        either as a shift of k-point grid in ground-state calculations,
        or as a stand-alone phonon wavevector.
        </p>
        <p>
         There are two basic techniques to generate the Q point : either
        by specifying it directly, possibly with a renormalisation factor ([[qptopt]]=0),
        or extracting it from a grid a Q points ([[qptopt]]=1 to 4), using the
        index [[iqpt]].
        At variance with the similar generation of k points, only ONE q point
        can be used per dataset.
        </p>
        <p>
         With [[qptopt]]=1 to 4, rely on [[ngqpt]] or
        [[qptrlatt]], as well as on
        [[nshiftq]] and
        [[shiftq]] to set up a q point
        grid, from which the q point with number [[iqpt]] will be selected.
        The values [[qptopt]]=1 to 4 differ by the treatment of symmetries. Note
        that the symmetries are
        recomputed starting from the values of [[rprimd]]
        [[xred]] and
        [[spinat]]. So, the explicit value of
        [[symrel]] are not used.
        This is to allow doing calculations with [[nsym]]=1,
        sometimes needed for T-dependent electronic structure, still decreasing
        the number of q points in the case [[qptopt]]=1 or [[qptopt]]=3.
         <ul>
          <li>
           0=&gt; read directly [[qpt]],
        and its (eventual) renormalisation factor [[qptnrm]].
          </li>
          <li>
           1=&gt;
        Take fully into account the symmetry to generate the
        grid of q points in the Irreducible Brillouin Zone only.
           <br />
           (This is the usual mode for RF calculations)
          </li>
          <li>
           2=&gt;
        Take into account only the time-reversal symmetry :
        q points will be generated in half the Brillouin zone.
           <br />
          </li>
          <li>
           3=&gt;
        Do not take into account any symmetry :
        q points will be generated in the full Brillouin zone.
           <br />
          </li>
          <li>
           4=&gt;
        Take into account all the symmetries EXCEPT the time-reversal symmetry
        to generate the k points in the Irreducible Brillouin Zone.
           <br />
          </li>
         </ul>
         In the case of a grid of q points, the auxiliary variables
        [[kptrlen]],
        [[ngkpt]]  and
        [[prtkpt]] might help
        you to select the optimal grid, similarly to the case of the K point grid.
        </p>
    topics: q-points_basic
    varset: gstate
    vartype: integer
- !variable
    abivarname: qptrlatt
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - 3
    - 3
    excludes: specified([[ngqpt]])
    mnemonics: 'Q - PoinTs grid : Real space LATTice'
    requires: null
    text: |-
        <p>
         This input variable is used only when [[qptopt]]
        is positive. It partially defines the q point grid.
        The other piece of information is contained in
        [[shiftq]].
        [[qptrlatt]] cannot be used together with [[ngqpt]].
        </p>
        <p>
         The values [[qptrlatt]](1:3,1), [[qptrlatt]](1:3,2),  [[qptrlatt]](1:3,3)
        are the coordinates of three vectors in real space, expressed
        in the [[rprimd]] coordinate system (reduced coordinates).
        They defines a super-lattice in real space.
        The k point lattice is the reciprocal of this super-lattice,
        possibly shifted (see [[shiftq]]).
        </p>
        <p>
         If neither [[ngqpt]] nor [[qptrlatt]]
        are defined, ABINIT will automatically generate a set
        of k point grids, and select the best combination
        of [[qptrlatt]] and [[shiftq]]
        that allows to reach a sufficient value of [[kptrlen]].
        See this latter variable for a complete description of this
        procedure.
        </p>
    topics: q-points_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: qrefine@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Q-point REFINEment order (experimental)
    requires: null
    text: |-
        <p>If <b>qrefine</b> is superior to 1, attempts to initialize a first set of dynamical matrices
        from the DDB file, with a q-point grid which is [[anaddb:ngqpt]]
        divided by <b>qrefine</b> (e.g. ngqpt 4 4 2 qrefine 2 2 1 starts with a 2x2x2 grid).
        The dynamical matrices are interpolated onto the full [[anaddb:ngqpt]]
        grid and any additional information found in the DDB file is imposed, before proceeding
        to normal band structure and other interpolations. Should implement Gaal-Nagy's algorithm in
        PRB <b>73</b> 014117.
    topics: PhononBands_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: quadmom
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: QUADrupole MOMents
    requires: '[[usepaw]]==1 and [[prtefg]]>=1 '
    text: |-
        <p>
         <ul>
          <li>
           Array of quadrupole moments, in barns, of the nuclei. These values are used in conjunction with the
        electric field gradients computed with [[prtefg]] to calculate the quadrupole
        couplings in MHz, as well as the asymmetries. Note that the electric field gradient at a nuclear site is independent of
        the nuclear quadrupole moment, thus the quadrupole moment of a nucleus can be input as 0, and the
        option [[prtefg]]=2 used to determine the electric field gradient at the site.
          </li>
         </ul>
        </p>
    topics: EFG_basic
    varset: paw
    vartype: real
- !variable
    abivarname: radstp@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.05
    dimensions: scalar
    excludes: null
    mnemonics: RADial STeP
    requires: null
    text: |-
        The length of the first step in the search of the
          exact Bader radius.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: ramansr@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RAMAN Sum-Rule
    requires: null
    text: |-
        <p>Govern the imposition of the sum-rule on the Raman tensors.
        <br>
        As in the case of the Born effective charges, the first-order derivatives
        of the linear dielectric susceptibility with respect to an atomic displacement
        must vanish when they are summed over all atoms. This sum rule is broken
        in most calculations. By putting <b>ramansr</b> equal to 1 or 2, this sum
        rule is imposed by giving each atom a part of the discrepancy.
        <ul>
          <li>0 =&gt; no sum rule is imposed;</li>
          <li>1 =&gt; impose the sum rule on the Raman tensors, giving each
        atom an equal part of the discrepancy;</li>
          <li>2 =&gt; impose the sum rule on the Raman tensors, giving each
        atom a part of the discrepancy proportional to the magnitude of its
        contribution to the Raman tensor.</li>
        </ul>
        For the time being, <b>ramansr</b>=1 is the preferred choice.
    topics: nonlinear_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: random_atpos
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RANDOM ATomic POSitions
    requires: null
    text: |-
        <p>
         Control the inner coordinates, which can be generated randomly by using 4 different methods depending
        ont its value
         <br />
         (0) if zero, no random generation and xred are taken as they have been introduced by the user
         <br />
         (1) if one, particles are generated completely random within the unit cell.
         <br />
         (2) if two, particles are generated randomly but the inner particle distance is always larger than a factor of the
        sum of the covalent bonds between the atoms (note : this is incompatible with the definition of alchemical mixing, in which
        [[ntypat]] differs from [[npsp]])
        </p>
    topics: crystal_expert, GeoOpt_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: ratmin@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: Radius Atomic MINimal
    requires: null
    text: |-
        The first estimation of the smallest radius of the basin of the
          atom (the distance at which the procedure that follows the gradient path
          announces that the gradient path finishes in the corresponding atom)
          This parameter is very important for the speed of the
          calculation, but this first estimation is not usually used because
          the program
          makes a new one based on the knowledge of CPs. In fact after
          the CP analysis, the new estimation is done by the product of the ad hoc
          parameter  [[aim:coff1]] (default 0.98) by the distance of the nearest
          bonding CP.
          If there is a problem later, [[aim:coff2]] (default 0.95) is used instead.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: ratsph
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        defaultval: 2.0
        usepaw==1:
        - '[[AUTO_FROM_PSP]]'
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: Radii of the ATomic SPHere(s)
    requires: null
    text: |-
        <p>
         Relevant only when
        [[prtdos]]=3 or [[prtdensph]]=1.
         <br />
         <br />
         When [[prtdos]]=3:
         <br />
         Provides the radius of the spheres around the [[natsph]] atoms
        of indices [[iatsph]], in which the local
        DOS and its angular-momentum projections will be analysed.
        The choice of this radius is quite arbitrary. In a plane-wave basis set,
        there is no natural definition of an atomic sphere. However, it might be wise
        to use the following well-defined and physically motivated procedure
        (in version 4.2, this procedure is NOT implemented, unfortunately) :
        from the Bader analysis, one can define the radius of the sphere
        that contains the same charge as the Bader volume. This
        "Equivalent Bader charge atomic radius" might then be used to perform
        the present analysis.
        See the [[help_aim]] for more explanations.
        Another physically motivated choice would be to rely on another
        charge partitioning, like the Hirshfeld one (see the cut3d utility).
        The advantage of using charge partitioning schemes comes from the fact that the
        sum of atomic DOS, for all angular momenta and atoms, integrated on the
        energy range of the occupied states,
        gives back the total charge.
        If this is not an issue, one could rely on the half of the nearest-neighbour distances, or
        any scheme that allows to define an atomic radius. Note that the choice of this
        radius is however critical for the balance between the s, p and d components. Indeed,
        the integrated charge within a given radius, behave as a different power of the
        radius, for the different channels s, p, d. At the limit of very small radii, the s component
        dominates the charge contained in the sphere ...
         <br />
         <br />
         When [[prtdensph]]=1:
         <br />
         Provides the radius of the spheres around (all) atoms in which the total charge density will be integrated.
         <br />
         <br />
         In case of PAW, [[ratsph]] radius has to be greater or equal to
        PAW radius of considered atom type (which is read from the PAW dataset file; see rc_sph or r_paw).
        </p>
    topics: printing_prdos, MagMom_useful, ElecBandStructure_useful, ElecDOS_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: ratsph_extra
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: Bohr
        value: 2.0
    dimensions: scalar
    excludes: null
    mnemonics: Radii of the ATomic SPHere(s) in the EXTRA set
    requires: null
    text: |-
        Radius for extra spheres the DOS is projected into. See [[natsph_extra]]
        and [[xredsph_extra]]
        for the number and positions of the spheres.
    topics: printing_prdos
    varset: gstate
    vartype: real
- !variable
    abivarname: rcut
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Radius of the CUT-off for coulomb interaction
    requires: null
    text: |-
        <p>
         Truncation of the Coulomb interaction in real space. The meaning of [[rcut]] is governed by the cutoff shape option [[icutcoul]].
        </p>
        <p>
         If [[rcut]] is negative, the cutoff is automatically calculated so to enclose the same volume inside the cutoff as the volume of the primitive cell.
        </p>
    topics: GWls_compulsory, Susceptibility_basic, SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: recefermi
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - initial guess  of the FERMI Energy
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        In the first  SCF calculation it fixes the initial guess for the Fermi energy.
        </p>
    topics: Recursion_useful
    varset: dev
    vartype: real
- !variable
    abivarname: recgratio
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - Grid RATIO
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        It represents the ratio of the two grid step: [[recgratio]]=fine_step/coarse_step and
        it is bigger or equal than 1.  It introduces a double-grid system which permits
        to compute the electronic density on a coarse grid, using a fine grid
        (defined by [[ngfft]]) in the
        discretisation of the green kernel (see [[recptrott]]).
        Successively the density and the recursion coefficients are interpolated on the fine grid by
        FFT interpolation.  Note that ngfft/recgratio=number of points of the
        coarse grid has to be compatible with the parallelization parameters.
        </p>
    topics: Recursion_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: recnpath
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 500
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - Number of point for PATH integral calculations
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Determine the number of discretisation points to compute some path
        integral in the recursion method ; those path integrals are used to
        compute the entropy and the eigenvalues energy. during the latest SFC
        cycles.
        </p>
    topics: Recursion_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: recnrec
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - Number of RECursions
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Determine the maximum order of recursion, that is the dimension of the
        krylov space we use to compute density. If the precision set by
        [[rectolden]] is reached before that order, the recursion method
        automatically stops.
        </p>
    topics: Recursion_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: recptrott
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - TROTTer parameter
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Determine the trotter parameter used to compute the exponential of the hamiltonian in the
        recursion method: exp(-beta*(-Delta + V)) ~ (exp(-beta/(4*recptrott)
        V) exp(-beta/(4*recptrott) Delta) exp(-beta/(4*recptrott)
        V))^(2*recptrott).
        If set to 0, we use recptrott = 1/2 in the above formula.
        Increasing [[recptrott]] improve the accuracy of the trotter formula, but
        increase the dicretisation error: it may be necessary to increase
        [[ngfft]]. The discretisation error is essentially the discretisation
        error of the green kernel exp((recptrott/beta*|r|^2)) on the ngfft
        grid.
        </p>
    topics: Recursion_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: recrcut
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - CUTing Radius
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Used to improve the
        computational time in the case of the recursion method in a large
        cell: the density at a point will be computed with taking account only of
        a sphere of radius [[recrcut]].
        </p>
    topics: Recursion_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: rectesteg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - TEST on Electron Gas
    requires: null
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        It is used to test an electron gas by putting the ion potential
        equal to zero.
        </p>
    topics: Recursion_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: rectolden
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: Default value to be changed.
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: RECursion - TOLerance on the difference of electronic DENsity
    requires: null
    text: |-
        <p>
        Used in Recursion method ([[tfkinfunc]]=2).
        Sets a tolerance for differences of electronic density that, reached TWICE
        successively, will cause one SCF cycle to stop. That electronic
        density difference is computed in the infinity norm (that is, it is
        computed point-by-point, and then the maximum difference is computed).
        </p>
    topics: Recursion_basic
    varset: dev
    vartype: real
- !variable
    abivarname: red_dfield
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: REDuced Displacement FIELD
    requires: '[[berryopt]] = 16, [[red_efield]]'
    text: |-
        <p>
         In case [[berryopt]]=16,
        a reduced finite electric displacement field calculation is performed. The value
        of this displacement field, and its direction is determined by [[red_dfield]].
        It must be given in atomic units.
        </p>
        <p>
         [[red_dfield]] is defined via Eq.(26) in the Supplement of M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009).
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: red_efield
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: REDuced Electric FIELD
    requires: '[[berryopt]] = 16'
    text: |-
        <p>
         In case [[berryopt]]=16,
        a reduced finite electric displacement field calculation is performed.
        In this case, the parameter red_efield specifies the initial electric field used on the first iteration, in atomic units.
        </p>
        <p>
         [[red_efield]] is defined via Eq.(25) in the Supplement of M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009).
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: red_efieldbar
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: REDuced Electric FIELD BAR
    requires: '[[berryopt]] = 14'
    text: |-
        <p>
         In case [[berryopt]]=14,
        a reduced finite electric field calculation is performed.
        The magnitude and direction of this electric field are determined by red_efieldbar. It must be given in atomic units.
        </p>
        <p>
         [[red_efieldbar]] is defined via Eq.(28) in the Supplement of M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009).
        </p>
    topics: Berry_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: relaxat@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RELAXation of AToms
    requires: null
    text: |-
        <p>If <b>relaxat</b>=1, relax atomic positions during a
        structural relaxation at constrained polarization.
        See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: relaxstr@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RELAXation of STRain
    requires: null
    text: |-
        <p>If <b>relaxat</b>=1, relax lattice constants
        (lengths/angles) during a structural relaxation
         at constrained polarization. See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: restartxf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: RESTART from (X,F) history
    requires: null
    text: |-
        <p>
         Control the restart of a molecular dynamics or structural
        optimization job.
         <br />
         <br />
         <b>
          restartxf&gt;0 (Deprecated)
         </b>
         :The code reads from the input wf file,
        the previous history of atomic coordinates and corresponding forces, in order
        to continue the work done by the job that produced this wf file.
        If [[optcell]]/=0, the history of
        [[acell]] and
        [[rprim]] variables is also taken into account.

        The code will take into consideration the whole history (if [[restartxf]]=1),
        or discard the few first (x,f) pairs, and begin only at the
        pair whose number corresponds to [[restartxf]].
         <br />
         Works only for [[ionmov]]=2 (Broyden) and
        when an input wavefunction file is specified, thanks to the
        appropriate values of [[irdwfk]] or [[getwfk]].
         <br />
         <br />
         NOTES :
         <br />
         * The input wf file must have been produced by a run that exited cleanly.
        It cannot be one of the temporary wf files that exist when a job crashed.
         <br />
         * One cannot restart a calculation with a non-zero [[optcell]]
        value from the (x,f) history of another run with a different non-zero [[optcell]]
         value. Starting a non-zero [[optcell]]
         run from a zero
        [[optcell]] run should work.
         <br />
         * Deprecated, the use of the new options (-1 and -2) is preferred.
         <br />
         <br />
         <b>
          restartxf=0 (Default)
         </b>
         : No restart procedure is enable
        and will start a Molecular dynamics or structural optimization
        from scratch.
         <br />
         <br />
         <b>
          restartxf=-1 (New)
         </b>
         : Use the HIST file to reconstruct
        a partial calculation. It will reconstruct the different configurations
        using the forces and stress store in the HIST file, instead of calling
        the SCF procedure.
         <br />
         Enable
         <b>
          restartxf=-1
         </b>
         from the beginning is harmless.
        The only condition is to keep the input file the same in such a way
        that the same predictor is used and it will predict the same structure
        recorded in the HIST file.
         <br />
         This option will always compute extra [[ntime]]
        iterations independent of the number of iterations recovered previously.
         <br />
         <br />
         <b>
          restartxf=-2 (New)
         </b>
         :Read the HIST file and select the atomic
        positions and cell parameters with the lowest energy. Forget all the
        history and start the calculation using those values. The original
        atomic coordinates and cell parameters are irrelevant in that case.
         <br />
         <br />
         NOTES:
         <br />
         * You can use
         <b>
          restartxf=-1 or -2
         </b>
         for all predictiors that
        make no use of random numbers.
         <br />
         * You can use
         <b>
          restartxf=-1 or -2
         </b>
         to restart a calculation
        that was not completed. The HIST file is written on each iteration. So
        you always have something to recover from.
         <br />
         * You can take advantage of the appropriate values
        of [[irdwfk]] or [[getwfk]]
         to get a good wave function
        to continue your job.
        </p>
    topics: PIMD_useful, MolecularDynamics_useful, GeoOpt_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: rf2_dkdk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Response Function : 2nd Derivative of wavefunctions with respect
        to K'
    requires: null
    text: |-
        <p>
        UNUSABLE (in development)
        </p>
        <p>
        Activates computation of second derivatives of wavefunctions with respect to wavevectors.
        This is not strictly a response function but is a needed auxiliary quantity in the calculations
        of 3rd-order derivatives of the energy (non-linear response).
        The directions for the derivatives are determined by [[rfdir]] (TO BE CORRECTED!).
         <ul>
          <li>
           0=&gt;no derivative calculation
          </li>
          <li>
           1=&gt;calculation along diagonal directions (d2/(dk_i dk_i), natom+10 is activated)
          </li>
          <li>
           2=&gt;calculation along off-diagonal directions (d2/(dk_i dk_j), natom+11 is activated)
          </li>
          <li>
           3=&gt;calculation along all directions (both natom+10 and natom+11 are activated)
          </li>
         </ul>
        </p>
    topics: DFPT_expert
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfasr
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Response Function : Acoustic Sum Rule'
    requires: null
    text: |-
        <p>
         Control the evaluation of the
        acoustic sum rule in effective charges and dynamical matrix at Gamma
        within a response function calculation (not active at the level of producing the DDB, but
        at the level of the phonon eigenfrequencies output).
         <ul>
          <li>
           0 =&gt; no acoustic sum rule imposed
          </li>
          <li>
           1 =&gt; acoustic sum rule imposed for dynamical matrix at Gamma, and charge neutrality imposed with
        extra charge evenly distributed among atoms
          </li>
          <li>
           2 =&gt; acoustic sum rule imposed for dynamical matrix at Gamma, and charge neutrality imposed with
        extra charge given proportionally to those atoms with
        the largest effective charge.
          </li>
         </ul>
         The treatment of the acoustic sum rule and charge neutrality sum rule is finer at the level of the ANADDB utility,
        with the two independent input variables [[anaddb:asr]] and [[anaddb:chneut]].
        </p>
    topics: Phonons_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfatpol
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    dimensions:
    - 2
    excludes: null
    mnemonics: 'Response Function : ATomic POLarisation'
    requires: null
    text: |-
        <p>
         Control the range
        of atoms for which displacements will be considered
        in phonon calculations (atomic polarizations), using the 2n+1 theorem.
         <br />
         These values are only relevant to phonon response function
        calculations.
         <br />
         May take values from 1 to [[natom]], with [[rfatpol]](1)&lt;=[[rfatpol]](2).
         <br />
         The atoms to be moved will be defined by the
         <br />
         do-loop variable iatpol :
         <br />
         do iatpol=[[rfatpol]](1),[[rfatpol]](2)
         <br />
         For the calculation of a full dynamical matrix, use
        [[rfatpol]](1)=1 and [[rfatpol]](2)=[[natom]], together with
        [[rfdir]] 1 1 1 . For selected elements of the
        dynamical matrix, use different values of [[rfatpol]] and/or
        [[rfdir]]. The name 'iatpol' is used for the part of the
        internal variable ipert when it runs from 1 to [[natom]]. The
        internal variable ipert can also assume values larger
        than [[natom]],
        denoting perturbations of electric field or stress type (see
         <a href="../../users/generated_files/help_respfn.html">
          the response function help file
         </a>
         ).
        </p>
    topics: DFPT_basic, Elastic_compulsory, Phonons_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfddk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Response Function with respect to Derivative with respect to K
    requires: null
    text: |-
        <p>
         Activates computation of derivatives of ground state
        wavefunctions with respect to wavevectors. This is not strictly a response
        function but is a needed auxiliary quantity in the electric field
        calculations (see [[rfelfd]]) The directions for the
        derivatives are determined by [[rfdir]].
         <ul>
          <li>
           0=&gt;no derivative calculation
          </li>
          <li>
           1=&gt;calculation of first derivatives of wavefunctions with respect to k points
        (d/dk calculation). The exact same functionality is provided by
        [[rfelfd]] = 2.
          </li>
         </ul>
        </p>
    topics: DFPT_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfdir
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: 'Response Function : DIRections'
    requires: null
    text: |-
        <p>
         Gives the directions
        to be considered for response function calculations
        (also for the Berry phase computation of the polarization, see
        the [[berryopt]] input variable).
         <br />
         The three elements corresponds to the three primitive
        vectors, either in real space (phonon calculations),
        or in reciprocal space (d/dk, homogeneous electric field, homogeneous magnetic field
        calculations). So, they generate a basis
        for the generation of the dynamical matrix or
        the macroscopic dielectric tensor or magnetic susceptibility and magnetic
        shielding, or the effective
        charge tensors.
         <br />
         If equal to 1, response functions, as defined
        by [[rfddk]],
        [[rfelfd]], [[rfphon]], [[rfdir]]
        and [[rfatpol]], are to be computed
        for the corresponding direction. If 0, this direction
        should not be considered.
        </p>
    topics: DFPT_compulsory, Elastic_compulsory, Phonons_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfelfd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Response Function with respect to the ELectric FielD
    requires: null
    text: |-
        <p>
         Turns on electric field response
        function calculations. Actually, such calculations
        requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the
        electric field perturbation itself.
         <ul>
          <li>
           0=&gt;no electric field perturbation
          </li>
          <li>
           1=&gt;full calculation, with first the
        derivative of ground-state wavefunction with
        respect to k (d/dk calculation), by a
        non-self-consistent calculation, then the generation of
        the first-order response to an homogeneous
        electric field
          </li>
          <li>
           2=&gt;only the derivative of ground-state wavefunctions with
        respect to k
          </li>
          <li>
           3=&gt;only the generation of the first-order response
        to the electric field,
        assuming that the data on derivative of ground-state
        wavefunction with respect to k is available on disk.
          </li>
         </ul>
         (Note : because the tolerances to be used for derivatives or
        homogeneous electric field are different, one often does the
        calculation of derivatives in a separate dataset, followed by
        calculation of electric field response as well as phonon.
         <br />
         The options 2 and 3 proves useful in that context ;
        also, in case a scissor shift is to be used,
        it is usually not applied for the d/dk response).
        </p>
    topics: EffMass_compulsory, DFPT_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfmagn
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Response Function with respect to MAGNetic B-field perturbation
    requires: null
    text: |-
        <p>
         It must be equal to 1
         to run response function calculations with respect to external magnetic field.
         Currently, orbital magnetism is not taken into account and the perturbing potential
         has Zeeman form.
        </p>
    topics: DFPT_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfmeth
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Response Function METHod
    requires: null
    text: |-
        <p>
         Selects method used in
        response function calculations. Presently, only 1
        is allowed.
        </p>
    topics: DFPT_expert
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfmeth@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Response-Function METHod
    requires: null
    text: |-
        <p>Select a particular set of Data Blocks in the DDB.
        (PRESENTLY, ONLY OPTION 1 IS AVAILABLE)
        <br>
        <ul>
          <li> 1 =&gt; Blocks obtained by a non-stationary formulation.</li>
          <li> 2 =&gt; Blocks obtained by a stationary formulation.</li>
        </ul>
        For more detailed explanations, see [[help_abinit]]
        If the information in the DDB is available, always use
        the option 2. If not, you can try option 1, which is less accurate.
    topics: Phonons_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: rfphon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Response Function with respect to PHONons
    requires: null
    text: |-
        <p>
         It must be equal to 1
        to run phonon response function calculations.
        </p>
    topics: DFPT_basic
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfstrs
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Response Function with respect to STRainS
    requires: null
    text: |-
        <p>
         Used to run strain response-function
        calculations (e.g. needed to get elastic constants). Define, with
        [[rfdir]], the set of perturbations.
         <ul>
          <li>
           0=&gt;no strain perturbation
          </li>
          <li>
           1=&gt;only uniaxial strain(s) (ipert=natom+3 is activated)
          </li>
          <li>
           2=&gt;only shear strain(s) (ipert=natom+4 is activated)
          </li>
          <li>
           3=&gt;both uniaxial and shear strain(s) (both ipert=natom+3 and ipert=natom+4 are activated)
          </li>
         </ul>
         See the possible restrictions on the use of strain perturbations, in the
         <a href="../../users/generated_files/help_respfn.html#1">
          respfn help file
         </a>
         .
        </p>
    topics: DFPT_basic, Elastic_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rfuser
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Response Function, USER-defined
    requires: null
    text: |-
        <p>
         Available to the developpers, to activate
        the use of ipert=natom+6 and ipert=natom+7, two sets of perturbations
        that the developpers can define.
         <br />
         <ul>
          <li>
           0=&gt;no computations for ipert=natom+6 or ipert=natom+7
          </li>
          <li>
           1=&gt;response with respect to perturbation natom+6 will be computed
          </li>
          <li>
           2=&gt;response with respect to perturbation natom+7 will be computed
          </li>
          <li>
           3=&gt;responses with respect to perturbations natom+6 and natom+7 will be computed
          </li>
         </ul>
        </p>
        <p>
         In order to define and use correctly the new perturbations,
        the developper might have to include code lines or additional routines
        at the level of the following routines :
        dfpt_cgwf.F90, dfpt_dyout.F90, dfpt_symph.F90, dfpt_dyout.F90, dfpt_etot.F90,
        littlegroup_pert.F90, dfpt_looppert.F90, dfpt_mkcor.F90, dfpt_nstdy.F90,
        dfpt_nstwf.F90, respfn.F90, dfpt_scfcv.F90, irreducible_set_pert.F90,
        dfpt_vloca.F90, dfpt_vtorho.F90, dfpt_vtowfk.F90.
        In these routines, the developper should pay a particular
        attention to the rfpert array, defined in the routine respfn.F90 ,
        as well as to the ipert local variable.
        </p>
    topics: DFPT_expert
    varset: dfpt
    vartype: integer
- !variable
    abivarname: rhoqpmix
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: RHO QuasiParticle MIXing
    requires: null
    text: |-
        <p>
         For self-consistent GW runs, [[rhoqpmix]] sets the mixing coefficient between the new and the previous
        electronic densities.
        This mixing damps the spurious oscillations in the Hartree potential when achieving self-consistency.
        [[rhoqpmix]] is meaningful only when doing self-consistency on the wavefunctions with
        [[gwcalctyp]] &#62;&#61; 20.
        </p>
    topics: GW_useful
    varset: gw
    vartype: real
- !variable
    abivarname: rifcsph@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: zero
    dimensions: scalar
    excludes: null
    mnemonics: Radius of the Interatomic Force Constant SPHere
    requires: null
    text: |-
        <p>Cut-off radius for the sphere for
        interatomic force constant, see also the alternative [[anaddb:nsphere]].
        If <b>rifcsph</b>= 0: maximum extent allowed by the grid .

        <p>This number defines the atoms for which the
        short range part of the interatomic force constants, after
        imposition of the acoustic sum rule, will not be put to zero.
    topics: PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: rprim
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: Internally, it is represented as rprim(3,3,[[nimage]])
    defaultval:
    -   - 1
        - 0
        - 0
    -   - 0
        - 1
        - 0
    -   - 0
        - 0
        - 1
    dimensions:
    - 3
    - 3
    excludes: null
    mnemonics: Real space PRIMitive translations
    requires: null
    text: |-
        <p>
         Give, in columnwise entry,
        the three dimensionless primitive translations in real space, to be rescaled by
        [[acell]] and [[scalecart]].
        <br />
        It is [[EVOLVING]] only if [[ionmov]]==2 and [[optcell]]/=0, otherwise it is fixed.
        <br />
         If the Default is used, that is, [[rprim]] is the unity matrix,
        the three dimensionless primitive vectors are three
        unit vectors in cartesian coordinates. Each will be (possibly) multiplied
        by the corresponding [[acell]] value, then (possibly)
        stretched along the cartesian coordinates by the corresponding [[scalecart]] value,
        to give the dimensional primitive vectors, called [[rprimd]].
         <br />
         In the general case, the dimensional cartesian
        coordinates of the crystal primitive translations R1p, R2p and R3p, see
        [[rprimd]], are
         <ul>
          <li>
           R1p(i)=[[scalecart]](i)[[rprim]](i,1)*[[acell]](1)
          </li>
          <li>
           R2p(i)=[[scalecart]](i)[[rprim]](i,2)*[[acell]](2)
          </li>
          <li>
           R3p(i)=[[scalecart]](i)[[rprim]](i,3)*[[acell]](3)
          </li>
         </ul>
         where i=1,2,3 is the component of the primitive translation (i.e. x, y, and z).
         <br />
         <br />
         The [[rprim]] variable, scaled by [[scalecart]], is thus used to define directions
        of the primitive vectors, that will be multiplied (so keeping the direction unchanged) by
        the appropriate length scale [[acell]](1), [[acell]](2),
        or [[acell]](3),
        respectively to give the dimensional primitive translations
        in real space in cartesian coordinates.
         <br />
         Presently, it is requested that the mixed product
        (R1xR2).R3 is positive. If this is not the case,
        simply exchange a pair of vectors.
         <br />
         To be more specific, keeping the default value of [[scalecart]]=1 to simplify the matter,
        [[rprim]] 1 2 3 4 5 6 7 8 9 corresponds to input of the
        three primitive translations R1=(1,2,3) (to be multiplied by [[acell]](1)), R2=(4,5,6) (to be multiplied by
        [[acell]](2)), and R3=(7,8,9) (to be multiplied by [[acell](3)).
         <br />
         Note carefully that the first
        three numbers input are the first column of [[rprim]], the next
        three are the second, and the final three are the third.
        This corresponds with the usual Fortran order for arrays.
        The matrix whose columns are the reciprocal space primitive
        translations is the inverse transpose of the matrix whose
        columns are the direct space primitive translations.
        </p>
        <p>
         Alternatively to [[rprim]], directions of dimensionless primitive
        vectors can be specified by using the input variable [[angdeg]].
        This is especially useful for hexagonal lattices (with 120 or 60 degrees angles).
        Indeed, in order for symmetries to be recognized, rprim must be symmetric up to
        [[tolsym]] (10 digits by default),
        inducing a specification such as
         <pre>
          rprim  0.86602540378  0.5  0.0
                -0.86602540378  0.5  0.0
                 0.0            0.0  1.0
         </pre>
         that can be avoided thanks to [[angdeg]]:
         <pre>
          angdeg 90 90 120
         </pre>
         <br />
         Although the use of [[scalecart]] or [[acell]] is
        rather equivalent when the primitive vectors are aligned with the cartesian directions, it is not the case for
        non-orthogonal primitive vectors. In particular, beginners often make the error of trying to use [[acell]]
        to define primitive vectors in face-centered tetragonal lattice, or body-centered tetragonal lattice, or similarly
        in face or body-centered orthorhombic lattices. Let us take the example of a body-centered tetragonal lattice, that
        might be defined using the following ("a" and "c" have to be replaced by the appropriate conventional cell vector length):
         <pre>
          rprim  "a"      0        0
                  0      "a"       0
                 "a/2"   "a/2"    "c/2"
        acell 3*1     scalecart 3*1    !  ( These are default values)
         </pre>
         The following is a valid, alternative way to define  the same primitive vectors :
         <pre>
          rprim   1        0       0
                  0        1       0
                  1/2      1/2     1/2
        scalecart  "a"  "a"  "c"
        acell 3*1    !  ( These are default values)
         </pre>
         Indeed, the cell has been stretched along the cartesian coordinates, by "a", "a" and "c" factors.
        </p>
        <p>
         At variance, the following is WRONG :
         <pre>
          rprim   1       0       0
                  0       1       0
                  1/2     1/2     1/2
        acell  "a"  "a"  "c"    !   THIS IS WRONG
        scalecart 3*1    !  ( These are default values)
         </pre>
         Indeed, the latter would correspond to :
         <pre>
          rprim  "a"      0       0
                  0      "a"      0
                 "c/2"   "c/2"   "c/2"
        acell 3*1     scalecart 3*1    !  ( These are default values)
         </pre>
         Namely, the third vector has been rescaled by "c". It is not at all in the center of the tetragonal cell whose basis vectors
        are defined by the scaling factor "a".
         <br />
         As another difference between [[scalecart]] or [[acell]],
        note that [[scalecart]] is [[INPUT_ONLY]] :
        its content will be immediately applied to rprim, at parsing time,
        and then scalecart will be set to the default values (3*1). So, in case [[scalecart]] is used,
        the echo of [[rprim]] in the output file is not the value contained in the input file,
        but the value rescaled by [[scalecart]].
        </p>
    topics: UnitCell_basic
    varset: basic
    vartype: real
- !variable
    abivarname: rprimd
    characteristics:
    - '[[INTERNAL_ONLY]]'
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: Internally, it is represented as rprimd(3,3,[[nimage]]).
    defaultval: null
    dimensions:
    - 3
    - 3
    excludes: null
    mnemonics: Real space PRIMitive translations, Dimensional
    requires: null
    text: |-
        <p>
         This internal variable gives the dimensional real space primitive
        vectors, computed from [[acell]],
        [[scalecart]],
        and [[rprim]].
         <ul>
          <li>
           R1p(i)=[[rprimd]](i,1)=[[scalecart]](i)*[[rprim]](i,1)*[[acell]](1) for i=1,2,3 (x,y,and z)
          </li>
          <li>
           R2p(i)=[[rprimd]](i,2)=[[scalecart]](i)*[[rprim]](i,2)*[[acell]](2) for i=1,2,3
          </li>
          <li>
           R3p(i)=[[rprimd]](i,3)=[[scalecart]](i)*[[rprim]](i,3)*[[acell]](3) for i=1,2,3
          </li>
         </ul>
        </p>
        It is [[EVOLVING]] only if [[ionmov]]==2 and [[optcell]]/=0, otherwise it is fixed.
        <br />
    topics: UnitCell_internal
    varset: basic
    vartype: real
- !variable
    abivarname: rsurdir@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 2
        value: 0.0
    dimensions:
    - 2
    excludes: null
    mnemonics: Radius SURface DIRection
    requires: null
    text: |-
        In the case [[aim:rsurf]]=1,
          gives the direction (angular coordinates theta,phi)
          along which the radius of the Bader
          surface is to be determined.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: rsurf@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: computation of the Radius bader SURFace
    requires: null
    text: |-
        Drive the computation of the radius of the Bader surface for
          the angles specified in the input variable
          [[aim:rsurdir]]
          <ul>
           <li>0, not calculated
           <li>1, calculated
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: scal@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0 1.0 1.0
    dimensions:
    - 3
    excludes: null
    mnemonics: SCALing of the cartesian coordinates
    requires: null
    text: |-
        SCALing of the cartesian coordinates.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: scalecart
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 1
    dimensions:
    - 3
    excludes: null
    mnemonics: SCALE CARTesian coordinates
    requires: null
    text: |-
        <p>
         Gives the scaling factors of cartesian coordinates by which
        dimensionless primitive translations (in "[[rprim]]") are
        to be multiplied.
        [[rprim]] input variable,
        the [[acell]] input variable,
        and the associated internal [[rprimd]] internal variable.
         <br />
         Especially useful for body-centered and face-centered tetragonal lattices, as well as
        body-centered and face-centered orthorhombic lattices, see [[rprimd]].
         <br />
         Note that this input variable is [[INPUT_ONLY]] : its content will be immediately applied to rprim, at parsing time,
        and then scalecart will be set to the default values. So, it will not be echoed.
        </p>
    topics: UnitCell_useful
    varset: basic
    vartype: real
- !variable
    abivarname: scissor@optic
    characteristics: null
    commentdefault: in Ha
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: SCISSOR operator
    requires: null
    text: |-
        LDA/GGA are well known to underestimate the band-gap by up to 100%. In order
          to get the optical spectrum and make a realistic comparison with experiments
          one needs to correct for this. This can be achieved in two ways. The scissors
          shift is normally chosen to be the difference between the experimental and
          theoretical band-gap and is used to shift the conduction bands only. Another
          way in which you do not have to rely on experimental data is to determine the
          self energy using the <a href="../../tutorial/generated_files/lesson_gw1.html">GW approach</a>.
          In this case the opening of the gap due to the GW correction can be used as
          scissor shift.
    topics: Optic_basic
    varset: optic
    vartype: real
- !variable
    abivarname: scphon_supercell
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    - 1
    dimensions:
    - 3
    excludes: null
    mnemonics: Self Consistent PHONon SUPERCELL
    requires: null
    text: |-
        <p>
         Give extent, in number of primitive unit cells, of the supercell being used for
        a self-consistent phonon calculation. Presumes the phonon frequencies and eigenvectors
        have been calculated in the original primitive unit cell, on a grid of q-points which
        corresponds to the supercell in the present calculation.

        TO BE IMPROVED : should contain a tutorial on how to do self-consistent phonon calculations, David Waroquiers 090831
        </p>
    topics: DFPT_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: scphon_temp
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Self Consistent PHONon TEMPerature
    requires: null
    text: |-
        <p>
         Temperature which is imposed on phonon distribution, in the self-consistent scheme of
        Souvatzis et al. PRL
         <b>
          100
         </b>
         , 095901. Determines the extent of the finite displacements
        used, and consequent anharmonic effects. Experimental.
        </p>
    topics: DFPT_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: selectz@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: SeLECT Z
    requires: null
    text: |-
        <p>Select some parts of the effective charge tensor.
        (This is done after the application or non-application of the ASR for
        effective charges). The transformed effective charges are then used for
        all the subsequent calculations. <br>
        <ul>
         <li> 0 => The effective charge tensor is left as it is.</li>
         <li> 1 => For each atom, the effective charge tensor is made
                isotropic, by calculating the trace of the matrix,
                dividing it by 3, and using this number in a
                diagonal effective charge tensor. </li>
         <li> 2 => For each atom, the effective charge tensor is made
                symmetric, by simply averaging on symmetrical elements.<li>
        </ul>
        <p>
        Note: this is for analysis the effect of anisotropy
        in the effective charge. The result with non-zero <b>selectz</b>
        are unphysical.</p>
    topics: Phonons_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: shiftk
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nshiftk]]>1': null
        defaultval:
        - 0.5
        - 0.5
        - 0.5
    dimensions:
    - 3
    - '[[nshiftk]]'
    excludes: null
    mnemonics: SHIFT for K points
    requires: null
    text: |-
        <p>
         It is used only when [[kptopt]]&gt;=0,
        and must be defined if [[nshiftk]] is larger than 1.
         <br />
         [[shiftk]](1:3,1:[[nshiftk]]) defines
        [[nshiftk]] shifts
        of the homogeneous grid of k points
        based on [[ngkpt]] or
        [[kptrlatt]].
         <br />
         The shifts induced by [[shiftk]] corresponds
        to the reduced coordinates in the coordinate system
        defining the k-point lattice. For example,
        if the k point lattice is defined using [[ngkpt]],
        the point whose reciprocal space reduced coordinates are
        ( [[shiftk]](1,ii)/[[ngkpt]](1)
        [[shiftk]](2,ii)/[[ngkpt]](2)
        [[shiftk]](3,ii)/[[ngkpt]](3) )
        belongs to the shifted grid number ii.
        </p>
        <p>
         The user might rely on ABINIT to suggest suitable and
        efficient combinations of [[kptrlatt]]
        and [[shiftk]].
        The procedure to be followed is described with the
        input variables [[kptrlen]].
        In what follows, we suggest some interesting values of the shifts,
        to be used with even values of [[ngkpt]].
        This list is much less exhaustive than the above-mentioned automatic
        procedure.
        </p>
        <p>
         1) When the primitive vectors of the lattice do NOT form
        a FCC or a BCC lattice, the default (shifted) Monkhorst-Pack
        grids are formed by using
        [[nshiftk]]=1 and [[shiftk]] 0.5 0.5 0.5 .
        This is often the preferred k point sampling, as the shift improves the sampling efficiency.
        However, it can also break symmetry, if the 111 direction is not an axis of rotation,
        e.g. in tetragonal or hexagonal systems. Abinit will complain about this breaking, and you
        should adapt [[shiftk]].
        For a non-shifted Monkhorst-Pack grid, use
        [[nshiftk]]=1 and [[shiftk]] 0.0 0.0 0.0 ,
        which will be compatible with all symmetries, and is necessary for some features such as k-point
        interpolation.
        </p>
        <p>
         2) When the primitive vectors of the lattice form a FCC lattice,
        with [[rprim]]
         <pre>
          0.0 0.5 0.5
          0.5 0.0 0.5
          0.5 0.5 0.0
         </pre>
         the (very efficient) usual Monkhorst-Pack sampling will be generated by using
        [[nshiftk]]= 4  and [[shiftk]]
         <pre>
          0.5 0.5 0.5
          0.5 0.0 0.0
          0.0 0.5 0.0
          0.0 0.0 0.5
         </pre>
        </p>
        <p>
         3) When the primitive vectors of the lattice form a BCC lattice,
        with [[rprim]]
         <pre>
          -0.5  0.5  0.5
           0.5 -0.5  0.5
           0.5  0.5 -0.5
         </pre>
         the usual Monkhorst-Pack sampling will be generated by using
        [[nshiftk]]= 2  and [[shiftk]]
         <pre>
          0.25  0.25  0.25
         -0.25 -0.25 -0.25
         </pre>
         However, the simple sampling
        [[nshiftk]]=1 and [[shiftk]] 0.5 0.5 0.5
        is excellent.
        </p>
        <p>
         4) For hexagonal lattices with hexagonal axes, e.g. [[rprim]]
         <pre>
          1.0  0.0       0.0
         -0.5  sqrt(3)/2 0.0
          0.0  0.0       1.0
         </pre>
         one can use
        [[nshiftk]]= 1  and [[shiftk]]  0.0 0.0 0.5
        </p>
        <p>
         In rhombohedral axes, e.g. using [[angdeg]] 3*60.,
        this corresponds to [[shiftk]]  0.5 0.5 0.5, to keep the shift along the
        symmetry axis.
        </p>
    topics: k-points_useful
    varset: basic
    vartype: real
- !variable
    abivarname: shiftq
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nshiftq]]>1': null
        defaultval:
        - 0.5
        - 0.5
        - 0.5
    dimensions:
    - 3
    - '[[nshiftq]]'
    excludes: null
    mnemonics: SHIFT for Q points
    requires: null
    text: |-
        <p>
         It is used only when [[qptopt]]&gt;=0,
        and must be defined if [[nshiftq]] is larger than 1.
         <br />
         [[shiftq]](1:3,1:[[nshiftq]]) defines
        [[nshiftq]] shifts
        of the homogeneous grid of q points
        based on [[ngqpt]] or
        [[qptrlatt]].
        </p>
        <p>
         See [[shiftk]] for more information on the definition,
        use, and suitable values for these shifts.
        </p>
    topics: q-points_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: signperm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: SIGN of PERMutation potential
    requires: null
    text: |-
        +1 favors alternation of species
        -1 favors segregation
    topics: MolecularDynamics_expert
    varset: rlx
    vartype: integer
- !variable
    abivarname: slabwsrad
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: jellium SLAB Wigner-Seitz RADius
    requires: null
    text: |-
        <p>
         Fix the bulk-mean positive charge density n<sub>bulk</sub> of a jellium slab (if the latter is employed, e.g. [[jellslab]] &ne; 0). Often called "r<sub>s</sub>" [see for example N. D. Lang and W. Kohn PRB 1, 4555 (1970)], [[slabwsrad]] is the radius of a sphere which has the same volume as the average volume per particle in a homogeneous electron gas with density n<sub>bulk</sub>, so:
         <pre>
          1/n<sub>bulk</sub> = 4/3 Pi * [[slabwsrad]]<sup>3</sup>
         </pre>
        For example, the bulk aluminum fcc lattice constant is a=4.0495 Angstroms (webelements.com), each cubic centered cell includes 4 Al atoms and each atom has 3 valence electrons, so the average volume per electron is a<sup>3</sup>/12=37.34 Bohr<sup>3</sup> which has to be equal to 4/3 Pi*r<sub>s</sub><sup>3</sup>. Consequently Al has approximately r<sub>s</sub> =2.07 Bohr, while for example magnesium has r<sub>s</sub> =2.65 Bohr, sodium 3.99 Bohr.
        <br />
        By default, given in Bohr atomic units (1 Bohr=0.5291772108 Angstroms).
        </p>
    topics: Artificial_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: slabzbeg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    dimensions: scalar
    excludes: null
    mnemonics: jellium SLAB BEGinning edge along the Z direction
    requires: null
    text: |-
        <p>
        Define the edges of the jellium slab (if used, so if [[jellslab]] &ne; 0) along z, namely the slab starts at a point along z which is expressed in Bohr by <b>slabzbeg</b> and it ends at a point expressed in Bohr by [[slabzend]]. The z direction is parallel to the third crystal primitive lattice vector which has to be orthogonal to the other ones, so the length of the cell along z is [[rprimd]](3,3). In addition <b>slabzbeg</b> and [[slabzend]] have to be such that:
         <pre>
          0 &le; <b>slabzbeg</b> &lt; [[slabzend]] &le; [[rprimd]](3,3)
         </pre>
        Together with [[slabwsrad]] they define the jellium positive charge density distribution n<sub>+</sub>(x,y,z) in this way:
         <pre>
          n<sub>+</sub>(x,y,z) = n<sub>bulk</sub>     if <b>slabzbeg</b> &le; z &le; [[slabzend]]
                    = 0        otherwise,
         </pre>
        so the positive charge density is invariant along the xy plane as well as the electrostatic potential generated by it.
        </p>
    topics: Artificial_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: slabzend
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    dimensions: scalar
    excludes: null
    mnemonics: jellium SLAB ENDing edge along the Z direction
    requires: null
    text: |-
        <p>
        Define the edges of the jellium slab (if used, so if [[jellslab]] &ne; 0) along z, namely the slab starts at a point along z which is expressed in Bohr by [[slabzbeg]] and it ends at a point expressed in Bohr by <b>slabzend</b>. The z direction is parallel to the third crystal primitive lattice vector which has to be orthogonal to the other ones, so the length of the cell along z is [[rprimd]](3,3). In addition [[slabzbeg]] and <b>slabzend</b> have to be such that:
         <pre>
          0 &le; [[slabzbeg]] &lt; <b>slabzend</b> &le; [[rprimd]](3,3)
         </pre>
        Together with [[slabwsrad]] they define the jellium positive charge density distribution n<sub>+</sub>(x,y,z) in this way:
         <pre>
          n<sub>+</sub>(x,y,z) = n<sub>bulk</sub>     if [[slabzbeg]] &le; z &le; <b>slabzend</b>
                    = 0        otherwise,
         </pre>
        so the positive charge density is invariant along the xy plane as well as the electrostatic potential generated by it.
        </p>
    topics: Artificial_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: smdelta
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: SMeared DELTA function
    requires: null
    text: |-
        <p>
         When [[smdelta]] in non-zero, it will trigger the calculation of the imaginary part of the second-order electronic eigenvalues, which can be related to the electronic lifetimes. The delta function is evaluated using:
         <br />
         <ul>
          <li>
           when [[smdelta]] == 1, Fermi-Dirac smearing : 0.25_dp/(cosh(xx/2.0_dp)**2
          </li>
          <li>
           when [[smdelta]] == 2, Cold smearing by Marzari using the parameter a=-.5634 (minimization of the bump): exp(-xx2)/sqrt(pi) * (1.5d0+xx*(-a*1.5d0+xx*(-1.0d0+a*xx)))
          </li>
          <li>
           when [[smdelta]] == 3, Cold smearing by Marzari using the parameter a=-.8165 (monotonic function in the tail): as 2 but different a
          </li>
          <li>
           when [[smdelta]] == 4, Smearing of Methfessel and Paxton (PRB40,3616(1989)) with Hermite polynomial of degree 2, corresponding to "Cold smearing" of N. Marzari with a=0 (so, same smeared delta function as smdelta=2, with different a).
          </li>
          <li>
           when [[smdelta]] == 5, Gaussian smearing :  1.0d0*exp(-xx**2)/sqrt(pi)
          </li>
         </ul>
        </p>
    topics: TDepES_compulsory
    varset: dfpt
    vartype: integer
- !variable
    abivarname: so_psp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: '[[npsp]]'
        value: 1
    dimensions:
    - '[[npsp]]'
    excludes: null
    mnemonics: Spin-Orbit treatment for each PSeudoPotential
    requires: '[[nspinor]]==2 and [[usepaw]]==0'
    text: |-
        <p>
         For each type of atom (each pseudopotential), specify
        the treatment of spin-orbit interaction (if [[nspinor]]==2 and Norm-conserving pseudopotentials [[usepaw]]==0)
         <br />
         If 0 : no spin-orbit interaction, even if [[nspinor]]=2
         <br />
         If 1 : treat spin-orbit as specified in the pseudopotential file.
         <br />
         If 2 : treat spin-orbit in the HGH form
        (usual form, although not allowed for all pseudopotentials)
         <br />
         If 3 : treat spin-orbit in the HFN form (Hemstreet-Fong-Nelson)
        (actually, not implemented ...).
        </p>
        <p>
        For typical usage, the default value is OK. If the spin-orbit needs to be turned off for one atom, 0 might be relevant.
        Note however, that the code will stop if [[nspinor]]=2 is used and one of the pseudopotential does not contain the information
        about the spin-orbit interaction (this is the case for some old pseudopotentials). Indeed, for spinorial calculations,
        turning off the spin-orbit interaction is unphysical, and also does not save CPU time ... It should only be done for test purposes
        </p>
        <p>
         Note that if [[nspinor]]==1, the spin-orbit cannot be treated
        anyhow, so the value of [[so_psp]] is irrelevant.
        In case [[usepaw]]=1, please refer to [[pawspnorb]].
        </p>
        <p>
         Prior to v5.4, the input variable
         <b>
          so_typat
         </b>
         was used, in place of [[so_psp]]. Because the values 0 and 1 have been switched
        between [[so_psp]] and so_typat, it was dangerous to continue to allow the use of so_typat.
        </p>
    topics: spinpolarisation_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: spbroad
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: SPectral BROADening
    requires: '[[optdriver]]==3 and [[spmeth]]==2'
    text: |-
        When a screening calculation ([[optdriver]]==3) uses a spectral representation of the irreducible polarizability in which
        the delta function is replaced by the gaussian approximant ([[spmeth]]==2), the standard deviation of the gaussian
        is given by [[spbroad]].
    topics: Susceptibility_useful
    varset: gw
    vartype: real
- !variable
    abivarname: spgaxor
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'SPace Group : AXes ORientation'
    requires: null
    text: |-
        <p>
         It is taken into account only when [[spgroup]]/=0; it
        allows one to define the axes orientation
        for the specific space groups for which this is needed.
        Trigonal groups (number 146,148,155,160,161,166,167):
         <ul>
          <li>
           1 represents the hexagonal axes
          </li>
          <li>
           2 represents the rhombohedral axes
          </li>
         </ul>
         Orthorhombic space groups :
        there are six possibilities corresponding to the possible
        axes permutations
         <ul>
          <li>
           1 abc -&gt; abc
          </li>
          <li>
           2 abc -&gt; cab
          </li>
          <li>
           3 abc -&gt; bca
          </li>
          <li>
           4 abc -&gt; acb
          </li>
          <li>
           5 abc -&gt; bac
          </li>
          <li>
           6 abc -&gt; cba
          </li>
         </ul>
         Monoclinic : there are 3 or 9 possibilities depending on
        the space group. See the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         for details.
        In the log/output file the notation used to describe the
        monoclinic groups is for example:
         <br />
         15:c1, A2/a_c = C2/c
         <br />
         where,
         <ul>
          <li>
           15 represents the space group number,
          </li>
          <li>
           c1 the orientation as it appears on the web page,
          </li>
          <li>
           A is the real Bravais type lattice,
          </li>
          <li>
           2/a the existent symmetry elements,
          </li>
          <li>
           _c marks the orientation of the two-fold axis or of the mirror plane,
          </li>
          <li>
           C2/c represents the parent space group.
          </li>
         </ul>
        </p>
        <p>
         How to determine which spgaxor you need:
         <ol>
          <li>
           check the reduced positions you have, for more symmetric positions, e.g. 1/2 1/4 3/4 etc... Let us say your symmetric positions are in the first coordinate (a axis) and you are using spgroup 62.
          </li>
          <li>
           look up the raw space group Wyckoff positions on
           <a href="http://www.cryst.ehu.es/cgi-bin/cryst/programs/nph-wp-list">
            the Bilbao server
           </a>
           to see where they put the corresponding symmetric positions. For spgroup 62 Bilbao puts the 1/4 3/4 in the second coordinate, ie along the b axis.
          </li>
          <li>
           in this case you need to swap the axes from the original abc order to a new order where the Bilbao axis (b) is in the first position. In this case you have 2 possibilities, spgaxor 3 or 5. If you have more than one highly symmetric coordinate you may have only a single possibility.
          </li>
         </ol>
        </p>
    topics: SmartSymm_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: spgorig
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: 'SPace Group : ORIGin'
    requires: '[[spgroup]]!=0'
    text: |-
        <p>
         Gives the choice of origin for the axes system.
         <br />
         It is defined according to the origin choice in the
        International Tables of Crystallography.
         <br />
         It applies only to the space groups 48, 50, 59, 70, 85, 86, 88, 125,
        126, 129, 130, 133, 134, 137, 141, 142, 201, 203, 222, 224, 227, 228.
         <br />
         For details see the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         .
        </p>
    topics: SmartSymm_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: spgroup
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: SPace GROUP number
    requires: null
    text: |-
        <p>
         Gives the number of the space group.
         <br />
         If [[spgroup]] is 0, the code assumes that all the symmetries
        are input through the [[symrel]] matrices and the [[tnons]]
        vectors, or obtained from the symmetry finder (the default when
        [[nsym]]==0).
         <br />
         It should be between 1 and 230.  This option can be
        used to obtain all the atoms in the unit cell, starting
        from the asymmetric unit cell.
         <br />
         The references for computing the symmetry corresponding to
        the space groups are :
         <ul>
          <li>
           International Tables for Crystallography, 1983, Ed. Theo Hahn,
        D. Reidel Publishing Company
          </li>
          <li>
           The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford.
          </li>
         </ul>
         <br />
         For details see the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         .
        </p>
    topics: crystal_useful, UnitCell_useful, SmartSymm_basic
    varset: geo
    vartype: integer
- !variable
    abivarname: spgroupma
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: SPace GROUP number defining a MAgnetic space group
    requires: null
    text: |-
        <p>
         This input variable might be used to define a Shubnikov
        magnetic space group (anti-ferromagnetic space group). The user is advised to consult
        "The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford."
         <br />
         A Shubnikov type IV magnetic space group might be defined by its Fedorov space group
        (set of spatial symmetries that do not change the magnetization), and an additional
        magnetic space group number [[spgroupma]].
         <br />
         A Shubnikov type III magnetic space group might be defined by its Fedorov space group
        (set of all spatial symmetries, irrespective of their magnetic action), and an additional
        magnetic space group number [[spgroupma]].
         <br />
         For the additional number [[spgroupma]], we follow the definition of Table 7.4 of the
        above-mentioned Bradley and Cracknell textbook.
         <br />
         Thus, one way to specify a Shubnikov IV magnetic space group, is to define both
        [[spgroup]] and [[spgroupma]].
         <br />
         For example, the group P2_1/c_prime has [[spgroup]]=14
        and [[spgroupma]]=78.
         <br />
         Alternatively,
        for Shubnikov IV magnetic groups, one might
        define [[spgroup]] and [[genafm]].
        For both the type III and IV, one might
        define by hand the set of symmetries, using [[symrel]],
        [[tnons]] and [[symafm]].
        </p>
    topics: spinpolarisation_useful, SmartSymm_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: spinat
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: !valuewithconditions
        '[[natrd]]<[[natom]]':
        - 3
        - '[[natrd]]'
        defaultval:
        - 3
        - '[[natom]]'
    excludes: null
    mnemonics: SPIN for AToms
    requires: null
    text: |-
        <p>
         Gives the initial electronic spin-magnetization
        for each atom, in unit of h-bar/2.
        </p>
        <p>
         Note that if [[nspden]]=2,
        the z-component must be given
        for each atom, in triplets (0 0 z-component).
         <br />
         For example, the electron of an hydrogen atom
        can be spin up (0 0 1.0) or spin down (0 0 -1.0).
        </p>
        <p>
         This value is only used to create
        the first exchange and correlation potential,
        and is not used anymore afterwards.
         <br />
         It is not checked against the initial occupation numbers
        [[occ]] for each spin channel.
         <br />
         It is meant to give an easy way to break
        the spin symmetry, and to allow
        to find stable local spin fluctuations, for example :
        antiferromagnetism, or the spontaneous spatial
        spin separation of elongated H2 molecule.
         <br />
         <br />
         <li>
          If the atom manipulator is used, [[spinat]] will be related
        to the preprocessed set of atoms, generated by the
        atom manipulator. The user must thus foresee the effect
        of this atom manipulator (see [[objarf]]).
         </li>
         <br />
         <li>
          If the atom manipulator is not used, and the symmetries
        are not specified by the user ([[nsym]]=0),
        spinat will be used, if present, to determine the anti-ferromagnetic
        characteristics of the symmetry operations, see [[symafm]].
          <br />
          In case of collinear antiferromagnetism
        ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=2),
        these symmetries are used to symmetrize the density.
          <br />
          In case of non-collinear magnetism
        ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=4),
        they are also used to symmetrize the density.
        In the latter case, this strongly constrains the magnetization (imposing its direction).
        If the user want to let all degrees of freedom of the magnetization evolve, it is
        then recommended to put [[nsym]]=1.
          <br />
         </li>
         <br />
         <li>
          If the symmetries are specified, and the irreducible set of atoms
        is specified, the anti-ferromagnetic characteristics of the symmetry
        operations [[symafm]] will be used to generate
        [[spinat]] for all the non-irreducible atoms.
         </li>
         <br />
         <li>
          In the case of PAW+U calculations using the [[dmatpawu]]
        initial occupation matrix, and if [[nspden]]=4, [[spinat]] is
        also used to determine the direction of the integrated magnetization matrix.
         </li>
        </p>
    topics: spinpolarisation_basic, crystal_useful, MagMom_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: spinmagntarget
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -99.99
    dimensions: scalar
    excludes: null
    mnemonics: SPIN-MAGNetization TARGET
    requires: null
    text: |-
        <p>
         This input variable is active only in the
        [[nsppol]]=2 case.
        If [[spinmagntarget]] is not the "magic" value of -99.99d0, the
        spin-magnetization of the primitive cell will be fixed (or optimized, if it is not possible to impose it)
        to the value of [[spinmagntarget]], in Bohr magneton units, e.g. for an Hydrogen atom, it is 1.
         <br />
        If [[occopt]] is a metallic one, the
        Fermi energies for spin up and spin down are adjusted to give the target
        spin-polarisation (this is equivalent to an exchange splitting).
        If [[occopt]]=1 and [[nsppol]]=2,
        the occupation numbers for spin up and spin down will be adjusted to give the required
        spin-magnetization (occupation numbers are identical for all k-points, with [[occopt]]=1).
        The definition of [[spinmagntarget]] is actually requested in this case, except for the single isolated Hydrogen atom.
         <br />
         If [[spinmagntarget]] is the default one, the spin-magnetization will not be constrained,
        and will be determined self-consistently, by having the same spin up and spin down
        Fermi energy in the metallic case, while for the other cases, there will be no spin-magnetization,
        except for an odd number of electrons if [[occopt]]=1 and [[nsppol]]=2.
        </p>
        <p>
         Note : for the time being, only the spin down Fermi energy
        is written out in the main output file. In the fixed
        magnetic moment case, it differs from the
        spin up Fermi energy.
        </p>
    topics: spinpolarisation_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: spmeth
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: SPectral METHod
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         The [[spmeth]] input variable defines the method used to calculate the irreducible
        polarizability $\chi^{(0)}_{KS}$.
        </p>
        <p>
         By default $\chi^{(0)}_{KS}$ is calculated employing the Adler-Wiser expression ([[spmeth]]=0)
        with a CPU effort that scales linearly with the number of frequencies.
        This approach is convenient when few frequencies are required, and is usually
        used in conjunction with plasmon-pole models in which only one or two frequencies are calculated,
        according to the value of [[ppmodel]].
         <br />
         Unfortunately a calculation based on the Adler-Wiser expression might be quite CPU demanding
        if the matrix elements of the self-energy operator are evaluated by performing numerically
        the convolution defining the self-energy.
        The integrand function, indeed, has poles above and below the real axis, and
        the screened interaction has to be evaluated on a dense frequency mesh in order to obtain accurate
        results.
        </p>
        <p>
         In the spectral method ([[spmeth]]=1 or 2) the irreducible polarizability is expressed as
        the Hilbert transform of the imaginary part.
        The advantage in using this approach consists in the fact that, once the spectral function is known,
        the irreducible polarizability for an arbitrary frequency can be easily obtained through inexpensive
        integrations. On the other hand an accurate evaluation of the imaginary part requires a dense
        frequency mesh due to the presence of delta functions.
        Two different approaches can be used to approximate these delta functions thus allowing the use
        of affordable frequency grids.
        </p>
        <p>
         Summarizing:
         <ul>
          <li>
           0 =&gt; use Adler-Wiser expression to calculate $\chi^{(0)}_{KS}$
          </li>
          <li>
           1 =&gt; use the spectral method approximating the delta function with a triangular approximant
        as proposed in
           <b>
            REF TO BE ADDED
           </b>
          </li>
          <li>
           2 =&gt; use spectral method but approximating the delta function with a Taylor expansion of the exponential
        as proposed in
           <b>
            REF TO BE ADDED
           </b>
          </li>
         </ul>
        </p>
    topics: Susceptibility_useful
    varset: gw
    vartype: integer
- !variable
    abivarname: spnorbscl
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: SPin-ORBit SCaLing
    requires: '[[usepaw]]==1 and [[pawspnorb]]>= 1 '
    text: |-
        <p>
         Scaling of the spin-orbit interaction. The default values gives the first-principles value, while
        other values are used for the analysis of the effect of the spin-orbit interaction,
        but are not expected to correspond to any physical situation.
        </p>
    topics: PAW_expert, spinpolarisation_useful
    varset: paw
    vartype: real
- !variable
    abivarname: stmbias
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Scanning Tunneling Microscopy BIAS voltage
    requires: null
    text: |-
        <p>
         Gives, in Hartree, the
        bias of the STM tip, with respect to the sample, in order to generate
        the STM density map.
         <br />
         Used with positive [[iscf]],
        [[occopt]]=7 (metallic, gaussian),
        [[nstep]]=1 ,
        and positive [[prtstm]], this
        value is used to generate a charge density map from electrons
        close to the Fermi energy, in a (positive or negative) energy range.
        Positive [[stmbias]] will lead to the inclusion of occupied (valence) states only, while
        negative [[stmbias]] will lead to the inclusion of unoccupied (conduction) states only.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[stmbias]] has the
        '[[ENERGY]]' characteristics
        (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
        With [[occopt]]=7,
        one has also to specify an independent broadening [[tsmear]].
        </p>
    topics: STM_compulsory
    varset: gstate
    vartype: real
- !variable
    abivarname: strfact
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    dimensions: scalar
    excludes: null
    mnemonics: STRess FACTor
    requires: null
    text: |-
        <p>
         The stresses multiplied
        by [[strfact]] will be treated like forces in the
        process of optimization ([[ionmov]]=2,
        non-zero
        [[optcell]]).
         <br />
         For example, the stopping criterion defined by
        [[tolmxf]] relates to these scaled
        stresses.
        </p>
    topics: GeoOpt_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: string_algo
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: STRING method ALGOrithm
    requires: null
    text: |-
        <p>
         Relevant only when [[imgmov]]=2 (String Method).
         <br />
         Gives the variant of the String Method method used.
         <br />
         Possible values can be:
         <br />
         <ul>
          <li>
           0=&gt;
           <b>
            Original String Method
           </b>
           .
           <br />
           NOT YET IMPLEMENTED
           <br />
           <i>
            See: Phys. Rev. B 66, 052301 (2002)
           </i>
          </li>
          <br />
          <li>
           1=&gt;
           <b>
            Simplified String Method
           </b>
           with parametrization by
           <b>
            equal arc length
           </b>
           .
           <br />
           Instead of using the normal force (wr the band), the full force is used; the
        reparametrization is enforced by keeping the points of the string equally spaced.
           <br />
           <i>
            See: J. Chem. Phys. 126, 164103 (2007)
           </i>
          </li>
          <br />
          <li>
           2=&gt;
           <b>
            Simplified String Method
           </b>
           with parametrization by
           <b>
            energy-weighted arc length
           </b>
           .
           <br />
           A variant of the Simplified String Method (like 2-); the reparametrization is done by using
        energy-weight arc-lengths, giving a finer distribution near the saddle point..
           <br />
           <i>
            See: J. Chem. Phys. 126, 164103 (2007) and J. Chem. Phys. 130, 244108 (2009)
           </i>
          </li>
         </ul>
        </p>
    topics: TransPath_useful
    varset: rlx
    vartype: integer
- !variable
    abivarname: strprecon
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: STRess PRECONditioner
    requires: null
    text: |-
        <p>
         This is a scaling factor to initialize the part of
        the Hessian related to the treatment of the stresses (optimisation
        of the unit cell). In case there is an instability, decrease the
        default value, e.g. set it to 0.1 .
        </p>
    topics: ForcesStresses_useful, GeoOpt_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: strtarget
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    - 0.0
    - 0.0
    - 0.0
    - 0.0
    dimensions:
    - 6
    excludes: null
    mnemonics: STRess TARGET
    requires: null
    text: |-
        The components of the stress tensor must be stored
        according to :
        (1,1)-&gt;1 ; (2,2)-&gt;2 ; (3,3)-&gt;3 ; (2,3)-&gt;4 ; (3,1)-&gt;5 ;
        (1,2)-&gt;6.
        The conversion factor
        between Ha/Bohr**3 and GPa is : 1 Ha/Bohr**3 = 29421.033d0 GPa.
        <br />
        Not used if [[optcell]]==0.
    topics: ForcesStresses_useful, GeoOpt_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: surf@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: computation of the bader SURFace
    requires: null
    text: |-
        Drive the computation of the full Bader surface.
          <ul>
           <li>0, not calculated
           <li>1, calculated
          </ul>
    topics: Bader_compulsory
    varset: aim
    vartype: integer
- !variable
    abivarname: symafm
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: '[[nsym]]'
        value: 1
    dimensions:
    - '[[nsym]]'
    excludes: null
    mnemonics: SYMmetries, Anti-FerroMagnetic characteristics
    requires: null
    text: |-
        <p>
         In case the material is magnetic (well, this is only interesting in the
        case of antiferromagnetism, collinear or not), additional symmetries might appear, that
        change the sign of the magnetization.
        They have been introduced by Shubnikov (1951). They can be used by ABINIT
        to decrease the CPU time, by using them to decrease the number of k-points.
         <br />
         [[symafm]] should be set to +1 for all the usual symmetry operations,
        that do not change the sign of the magnetization, while it should be
        set to -1 for the magnetization-changing symmetries.
         <br />
         If the symmetry operations are not specified by the user
        in the input file, that is, if [[nsym]]=0,
        then ABINIT will use the values of [[spinat]]
        to determine the content of [[symafm]].
         <br />
         The symmetries found as "antiferro magnetic" ([[symafm]]=-1) are used to symmetrize density and magnetization in the following cases:
         <br />
         - antiferromagnetism ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=2)
         <br />
         - non-collinear magnetism ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=4)
         <br />
         In other cases they are not used.
        </p>
    topics: spinpolarisation_useful
    varset: gstate
    vartype: integer
- !variable
    abivarname: symchi
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: SYMmetryze \chi_o
    requires: '[[optdriver]]==3'
    text: |-
        <p>
         The evaluation of the irreducible polarizability for a given q-point requires an
        integration over the Brillouin zone (BZ) which is approximated by a discrete sum over k-points.
        In principle the integrand function should be evaluated for each k-point in the BZ, however it is possible
        to reduce the number of points to be explicitly considered by taking advantage of symmetry properties.
        The development input variable [[symchi]] is used to choose between these two equivalent methods:
         <ul>
          <li>
           0=&gt; the summation over k-points is performed considering ALL the points in the BZ (useful for testing and debugging).
          </li>
          <li>
           1=&gt; the summation is restricted to the k-points belonging to the irreducible wedge
        defined by the little group associated to the external vector q.
          </li>
         </ul>
        </p>
    topics: Susceptibility_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: symdynmat
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: SYMmetrize the DYNamical MATrix
    requires: null
    text: |-
        If symdynmat is equal to 1, the dynamical matrix is symmetrized before the diagonalization (same meaning as the corresponding anaddb variable).
        Note that symdynmat==1 will automatically enable the symmetrization of the electron-phonon linewidths.
    topics: Phonons_useful
    varset: eph
    vartype: integer
- !variable
    abivarname: symdynmat@anaddb
    characteristics: null
    commentdefault: (was 0 before v5.3)
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: SYMmetrize the DYNamical MATrix
    requires: null
    text: |-
        <p>If <b>symdynmat</b> is equal to 1, the dynamical matrix
        is symmetrized before the diagonalization.
        <br>
        This is especially useful when the set of primitive vectors of the unit cell
        and their opposite do not reflect the symmetries of the Bravais lattice
        (typical case: body-centered tetragonal lattices ; FCC and BCC lattices
        might be treated with the proper setting of the
        [[anaddb:brav]] variable), and the interpolation
        procedure based on interatomic force constant is used: there are some
        slight symmetry breaking effects. The latter can be bypassed by this
        additional symmetrization.
    topics: Phonons_useful, PhononBands_useful
    varset: anaddb
    vartype: integer
- !variable
    abivarname: symgkq@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: SYMmetrize the GKk matrix elements for each Q
    requires: null
    text: |-
        <p>If <b>symgkq</b> is equal to 1, the electron-phonon matrix elements are symmetrized
        over the small group of the q-point they correspond to. This should always be used,
        except for debugging or test purposes.
    topics: ElPhonInt_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: symmorphi
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: SYMMORPHIc symmetry operation selection
    requires: null
    text: |-
        <p>
         With [[symmorphi]]=1, symmetry operations with a non-symmorphic vector are allowed.
        With [[symmorphi]]=0, they are not allowed.
        In the latter case, if the symmetry operations are specified in the input file, the code
        will stop and print an error message if a non-symmorphic vector is encountered.
        By contrast, if the symmetry operations are to be determined automatically
        (if [[nsym]]=0), then the set of symmetries will
        not include the non-symmorphic operations.
        </p>
        <p>
         Note : this feature exist because in a previous status of the GW calculations, non-symmorphic
        symmetry operations could not be exploited. Thus, the k points were restricted
        to the IBZ. In order to prepare GW calculations, and to perform GW calculations,
        [[symmorphi]]=0 was to be used, together with [[nsym]]=0.
        </p>
    topics: crystal_expert, GW_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: symrel
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nsym]]==1':
        -   - 1
            - 0
            - 0
        -   - 0
            - 1
            - 0
        -   - 0
            - 0
            - 1
        defaultval: null
    dimensions:
    - 3
    - 3
    - '[[nsym]]'
    excludes: null
    mnemonics: SYMmetry in REaL space
    requires: null
    text: |-
        <p>
         Gives "[[nsym]]" 3x3 matrices
        expressing space group symmetries in terms of their action
        on the direct (or real) space primitive translations.
         <br />
         It turns out that these can always be expressed as integers.
         <br />
         Always give the identity matrix even if no other symmetries
        hold, e.g.
        [[symrel]] 1 0 0 0 1 0 0 0 1
         <br />
         Also note that for this array as for all others the array
        elements are filled in a columnwise order as is usual for
        Fortran.
         <br />
         The relation between the above symmetry matrices [[symrel]],
        expressed in the basis of primitive translations, and
        the same symmetry matrices expressed in cartesian coordinates,
        is as follows.  Denote the matrix whose columns are the
        primitive translations as R, and denote the cartesian
        symmetry matrix as S.  Then
         <br />
         [[symrel]] = R(inverse) * S * R
         <br />
         where matrix multiplication is implied.
         <br />
         When the symmetry finder is used (see [[nsym]]), [[symrel]]
        will be computed automatically.
        </p>
    topics: crystal_useful
    varset: basic
    vartype: integer
- !variable
    abivarname: symsigma
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: SYMmetrization of SIGMA matrix elements
    requires: '[[optdriver]]==4'
    text: |-
        <p>
         This option is used to switch on the symmetrization of the self-energy matrix elements ([[symsigma]]=1).
        In this case the BZ integration defining the self-energy matrix elements is
        reduced to an appropriate irreducible wedge defined by the point group of the wave-vector k
        specified in the [[kptgw]] list.
        </p>
        <p>
         The symmetrized expression leads to a considerable speedup of the run but, unfortunately,
        this option is not yet compatible with self-consistent GW calculations
        (see [[gwcalctyp]]).
        </p>
        <p>
         The algorithm implemented in [[symsigma]]=1
        constructs a symmetric invariant for the diagonal matrix elements of the self-energy
        by simply averaging the GW results within the degenerate subspace.

        Therefore particular care has to be taken in the presence of accidental degeneracies.
        since GW calculations performed with [[symsigma]]=1 will not be able to remove
        the initial accidental degeneracy.
        </p>
    topics: SelfEnergy_expert
    varset: gw
    vartype: integer
- !variable
    abivarname: targetpol@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: TARGET POLarization
    requires: null
    text: |-
        <p>Target value of the polarization in cartesian
        coordinates and in C/m^2.
        See [[anaddb:polflag]].
    topics: ConstrainedPol_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: td_maxene
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: 'Time-Dependent dft : MAXimal kohn-sham ENErgy difference'
    requires: null
    text: |-
        <p>
         The Matrix to be diagonalized in the Casida framework
        (see "Time-Dependent Density Functional Response Theory of Molecular
        systems: Theory, Computational Methods, and Functionals", by M.E. Casida,
        in Recent Developments and Applications of Modern Density Functional
        Theory, edited by J.M. Seminario (Elsevier, Amsterdam, 1996).)
        is a NxN matrix, where, by default, N is the product of
        the number of occupied states by the number of unoccupied states.
         <br />
         The input variable [[td_maxene]] allows to diminish N : it selects
        only the pairs of occupied and unoccupied states for which the
        Kohn-Sham energy difference is less than [[td_maxene]].
        The default value 0.0 means that all pairs are taken into account.
         <br />
         See [[td_mexcit]] for an alternative
        way to decrease N.
        </p>
    topics: TDDFT_useful
    varset: dfpt
    vartype: real
- !variable
    abivarname: td_mexcit
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: 'Time-Dependent dft : Maximal number of EXCITations'
    requires: null
    text: |-
        <p>
         The Matrix to be diagonalized in the Casida framework
        (see "Time-Dependent Density Functional Response Theory of Molecular
        systems: Theory, Computational Methods, and Functionals", by M.E. Casida,
        in Recent Developments and Applications of Modern Density Functional
        Theory, edited by J.M. Seminario (Elsevier, Amsterdam, 1996).)
        is a NxN matrix, where, by default, N is the product of
        the number of occupied states by the number of unoccupied states.
         <br />
         The input variable [[td_mexcit]] allows to diminish N : it selects
        the first [[td_mexcit]] pairs of occupied and unoccupied states, ordered
        with respect to increasing Kohn-Sham energy difference.
        However, when [[td_mexcit]] is zero, all pairs are allowed.
         <br />
         See [[td_maxene]]
         for an alternative
        way to decrease N.
        </p>
    topics: TDDFT_useful
    varset: dfpt
    vartype: real
- !variable
    abivarname: telphint@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Technique for ELectron-PHonon INTegration
    requires: null
    text: |-
        <p>Flag controlling the Fermi surface integration
        technique used for electron-phonon quantities.
        <ul>
          <li>0 = tetrahedron method (no adjustable parameter)</li>
          <li>1 = Gaussian smearing (see [[anaddb:elphsmear]])</li>
          <li>2 = uniformly weighted band window between [[anaddb:ep_b_min]] and [[anaddb:ep_b_max]], for all k-points</li>
        </ul>
    topics: ElPhonTransport_basic, PhononWidth_basic
    varset: anaddb
    vartype: integer
- !variable
    abivarname: temperinc@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100.0
    dimensions: scalar
    excludes: null
    mnemonics: TEMPERature INCrease
    requires: null
    text: |-
        <p>Increment of the temperature in Kelvin, for thermodynamical and el-phon
        transport properties. See the associated
        [[anaddb:tempermin]] and [[anaddb:ntemper]] variables.
        The default temperature grid goes from 100K to 1000K by step of 100K. For the largest temperatures, for most solids, anharmonic effects not accounted in the harmonic approximation implemented in anaddb will be important. For weakly bounded systems (e.g. Van der Waals solids), such anharmonic effects might be important already at room temperature.
    topics: Temperature_basic
    varset: anaddb
    vartype: real
- !variable
    abivarname: tempermin@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100.0
    dimensions: scalar
    excludes: null
    mnemonics: TEMPERature MINimum
    requires: null
    text: |-
        <p>Lowest temperature (Kelvin) at which the thermodynamical quantities
        have to be evaluated. Cannot be zero when [[anaddb:thmflag]] is 1.
        <p>The highest temperature is defined using
        [[anaddb:temperinc]] and [[anaddb:ntemper]].
        The default temperature grid goes from 100K to 1000K by step of 100K. For the largest temperatures, for most solids, anharmonic effects not accounted in the harmonic approximation implemented in anaddb will be important. For weakly bounded systems (e.g. Van der Waals solids),
        such anharmonic effects might be important already at room temperature.
    topics: Temperature_basic
    varset: anaddb
    vartype: real
- !variable
    abivarname: tfkinfunc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Thomas-Fermi KINetic energy FUNCtional
    requires: null
    text: |-
        <ul>
          <li>
           [[tfkinfunc]]=1 : <span style="text-decoration: underline;">Thomas-Fermi</span>
        kinetic functional (explicit functional of the density) is used instead of Kohn-Sham kinetic
        energy functional (implicit functional of the density through Kohn-Sham wavefunctions).<br/>
        See Perrot F., Phys. Rev. A20,586-594 (1979)).
           </li>
          <li>
           [[tfkinfunc]]=11 : <span style="text-decoration: underline;">Thomas-Fermi-Weizsacker</span>
        kinetic functional with Gradient Corrections is used.<br/>
        The convergence of a calculation with this functional needs to be initialized from a calculation without Gradient Correction.
        This is automatically done with [[tfkinfunc]]=11. For the initialization steps, the [[tfw_toldfe]] criterion is used.
        When it is reached, then the Gradient Correction is added and the SCF cycle continues.<br/>
        Note: to obtain the convergence of a Molecular Dynamics simulation with TFW, it is necessary to find the best set of
        preconditionning parameters ([[diemix]], [[diemac]], [[dielng]]) and the best value of [[npulayit]] (if the default Pulay mixing is used).
           </li>
           <li>
           [[tfkinfunc]]=12 : same as <b>tfkinfunc</b>=11,
        but without the initialization steps. Gradient correction is directly added.
           </li>
        <li>
           [[tfkinfunc]]=2 : the <span style="text-decoration: underline;">Recursion Method</span>
        is used in order to compute electronic density, entropy, Fermi energy and eigenvalues energy.
        This method computes the density without computing any orbital, is efficient at high temperature,
        with a efficient parallelization (almost perfect scalability). When that option is in use, the
        [[ecut]] input variable is no longer a convergence parameter ;
        [[ngfft]] becomes the main convergence parameter: you should adapt ecut for the ngfft
        grid you need (it is not yet automatically computed). Other convergence parameter are for the energetic values:
        [[recnrec]], [[recptrott]], [[recnpath]].<br/>
        Since the convergence of the self-consistent cycle
        is determined directly by the convergence of the density:
        [[toldfe]], [[toldff]], [[tolrff]],
        [[tolvrs]], [[tolwfr]] are not used, and are replaced by
        [[rectolden]]; the energetic values, except for the fermi energy, are only
        computed during the latest SFC cycle : the output file will show a
        jump of the total energy at the end, but it is not because of a bad
        convergence behavior. Computational speed can be improved by the use
        of  [[recrcut]] and  [[recgratio]].
        The recursion method has not be tested in the case of non cubic cell
        or with the use of symmetries.<br/>
        In the recursion method the following variables are set to:
        [[useylm]]=1,  [[userec]]=1.
          </li>
         </ul>
        </p>
    topics: Recursion_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: tfw_toldfe
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-6 or [[toldfe]] is present
    dimensions: scalar
    excludes: null
    mnemonics: 'Thomas-Fermi-Weizsacker: TOLerance on the DiFference of total
        Energy, for initialization steps'
    requires: '[[tfkinfunc]]=11'
    text: |-
        This input variable has the same definition as [[toldfe]] and is only relevant when [[tfkinfunc]]=11.<br/>
        It sets a tolerance for absolute differences of total energy that, reached TWICE successively, will cause the
        initialization steps (without gradient correction) to stop and the gradient correction to be added.<br/>
        Can be specified in Ha (the default), Ry, eV or Kelvin, since it has the 'ENERGY' characteristics.
    topics: Recursion_useful
    varset: dev
    vartype: real
- !variable
    abivarname: thermal_supercell@anaddb
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: do not calculate any thermalized supercells
    commentdims: null
    defaultval: (/(/0,0,0/),  (/0,0,0/),  (/0,0,0/)/)
    dimensions:
    - 3
    - 3
    excludes: null
    mnemonics: THERMALized SUPERCELL lattice vectors
    requires: null
    text: |-
        <p>Thermal_supercell defines the real space supercell in which a thermalized atomic configuration should be produced, following the prescription of Zacharias and Giustino (PRB 94 075125 (2016)). The displacements are chosen for each phonon mode according to a temperature, and the displacements are alternated in sign/direction to obtain maximal compensation of the linear electron phonon coupling. In this way in the PRB dielectric properties at finite T can be obtained from a single supercell calculation instead of lots of MD and configuration averaging.</p>

        <p>The supercell vectors are not constrained to be collinear with the normal lattice vectors: this effect is obtained by using a diagonal Thermal_supercell. The lines of the matrix describe the linear combination of the primitive cell lattice vectors yielding the supercell vectors, as for kptrlatt.</p>

        <p>For the moment this feature is under development and it looks like the relative phases of the displacements are not fixed properly yet... (Aug 2017)</p>
    topics: Phonons_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: thetamax@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: pi
    dimensions: scalar
    excludes: null
    mnemonics: THETA MAXimal angle
    requires: null
    text: |-
        Angular limits of integration of the Bader volume
          for the theta variables. The number
          of integration points is given by
          [[aim:ntheta]].
          The range of integration can be decreased if there are
          symmetry reasons for doing this.
    topics: Bader_basic
    varset: aim
    vartype: real
- !variable
    abivarname: thetamin@aim
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: THETA MINimal angle
    requires: null
    text: |-
        Angular limits of integration of the Bader volume
          for the theta variables. The number
          of integration points is given by
          [[aim:ntheta]].
          The range of integration can be decreased if there are
          symmetry reasons for doing this.
    topics: Bader_expert
    varset: aim
    vartype: real
- !variable
    abivarname: thmflag@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: THerMal FLAG
    requires: null
    text: |-
        <p>Flag controlling the calculation of thermal quantities.

        <ul>
        <li>When <b>thmflag</b> == 1, the code will compute, using the histogram method:
        <ul>
        <li> the normalized phonon DOS </li>
        <li> the phonon internal energy, free energy,
               entropy, constant volume heat capacity
               as a function of the temperature </li>
        <li> the Debye-Waller factors (tensors) for
               each atom, as a function of the temperature</li>
        <li> the mean-square velocity tensor for each atom, as a function of temperature </li>
        <li> the "average frequency"
               as a function of the temperature
        </ul> </li>
        <li>When <b>thmflag</b> == 2, all the phonon frequencies for the
        q points in the second grid are printed. </li>

        <li>When <b>thmflag</b> == 3, 5 or 7, the thermal corrections to the electronic eigenvalues are calculated.
        If <b>thmflag</b>==3, the list of phonon wavevector from the first list is used (with equal weight for all wavevectors in this list),
        while if <b>thmflag</b>==5 or 7, the first grid of wavevectors is used,
        possibly folded to the irreducible Brillouin Zone if symmetry operations are present,
        or if they are recomputed (this happens for <b>thmflag</b>==7).</li>
        <li>When <b>thmflag</b> == 4 or 6, the temperature broadening (electron lifetime) of the electronic eigenvalues is calculated.
        If <b>thmflag</b>==4, the list of phonon wavevector from the first list is used (with equal weight for all wavevectors in this list),
        while if <b>thmflag</b>==6, the first grid of wavevectors is used, possibly folded to the irreducible Brillouin Zone
        if symmetry operations are present or if they are recomputed (this happens for <b>thmflag</b>==8).</li>
        </ul>
        WARNING: The use of symmetries for the temperature dependence of the eigenenergies is tricky ! It can only be valid
         for the  k points that respect the symmetries (i.e. the Gamma point), provided one also averages over the
        degenerate states.
        <br>

        <p>
        Input variables that may be needed if this flag is activated:
        [[anaddb:dostol]], [[anaddb:nchan]], [[anaddb:ntemper]], [[anaddb:temperinc]], [[anaddb:tempermin]],
        as well as the wavevector grid number 2 definition,  [[anaddb:ng2qpt]], [[anaddb:ngrids]], [[anaddb:q2shft]].
    topics: Temperature_compulsory
    varset: anaddb
    vartype: integer
- !variable
    abivarname: thmtol@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.05
    dimensions: scalar
    excludes: null
    mnemonics: THerModynamic TOLerance
    requires: null
    text: |-
        <p>The relative tolerance on the thermodynamical functions
        This number will determine when the series of channel widths
        with which the DOS is calculated can be stopped, i.e.
        the mean of the relative change going from one grid
        to the next bigger is smaller than <b>thmtol</b>.
    topics: Temperature_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: timopt
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[SEQUENTIAL]]': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: TIMing OPTion
    requires: null
    text: |-
        <p>
         This input variable allows to modulate the use of the timing routines.
        </p>
        <p>
         If 0 =&gt; as soon as possible, suppresses all calls to timing routines
         <br />
         If 1 =&gt; usual timing behaviour, with short analysis, appropriate
        for sequential execution
         <br />
         If 2 =&gt; close to [[timopt]]=1, except that the analysis routine
        does not time the timer, appropriate for parallel execution.
         <br />
         If 3 =&gt; close to [[timopt]]=1, except that the different parts of the lobpcg routine are timed in detail.
         <br />
         If 4 =&gt; close to [[timopt]]=1, except that the different parts of the lobpcg routine are timed in detail.
        A different splitting of lobpcg than for [[timopt]]=-3 is provided.
         <br />
         If -1 =&gt; a full analysis of timings is delivered
         <br />
         If -2 =&gt; a full analysis of timings is delivered,
        except timing the timer
         <br />
         If -3 =&gt; a full analysis of timings is delivered, including the detailed timing of the different parts of the lobpcg routine.
        (this takes time, and is discouraged for too small runs - the timing would take more time than the run !). The timer is timed.
         <br />
         If -4 =&gt; a full analysis of timings is delivered, including the detailed timing of the different parts of the lobpcg routine.
        A different splitting of lobpcg than for [[timopt]]=-3 is provided
        (this takes time, and is discouraged for too small runs - the timing would take more time than the run !). The timer is timed.
        The sum of the independent parts is closer to 100% than for [[timopt]]=-3.
        </p>
    topics: Control_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: tl_nprccg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: TaiL maximum Number of PReConditionner Conjugate Gradient iterations
    requires: null
    text: |-
        <p>
         This variable is similar to [[wvl_nprccg]]
         but for the preconditionner iterations during the tail
        corrections (see [[tl_radius]]
         </a>
         ).

        TO BE IMPROVED : all tl_* and wvl_* variables should contain a link to a tutorial, David Waroquiers 090831.
        </p>
    topics: Wavelets_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: tl_radius
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: TaiL expansion RADIUS
    requires: null
    text: |-
        <p>
         In the wavelet computation case, the linkage between the grid and the
        free boundary conditions can be smoothed using an exponential
        decay. This means a correction on the energy at the end on each
        wavefunction optimisation run. If this parameter is set to zero,
        no tail computation is done. On the contrary, put it to a
        positive value makes the tail correction available. The value
        correspond to a length in atomic units being the spacial expansion
        with the exponential decay around the grid.
        </p>
    topics: Wavelets_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: tnons
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    - '[[nsym]]'
    excludes: null
    mnemonics: Translation NON-Symmorphic vectors
    requires: null
    text: |-
        <p>
         Gives the (nonsymmorphic) translation
        vectors associated with the symmetries expressed
        in "[[symrel]]".
         <br />
         These may all be 0, or may be fractional (nonprimitive)
        translations expressed relative to the real space
        primitive translations (so, using the "reduced" system
        of coordinates, see "[[xred]]").
        If all elements of the space
        group leave 0 0 0 invariant, then these are all 0.
         <br />
         When the symmetry finder is used (see [[nsym]]), [[tnons]]
        is computed automatically.
        </p>
    topics: crystal_useful
    varset: basic
    vartype: real
- !variable
    abivarname: toldfe
    characteristics:
    - '[[ENERGY]]'
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldff]]) or specified([[tolrff]]) or specified([[tolvrs]])
    mnemonics: TOLerance on the DiFference of total Energy
    requires: null
    text: |-
        <p>
         Sets a tolerance for absolute differences
        of total energy that, reached TWICE successively,
        will cause one SCF cycle to stop (and ions to be moved).
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[toldfe]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
         <br />
         Because of machine precision, it is not worth to try
        to obtain differences in energy that are smaller
        than about 1.0d-12 of the total energy.
        To get accurate stresses may be quite demanding.
         <br />
         When the geometry is optimized (relaxation of atomic positions or primitive vectors), the use of
        [[toldfe]] is to be avoided. The use of [[toldff]] or
        [[tolrff]] is by far preferable, in order to have a handle on the
        geometry characteristics. When all forces vanish by symmetry (e.g. optimization of the lattice parameters
        of a high-symmetry crystal), then place [[toldfe]] to 1.0d-12, or use (better) [[tolvrs]].
         <br />
        Since [[toldfe]], [[toldff]], [[tolrff]], [[tolvrs]] and [[tolwfr]] are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    topics: SCFControl_basic
    varset: basic
    vartype: real
- !variable
    abivarname: toldff
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldfe]]) or specified([[tolrff]]) or specified([[tolvrs]])
    mnemonics: TOLerance on the DiFference of Forces
    requires: null
    text: |-
        <p>
         Sets a tolerance for differences of forces
        (in hartree/Bohr) that, reached TWICE successively,
        will cause one SCF cycle to stop (and ions to be moved).
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
        This tolerance applies to any particular cartesian
        component of any atom, INCLUDING fixed ones.
        This is to be used when trying to equilibrate a
        structure to its lowest energy configuration ([[ionmov]]=2),
        or in case of molecular dynamics ([[ionmov]]=1)
         <br />
         A value ten times smaller
        than [[tolmxf]] is suggested (for example 5.0d-6 hartree/Bohr).
         <br />
         This stopping criterion is not allowed for RF calculations.
         <br />
        Since [[toldfe]], [[toldff]], [[tolrff]], [[tolvrs]] and [[tolwfr]] are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    topics: SCFControl_basic, ForcesStresses_basic
    varset: basic
    vartype: real
- !variable
    abivarname: tolerance@optic
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.d-3 Ha
    dimensions: scalar
    excludes: null
    mnemonics: TOLERANCE
    requires: null
    text: |-
        When energy denominators are smaller than <b>tolerance</b>, the term
          is discarded from the sum.
    topics: Optic_basic
    varset: optic
    vartype: real
- !variable
    abivarname: tolimg
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 5.0E-5
    dimensions: scalar
    excludes: null
    mnemonics: TOLerance on the mean total energy for IMaGes
    requires: null
    text: |-
        <p>
         Sets a maximal absolute energy tolerance (in hartree, averaged over dynamic images)
        below which iterations on images (the one governed by the [[ntimimage]]
         input variable) will stop.
         <br />
         This is to be used when trying to optimize a
        population of structures to their lowest energy configuration,
        taking into account the particular algorithm defined by [[imgmov]]
         <br />
         A value of about 5.0d-5 hartree or smaller
        is suggested (this corresponds to about 3.7d-7 eV).
         <br />
         No meaning for RF calculations.
        </p>
    topics: TransPath_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: tolmxde
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: TOLerance on the MaXimal Difference in Energy
    requires: null
    text: |-
        <p>
         Sets a maximal difference in energy with respect to the
          two previous steps below which
        BFGS structural relaxation iterations will stop.
         <br />
         A value of about 0.0005 eV/atom or smaller is suggested.
         <br />
         In order to use tolmxde, you should explicitly set tolmxf to 0.0.
         <br />
         No meaning for RF calculations.
        </p>
    topics: GeoOpt_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: tolmxf
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5.0E-5
    dimensions: scalar
    excludes: null
    mnemonics: TOLerance on the MaXimal Force
    requires: null
    text: |-
        <p>
         Sets a maximal absolute force tolerance
        (in hartree/Bohr) below which
        BFGS structural relaxation iterations will stop.
         <br />
         Can also control tolerance on stresses, when [[optcell]]
         /=0,
        using the conversion factor [[strfact]].
        This tolerance applies to any particular cartesian
        component of any atom, excluding fixed ones.
        See the parameter [[ionmov]].
         <br />
         This is to be used when trying to equilibrate a
        structure to its lowest energy configuration ( [[ionmov]]
         =2).
         <br />
         A value of about 5.0d-5 hartree/Bohr or smaller
        is suggested (this corresponds to about 2.5d-3 eV/Angstrom).
         <br />
         No meaning for RF calculations.
        </p>
    topics: GeoOpt_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: tolrde
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.005
    dimensions: scalar
    excludes: null
    mnemonics: TOLerance on the Relative Difference of Eigenenergies
    requires: null
    text: |-
        <p>
         Sets a tolerance for the ratio of differences of eigenenergies
        in the line minimisation conjugate-gradient algorithm. It compares the
        decrease of the eigenenergy due to the last line minimisation, with the
        one observed for the first line minimisation.
        When the ratio is lower than [[tolrde]],
        the next line minimisations are skipped.
         <br />
         The number of line minimisations is limited by
        [[nline]] anyhow.
         <br />
         This stopping criterion is present for both GS and RF calculations.
        In RF calculations, [[tolrde]] is actually doubled before comparing with the above-mentioned
        ratio, for historical reasons.
        </p>
    topics: SCFControl_expert
    varset: dev
    vartype: real
- !variable
    abivarname: tolrff
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldfe]]) or specified([[toldff]]) or specified([[tolvrs]])'
    mnemonics: TOLerance on the Relative diFference of Forces
    requires: null
    text: |-
        <p>
         Sets a tolerance for the ratio of differences of forces
        (in hartree/Bohr) to maximum force, that, reached TWICE successively,
        will cause one SCF cycle to stop (and ions to be moved) : diffor &lt; tolrff * maxfor.
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
        This tolerance applies to any particular cartesian
        component of any atom, INCLUDING fixed ones.
        This is to be used when trying to equilibrate a
        structure to its lowest energy configuration ([[ionmov]]=2),
        or in case of molecular dynamics ([[ionmov]]=1)
         <br />
         A value of 0.02 is suggested.
         <br />
         This stopping criterion is not allowed for RF calculations.
         <br />
         Since [[toldfe]], [[toldff]], [[tolrff]], [[tolvrs]] and [[tolwfr]] are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    topics: SCFControl_basic, ForcesStresses_basic
    varset: basic
    vartype: real
- !variable
    abivarname: tolsym
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-8
    dimensions: scalar
    excludes: null
    mnemonics: TOLERANCE for SYMmetries
    requires: null
    text: |-
        <p>
         Gives the tolerance on the atomic positions (reduced coordinates), primitive
        vectors, or magnetization, to be considered equivalent, thanks to symmetry operations.
        This is used in the recognition of the set of symmetries of the system,
        or the application of the symmetry operations to generate from a reduced set of atoms,
        the full set of atoms. Note that a value larger than 0.01 is considered to be unacceptable.
         <br />
         Note : ABINIT needs the atomic positions to be symmmetric to each others within 1.e-8 .
        If [[tolsym]] is set to a larger value than 1.e-8, then the input atomic coordinates
        will be automatically symmetrized by the symmetry operations that will have been found.
        </p>
    topics: crystal_useful
    varset: geo
    vartype: real
- !variable
    abivarname: tolvrs
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldfe]]) or specified([[toldff]]) or specified([[tolrff]])'
    mnemonics: TOLerance on the potential V(r) ReSidual
    requires: null
    text: |-
        <p>
         Sets a tolerance for potential
        residual that, when reached, will cause one SCF cycle
        to stop (and ions to be moved).
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
         <br />
         To get accurate stresses may be quite demanding. For simple materials with internal positions determined by symmetries,
         a value of [[tolvrs]]=10^-12 empirically leads to a very approximate 10^-6 atomic unit accuracy for the optimized lattice parameter.
        </p>
        <p>
         Additional explanation : the residual of the potential is the difference between the
        input potential and the output potential, when the latter is obtained from the density
        determined from the eigenfunctions of the input potential. When the self-consistency
        loop is achieved, both input and output potentials must be equal, and the residual
        of the potential must be zero. The tolerance on the
        potential residual is imposed by first subtracting the mean of the residual of the potential
        (or the trace of the potential matrix, if the system is spin-polarized),
        then summing the square of this function over all FFT grid points. The result should be
        lower than [[tolvrs]].
         <br />
        Since [[toldfe]], [[toldff]], [[tolrff]], [[tolvrs]] and [[tolwfr]] are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    topics: SCFControl_basic
    varset: basic
    vartype: real
- !variable
    abivarname: tolwfr
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: specified([[toldfe]]) or specified([[toldff]]) or specified([[tolrff]]) or specified([[tolvrs]])
    mnemonics: TOLerance on WaveFunction squared Residual
    requires: null
    text: |-
        <p>
         The signification of this tolerance depends on
        the basis set. In plane waves, it gives a convergence tolerance for the
        largest squared "residual" (defined below) for any
        given band.  The squared residual is:
         <br />
         <pre>
          &lt; nk|(H-E)<sup>2</sup>|nk &gt;,    E = &lt; nk|H|nk &gt;
         </pre>
         <br />
         which clearly is nonnegative and goes to 0 as
        the iterations converge to an eigenstate.
        With the squared residual expressed in
        Hartrees
         <sup>
          2
         </sup>
         (Hartrees squared), the largest squared
        residual (called residm) encountered over all bands
        and k points must be less than [[tolwfr]] for iterations
        to halt due to successful convergence.
         <br />
         Note that if [[iscf]]&gt;0, this criterion should be replaced
        by those based on [[toldfe]] (preferred for [[ionmov]]==0),
        [[toldff]]
        [[tolrff]] (preferred for [[ionmov]]/=0), or
        [[tolvrs]] (preferred for theoretical reasons!).
         <br />
         When [[tolwfr]] is 0.0, this criterion is ignored,
        and a finite value of [[toldfe]], [[toldff]]
        or [[tolvrs]] must be specified.
        This also imposes a restriction
        on taking an ion step; ion steps are not permitted
        unless the largest squared residual is less than
        [[tolwfr]], ensuring accurate forces.
         <br />
         To get accurate stresses may be quite demanding.
         <br />
         Note that the preparatory GS calculations
        before a RF calculations must be highly converged.
         <br />
         Typical values for these preparatory runs are [[tolwfr]]
        between 1.0d-16 and 1.0d-22.
        </p>
        <p>
         Note that [[tolwfr]] is often used in the test cases, but this is
         <em>
          tolwfr
         </em>
         purely for historical reasons :
        except when [[iscf]]&lt;0, other critera
        should be used.
        </p>
        <p>
         In the wavelet case (see [[usewvl]] =
        1), this criterion is the favoured one. It is based on the
        norm 2 of the gradient of the wavefunctions. Typical values
        range from 5*10
         <sup>
          -4
         </sup>
         to 5*10
         <sup>
          -5
         </sup>
         .
        </p>
        <br />
        Since [[toldfe]], [[toldff]], [[tolrff]], [[tolvrs]] and [[tolwfr]] are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
    topics: SCFControl_basic
    varset: basic
    vartype: real
- !variable
    abivarname: tphysel
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: Temperature (PHYSical) of the ELectrons
    requires: null
    text: |-
        <p>
         Gives, in Hartree, the physical temperature of the
        system, in case [[occopt]]=4, 5, 6, or 7.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics
        (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
        One has to specify an independent broadening [[tsmear]].
        The combination of the two parameters
        [[tphysel]] and [[tsmear]] is described
        in a paper by M. Verstraete and X. Gonze, Phys. Rev. B 65, 035111 (2002).
        Note that the signification of the entropy is modified with respect
        to the usual entropy. The choice has been made to use
        [[tsmear]] as a prefactor of the entropy,
        to define the entropy contribution to the free energy.
        </p>
    topics: BandOcc_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: tsmear
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    dimensions: scalar
    excludes: null
    mnemonics: Temperature of SMEARing
    requires: null
    text: |-
        <p>
         Gives the broadening of occupation
        numbers [[occ]], in the metallic cases
        ([[occopt]]=3, 4, 5, 6 and 7).
        Can be specified in Ha (the default), eV, Ry, or Kelvin, since
        [[tsmear]] has the
        '[[ENERGY]]' characteristics
        (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
         <br />
         Default is 0.01 Ha. This should be OK using gaussian like smearings (occopt 4,5,6,7) for a free-electron
         metal like Al. For d-band metals, you may need to use less.
         <br />
         Always check the convergence of the calculation
        with respect to this parameter, and simultaneously,
        with respect to the sampling of k-points (see [[nkpt]])
         <br />
         If [[occopt]]=3, [[tsmear]] is the
        physical temperature, as the broadening is based on Fermi-Dirac statistics.
        However,
        if [[occopt]]=4, 5, 6, or 7,
        the broadening is not based on Fermi-Dirac statistics, and
        [[tsmear]] is only a convergence parameter. It is still possible
        to define a physical temperature, thanks to the input variable
        [[tphysel]]. See the paper
        by M. Verstraete and X. Gonze, Phys. Rev. B (2002).
        </p>
    topics: BandOcc_basic, STM_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: typat
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[natom]]==1': 1
        defaultval: null
    dimensions: !valuewithconditions
        '[[natrd]]<[[natom]]':
        - 3
        - '[[natrd]]'
        defaultval:
        - 3
        - '[[natom]]'
    excludes: null
    mnemonics: TYPe of AToms
    requires: null
    text: |-
        <p>
         Array giving an integer label to every atom in the unit
        cell to denote its type.
         <br />
         The different types of atoms
        are constructed from the pseudopotential files.
        There are at most [[ntypat]] types of atoms.
         <br />
         As an example, for BaTiO3, where the pseudopotential for Ba is number 1,
        the one of Ti is number 2, and the one of O is number 3, the actual
        value of the [[typat]] array might be :
         <pre>
          typat 1 2 3 3 3
         </pre>
         <br />
         The array [[typat]] has to agree with the actual locations
        of atoms given in [[xred]] , [[xcart]] or
        [[xangst]], and the input
        of pseudopotentials has to be ordered to agree with the
        atoms identified in [[typat]].
         <br />
         The nuclear charge of the
        elements, given by the array [[znucl]], also must agree with
        the type of atoms designated in "[[typat]]".
         <br />
         The array [[typat]] is
        not constrained to be increasing. An
        internal representation of the list of atoms,
        deep in the code (array atindx), groups the atoms of same type
        together. This should be transparent to the
        user, while keeping efficiency.
        </p>
    topics: crystal_basic, AtomTypes_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: ucrpa
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: calculation of the screened interaction U with the Constrained RPA method
    requires: '[[nspinor]] == 1'
    text: |-
        <p>
         When equal to one or two, this variable allows for the calculation of U with the cRPA method.
        An explicit test is shown in automatic tests v7/t23-t24-t25 and in v7/t68-t69.
        The present implementation is parallelized (as for usual GW calculations), use symetry over k-points only for calculations involving one correlated atom,
        and can be use when correlated bands are entangled or not.
        The constrained calculation of the polarisability can be done by eliminating
        transition betweens correlated bands (and not orbitals) with the variable [[ucrpa_bands]].
        </p>
        <p>
         For [[ucrpa]] = 1, two solutions are possible. The first one is to specify
        (with the variable [[ucrpa_bands]]) the bands to exclude from the polarisability calculation.
        The second solution is to provide an energy window (with the variable [[ucrpa_window]]). The electronic transitions
        inside this window will not be taken into account in
        the polarisability calculation.
        </p>
        <p>
         For [[ucrpa]] = 2, the ucrpa_bands should be equal to the [[dmftbandi]] and [[dmftbandf]]
        values, and the polarisability of the correlated subspace
        is constructed with a band and k-point dependent weight.
        </p>
        <p>
        The implementation is restricted to the case of [[nspinor]] = 1 (collinear case).
        </p>
        <p>
        A short presentation of the method and some aspect of the implementation can be found in Section II and Appendix A of
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.89.125110">
          B. Amadon, T. Applencourt and F. Bruneval Phys. Rev. B 89, 125110 (2014)
         </a>
         .
        </p>
        <p>
        </p>
    topics: CRPA_compulsory
    varset: gw
    vartype: integer
- !variable
    abivarname: ucrpa_bands
    characteristics: null
    commentdefault: That is, the default includes no band.
    commentdims: null
    defaultval:
    - -1
    - -1
    dimensions:
    - 2
    excludes: null
    mnemonics: For the calculation of U with the Constrained RPA method, gives correlated BANDS
    requires: null
    text: |-
        <p>
         Gives the first and last correlated bands for the cRPA calculation of the polarisability.
        </p>
        <p>
        </p>
    topics: CRPA_basic
    varset: gw
    vartype: integer
- !variable
    abivarname: ucrpa_window
    characteristics: null
    commentdefault: That is, the energy window is empty by default.
    commentdims: null
    defaultval:
    - -1
    - -1
    dimensions:
    - 2
    excludes: null
    mnemonics: For the calculation of U with the Constrained RPA method, gives energy WINDOW
    requires: null
    text: |-
        <p>
         Specify a window of energy for the cRPA calculation of the polarisability.
        The transition inside this window will not be taken into account in the constrained polarisabilty calculations.
        </p>
        The lower bound and the upper bound energies must be specified (two real numbers) with respect to the position of the Fermi level.
        <p>
        </p>
    topics: CRPA_basic
    varset: gw
    vartype: real
- !variable
    abivarname: udtset
    characteristics: null
    commentdefault: It is not used when it is not defined
    commentdims: null
    defaultval: null
    dimensions:
    - 2
    excludes: null
    mnemonics: Upper limit on DaTa SETs
    requires: null
    text: |-
        <p>
         Used to define the set of indices in the multi-data set
        mode, when a double loop is needed (see later).
         <br />
         The values of [[udtset]](1) must be between 1 and 999,
        the values of [[udtset]](2) must be between 1 and 9, and their
        product must be equal to [[ndtset]].
         <br />
         The values of [[jdtset]] are obtained by
        looping on the two indices defined by [[udtset]](1) and  [[udtset]](2) as follows :
         <pre>
          do i1=1,intarr(1)
           do i2=1,intarr(2)
            idtset=idtset+1
            dtsets(idtset)%jdtset=i1*10+i2
           end do
          end do
         </pre>
         So, [[udtset]](2) sets the largest value for the unity digit, that varies between 1 and [[udtset]](2).
         <br />
         If [[udtset]] is used, the input variable [[jdtset]] cannot be used.
        </p>
    topics: multidtset_basic
    varset: basic
    vartype: integer
- !variable
    abivarname: upawu
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: value of U for PAW+U
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    text: |-
        <p>
         Gives the value of the
        screened coulomb interaction between correlated electrons corresponding
        to [[lpawu]] for each species.
         <br />
         In the case where
        [[lpawu]]
        =-1, the value is not used.
         <br />
         In the case of a GW calculation, the U interaction defined by [[upawu]] will be REMOVED from the self energy.
        In particular, for G0 W0 calculations (perturbative calculations), the energy eigenvalues obtained
        after an underlying DFT+U calculation will be
         <br />
         E_GW = E_DFT+U + &lt; phi | Self-energy - U | phi&gt;
         <br />
         Actually, in order to perform a GW @ DFT+U calculation, one should define the same value of U in the self-energy calculation,
        than the one defined in the DFT calculation.
        The easiest is actually to define the value of U for the whole set of calculations (for the different datasets),
        including the screening, even if the U value does not play explicitly a role in the computation of the latter (well, the input
        wavefunctions will be different anyhow).
         <br />
         It is possible to perform calculations of the type GW+U_prime @ DFT+U , so keeping a U interaction  (usually smaller than the initial U)
        in the GW calculation, by defining a smaller U than the one used in the DFT calculation. This value will be subtracted in the GW correction calculation,
        as outlined above.
         <br />
         Explicitly, in order to do a calculation of a material with a DFT U value of 7.5 eV, followed by a GW calculation where there is a residual
        U value of 2 eV, one has to define :
         <pre>
          upawu1   7.5 eV   ! This is for the DFT calculation
        ...
        optdriver4  4
        upawu4   5.5 eV   ! This is for the screening calculation
         </pre>
        </p>
    topics: DFT+U_compulsory
    varset: paw
    vartype: real
- !variable
    abivarname: use_gemm_nonlop
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: because it is not usually worth using it unless bandpp is large and it requires additional memory
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE the GEMM routine for the application of the NON-Local OPerator
    requires: null
    text: |-
        <p>
         This keyword tells abinit to use a BLAS routine to speed up the computation of the non-local operator. This requires the precomputation of a large matrix, and has a significant memory overhead. In exchange, it provides improved performance when used on several bands at once (Chebyshev or LOBPCG algorithm with [[bandpp]]
        <p>
         The memory overhead is proportional to the number of atoms, the number of plane waves, and the number of projectors per atom. It can be mitigated by distributing the array with
         [[npfft]]
        </p>
        <p>
         The performance depends crucially on having a good BLAS installed. Provided the BLAS supports OpenMP, this option also yields very good scaling for the nonlocal operator.
        </p>
    topics: parallelism_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: use_gpu_cuda
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[optdriver]]==0 and [[CUDA]]': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: activate USE of GPU accelerators with CUDA (nvidia)
    requires: null
    text: |-
        <p>
         Only available if ABINIT executable has been compiled with cuda nvcc compiler.
         <br />
         This parameter activates the use of NVidia graphic accelerators (GPU) if present.
         <br />
         If [[use_gpu_cuda]] = 1, some parts of the computation are transmitted to the GPUs.
         <br />
         If [[use_gpu_cuda]] = 0, no computation is done on GPUs, even if present.
         <br />
         <br />
         Note that, while running ABINIT on GPUs, it is recommended to use MAGMA external library
        (i.e. Lapack on GPUs). The latter is activated during compilation stage (see "configure"
        step of ABINIT compilation process). If MAGMA is not used, ABINIT performances on GPUs
        can be poor.
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: integer
- !variable
    abivarname: use_k_fine@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE K-grid FINEr than the coarse k-grid
    requires: null
    text: |-
        <p>When set, [[anaddb:kptrlatt_fine]] is suggested to be given. For the present version, both eigenvalues (densergridGKK, obtained from mrggkk with only the GS WFK file) and electronic velocities(GKK files from DDK calculation) are needed. Note that the coarse k-grid must be a subset of the fine k-grid.
    topics: PhononWidth_expert
    varset: anaddb
    vartype: integer
- !variable
    abivarname: use_nonscf_gkk
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: Default is 0 for the moment. Do not use non-scf method.
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE NON-SCF calculation of GKK matrix elements (electron phonon)
    requires: null
    text: |-
        <p>
         When this flag is activated during a phonon calculation with abinit, all of the perturbations are cycled through, but only the symmetry-irreducible ones are calculated self-consistently. For the others the perturbed density is rotated by the appropriate symop and the gkk matrix elements are calculated non-self-consistently. As they do not depend on the perturbed wave functions, they are correct from the first iteration, and nstep is set to 1 for those perturbations. Note that the resulting 1DEN files are simply the rotate/symmetric ones and that the resulting 1WF files are garbage (completely unconverged) except the matrix elements in the header (equivalent to GKK files, but please use the latter much smaller files for el-ph calculations). The new default behavior with [[use_nonscf_gkk]] = 1 should be transparent for the user, with the same output files but a much quicker execution.
        </p>
        <p>
         Caveat: Note that very tight convergence of ground state and phonon calculations is necessary to get good GKK matrix elements! [[tolwfr]] = 1.e-24 or so is recommended everywhere. There may be problems using use_nonscf_gkk = 1 with non-symmorphic symmetries - please check (at least) that lifetimes for phonons go to 0 for acoustic modes at Gamma.
        </p>
    topics: ElPhonInt_useful
    varset: dev
    vartype: integer
- !variable
    abivarname: use_slk
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE ScaLapacK
    requires: null
    text: |-
        <p>
         If set to 1, enable the use of ScaLapack within LOBPCG.
        </p>
    topics: parallelism_expert
    varset: paral
    vartype: integer
- !variable
    abivarname: usedmatpu
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE of an initial Density MATrix in Paw+U
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    text: |-
        <p>
         When [[usedmatpu]]/=0, an initial density matrix (given by [[dmatpawu]]
        keyword) is used and kept fixed during the first ABS([[usedmatpu]]) SCF steps.
         <br />
         This starting value of the density matrix can be useful to find the correct ground state.
        Within LDA+U formalism, finding the minimal energy of the system is tricky; thus it is advised to test several values
        of the initial density matrix.
         <br />
         Note also that the density matrix has to respect some symmetry rules determined by the space group.
        If the symmetry is not respected in the input, the matrix is however automatically symmetrised.
         <br />
         <br />
         The sign of [[usedmatpu]] has influence only when [[ionmov]]/=0 (dynamics or relaxation):
         <br />
         - When [[usedmatpu]]&gt;0, the density matrix is kept constant only at first ionic step
         <br />
         - When [[usedmatpu]]&lt;0, the density matrix is kept constant at each ionic step
         <br />
        </p>
    topics: DFT+U_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: usedmft
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE Dynamical Mean Field Theory
    requires: null
    text: |-
        <p>
         If set to 1, enable the use of DFT+DMFT, see in particular the important variables
        [[dmft_solv]],
        [[dmftbandi]],
        [[dmftbandf]],
        [[dmft_nwli]],
        [[dmft_nwlo]],
        [[dmft_tollc]],
        [[dmft_tolfreq]],
        and [[dmft_iter]].
        </p>
        <p>
         The current implementation uses Wannier functions obtained from
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">
          projected local orbitals
         </a>
         as correlated orbitals (see [[dmftbandi]]  and [[dmftbandf]] input variables to define them).
        </p>
        <p>
         The Green functions are computed on a mesh of linear Matsubara frequencies. However, most of the code uses logarithmic Matsubara grid to lower the computational cost. Both [[dmft_nwli]] and [[dmft_nwlo]] are thus convergence parameters.
        </p>
        <p>
         DMFT is currently available for collinear ([[nspinor]]=1) polarized or unpolarized calculations ([[nspden]]=[[nsppol]]=2 or [[nspden]]=[[nsppol]]=1)
        and for non collinear calculations ([[nspinor]]=2,[[nspden]]=4,[[nsppol]]=1). However it is not yet available
        for collinear antiferromagnetic calculations  ([[nspden]]=2,[[nsppol]]=1) and non collinear non magnetic calculations ([[nspden]]=1, [[nsppol]]=1,[[nspinor]]=2).
        CTQMC calculations ([[dmft_solv]]=5) are not yet possible if [[nspinor]]=2.
        </p>
        <p>
         Only static calculations without relaxation or dynamics are possible (forces and stress are not computed in the scheme: so the computed values should NOT be trusted).
        </p>
        <p>
         When correlated density matrices are diagonal, all values of [[upawu]] and [[jpawu]]
         are possible. If the correlated density matrices are non diagonal, only [[jpawu]] = 0 is implemented.
        </p>
        <p>
         Relevant direct output quantities from
        converged DMFT calculations are total energy and occupation of correlated orbitals. For Hubbard I calculation ([[dmft_solv]]=2), total and partial spectral
        functions can be obtained with prtdos=1 and can be found in files OUTSpFunc* (where OUT is the root for
        output files). For CTQMC calculations ([[dmft_solv]]=5), imaginary time impurity Green function are output of the calculations and can be used to produce
        spectral function using an external Maximum Entropy Code.
        </p>
        <p>
         A typical DFT+DMFT calculation involves two runs. First, a DFT calculation is fully converged (even unoccupied wavefunctions have to be converged).
        Then, the DFT+DMFT calculation is started using DFT wavefunctions or density files.  As DFT+DMFT calculations (with CTQMC) are computationnally
        expensive, it is convenient to use prtden=-1, to write DEN file at each DFT iteration, in order to be able to restart the calculation easily.
        </p>
        <p>
         For details of the implementation see,
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">
          B. Amadon, F. Lechermann, A. Georges, F.  Jollet, T. O.  Wehling, and A. I.  Lichtenstein, Phys. Rev. B 77(20), (2008)
         </a>
         , for Wannier functions and
          B. Amadon, J. Phys.: Condens. Matter 24 075604 (2012) (doi:10.1088/0953-8984/24/7/075604),
        for self-consistency and Hubbard I implementation.

        If [[usedmft]]=1 and [[nbandkss]]/=0, then, the DFT+DMFT calculation is not done and only projections are computed at the end
        of the calculation. They can be used by an external code or used to compute the screened interaction (see variable [[ucrpa]]).
        </p>
    topics: DMFT_compulsory
    varset: dev
    vartype: integer
- !variable
    abivarname: useexexch
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE of EXact EXCHange
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         When [[useexexch]]=1, the hybrid functional PBE0 is used
        in PAW, inside PAW spheres only, and only for correlated orbitals given by
        [[lexexch]]. To change the ratio of exact exchange, see also [[exchmix]].
        </p>
    topics: xc_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: usefock
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE FOCK exact exchange
    requires: null
    text: |-
        <p>
         This internal variable is automatically set to 1 when the value of [[ixc]]  refers to an Hartree-Fock calculation or hybrid functionals.
         <ul>
          <li>
           0 =&gt; No use of exact exchange.
          </li>
          <li>
           1 =&gt; exact exchange is required for the calculation.
          </li>
         </ul>
        </p>
    topics: Hybrids_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: usekden
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE Kinetic energy DENsity
    requires: null
    text: |-
        <p>
         If [[usekden]]=1 the kinetic energy density will be computed during the self-consistency loop,
        in a way similar to the computation of the density.
        This is needed if a meta-GGA is to be used as XC functional. Otherwise ([[usekden]]=0), the kinetic energy
        density is not computed during the self-consistency loop.
        </p>
    topics: xc_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: usepaw
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    dimensions: scalar
    excludes: null
    mnemonics: USE Projector Augmented Waves method
    requires: null
    text: |-
        <p>
         This variable is determined by the pseudopotentials files.
        PAW calculations (see [[lesson:paw1]]) can only
        be performed with PAW atomic data input files, while
        pseudopotential calculations are performed in ABINIT with norm-conserving
        pseudopotential input files. Most functionalities in ABINIT are available
        with either type of calculation.
        </p>
    topics: PAW_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: usepawu
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE PAW+U (spherical part)
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         Must be non-zero if a DFT+U calculation is done, or if a GW calculation following a DFT+U calculation is done (important !).
         <ul>
          <li>
           If set to 0, the LDA+U method is not used.
           <br />
          </li>
          <li>
           If set to 1 or 2, the LDA+U method (cf [1])  is used. The full rotationally invariant
        formulation is used (see Eq. (3) of Ref [2]) for the interaction term of the energy.
        Two choices are allowed concerning the double counting term:
           <br />
          </li>
          <ul>
           <li>
            If [[usepawu]]=1, the Full Localized
        Limit (FLL) (or Atomic limit) double counting is used (cf Eq. (4) of Ref.[2] or
        Eq. (8) of Ref[3]).
            <br />
           </li>
           <li>
            If [[usepawu]]=2, the Around Mean Field (AMF) double counting is used
        (cf Eq. (7) of Ref [3]). Not valid if nspinor=2.
            <br />
           </li>
          </ul>
         </ul>
         If LDA+U is activated ([[usepawu]]=1 or 2), the [[lpawu]],
        [[upawu]] and [[jpawu]] input variables are read.
         <br />
         The implementation is done inside PAW augmentation regions only (cf Ref [4]). The initial density matrix can be
        given in the input file (see  [[usedmatpu]]).
        The expression of the density matrix is chosen thanks to
        [[dmatpuopt]]. See also
         <a href="../../users/How_to_use_LDA_plus_U.txt">
          How_to_use_LDA_plus_U.txt
         </a>
         .
        for some informations.
         <br />
         In the case of a GW calculation on top of a DFT+U, the absence of definition of a U value in the self-energy
        will LEAVE the underlying U from the DFT calculation.
        Thus, the code will actually do a GW+U @ DFT+U calculation.
        Note that the screening calculation will not be affected by the presence/absence of a U value.
         <br />
         Actually, in order to perform a GW @ DFT+U calculation, one should define the same value of U in the self-energy calculation,
        than the one defined in the DFT calculation. The code will know that the interaction corresponding to that value has to be
        SUBTRACTED inside the self-energy. The easiest is actually to define the presence of U for the whole set of calculations (for the different datasets),
        including the screening, even if the U value does not play explicitly a role in the computation of the latter (well, the input
        wavefunctions will be different anyhow).
         <br />
         It is possible to perform calculations of the type GW+U_prime @ DFT+U , so keeping a smaller U interaction in the GW calculation, by subtracting
        a smaller U than the one used in the DFT calculation. See the description of the [[upawu]] input variable.
         <br />
         References:
         <br />
         [1] V. I. Anisimov, J. Zaanen, and O. K. Andersen PRB 44, 943 (1991)
         <br />
         [2] A.I. Lichtenstein, V.I. Anisimov and J. Zaanen  PRB 52, 5467 (1995)
         <br />
         [3] M. T. Czyzyk and G.  A. Sawatzky PRB 49, 14211 (1994)
         <br />
         [4] O. Bengone, M. Alouani, P. Blochl, and J. Hugel PRB 62, 16392 (2000)
         <br />
         <br />
         <br />
         Suggested acknowledgment:
         <br />
         - B. Amadon, F. Jollet and M. Torrent, Phys. Rev. B 77, 155104 (2008).
         <br />
        </p>
    topics: DFT+U_compulsory, PAW_useful, GW_useful, SelfEnergy_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: usepotzero
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE POTential ZERO
    requires: null
    text: |-
        <p>
         <ul>
          <li>
           [[usepotzero]]=0, the usual convention: the smooth potential is set to zero averarage value.
          </li>
          <li>
           [[usepotzero]]=1, the new convention: the physical potential is set to zero average value.
          </li>
          <li>
           [[usepotzero]]=2, the PWscf convention: the potential of equivalent point charges is set to zero average value (convention also valid for NC pseudopotentials).
          </li>
         </ul>
        </p>
    topics: Coulomb_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: userec
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE RECursion
    requires: null
    text: |-
        <p>
         This internal variable is set to 1 when the recursion method is
        activated (see [[tfkinfunc]]).
        </p>
    topics: Recursion_internal
    varset: internal
    vartype: integer
- !variable
    abivarname: useria
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USER Integer variable A
    requires: null
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    topics: Dev_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: userib
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USER Integer variable B
    requires: null
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    topics: Dev_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: useric
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USER Integer variable C
    requires: null
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    topics: Dev_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: userid
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USER Integer variable D
    requires: null
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    topics: Dev_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: userie
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USER Integer variable E
    requires: null
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    topics: Dev_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: userra
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: USER Real variable A
    requires: null
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    topics: Dev_expert
    varset: dev
    vartype: real
- !variable
    abivarname: userrb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: USER Real variable B
    requires: null
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    topics: Dev_expert
    varset: dev
    vartype: real
- !variable
    abivarname: userrc
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: USER Real variable C
    requires: null
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    topics: Dev_expert
    varset: dev
    vartype: real
- !variable
    abivarname: userrd
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: USER Real variable D
    requires: null
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    topics: Dev_expert
    varset: dev
    vartype: real
- !variable
    abivarname: userre
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: USER Real variable E
    requires: null
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    topics: Dev_expert
    varset: dev
    vartype: real
- !variable
    abivarname: usewvl
    characteristics: null
    commentdefault: use plane-wave basis set
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Use WaVeLet basis set
    requires: null
    text: |-
        <p>
         Used to define if the calculation is done on a
        wavelet basis set or not.
         <br />
         The values of [[usewvl]] must be 0 or 1. Putting [[usewvl]]
        to 1, makes [[icoulomb]]
        mandatory to 1. The number of band ([[nband]]) must be set manually to
        the strict number need for an isolator system (
         <i>
          i.e.
         </i>
         number of electron over two). The cut-off is not relevant in the
        wavelet case, use [[wvl_hgrid]]
        instead.
         <br />
         In wavelet case, the system must be isolated systems (molecules or
        clusters). All geometry optimization are available (see [[ionmov]], especially the geometry
        optimisation and the molecular dynamics).
         <br />
         The spin computation is not currently possible with wavelets and
        metalic systems may be slow to converge.
        </p>
    topics: Wavelets_compulsory
    varset: basic
    vartype: integer
- !variable
    abivarname: usexcnhat
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -1
    dimensions: scalar
    excludes: null
    mnemonics: USE eXchange-Correlation with NHAT (compensation charge density)
    requires: '[[usepaw]]==1'
    text: |-
        <p>
         <br />
         This flag determines how the exchange-correlation terms are computed for the pseudo-density.
         <br />
         When [[usexcnhat]]=0, exchange-correlation potential does not include the compensation charge density, i.e.
        Vxc=Vxc(tild_Ncore + tild_Nvalence).
         <br />
         When [[usexcnhat]]=1, exchange-correlation potential includes the compensation charge density, i.e.
        Vxc=Vxc(tild_Ncore + tild_Nvalence + hat_N).
         <br />
         When [[usexcnhat]]=-1,the value of [[usexcnhat]] is determined from the reading of the PAW dataset file
        (pseudopotential file). When PAW datasets with different treatment of Vxc are used in the same
        run, the code stops.
        </p>
    topics: PAW_useful
    varset: paw
    vartype: integer
- !variable
    abivarname: useylm
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[tfkinfunc]]==1': 1
        '[[usepaw]]==1': 1
        defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: USE YLM (the spherical harmonics)
    requires: null
    text: |-
        <p>
         When this flag is activated, the non-local operator is applied using an algorithm based on spherical harmonics. Non-local projectors are used with their usual form:
         <br />
         <ul>
          P
          <sub>
           lmn
          </sub>
          (r)=Y
          <sub>
           lm
          </sub>
          (r)*p
          <sub>
           ln
          </sub>
          (r)
         </ul>
         <br />
         <br />
         When [[useylm]]=0, the sum over Y_lm can be reduced to a Legendre polynomial form.
        </p>
    topics: TuningSpeed_expert
    varset: dev
    vartype: integer
- !variable
    abivarname: vaclst
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[vacnum]]'
    excludes: null
    mnemonics: VACancies LiST
    requires: null
    text: |-
        <p>
         Gives the identification number(s) of atoms
        to be subtracted from the set of atoms that are obtained
        after having rotated, translated and repeated the objects.
         <br />
         Useful to created vacancies.
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: vacnum
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: VACancies NUMber
    requires: null
    text: |-
        <p>
         Gives the number of atoms to be subtracted
        from the list of atoms after the rotations, translations
        and repetitions have been done. The list of these
        atoms is contained in [[vaclst]].
        </p>
    topics: AtomManipulator_useful
    varset: geo
    vartype: integer
- !variable
    abivarname: vacuum
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    excludes: null
    mnemonics: VACUUM identification
    requires: null
    text: |-
        <p>
         Establishes the presence (if 1) or absence (if 0) of a vacuum
        layer, along the three possible directions normal to the
        primitive axes.
        </p>
        <p>
         This information might be used to generate k-point grids,
        if [[kptopt]]=0 and neither
        [[ngkpt]] nor [[kptrlatt]]
        are defined (see explanations with the input variable
        [[prtkpt]]).
         <br />
         It will allow to select
        a zero-, one-, two- or three-dimensional
        grid of k points. The coordinate of the k points
        along vacuum directions is automatically set to zero.
        </p>
        <p>
         If [[vacuum]] is not defined, the input variable
        [[vacwidth]]
        will be used to determine automatically whether the
        distance between atoms is sufficient to have the
        presence or absence of vacuum.
        </p>
    topics: k-points_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: vacwidth
    characteristics:
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    dimensions: scalar
    excludes: null
    mnemonics: VACuum WIDTH
    requires: null
    text: |-
        <p>
         Give a minimum "projected" distance between
        atoms to be found in order to declare that there
        is some [[vacuum]] present for each of the three
        directions.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[vacwidth]] has the
        '[[LENGTH]]' characteristics.
         <br />
         The precise requirement is that a slab
        of width [[vacwidth]], delimited by two
        planes of constant reduced coordinates in the
        investigated direction, must be empty of atoms.
        </p>
    topics: k-points_expert
    varset: gstate
    vartype: real
- !variable
    abivarname: vcutgeo
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    dimensions:
    - 3
    excludes: null
    mnemonics: V (potential) CUT-off GEOmetry
    requires: '[[icutcoul]] in [1,2]'
    text: |-
        <p>
         [[vcutgeo]] is used in conjunction with [[icutcoul]]
        to specify the geometry used to truncate the Coulomb interaction, as well as the
        particular approach to be used.
        It has a meaning only for the cylindrical symmetry
        ([[icutcoul]]=1) or in the case of surfaces
        ([[icutcoul]]=2).
        For each geometry, two different definitions of the cutoff region are available
        (see Phys. Rev. B 73, 233103 and Phys. Rev. B 73, 205119 for a complete description of the methods)
        </p>
        <p>
         In Beigi method (Phys. Rev. B 73, 233103), the cutoff region is given by the Wigner-Seitz cell
        centered on the axis of the cylinder.
        The cutoff region is thus automatically defined by the unit cell and there is no need to specify
        When [[rcut]].
        </p>
        <p>
        To define a cylinder along the z-axis use the following lines.

        icutcoul 1
        vcutgeo  0 0 1
        </p>
        <p>
         Please note that Beigi method is implemented only in the case if an orthorhombic
        Bravais lattic. For hexagonal lattices, one has to use the method of Rozzi (Phys. Rev. B 73, 205119)
        In this case, the interaction is truncated in a finite cylinder.
        Contrarily to the first approach, here one has to specify both the radius of the cylinder
        with [[rcut]]
        as well as the length of the cylinder along the periodic dimension that should always be smaller
        than the extension of the Born von Karman box.
        The length of the cylinder is given in terms of the fraction of the primitive vector along the periodic direction.
        </p>
        <p>
         For example, in order to define a finite cylinder along z of radius 2.5 Bohr and length 3*R3

        icutcoul 1
        vcutgeo  0 0 -3.0 # note the minus sign
        rcut     2.5
        </p>
        <p>
         For surface calculations ([[icutcoul]]=2),
        [[vcutgeo]] is used to define the two periodic directions defining the surface.
        Also in this case two different techniques are available.
        In the method of Beigi, the (positive) non-zero components of vcutgeo define the periodic
        directions of the infinite surface. The interaction is truncated within a slab
        of width L where L is the length of the primitive vector of the lattice along the non-periodic dimension.
        For example:

        icutcoul 2
        vcutgeo 1 1 0

        It is also possible to define a finite surface by employing negative values
        For example:

        icutcoul 2
        vcutgeo -3 -2 0

        defines ....
        </p>
    topics: GWls_compulsory, Susceptibility_basic, SelfEnergy_basic
    varset: gw
    vartype: real
- !variable
    abivarname: vdw_df_acutmin
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF MINimum Angular CUT-off
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_aratio
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: |-
        vdW-DF Angle RATIO between the highest and
        lowest angles.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_damax
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    dimensions: scalar
    excludes: null
    mnemonics: 'vdW-DF Delta for Angles, MAXimum '
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_damin
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Delta for Angles, MINimum
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_dcut
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF D-mesh CUT-off
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_dratio
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    dimensions: scalar
    excludes: null
    mnemonics: |-
        vdW-DF, between the highest and
        lowest D, RATIO.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_dsoft
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Distance for SOFTening.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_gcut
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF G-space CUT-off
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to filter the vdW-DF kernel in reciprocal space.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_ndpts
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Number of D-mesh PoinTS
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_df_ngpts
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Number of G-mesh PoinTS
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_df_nqpts
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Number of Q-mesh PoinTS
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_df_nrpts
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 2048
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Number of R-PoinTS
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to define the sampling of the vdW-DF-kernel in real-space.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_df_nsmooth
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 12
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Number of SMOOTHening iterations
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to exponentially smoothen q near q0.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_df_phisoft
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1.0
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF PHI value SOFTening.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_qcut
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Q-mesh CUT-off
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_qratio
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF, between highest and lowest Q, RATIO .
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        .
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_rcut
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 100
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF Real-space CUT-off
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to define the vdW-DF kernel cut-off radius.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_rsoft
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF radius SOFTening.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_threshold
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF energy calculation THRESHOLD
    requires: '[[vdw_xc]]>0'
    text: |-
        <p>
        Sets a threshold for the energy gradient that,
        when reached, will cause the vdW-DF interactions to be calculated.
        <br />
        Adjust it to a big value (e.g. 1e12) to enable it all along the SCF
        calculation. Too small values, as well as negative values, will result
        in the vdW-DF energy contributions never being calculated.
        </p>
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_tolerance
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-13
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF global TOLERANCE.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_df_tweaks
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF TWEAKS.
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
        <b>
         <i>
          IMPORTANT NOTE: modifying this variable will likely transform the calculated energies and their gradients into garbage. You have been warned!
         </i>
        </b>
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_df_zab
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -0.8491
    dimensions: scalar
    excludes: null
    mnemonics: vdW-DF ZAB parameter
    requires: '[[vdw_xc]]>0'
    text: |-
        Used when [[vdw_xc]]&gt;0,
        as introduced in
        <a href="http://dx.doi.org/10.1103/PhysRevLett.92.246401">
         doi:10.1103/PhysRevLett.92.246401
        </a>
        .
        <br />
    topics: vdw_expert
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_nfrag
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Van Der Waals Number of interacting FRAGments
    requires: '[[vdw_xc]] in [10,11]'
    text: |-
        <p>
         The absolute value of vdw_nfrag is the number of vdW interacting
        fragments in the unit cell. As wannierization takes place in reciprocal space, the MLWF
        center positions could be translated by some lattice vector from the cell where atoms
        are placed. If [[vdw_nfrag]] &gt;= 1 then MLWFs are translated to the original
        unit cell, otherwise the program will keep the positions obtained by Wannier90. The
        later is usually correct if some atoms are located at the corners or at limiting
        faces of the unit cell.
        </p>
    topics: vdw_basic
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_supercell
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    dimensions:
    - 3
    excludes: null
    mnemonics: Van Der Waals correction from Wannier functions in SUPERCELL
    requires: '[[vdw_xc]] in [10,11]'
    text: |-
        <p>
         Set of dimensionless positive numbers which define the maximum multiples
        of the primitive translations ([[rprimd]]) in the supercell construction. Each component of vdw_supercell
        indicates the maximum number of cells along both positive or negative directions of the corresponding
        primitive vector i.e. the components of [[rprimd]]. In the case of layered
        systems for which vdW interactions occur between layers made of tightly bound atoms, the evaluation
        of vdW corrections coming from MLWFs in the same layer (fragment) must be avoided. Both a negative or
        null value for one component of [[vdw_supercell]]  will indicate that the  corresponding direction
        is normal to the layers.

        </p>
    topics: vdw_basic
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_tol
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-10
    dimensions: scalar
    excludes: null
    mnemonics: Van Der Waals TOLerance
    requires: '[[vdw_xc]]==5'
    text: |-
        <p>
         The DFT-D methods (S. Grimme approach) dispersion potentials, [[vdw_xc]]==5 or 6 or 7, include a pair potential.
        The number of pairs of atoms contributing to the potential is necessarily limited. To be included
        in the potential a pair of atom must have contribution to the energy larger than [[vdw_tol]].
        </p>
    topics: vdw_compulsory
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_tol_3bt
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: Do include the 3-body term in the correction
    commentdims: null
    defaultval: -1
    dimensions: scalar
    excludes: null
    mnemonics: Van Der Waals TOLerance for 3-Body Term
    requires: '[[vdw_xc]] == 6'
    text: |-
        Control the computation of the 3-body correction inside DFT-D3 dispersion correction (Grimme approach) to the total energy:
        <br />
        -If <b> vdw_tol_3bt</b>&lt;0, no 3-body correction.
        <br />
        -If <b> vdw_tol_3bt</b>&gt;0, the 3-body term is included with a tolerance = <b>vdw_tol_3bt</b>
        <br />
        <br />
        DFT-D3 as proposed by S. Grimme adds two contributions to the total energy in order to take into account of the dispersion:
        <br />
         <ul>
        <li>
        A pair-wise potential for which the tolerance is controlled by [[vdw_tol]]
        </li>
        <br />
        <li>A 3-body term which is obtained by summing over all triplets of atoms. Each individual contribution depends of the distances and angles between the three atoms. As it is impossible to sum over all the triplets in a periodic system, one has to define a stopping criterium which is here that an additional contribution to the energy must be higher than <b>vdw_tol_3bt</b>
        </li>
        </ul>
        The last term has been predicted to have an important effect for large molecules (see for e.g. <i> Grimme S.,  J. Chem. Phys. 132, 154104 (2010) </i>). It is however quite costly in computational time for periodic systems and seems to lead to an overestimation of lattice parameters for weakly bound systems (see for e.g. <i> Reckien W., J. Chem. Phys. 132, 154104(2010) </i>). Still, its contribution to energy, to forces and to stress is available (not planned for elastic constants, dynamical matrix and internal strains)
    topics: vdw_basic
    varset: vdw
    vartype: real
- !variable
    abivarname: vdw_typfrag
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 1
        value: '[[natom]]'
    dimensions:
    - '[[natom]]'
    excludes: null
    mnemonics: Van Der Waals TYPe of FRAGment
    requires: '[[vdw_xc]] in [10,11]'
    text: |-
        <p>
         This array defines the interacting fragments by assigning to each atom an
        integer index from 1 to
         <b>
          vdw_nfrag
         </b>
         . The ordering of [[vdw_typfrag]] is the same as
        [[typat]] or [[xcart]]. Internally each MLWF is
        assigned to a given fragment by computing the distance to the atoms. MLWFs belong to
        the same fragment as their nearest atom. The resulting set of MLWFs in each interacting fragment
        can be found in the output file in xyz format for easy visualization.
        </p>
    topics: vdw_basic
    varset: vdw
    vartype: integer
- !variable
    abivarname: vdw_xc
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Van Der Waals eXchange-Correlation functional
    requires: null
    text: |-
        <p>
         Selects a van-der-Waals density functional to
        apply the corresponding correction to the exchange-correlation energy.
        If set to zero, no correction will be applied.
         <br />
         Possible values are:
         <ul>
          <li>
           0: no correction.
          </li>
          <li>
           1: apply vdW-DF1 (DRSLL) from Dion
           <i>
            et al.
           </i>
           <br />
           <i>
            doi:10.1103/PhysRevLett.92.246401
           </i>
          </li>
          <li>
           2: apply vdw-DF2 (LMKLL) from Lee
           <i>
            et al.
           </i>
           <br />
           <i>
            arXiv:1003.5255v1
           </i>
          </li>
          <li>
           5: apply vdw-DFT-D2 as proposed by S. Grimme (adding a semi-empirical dispersion potential)
           <br />
           Available only for ground-state calculations and response functions; see [[vdw_tol]] variable
        to control convergency
           <br />
           <i>
            J. Comp. Chem. 27, 1787 (2006)
           </i>
          </li>
        <li>
           6: apply vdw-DFT-D3 as proposed by S. Grimme (refined version of DFT-D2)
           <br />
           Available only for ground-state calculations and response functions; see [[vdw_tol]] variable
        to control convergency and [[vdw_tol_3bt]] variable to include 3-body corrections
           <br />
           <i>
            J. Chem. Phys. 132, 154104 (2010)
           </i>
          </li>
           <li>
           7: apply vdw-DFT-D3(BJ) as proposed by Grimme (based on Becke-Jonhson method J. Chem. Phys. 2004-2006)
           <br />
           Available only for ground-state calculations and response functions; see [[vdw_tol]] variable
        to control convergency
           <br />
           <i>
            J. Comput. Chem. 32, 1456 (2011)
           </i>
          </li>
          <li>
           10: evaluate the vdW correlation energy from maximally localized Wannier functions, as proposed by
        P. L. Silvestrelli, also known as vdW-WF1 method.
           <br />
           <i>
            doi:10.1103/PhysRevLett.100.053002.
           </i>
           For details on this implementation please check:
           <i>
            doi:10.1016/j.cpc.2011.11.003
           </i>
           <br />
           The improvements introduced by Andrinopoulos
           <i>
            et al.
           </i>
           in
           <i>
            J. Chem. Phys. 135, 154105 (2011)
           </i>
           namely
        the amalgamation procedure, splitting of p-like MLWFs
        into
           <br />
           two s-like Wannier functions and fractional occupation of MLWFs are performed automatically.
           <br />
          </li>
          <li>
           11: evaluate the vdW correlation energy from maximally localized Wannier functions, as proposed by
        A. Ambrosetti and P. L. Silvestrelli, also known as vdW-WF2 method.
           <br />
           <i>
            doi:10.1103/PhysRevB.85.073101
           </i>
          </li>
          <li>
           14: apply DFT/vdW-QHO-WF method as proposed by Silvestrelli, which combines the quantum harmonic
        oscillator-model with localized Wannier functions.
           <br />
           <i>
            J. Chem. Phys. 139, 054106 (2013)
           </i>
           <br />
           For periodic systems a supercell approach has to be used since
           <b>
            vdw_supercell
           </b>
           is not enabled in this case.
          </li>
         </ul>
         For [[vdw_xc]]=1 and [[vdw_xc]]=2, the implementation follows the strategy devised
        in the article of Rom&aacute;n-P&eacute;rez and Soler
        (<a href="https://dx.doi.org/10.1103/PhysRevLett.103.096102">doi:10.1103/PhysRevLett.103.096102</a>)
        </p>
    topics: vdw_compulsory
    varset: vdw
    vartype: integer
- !variable
    abivarname: vel
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: It is represented internally as [[vel]](3,[[natom]],[[nimage]])
    defaultval: !multiplevalue
        number: null
        value: 0
    dimensions:
    - 3
    - '[[natom]]'
    excludes: null
    mnemonics: VELocity
    requires: '[[ionmov]] > 0'
    text: |-
        <p>
         Gives the starting velocities
        of atoms, in cartesian coordinates, in Bohr/atomic time
        units (atomic time units given where [[dtion]]
        is described).
         <br />
         For [[ionmov]]=8 (Nose thermostat),
        if [[vel]] is not initialized, a random initial
        velocity giving the right kinetic energy will be generated.
         <br />
         If the atom manipulator is used, [[vel]] will be related
        to the preprocessed set of atoms, generated by the
        atom manipulator. The user must thus foresee the effect
        of this atom manipulator (see [[objarf]]).
         <br />
         Velocities evolve is [[ionmov]]==1.
        </p>
    topics: PIMD_useful, MolecularDynamics_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: vel_cell
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: 'It is represented internally as [[vel_cell]](3,3,[[nimage]]) '
    defaultval: !multiplevalue
        number: null
        value: 3
    dimensions:
    - 3
    - 3
    excludes: null
    mnemonics: VELocity of the CELL parameters
    requires: |-
        [[imgmov]] in [9,13] and [[optcell]] > 0
        (Path-Integral Molecular Dynamics
        with NPT algorithm)
    text: |-
        <p>
         Irrelevant unless [[imgmov]]=9 or 13
        and [[optcell]]&gt;0 (Path-Integral Molecular Dynamics
        with NPT algorithm).
         <br />
         Gives the starting velocities of the dimensional cell parameters in Bohr/atomic time
        units (atomic time units given where [[dtion]]
        is described).
        </p>
    topics: PIMD_expert
    varset: rlx
    vartype: real
- !variable
    abivarname: vis
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    dimensions: scalar
    excludes: null
    mnemonics: VIScosity
    requires: null
    text: |-
        The equation of motion is :
        <br />
        M
        <sub>
         I
        </sub>
        d
        <sup>
         2
        </sup>
        R
        <sub>
         I
        </sub>
        /dt
        <sup>
         2
        </sup>
        = F
        <sub>
         I
        </sub>
        - [[vis]] dR
        <sub>
         I
        </sub>
        /dt
        <br />
        <br />
        The atomic unit of viscosity is hartrees*(atomic time units)/Bohr
        <sup>
         2
        </sup>
        .
        Units are not
        critical as this is a fictitious damping used to relax
        structures. A typical value for silicon is 400 with
        [[dtion]] of 350 and atomic mass 28 [[amu]]. Critical
        damping is most desirable and is found only by
        optimizing [[vis]] for a given situation.
        <br />
        <br />
        In the case of Path-Integral Molecular Dynamics using the Langevin Thermostat ([[imgmov]]=9), [[vis]] defines the friction coefficient, in atomic units. Typical value range is 0.00001-0.001.
    topics: PIMD_basic,  MolecularDynamics_basic
    varset: rlx
    vartype: real
- !variable
    abivarname: vprtrb
    characteristics:
    - '[[DEVELOP]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    dimensions:
    - 2
    excludes: null
    mnemonics: potential -V- for the PeRTuRBation
    requires: '[[qprtrb]]'
    text: |-
        <p>
         Gives the real and imaginary
        parts of a scalar potential perturbation.
        Can be specified in Ha (the default), Ry, eV or Kelvin, since [[vprtrb]] has the
        '[[ENERGY]]' characteristics.
         <br />
         This is made
        available for testing responses to such perturbations.
        The form of the perturbation, which is added to the local
        potential, is:
         <ul>
          <li>
           ([[vprtrb]](1)+I*[[vprtrb]](2))/2 at G=[[qprtrb]]  and
          </li>
          <li>
           ([[vprtrb]](1)-I*[[vprtrb]](2))/2 at G=-[[qprtrb]]
        (see [[qprtrb]] also).
          </li>
         </ul>
        </p>
    topics: Artificial_useful
    varset: ffield
    vartype: real
- !variable
    abivarname: vpts@aim
    characteristics: null
    commentdefault: null
    commentdims: 6 for 1D, 9 for 2D
    defaultval: !multiplevalue
        number: 6
        value: 0.0
    dimensions:
    - 6
    excludes: null
    mnemonics: Vectors defining the PoinTS of the surface
    requires: null
    text: |-
        Basic vectors of the line or rectangle in real space,
          defining the points for which the density or
          laplacian will be computed, thanks to
         [[aim:denout]]
          or
          [[aim:lapout]]
    topics: Bader_useful
    varset: aim
    vartype: real
- !variable
    abivarname: vs_qrad_tolkms@anaddb
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2*0.0d0
    dimensions:
    - 2
    excludes: null
    mnemonics: Speed of Sound Q-radius, TOLerance KiloMeter/Second
    requires: null
    text: |-
        <p>This variable activates the calculation of the speed of sound
        (requires [[anaddb:ifcflag]] = 1).
        The first entry of the array defines the radius of the small sphere around the Gamma point (Bohr-1).
        The second entry gives the absolute tolerance in kilometer/second.
        The speed of sound is evaluated by performing a spherical average on the small sphere using
        Lebedev-Laikov grids (typical values for q-radius: 0.1 Bohr-1)
        The number of radial points is increased until the integration converges twice withing the tolerance
        specified by the user (typical values for tolkms: 0.05 km/s).
        <p>The default values will not work.
    topics: PhononBands_useful
    varset: anaddb
    vartype: real
- !variable
    abivarname: w90iniprj
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: Wannier90- INItial PROJections
    requires: '[[prtwant]]==2 or [[prtwant]]==3'
    text: |-
        <p>
         In order to find the Maximally Localized Wannier Functions, the user
        has to provide an initial guess. A set of localized trial orbitals
        is chosen
        corresponding to some rough initial guess at the
        Wannier Functions, and these are projected onto the  Bloch
        eigenstates. See Ivo
        Souza, Nicola Marzari, and David Vanderbilt. Phys. Rev. B, 65, 035109 (2001).
         <br />
         These initial projections are stored in a file .amn and the variable
         <b>
          w90iniprj
         </b>
         is used to construct them:
         <ul>
          <li>
           <b>
            w90iniprj
           </b>
           =1:
        Random projections.
           <br />
           <br />
          </li>
          <li>
           <b>
            w90iniprj
           </b>
           =2:
        The initial projections will be a linear combination of hydrogenic
        atomic orbitals.
           <br />
           The user has to define the projections in the secondary input file
        wannier90.win
           <br />
           Information about how to define them can be found in the manual of
        Wannier90. See
           <span>
            <a href="http://www.wannier.org">
             www.wannier.org
            </a>
           </span>
          </li>
         </ul>
        </p>
    topics: Wannier_basic
    varset: w90
    vartype: integer
- !variable
    abivarname: w90prtunk
    characteristics: null
    commentdefault: |-
        The default is set to zero because UNKp.s files occupy a lot of
        memory.
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: Wannier90- PRINT UNKp.s file
    requires: '[[prtwant]]==2 or [[prtwant]]==3'
    text: |-
        <p>
         Defines whether or not the UNKp.s file will be printed.
         <ul>
          <li>
           [[w90prtunk]]=0: Do not print the UNKp.s files
           <br />
           <br />
          </li>
          <li>
           [[w90prtunk]]=1: Print the UNKp.s files on a fine grid
           <br />
           <br />
          </li>
          <li>
           [[w90prtunk]]&gt;1: Print the UNKp.s files on a coarse grid
           <br />
           Instead of printing every record we will print every w90prtunk records. This is useful to reduce the size of the UNKp.s files, but, the quality is also reduced.
          </li>
         </ul>
         <br />
         <br />
        These files contain the periodic part of the bloch states represented
        on a regular real space grid. They are indexed by k-point
         <b>
          p
         </b>
         (from 1 to
        nkpt) and spin
         <b>
          s
         </b>
         ('1' for 'up','2' for 'down').
         <br />
         <br />
         The name of the wavefunction file is assumed to have the form:
         <br />
         <br />
         write(wfnname,200)
         <b>
          p
         </b>
         ,
         <b>
          spin
         </b>
         <br />
         200 format ('UNK',i5.5,'.',i1)
         <br />
         <br />
         These file are unformatted.
        The first line of each file contains 5 integers: the number of
        grid points in each direction (
         <b>
          n1
         </b>
         ,
         <b>
          n2
         </b>
         and
         <b>
          n3
         </b>
         ), the k-point number
         <b>
          ikpt
         </b>
         and the total number of bands mband in the file. The following rows contain the wavefunctions in real space.
        </p>
        <p>
         These files are written in the following way for the coarse grid:
        </p>
        <pre>
         write(iun_plot) n1/w90prtunk,n2/w90prtunk,n3/w90prtunk,ikpt,nband
        write(iun_plot) (((fofr(1,jj1,jj2,jj3),fofr(2,jj1,jj2,jj3),&amp;
        &amp;      jj1=1,n1,w90prtunk),jj2=1,n2,w90prtunk),jj3=1,n3,w90prtunk)
        </pre>
        Where
        <b>
         fofr
        </b>
        is a double precision variable which contains the wavefunctions in real space.
        Note that in order to reduce the size of the UNK files we are just
        including records in the wavefunctions for 1/(w90prtunk^3) of the grid points.
        That is why we divide n1, n2 and n3 by prtunk. The output .xsf files for plotting
        with XCrysDen will also be on the coarse grid.  When this does not produce an
        acceptable plot, prtunk can be set to 1 to output every grid point.
        (You should try spline interpolation in XCrysDen first.)
    topics: Wannier_basic
    varset: w90
    vartype: integer
- !variable
    abivarname: wfkfile@optic
    characteristics: null
    commentdefault: no default
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: WaveFunction K FILE
    requires: null
    text: |-
        Specify the filename that has been produced by the preparatory Abinit run.
          This file must contain the matrix elements of the d/dk operator along direction X.
          It must not contain the first-order wavefunctions and may be generated using [[prtwf]] 3.<br />
          You should make sure that the number of bands, of spin channels and of k-points are the same in all the files.
    topics: Optic_basic
    varset: optic
    vartype: string
- !variable
    abivarname: wfoptalg
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: 0 when [[usepaw]]=0 (norm-conserving pseudopotentials), 10 when [[usepaw]]=1 (PAW) ; 114 if [[paral_kgb]]=1.
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    dimensions: scalar
    excludes: null
    mnemonics: WaveFunction OPTimisation ALGorithm
    requires: null
    text: |-
        <p>
         Allows one to choose the algorithm for the optimisation of the wavefunctions.
         <br />
         The different possibilities are :
         <ul>
          <li>
           [[wfoptalg]]=0 : standard state-by-state conjugate gradient algorithm,
        with no possibility to parallelize over the states;
          </li>
          <li>
           [[wfoptalg]]=2 : minimisation of the residual with respect
        to different shifts, in order to cover the whole set of occupied
        bands, with possibility to parallelize over blocks of states (or bands).
        The number of states in a block
        is defined in [[nbdblock]].
        THIS IS STILL IN DEVELOPMENT.
          </li>
          <li>
           [[wfoptalg]]=3 : minimisation of the residual with respect
        to a shift. Available only in the non-self-consistent case
        [[iscf]]=-2,
        in order to find eigenvalues and wavefunctions close to a
        prescribed value.
          </li>
          <li>
           [[wfoptalg]]=4 : (see also [[wfoptalg]]=14), a parallel code based on the Locally Optimal
        Block Preconditioned Conjugate Gradient (LOBPCG) method of Knyazev.
           <a href="http://dx.doi.org/10.1137/S1064827500366124">
            Reference : A.V. Knyazev, "Toward the Optimal Preconditioned Eigensolver
        : Locally Optimal Block Preconditioned Conjugate Gradient Method". SIAM
        Journal on Scientific Computing 23, pp517-541 (2001)
           </a>
           .
        The implementation rests on the
           <a href="http://www.mathworks.com/matlabcentral/fileexchange/48-lobpcg-m">
            matlab program by Knyazev
           </a>
           .
           <a href="http://dx.doi.org/10.1137/060661624">
            Reference A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov,
        Block Locally Optimal Preconditioned Eigenvalue Xolvers (BLOPEX) in
        hypre and PETSc (2007). SIAM Journal on Scientific Computing (SISC).
        25(5): 2224-2239
           </a>
           .
        For more information see
           <a href="http://dx.doi.org/10.1016/j.commatsci.2007.07.019">
            F. Bottin, S. Leroux, A. Knyazev, G. Zerah, Large scale
        ab initio calculations based on three levels of parallelization. (2008).
        Computational Material Science, 42(2), 329-336.
           </a>
          </li>
          <li>
           [[wfoptalg]]=10 : (for PAW) standard state-by-state conjugate gradient algorithm,
        with no possibility to parallelize over the states, but modified
        scheme described in Kresse, Furthmuller, PRB 54, 11169 (1996)
        (modified kinetic energy, modified preconditionning, minimal
        orthogonalization, ...) ;
          </li>
          <li>
           [[wfoptalg]]=14 :
        the recommended for parallel code, the same as [[wfoptalg]]=4 except that the preconditioning of
        the block vectors does not depend on the kinetic energy of each band,
        and the orthogonalization after the LOBPCG algorithm is no longer
        performed. The first modification increases the convergence and the
        second one the efficiency.
          </li>
        <li>
           [[wfoptalg]]=114 :
        A new version of [[wfoptalg]]=14 which is more efficient for few blocks and can take advantage of OpenMP if abinit is compiled with a multithreaded linear algebra library.
        With more than 1 thread [[npfft]] shoud NOT be used for the time being.
          </li>
          <li>
           [[wfoptalg]]=1 :
        new algorithm based on Chebyshev filtering, designed for very large number of processors, in the regime where LOBPCG does not scale anymore. It is not able to use preconditionning and therefore might converge slower than other algorithms. By design, it will
           <b>
            not
           </b>
           converge the last bands: it is recommended to use slightly more bands than necessary. For usage with [[tolwfr]], it is imperative to use [[nbdbuf]]. For more performance, try [[use_gemm_nonlop]]. For more information, see the
           <a href="../../theory/howto_chebfi.pdf">
            performance guide
           </a>
           and the
           <a href="https://arxiv.org/abs/1406.4350">
            paper
           </a>
           by A. Levitt and M. Torrent. Status: experimental but usable. Questions and bug reports should be sent to antoine (dot) levitt (at) gmail.com.
          </li>
         </ul>
        </p>
    topics: SCFAlgorithms_basic
    varset: dev
    vartype: integer
- !variable
    abivarname: wtatcon
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 3
    - '[[natcon]]'
    - '[[nconeq]]'
    excludes: null
    mnemonics: WeighTs for AToms in CONstraint equations
    requires: null
    text: |-
        <p>
         Gives the weights determining how the motion of atoms
        is constrained
        during structural optimization or molecular dynamics (see [[nconeq]]
         , [[natcon]],
        and [[iatcon]]). For each of the [[nconeq]]
         independent constraint equations,
        wtatcon is a 3*[[natcon]] array giving
        weights, W
         <sub>
          I
         </sub>
         ,
        for the x, y, and z components of each of the atoms (labeled by I) in
        the list of indices [[iatcon]].
        Prior to taking an atomic step, the calculated forces, F
         <sub>
          I
         </sub>
         ,
        are
        replaced by projected forces, F'
         <sub>
          I
         </sub>
         , which satisfy the set of
        constraint equations
         <br />
         <br />
         Sum
         <sub>
          mu=x,y,z; I=1,natcon
         </sub>
         : W
         <sub>
          mu,I
         </sub>
         * F'
         <sub>
          mu,I
         </sub>
         = 0 for each of the [[nconeq]] arrays W
         <sub>
          I
         </sub>
         .
         <br />
         <br />
         Different types of motion constraints can be implemented this way. For
        example,
         <br />
         <br />
         nconeq 1 natcon 2 iatcon 1 2 wtatcon 0 0 +1 0 0 -1
         <br />
         <br />
         could be used to constrain the relative height difference of two
        adsorbate atoms on a surface (assuming their
        masses are equal), since F'
         <sub>
          z,1
         </sub>
         - F'
         <sub>
          z,2
         </sub>
         = 0
        implies z
         <sub>
          1
         </sub>
         - z
         <sub>
          2
         </sub>
         = constant.
        </p>
    topics: GeoConstraints_useful
    varset: rlx
    vartype: real
- !variable
    abivarname: wtk
    characteristics: null
    commentdefault: Except when [[kptopt]]/=0
    commentdims: null
    defaultval: !multiplevalue
        number: '[[nkpt]]'
        value: 1.0
    dimensions:
    - '[[nkpt]]'
    excludes: null
    mnemonics: WeighTs for K points
    requires: null
    text: |-
        <p>
         Gives the k point weights.
         <br />
         The
        k point weights will have their sum (re)normalized to 1
        (unless [[occopt]]=2 and [[kptopt]]=0;
        see description of [[occopt]])
        within the program and therefore may be input with any
        arbitrary normalization.  This feature helps avoid the
        need for many digits in representing fractional weights
        such as 1/3.
         <br />
         [[wtk]] is ignored if [[iscf]] is not positive,
        except if [[iscf]]=-3.
        </p>
    topics: k-points_useful
    varset: basic
    vartype: real
- !variable
    abivarname: wtq
    characteristics: null
    commentdefault: Except when [[qptopt]]/=0
    commentdims: null
    defaultval: 1
    dimensions: scalar
    excludes: null
    mnemonics: WeighTs for the current Q-points
    requires: null
    text: |-
        <p>
         Gives the current q-point weight.
        </p>
    topics: q-points_useful
    varset: gstate
    vartype: real
- !variable
    abivarname: wvl_bigdft_comp
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: WaVeLet BigDFT Comparison
    requires: null
    text: |-
        This variable is used for the wavelets capabilities of ABINIT (see [[usewvl]]
        </a>
        ).
        It is used to compare the results obtained with ABINIT
        with those obtained with BigDFT stand-alone.
        When it is set to 1, ABINIT will follow the workflow as in BigDFT stand-alone.
        Therefore, the results must be exactly the same with the two codes.
    topics: Wavelets_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: wvl_crmult
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 6.0
    dimensions: scalar
    excludes: null
    mnemonics: WaVeLet Coarse grid Radius MULTiplier
    requires: null
    text: |-
        <p>
         This factor is used to defined the expansion of the coarse resolution
        grid in the case of wavelets (seea [[usewvl]]
         ). The grid is made of
        points inside spheres centered on atoms. The radius of these
        spheres are the product between this factor and the covalent
        radius of element (read from the pseudo-potential file).
         <br />
         This factor is responsible for the amount of used memory (see also [[wvl_hgrid]]).
        </p>
    topics: Wavelets_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: wvl_frmult
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    dimensions: scalar
    excludes: null
    mnemonics: WaVeLet Fine grid Radius MULTiplier
    requires: null
    text: |-
        <p>
         This factor is used to defined the expansion of the fine resolution
        grid in the case of wavelets (see [[usewvl]]
         ). This fine resolution
        grid has the same grid step than the coarse one (see
        [[wvl_crmult]]
         ), but on each
        point, 8 coefficients are stored instead of one, increasing the
        precision of the calculation in this area. The grid is made of
        points inside spheres centered on atoms. The radius of these
        spheres are the product between this factor and a value read from the pseudo-potential file.
         <br />
         This factor is responsible for the amount of used memory (see also [[wvl_hgrid]]).
        </p>
    topics: Wavelets_basic
    varset: gstate
    vartype: real
- !variable
    abivarname: wvl_hgrid
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    dimensions: scalar
    excludes: null
    mnemonics: WaVeLet H step GRID
    requires: null
    text: |-
        <p>
         It gives the step size in real space for the
        grid resolution in the wavelet basis set. This value is highly
        responsible for the memory occupation in the wavelet
        computation. The value is a length in atomic units.
        </p>
    topics: Wavelets_basic
    varset: basic
    vartype: real
- !variable
    abivarname: wvl_ngauss
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 100
    dimensions:
    - 2
    excludes: null
    mnemonics: WaVeLet Number of GAUSSians
    requires: null
    text: |-
        <p>
         In the wavelet-PAW computation case, projectors may be
        fitted to a sum of complex Gaussians.
        The fit is done for wvl_ngauss(1), wvl_ngauss(1)+1 ... up to wvl_ngauss(2) Gaussians.
        </p>
    topics: Wavelets_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: wvl_nprccg
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5
    dimensions: scalar
    excludes: null
    mnemonics: WaVeLet maximum Number of PReConditionner Conjugate Gradient iterations
    requires: null
    text: |-
        <p>
         In the wavelet computation case, the wavefunctions are directly
        minimised using a real-space preconditionner. This preconditionner
        has internally some conjugate gradient iterations. This value
        defines a boundary for the number of conjugate gradient
        iterations on each wavefunction convergence step.
        </p>
    topics: Wavelets_expert
    varset: gstate
    vartype: integer
- !variable
    abivarname: xangst
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    - min([[natom]],[[natrd]])
    excludes: null
    mnemonics: vectors (X) of atom positions in cartesian coordinates -length in ANGSTrom-
    requires: null
    text: |-
        <p>
         Gives the cartesian coordinates
        of atoms within unit cell, in angstrom.  This information is
        redundant with that supplied by array [[xred]] or [[xcart]].
         <br />
         If [[xred]] and [[xangst]] are ABSENT from the input file and
        [[xcart]] is
        provided, then the values of [[xred]] will be computed from
        the provided [[xcart]] (i.e. the user may use xangst instead
        of [[xred]] or [[xcart]] to provide starting coordinates).
         <br />
         One and only one of [[xred]], [[xcart]]
        and [[xangst]] must be provided.
         <br />
         The conversion factor between Bohr and Angstrom
        is 1 Bohr=0.5291772108 Angstrom, see the
         <a href="http://physics.nist.gov/cuu/Constants/index.html">
          NIST site
         </a>
         .
         <br />
         Atomic positions evolve if [[ionmov]]/=0 .
        In constrast with [[xred]] and
        [[xcart]], [[xangst]] is not internal.
        </p>
    topics: crystal_compulsory
    varset: basic
    vartype: real
- !variable
    abivarname: xc_denpos
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-14
    dimensions: scalar
    excludes: null
    mnemonics: eXchange-Correlation - DENsity POSitivity value
    requires: null
    text: |-
        <p>
         For the evaluation of the exchange-correlation functionals, the density
        cannot be negative, or even too small (e.g. the LDA exchange kernel
        behaves like the density at power -(2/3), and the density is used at the denominator
        of different factors in GGAs and metaGGAs.
        [[xc_denpos]] is the smallest value that the density can assume at the time of the
        evaluation of a XC functional, in ABINIT. When then computed density drops below [[xc_denpos]]
        before attacking the evaluation of the XC functional, then it will be (only for that purpose)
        replaced by [[xc_denpos]]. Note that the evaluation of the gradients or other quantities
        that are density-dependent is performed before this replacement.
        </p>
        <p>
         It has been observed that the SCF cycle of the Tran-Blaha mGGA can be quite hard to make converge, for systems
        for which there is some vacuum. In this case, setting [[xc_denpos]] to 1.0e-7 ... 1.0e-6 has been seen
        to allow good convergence. Of course, this will affect the numerical results somehow, and one should play
        a bit with this value to avoid incorrect calculations.
        </p>
    topics: xc_expert
    varset: dev
    vartype: real
- !variable
    abivarname: xc_tb09_c
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 99.99
    dimensions: scalar
    excludes: null
    mnemonics: Value of the c parameter in the eXchange-Correlation TB09 functional
    requires: null
    text: |-
        <p>
         The modified Becke-Johnson exchange-correlation functional by Tran and Blaha (Phys. Rev. Lett. 102, 226401 (2009)) reads :
        </p>
        <p>
         V_x(r) = c * V_x^{BR}(r) + (3*c - 2) * 1/pi * sqrt(5/12) * sqrt(2*kden(r)/den(r))
        </p>
        <p>
         in which V_x^{BR}(r) is the Becke-Roussel potential.
        </p>
        <p>
         In this equation the parameter c can be evaluated at each SCF step according to the following equation :
        </p>
        <p>
         c = alpha + beta * sqrt(1/V_{cell} * \int_{V_{cell}} |grad(den(r))|/den(r) d3r)
        </p>
        <p>
         The c parameter is evaluated thanks to the previous equation when xc_tb09_c is equal to the "magic" default value 99.99.
        The c parameter can also be fixed to some (property-optimized or material-optimized) value by using this variable.
        </p>
    topics: xc_expert
    varset: dev
    vartype: real
- !variable
    abivarname: xcart
    characteristics:
    - '[[EVOLVING]]'
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - 3
    - min([[natom]],[[natrd]])
    excludes: null
    mnemonics: vectors (X) of atom positions in CARTesian coordinates
    requires: null
    text: |-
        <p>
         Gives the cartesian coordinates
        of atoms within unit cell.  This information is
        redundant with that supplied by array [[xred]] or [[xangst]].
        By default, [[xcart]] is given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[xcart]] has the
        '[[LENGTH]]' characteristics.
         <br />
         If [[xred]] and [[xangst]] are
        ABSENT from the input file and [[xcart]] is
        provided, then the values of [[xred]] will be computed from
        the provided [[xcart]] (i.e. the user may use [[xcart]] instead
        of [[xred]] or [[xangst]] to provide starting coordinates).
         <br />
         One and only one of [[xred]], [[xcart]]
        and
         <b>
          xangst
         </b>
         must be provided.
         <br />
         Atomic positions evolve if [[ionmov]]/=0 .
        </p>
    topics: crystal_compulsory
    varset: basic
    vartype: real
- !variable
    abivarname: xclevel
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions: scalar
    excludes: null
    mnemonics: eXchange Correlation functional LEVEL
    requires: null
    text: |-
        <p>
         Automatically determined from the value of [[ixc]].
         <ul>
          <li>
           0 =&gt; No XC contribution.
          </li>
          <li>
           1 =&gt; LDA functional.
          </li>
          <li>
           2 =&gt; GGA functional or hybrid functional based on GGA.
          </li>
          <li>
           3 =&gt; Functional for TDDFT.
          </li>
         </ul>
        </p>
    topics: xc_internal, TDDFT_useful
    varset: internal
    vartype: integer
- !variable
    abivarname: xred
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: represented internally as xred(3,[[natom]],[[nimage]])
    defaultval: !multiplevalue
        number: null
        value: 0.0
    dimensions:
    - 3
    - min([[natom]],[[natrd]])
    excludes: null
    mnemonics: vectors (X) of atom positions in REDuced coordinates
    requires: null
    text: |-
        <p>
         Gives the atomic locations within
        unit cell in coordinates relative to real space primitive
        translations (NOT in cartesian coordinates).  Thus these
        are fractional numbers typically between 0 and 1 and
        are dimensionless.  The cartesian coordinates of atoms (in Bohr)
        are given by:
         <br />
         <tele>
          R_cartesian = xred1*rprimd1+xred2*rprimd2+xred3*rprimd3
         </tele>
         <br />
         where (xred1,xred2,xred3) are the "reduced coordinates" given in
        columns of "[[xred]]", (rprimd1,rprimd2,rprimd3) are the columns of
        primitive vectors array "[[rprimd]]" in Bohr.
         <br />
         If you prefer to work only with cartesian coordinates, you
        may work entirely with "[[xcart]]" or "[[xangst]]" and ignore [[xred]], in
        which case [[xred]] must be absent from the input file.
         <br />
         One and only one of [[xred]], [[xcart]] and [[xangst]]
         must be provided.
         <br />
         Atomic positions evolve if [[ionmov]]/=0 .
        </p>
    topics: crystal_compulsory
    varset: basic
    vartype: real
- !variable
    abivarname: xredsph_extra
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0
    dimensions:
    - 3
    - '[[natsph_extra]]'
    excludes: null
    mnemonics: X(position) in REDuced coordinates of the SPHeres for dos projection in the EXTRA set
    requires: '[[natsph_extra]] > 0'
    text: |-
        <p>
         The positions in reduced coordinates of extra spheres used in the DOS projection, simulating an STS signal.
        See [[natsph_extra]] for a more complete description.
        </p>
    topics: printing_prdos
    varset: gstate
    vartype: real
- !variable
    abivarname: xyzfile
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions: scalar
    excludes: null
    mnemonics: XYZ FILE input for geometry
    requires: null
    text: |-
        <p>
         Gives the name of a xyz format file, to take
        [[natom]], [[ntypat]], [[typat]], [[znucl]],
        and [[xangst]] from. This input can not be mixed with normal atom specifications for other datasets.
        </p>
        <p>
         Notes: do not quote the file name in the abinit input file, simply leave a space after xyzfile. The xyz format is the number of atoms on the first line, a comment line, then one line per atom, with the element as a 2 letter symbol ("As" "O" or "Pu") and the three cartesian coordinates in Angstrom.
        </p>
    topics: crystal_useful
    varset: geo
    vartype: string
- !variable
    abivarname: zcut
    characteristics:
    - '[[ENERGY]]'
    commentdefault: 0.0036749326 Ha = 0.1 eV
    commentdims: null
    defaultval: 0.0036749326
    dimensions: scalar
    excludes: null
    mnemonics: Z-CUT
    requires: '[[optdriver]] in [3,4,99]'
    text: |-
        <p>
         It is meant to avoid some divergencies that might occur during the evaluation of the Adler-Wiser expression of
        the irreducible polarizability ([[optdriver]]=3) or during the numerical treatment
        of the integrals defining the contribution to the self-energy matrix elements
        ([[optdriver]]=4).
        If the denominator becomes smaller than [[zcut]], a small imaginary part (depending on [[zcut]]) is added,
        in order to avoid the divergence.
        </p>
        <p>
         When [[optdriver]]=99, [[zcut]] defines the small complex shift
        used to avoid divergences in the expression for the macroscopic dieletric function.
        It simulates the experimental uncertainty and the finite lifetime of the quasiparticles
        (although the true lifetime should be k- and band-dependent).
        The value of [[zcut]] affects the number of iteration needed to achieve convergence
        in the Haydock iterative method. In this case, [[zcut]] should be
        larger than the typical distance between the eigenvalues of the exciton Hamiltonian.
         <br />
         Ideally, one should make a convergence study decreasing the value of [[zcut]] for increasing number of k-points.
        </p>
    topics: Susceptibility_expert, BSE_expert, SelfEnergy_expert
    varset: gw
    vartype: real
- !variable
    abivarname: zeemanfield
    characteristics:
    - '[[MAGNETIC_FIELD]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    dimensions:
    - 3
    excludes: null
    mnemonics: ZEEMAN FIELD
    requires: null
    text: |-
        <p>
         Give the value of the Zeeman field, H, acting on the spinorial wavefunctions.
        Note that Tesla are admitted. This sets the magnitude of mu_0*H, in Tesla,
        with H in Amperes/metre.
        </p>
    topics: MagField_basic
    varset: ffield
    vartype: real
- !variable
    abivarname: ziontypat
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    dimensions:
    - '[[ntypat]]'
    excludes: null
    mnemonics: Z (charge) of the IONs for the different TYPes of AToms
    requires: null
    text: |-
        <p>
         Charge of the pseudo-ion (=number of valence electrons
        that are needed to screen exactly the pseudopotential).
        </p>
    topics: AtomTypes_internal, PseudosPAW_internal
    varset: internal
    vartype: real
- !variable
    abivarname: znucl
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    dimensions:
    - '[[npsp]]'
    excludes: null
    mnemonics: charge -Z- of the NUCLeus
    requires: null
    text: |-
        <p>
         Gives nuclear charge for each
        type of pseudopotential, in order.
         <br />
         If [[znucl]] does not agree with nuclear charge,
        as given in pseudopotential files, the program writes
        an error message and stops.
        </p>
        <p>
         N.B. : In the pseudopotential files, [[znucl]] is called "zatom".
        </p>
        <p>
         For a "dummy" atom, with [[znucl]]=0 , as used in the case of calculations
        with only a jellium surface, ABINIT sets arbitrarily the covalent radius to one.
        </p>
    topics: AtomTypes_compulsory, PseudosPAW_compulsory
    varset: basic
    vartype: real

