- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: ACCURACY
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
        Allows to tune the accuracy of a calculation by setting automatically the variables [[ecut]],  [[boxcutmin]], [[fband]],
         [[tolvrs]], [[tolmxf]],
         [[optforces]], [[timopt]], [[npulayit]],
         [[nstep]], [[prteig]], [[prtden]], and if [[usepaw]]=1,  [[pawecutdg]],
         [[bxctmindg]], [[pawxcdev]], [[pawmixdg]],
         [[pawovlp]], [[pawnhatxc]], according to the following table:

         <p style="margin-left: 40px;">
          <table style="border: medium none ; border-collapse: collapse; width: 549px; height: 102px;" summary="Input file examples">
            <tbody>
              <tr style="height: 33.45pt;">

                <td style="border-style: solid solid solid solid;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.45pt; font-weight: bold">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent" ><small>accuracy</small></p>
                </td>

                <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 1 </small></p>
                </td>

                <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 2 </small></p>
                 </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 3 </small></p>
                </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 4 </small></p>
                </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 5 </small></p>
                </td>

               <td style="border-style: solid solid solid none;  border-width: 2.25pt 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt; ">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 6 </small></p>
                </td>
              </tr>

              <tr style="height: 33.45pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.45pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>E_min</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>E_med</small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>E_med</small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>E_max</b></small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>E_max</b></small></p>
                </td>

               <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.45pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>E_max</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawecutdg</small></p>
                </small></td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.2*ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1.5*ecut</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2*ecut</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2*ecut</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>fband</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0.5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0.75</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0.75</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>boxcutmin</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.5</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>bxctmindg</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.5</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.8</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2.0</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawxcdev</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>2</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawmixdg</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>0</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawovlp</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>10</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>7</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>7</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>pawnhatxc</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>


             <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>tolvrs</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-3</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-5</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-7</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-9</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-10</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-12</small></p>
                </td>
              </tr>

             <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>tolmxf</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-3</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>5.0d-4</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-4</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>5.0d-5</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-6</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1.0d-6</small></p>
                </td>
              </tr>


             <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>optforces</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 1</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>1</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>2</b></small></p>
                </td>
              </tr>


            <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>timopt</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>npulayit</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 4</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>7</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>7</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>7</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>15</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>15</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>nstep</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> <b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>30</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>50</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>50</small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>prteig</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>

              <tr style="height: 33.3pt;">
                <td style="border-style: none solid solid;  border-width: medium 2.25pt 2.25pt; padding: 0cm 3.5pt; width: 90pt; height: 33.3pt; font-weight: bold;">
                <p style="margin: 0cm 0cm 0.0001pt; font-weight: normal;" class="MsoBodyTextIndent"><small>prtden</small></p>
                </td>

                <td style="border-style: none solid solid none; border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 164.3pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small> 0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small>0</small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>

                <td style="border-style: none solid solid none;  border-width: medium 2.25pt 2.25pt medium; padding: 0cm 3.5pt; width: 163.15pt; height: 33.3pt;">
                <p style="margin: 0cm 0cm 0.0001pt; text-align: center;" class="MsoBodyTextIndent" align="center"><small><b>1</b></small></p>
                </td>
              </tr>

            </tbody>
          </table>
          </p>
        <br>For a parallel calculation, [[timopt]] is enforced to be 0.
        <br>E_min, E_med and E_max may be read from the pseudopotential file (available only for XML PAW atomic data files). If E_min, E_med and E_max are not given in the pseudopotential file, [[ecut]] must be given in the input file and E_max=E_med=E_max=ecut.
        <br>The values in bold font are the default values of ABINIT. [[accuracy]]=4 corresponds to the default tuning of ABINIT. It is already a very accurate tuning.
        <br>If the user wants to modify one of the input variable automatically tuned by [[accuracy]], he must put it in the input file. The other input variables automatically tuned by [[accuracy]] will not be affected.
        <br />
        [[accuracy]]=0 means that this input variable is desactivated.

        <p>
    varname: accuracy
    vartype: integer
- !variable
    characteristics:
    - '[[EVOLVING]]'
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: represented internally as acell(3,[[nimage]])
    defaultval: !multiplevalue
        number: 3
        value: 1
    definition: CELL lattice vector scaling
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the length scales by which
        dimensionless primitive translations (in [[rprim]]) are
        to be multiplied.  By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[acell]] has the
        '[[LENGTH]]' characteristics.
        See further description of [[acell]] related to the
        [[rprim]] input variable,
        the [[scalecart]] input variable,
        and the associated internal [[rprimd]] input variable.
        </p>
        <p>
         Note that [[acell]] is NOT the length of the conventional orthogonal basis vectors, but the scaling factors of the primitive vectors.
        Use [[scalecart]] to scale the cartesian coordinates.
        </p>
    varname: acell
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: ADiabatic Path-Integral Molecular Dynamics
    dimensions: scalar
    excludes: null
    requires: '[[imgmov]]==9 or [[imgmov]]==13'
    section: varrlx
    text: |-
        <p>
         Controls whether adiabatic Path-Integral Molecular Dynamics is performed or not.
         <br />
         The corresponding adiabaticity parameter is given by [[adpimd_gamma]].
         <br />
         <br />
         If equal to 0, no adiabatic Path-Integral Molecular Dynamics (standard PIMD) is performed.
         <br />
         If equal to 1, adiabatic Path-Integral Molecular Dynamics is activated.
         <br />
         Only relevant with [[pitransform]]=1 (normal mode transformation). In that case,
         <br />
         - the mass associated with to the zero-frequency mode is the true mass [[amu]],
         <br />
         - the mass associated to the other higher frequency modes of the polymer chains is equal to the normal mode mass divided by
        [[adpimd_gamma]] (adiabaticity parameter),
         <br />
         - the equation of motion on the zero-frequency mode is not thermostated.
         <br />
         NOT YET USABLE
        </p>
    varname: adpimd
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'ADiabatic Path-Integral Molecular Dynamics: GAMMA factor'
    dimensions: scalar
    excludes: null
    requires: '[[adpimd]]==1 and [[imgmov]] in [9,13]'
    section: varrlx
    text: |-
        <p>
         Adiabaticity parameter to be used in adiabatic Path-Integral Molecular Dynamics.
         <br />
         NOT YET USABLE
        </p>
    varname: adpimd_gamma
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 1
    definition: ALGorithm for generating ALCHemical pseudopotentials
    dimensions:
    - '[[ntypalch]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Used for the generation of alchemical pseudopotentials, that is,
        when [[ntypalch]] is non-zero.
        </p>
        <p>
         Give the algorithm to be used to
        generate the [[ntypalch]] alchemical potentials
        from the different [[npspalch]] pseudopotentials
        dedicated to this use.
        </p>
        <p>
         Presently, [[algalch]] can only have the value 1, that is :
         <ul>
          <li>
           the local potentials are mixed, thanks to the [[mixalch]]
        mixing coefficients
          </li>
          <li>
           the form factors of the non-local projectors are all preserved, and all considered
        to generate the alchemical potential
          </li>
          <li>
           the scalar coefficients of the non-local projectors are multiplied by the proportion
        of the corresponding type of atom that is present in [[mixalch]]
          </li>
          <li>
           the characteristic radius for the core charge is a
        linear combination of the characteristic radii of the core charges,
        build with the [[mixalch]] mixing
        coefficients
          </li>
          <li>
           the core charge function f(r/rc) is a linear combination
        of the core charge functions, build with the [[mixalch]]
        mixing coefficients
          </li>
         </ul>
         Later, other algorithms for the mixing might be included.
        </p>
        <p>
         Note that alchemical mixing cannot be used with PAW.
        </p>
    varname: algalch
    vartype: integer
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: provided by a database of atomic masses.
    commentdims: null
    defaultval: null
    definition: Atomic Mass Units
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the masses in atomic mass units for each kind
        of atom in cell. These masses are used in performing
        molecular dynamical atomic motion if
        [[ionmov]]=1, 6, 7 or 8.
        They are also used in phonon calculations, in the diagonalization of the dynamical matrix.
        Note that one may set all masses to 1 for certain cases
        in which merely structural relaxation is desired and not
        actual molecular dynamics.
        </p>
        <p>
         Using 1986 recommended values, 1 atomic mass unit =
        1.6605402e-27 kg.
        In this unit the mass of Carbon 12 is exactly 12.
        </p>
        <p>
         A database of atomic masses is provided, giving
        default values.
        Note that the default database uses mixed isotope masses (for Carbon
        the natural occurrence of Carbon 13 is taken into account).
        The values are those recommended by the commission on Atomic Weights
        and
        Isotopic Abundances, Inorganic Chemistry Division, IUPAC, in
         <i>
          Pure Appl. Chem.
         </i>
         <b>
          60
         </b>
         , 841 (1988).
        For Tc, Pm, Po to Ac, Pa and beyond U,
        none of the isotopes has a half-life greater than 3.0d10 years, and
        the values provided in the database do not come from that source.
        </p>
        <p>
         For alchemical pseudoatoms, the masses of the constituents
        atoms are mixed, according to the alchemical mixing
        coefficients [[mixalch]]
        </p>
        <p>
         In most cases, the use of [[amu]]
        will be as a static (non-evolving) variable. However, the possibility to have
        different values of [[amu]] for different images has been coded. A population of
        cells with different atomic characteristics can thus be considered,
        and can be made to evolve, e.g. with a genetic algorithm (not coded in v7.0.0 though).
        </p>
    varname: amu
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: deduced from '[[rprim]]'
    commentdims: null
    defaultval: null
    definition: ANGles in DEGrees
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the angles between directions of
        primitive vectors of the unit cell (in degrees),
        as an alternative to the input array [[rprim]] .
        Will be used to set up [[rprim]],
        that, together with the array [[acell]], will be used to define the
        primitive vectors.
         <ul>
          <li>
           [[angdeg]](1) is the angle between the 2nd and 3rd vectors,
          </li>
          <li>
           [[angdeg]](2) is the angle between the 1st and 3rd vectors,
          </li>
          <li>
           [[angdeg]](3) is the angle between the 1st and 2nd vectors,
          </li>
         </ul>
         If the three angles are equal within 1.0d-12 (except if they are exactly 90 degrees),
        the three primitive
        vectors are chosen so that the trigonal symmetry that exchange
        them is along the z cartesian axis :
         <pre>
        R1=( a , 0,c)
        R2=(-a/2, sqrt(3)/2*a,c)
        R3=(-a/2,-sqrt(3)/2*a,c)
         </pre>
         where a
         <sup>
          2
         </sup>
         +c
         <sup>
          2
         </sup>
         =1.0d0
         <br />
         If the angles are not all equal (or if they are all 90 degrees), one will have the following
        generic form :
         <ul>
          <li>
           R1=(1,0,0)
          </li>
          <li>
           R2=(a,b,0)
          </li>
          <li>
           R3=(c,d,e)
          </li>
         </ul>
         where each of the vectors is normalized,
        and form the desired angles with the others.
        </p>
    varname: angdeg
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Acoustic Sum Rule
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        Govern the imposition of the Acoustic Sum Rule (ASR) in phonon calculations. Same meaning as the corresponding anaddb variable.
    varname: asr
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0d0
    definition: ATomic potential (V) energy SHIFTs
    dimensions:
    - '[[natvshift]]'
    - '[[nsppol]]'
    - '[[natom]]'
    excludes: null
    requires: '[[usepawu]] /= 0 and [[natvshift]] in [5,7]'
    section: varff
    text: |-
        <p>
         Defines for each atom and each spin channel (at present, can only be used
        with [[nsppol]]=1 or 2, like the +U scheme),
        a possible potential shift, for the d
        (with [[lpawu]]=2,
        [[natvshift]]=5),
        or f states
        (with [[lpawu]]=3,
        [[natvshift]]=7).
        In the case of d states, and 2 spin channels, a set of 10 numbers for
        each atom must be defined.
        The first set of 5 numbers corresponds to real spherical harmonics
        m=-2 to m=+2 for the spin-up channel,
        the second set of 5 numbers corresponds to real spherical harmonics
        m=-2 to m=+2 for the spin-down channel.
        In the case of f states, the same ordering applies, for sets of 7 numbers,
        corresponding to m=-3 to m=+3.
         <br />
         [[usepawu]] should be non-zero,
        [[lpawu]] should be 2 or 3.
        </p>
    varname: atvshift
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: AUTOmatisation of the PARALlelism
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         This input variable is used only when running ABINIT in parallel and for Ground-State calculations.
         <br />
         It controls the automatic determination of parameters related to parallel work distribution (if not imposed in input file).
        Given a total number of processors, ABINIT can find a suitable distribution that fill (when possible)
        all the different levels of parallelization. ABINIT can also determine optimal parameters for
        the use of parallel Linear Algebra routines (using Scalapack or Cuda, at present).
         <br />
         The different values for [[autoparal]] are:
         <ul>
          <li>
           <b>
            0:
           </b>
           The [[autoparal]] feature is deactivated. For ground-state  and response function calculations,
        ABINIT can only activate automatically the parallelism over spins and k-points.
          </li>
          <li>
           <b>
            1:
           </b>
           The number of processors per parallelization level is determined by mean of
        a simple (but relatively efficient) heuristic. A scaling factor is attributed to each level
        and an simple speedup factor is computed. The selected parameters are those giving the best speedup factor.
           <br />
           Possibly concerned parameters: [[npimage]], [[npkpt]],
        [[npspinor]], [[npfft]],
        [[npband]], [[bandpp]].
          </li>
          <li>
           <b>
            2:
           </b>
           The number of processors per parallelization level is first determined by mean of
        a simple (but relatively efficient) heuristic (see 1 above). Then the code performs a series
        of small benchmarks using the scheme applied for the LOBPCG algorithm
        (see: [[wfoptalg]]=4 or 14). The parallel distribution is then
        changed according to the benchmarks.
           <br />
           Possibly concerned parameters: [[npimage]], [[npkpt]],
        [[npspinor]], [[npfft]],
        [[npband]], [[bandpp]].
          </li>
          <li>
           <b>
            3:
           </b>
           Same as [[autoparal]]=1, plus automatic determination of Linear Algebra routines parameters.
           <br />
           In addition, the code performs a series of small benchmarks using the Linear Algebra routines
        (ScaLapack or Cuda-GPU). The parameters used to optimize Linear Algebra work distribution
        are then changed according to the benchmarks.
           <br />
           Possibly concerned parameters (in addition to those modified for [[autoparal]]=1):
        [[use_slk]], [[np_slk]],
        [[gpu_linalg_limit]]
          </li>
          <li>
           <b>
            4:
           </b>
           combination of [[autoparal]]=2 and [[autoparal]]=3.
          </li>
         </ul>
         Note that [[autoparal]]=1 can be used on every set of processors; [[autoparal]] &gt; 1 should be used on a sufficiently large number of MPI process.
         <br />
         Also note that [[autoparal]] can be used simultaneously with
        [[max_ncpus]]; in this case, ABINIT performs
        an optimization of process distribution for each total number of processors from 2
        to [[max_ncpus]].
        A weight is associated to each distribution and the higher this weight is the better the distribution is.
        After having printed out the weights, the code stops.
        </p>
    varname: autoparal
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: evaluate the Adler-Wiser expression of $\chi^{0}_{KS}$ assuming Time-Reversal
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         This input variable defines whether the irreducible polarizability $\chi^{0}_{KS}$ is evaluated
        taking advantage of time-reversal symmetry or not.
         <ul>
          <li>
           0 =&gt; Use the "standard" Adler-Wiser expression without assuming time-reversal symmetry.
        In this case, the irreducible polarizability is calculated summing over all possible electronic
        transitions (both resonant and antiresonant).
          </li>
          <li>
           1 =&gt; Take advantage of time-reversal symmetry to halve the number of transitions to be
        explicitly considered. This method leads to a decrease in the CPU time by a factor two with respect
        to the [[awtr]]=0 case.
          </li>
         </ul>
        </p>
        <p>
         Note that the parallel algorithm [[gwpara]]=2 is not compatible with
        the choice [[awtr]]=0.
        </p>
    varname: awtr
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: BAND Per Processor
    dimensions: scalar
    excludes: null
    requires: '[[paral_kgb]]==1'
    section: varpar
    text: |-
        <p>
         Control the size of the block in the LOBPCG algorithm.
        This keyword works only with [[paral_kgb]]=1 and has to be either 1 or a multiple of 2.
         <br />
         <br />
         -- With [[npband]]=1:
         <ul>
          <li>
           1 =&gt; band-per-band algorithm
          </li>
          <li>
           n =&gt; The minimization is performed using [[nband]]/n blocks of n bands.
          </li>
         </ul>
         Note: [[nband]]/n has to be an integer.
         <br />
         <br />
         -- With [[npband]]/=1:
         <ul>
          <li>
           1 =&gt; The minimization is performed using [[nband]]/[[npband]] blocks of [[npband]] bands.
          </li>
          <li>
           n =&gt; The minimization is performed using [[nband]]/([[npband]]*n) blocks of [[npband]]*n bands.
          </li>
         </ul>
         Note: [[nband]]/([[npband]]*n) has to be an integer.
         <br />
         <br />
         By minimizing a larger number of bands together in LOBPCG, we increase the convergency of the residual.
        The better minimization procedure (as concerns the convergency, but not as concerns the speed) is generally
        performed by using [[bandpp]]*[[npband]]=[[nband]].
        Put [[bandpp]]=2 when [[istwfk]]=2 (the time spent in FFTs is divided by two).
        </p>
    varname: bandpp
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 4
        value: 0
    definition: BanD limits for BERRY phase
    dimensions:
    - 4
    excludes: null
    requires: '[[berryopt]] in [1, 2, 3] and [[nberry]] > 0'
    section: varff
    text: |-
        <p>
         Give the lower band and the upper band of the set of bands
        for which the Berry phase must be computed.
        Irrelevant if [[nberry]] is not positive.
        When [[nsppol]] is 1 (no spin-polarisation),
        only the two first numbers, giving the lower and highest
        bands, are significant. Their occupation number is assumed to be 2.
        When [[nsppol]] is 2 (spin-polarized calculation),
        the two first numbers give the lowest and highest
        bands for spin up, and the third and fourth numbers
        give the lowest and highest bands for spin down.
        Their occupation number is assumed to be 1 .
        </p>
        <p>
         Presently, [[bdberry]] MUST be initialized by the user
        in case of a Berry phase calculation with [[berryopt]] = 1, 2, or 3: the above-mentioned
        default will cause an early exit.
        </p>
    varname: bdberry
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    definition: BanD for second-order EIGenvalues from Response-Function
    dimensions: scalar
    excludes: null
    requires: '[[ieig2rf]] in [1,2,3,4,5]'
    section: varrf
    text: |-
        <p>
        that is, if the user is performing second-order eigenvalue calculations using response-functions.
         <br />
         <br />
         The variable [[bdeigrf]] is the maximum number of bands for which the second-order eigenvalues must be calculated: the full number of bands is still used during the computation of these corrections.
         <br />
         <br />
         If [[bdeigrf]] is set to -1, the code will automatically set [[bdeigrf]] equal to nband.
        </p>
    varname: bdeigrf
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: BanDs for GW calculation
    dimensions:
    - 2
    - '[[nkptgw]]'
    - '[[nsppol]]'
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         For each k-point with number ikptgw in the range (1:[[nkptgw]]) and each
        spin index isppol,
         <b>
          bdgw(1,ikptgw,isppol)
         </b>
         is the number of the lowest band for which the [[GW]] computation must be done,
        and
         <b>
          bdgw(2,ikptgw,isppol)
         </b>
         is the number of the highest band for which the [[GW]] computation must be done.
        </p>
        <p>
         When [[gwcalctyp]] &#62;&#61; 20,
        the quasiparticle wavefunctions are computed and represented as linear combination of Kohn-Sham wavefunctions.
        In this case [[bdgw]] designates the range of KS wavefunctions used as basis set.
        For each k-point, indeed, the quasiparticle wavefunctions are expanded considering only the KS states between
         <b>
          bdgw(1,ikptgw,isppol)
         </b>
         and
         <b>
          bdgw(2,ikptgw,isppol)
         </b>
         .
        </p>
        <p>
        Note that the initial values given in the input file might be changed inside the code so that all
        the degenerate states at a given k-point and spin are included.
        This might happen when [[symsigma]]=1 is used or in the case of
        self-consistent [[GW]] calculations.
        </p>
        <p>
         When [[symsigma]]=1, the diagonal matrix elements of the
        self-energy are obtained by averaging the unsymmetrized results in the subspace spanned by the degenerate states.
        </p>
        <p>
         For self-consistent calculations, on the other hand, the basis set used to expand the [[GW]]
        wavefunctions should include all the degenerate states belonging to the same irreducible
        representation. Only in this case, indeed, the initial symmetries and energy degenerations are preserved.
        </p>
    varname: bdgw
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: BERRY phase OPTions
    dimensions: scalar
    excludes: null
    requires: null
    section: varff
    text: |-
        <p>
         Specifies the use of Berry phase for the computation
        of either the polarization, the derivatives with respect to the
        wavevector, or finite electric field calculations.
         <ul>
          <li>
           0 =&gt; no computation of expressions relying on a Berry phase (default)
          </li>
          <li>
           1 =&gt; the computation of Berry phases is activated (berryphase routine)
          </li>
          <li>
           2 =&gt; the computation of derivatives with respect to the wavevector,
        thanks to the Berry phase finite-difference formula, is activated (uderiv routine)
          </li>
          <li>
           3 =&gt; same as option 1 and 2 together
          </li>
        <B>Note that options 1 to 3 require the use of a serial build of Abinit.</B>
         <li>
           -1 =&gt; alternative computation of Berry phases (berryphase_new routine)
          </li>
          <li>
           -2 =&gt; alternative computation of derivatives with respect to the wavevector,
        thanks to the Berry phase finite-difference formula (berryphase_new routine)
          </li>
          <li>
           -3 =&gt; same as option -1 and -2 together
          </li>
        <B>Options -1 to -3 permit use of a parallel build and will be preferred by most users.</B>
          <li>
           4 =&gt; finite electric field calculation (unreduced E-field)
          </li>
          <li>
           6 =&gt; finite electric displacement field calculation (unreduced D-field)
          </li>
          <li>
           14 =&gt; finite reduced electric field calculation
          </li>
          <li>
           16 =&gt; finite electric displacement field calculation
          </li>
          <li>
           17 =&gt; mixed electric boundary condition: finite reduced electric field in some directions, finite reduced electric displacement field along other directions. See variable [[jfielddir]] for more details.
          </li>

         </ul>
        </p>
        <p>
         Other related input variables are :
         <ul>
          <li>
           in case of [[berryopt]]=1,2, or 3 : [[bdberry]]
        and [[kberry]]; also, [[nberry]]
        must be larger than 0;
          </li>
          <li>
           in case of [[berryopt]]=-1,-2, or -3 : the variable
        [[rfdir]] must be used to specify the primitive
        vector along which the projection of the polarization or the ddk will be computed.
        For example if [[berryopt]]=-1 and [[rfdir]]=1 0 0,
        the projection of the polarization along the reciprocal lattice vector
        G_1 is computed. In case [[rfdir]]=1 1 1,
        ABINIT computes the projection of P along G_1, G_2 and G_3 and transforms the results
        to cartesian coordinates;
          </li>
          <li>
           in cases where [[berryopt]] is negative, [[berrystep]]
        allow a computation of multiple-step Berry phase in order to accelerate the convergence.
          </li>
          <li>
           [[efield]] and
        [[rfdir]] in case of [[berryopt]]=4 ;
          </li>
         </ul>
        </p>
        <p>
         The cases [[berryopt]]=-1,-2,-3, 4, 6, 7, 14, 16, and 17 have to be used with [[occopt]]=1.
        </p>
        <p>
         The cases [[berryopt]]=-1 and 4, 6, 7, 14, 16, 17 are compatible with PAW, howevever, if in these cases one uses
        [[kptopt]]/=3, one must also use only symmorphic symmetries (either because the space group is
        symmorphic or the variable [[symmorphi]] is set to zero).
        </p>
        <p>
         For a phonon calculation under a finite electric field, respect the following procedure.
         <ul>
          <li>
           1. Run a scf ground-state calculation at zero electric field
        to get wavefunctions to initialize the ground-state calculation in finite electric fields.
          </li>
          <li>
           2. Run a scf ground-state calculation in finite electric field. The
        electric field is controlled by the input variable [[efield]].
        [[berryopt]] should be 4.
        The input variable [[kptopt]] should be set to be 2.
          </li>
          <li>
           3. Based on the wave functions obtained in step (2), perform phonon
        calculation by setting [[berryopt]]=4, [[kptopt]]=3 and
        The same value of [[efield]] than in step 2.
        [[nsym]] should be set to 1 currently but this restriction may be
        removed later . The other
        parameters are the same as phonon calculation at zero electric field.
          </li>
          <li>
           Note : the choice of k-point sampling N x N x N should be the same in the three runs
        and N should be an even number.
          </li>
         </ul>
        </p>
        <p>
         In case of finite electric and displacement field calculations ([[berryopt]]=4,6,7,14,16,17), see also the input variables
        [[berrysav]], [[dfield]],
        [[red_dfield]], [[red_efield]],
        [[ddamp]]
        </p>
    varname: berryopt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: BERRY SAVe
    dimensions: scalar
    excludes: null
    requires: null
    section: varff
    text: |-
        <p>
         <ul>
          <li>
           0 =&gt; for finite electric field calculation ([[berryopt]]=4/14), the polarization branch will be chosen on each iteration from (-pi, pi);
        for finite electric displacement field calculation([[berryopt]]=6/7/16/17), the polarization will be chosen to minimize the internal energy.
          </li>
          <li>
           1 =&gt; the polarization will be kept in the same branch on each iteration. At the end of the run, a file "POLSAVE" will be saved containing the reduced polarization in atomic units. Note: Make sure that "POLSAVE" is empty or it does not exist before the calculation, or else that it specifies the desired polarization branch.
          </li>
         </ul>
        </p>
    varname: berrysav
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'BERRY phase : multiple STEP'
    dimensions: scalar
    excludes: null
    requires: 0 > [[berryopt]]
    section: varff
    text: |-
        <p>
         If [[berryopt]] is negative,
        this variable is used to compute berry phases using multiple discrete steps, in order to accelerate convergence. The single-step berry phase
        is the standard calculation using strings of k-points based on overlap of Bloch function separated by dk, while the two-step
        berry phase use strings use overlaps based on dk and 2*dk, the three-step use overlaps based on dk, 2*dk and 3*dk...
        </p>
        <p>
         The default value of this variable is 1, meaning that only the single-step berry phase calculation is done.
        If a larger value is set, ABINIT will compute all the multiple-step berry phase from the single-step to the
        [[berrystep]]-step, and use the large-step values of berry phase to correct the single-step berry phase.
        Use with care: while experience is still to be gained with this procedure, the outlook is promising.
        </p>
    varname: berrystep
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: finite B FIELD calculation
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varff
    text: |-
        <p>
         Perform finite magnetic field calculation. <br><b>THIS CODE IS UNDER DEVELOPMENT AND IS NOT READY FOR USE.</b>
        </p>
    varname: bfield
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: Barostat MASS
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         bmass is the mass of the barostat when
        [[ionmov]]=13 (constant pressure molecular dynamics)
        </p>
    varname: bmass
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.5
    - 0.5
    - 0.5
    definition: BOX CENTER
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Defines the center of the box, in reduced coordinates.
        At present, this information is only used in the case of
        Time-Dependent DFT computation of the oscillator strength.
        One must take boxcenter such as to be roughly the center of
        the cluster or molecule. The default is sensible when
        the vacuum surrounding the cluster or molecule has xred 0 or 1.
        On the contrary, when the cluster or molecule is close to
        the origin, it is better to take [[boxcenter]]=(0 0 0).
        </p>
    varname: boxcenter
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    definition: BOX CUT-off MINimum
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         The box cut-off ratio is the ratio between the wavefunction plane wave sphere
        radius, and the radius of the sphere that can be inserted in the
        FFT box, in reciprocal space. In order for the density to be exact
        (in the case of plane wave, not PAW), this ratio should be at least two.
        If one uses a smaller ratio, one will gain speed, at the expense of accuracy.
        In case of pure ground state calculation (e.g. for the determination
        of geometries), this is sensible. However,
        the wavefunctions that are obtained CANNOT be used for starting response function
        calculation.
        </p>
    varname: boxcutmin
    vartype: real
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: BRaVais LaTTice type
    dimensions: scalar
    excludes: null
    requires: '[[spgroup]] != 0'
    section: vargeo
    text: |-
        <p>
         Set the type of Bravais lattice.
        The cell defined by [[acell]]
        and [[rprim]] or [[angdeg]]
        should be the CONVENTIONAL cell.
        </p>
        <p>
         If brvltt=0, the code will assign
        brvltt from the space group information
        [[spgroup]],
        and produce the symmetry operations for the conventional unit cell.
        If the conventional cell is not primitive, the user should
        set [[chkprim]]=0.
        </p>
        <p>
         If brvltt=-1, the code will assign brvltt from
        the space group information, then reduce the unit cell
        to a primitive unit cell. The echo of [[acell]]
        and [[rprim]] might thus differ from those
        derived directly from the input variables.
        Also, the input variable
        [[xred]] will refer to the
        CONVENTIONAL unit cell, but its echo will refer to the
        preprocessed PRIMITIVE unit cell.
        There is of course no problem with
        [[xangst]] and
        [[xcart]], as they are independent
        of the unit cell.
        </p>
        <p>
         The echo of [[brvltt]] in the output file will be one
        of the following Bravais lattices:
         <br />
         <ul>
          <li>
           1 = Primitive with no associated translations
          </li>
          <li>
           2 = Inner centered with (a/2 + b/2 + c/2)
        associated translation
          </li>
          <li>
           3 = Face centered with (a/2 + b/2; b/2 + c/2; c/2 + a/2)
        associated translations
          </li>
          <li>
           4 = C - centered with (a/2 + b/2) associated translation
          </li>
          <li>
           5 = A - centered with (b/2 + c/2) associated translation
          </li>
          <li>
           6 = B - centered with (c/2 + a/2) associated translation
          </li>
          <li>
           7 = Rhombohedral lattice.
          </li>
         </ul>
         The user might also input directly these values, although
        they might not be consistent
        with [[spgroup]].
        </p>
        <p>
         The space groups 146, 148, 155, 160, 161, 166, 167, when used
        with [[spgaxor]]=1 (hexagonal axes) will have [[brvltt]]=7
        and two associated translations: (2/3, 1/3, 1/3) and
        (1/3, 2/3, 2/3).
         <br />
         For more details see the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         .
        </p>
    varname: brvltt
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: Bethe-Salpeter ALGORITHM
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
         The bs_algorithm input variable defines the algorithm employed to calculate the macroscopic dielectric function.
        Possible values are 1, 2 or 3:
         <ul>
          <li>
           1 =&gt;
        The macroscopic dielectric is obtained by performing a direct diagonalization of the excitonic Hamiltonian.
        Advantages: It gives direct access to the excitonic eigenvalues as well as to the oscillator strengths.
        Drawbacks: It is a very CPU- and memory-consuming approach as the size of the Hamiltonian scales as (nk*nc*nv)**2.
        where nk is the number of k-point in the FULL Brillouin zone, and nc and nv are the number of
        conduction and valence states, respectively.
        Pros: It can be used both for resonant-only and resonant+coupling calculations (non Tamm-Dancoff approximation).
          </li>
          <li>
           2 =&gt;
        Haydock iterative method. The macroscopic dielectric function
        is obtained by iterative applications of the Hamiltonian on a set of vectors in the electron-hole space.
        Advantages: It is less memory demanding and usually faster
        than the direct diagonalization provided that [[zcut]] is larger than the typical
        energy spacing of the eigenvalues. Drawbacks: It is an iterative method therefore
        the convergence with respect to bs_haydock_niter should be checked.
        It is not possible to have direct information on the exciton spectrum, oscillator strengths and excitonic wave functions.
        For the time being [[bs_algorithm]]=2 cannot be used for calculations in which the coupling term is included (Tamm-Dancoff approximation).
          </li>
          <li>
           3 =&gt;
        Conjugate-gradient method. This method allows to find the few first excitonic eigenvalues.
        Only available for resonant calculations (Tamm-Dancoff approximation).
          </li>
         </ul>
        </p>
    varname: bs_algorithm
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Bethe-Salpeter CALCulation TYPE
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
         Possible values are 1,2,3.
         <ul>
          <li>
           1 =&gt; use the KS eigenvalues and wave functions stored in the KSS file
        to construct the transition space
          </li>
          <li>
           2 =&gt; The transition space is constructed with Kohn-Sham orbitals
        but the energies are read from the external [[GW]] file
          </li>
          <li>
           3 =&gt; QP amplitudes and energies will be read from the QPS file and used to construct H_ex.
        Not coded yet because &lt;\psi|r|\psj&gt;^QP should be calculated taking into account the non-locality of
        the self-energy in the commutator [H,r].
          </li>
         </ul>
        </p>
    varname: bs_calctype
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 11
    definition: Bethe-Salpeter COULOMB TERM
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
        This variable governs the choice among the different options that are available for the treatment
        of Coulomb term of the [[BETHE_SALPETER]] Hamiltonian.
        [[bs_coulomb_term]] is the concatenation of two digits, labelled (A) and (B).
        </p>
        <p>
         The first digit (A) can assume the values 0,1,2:
         <ul>
          <li>
           0 =&gt; The Coulomb term is not computed. This choice is equivalent to computing the RPA
        spectrum but using the representation in transition space instead of the
        more efficient approach based on the sum over states.
          </li>
          <li>
           1 =&gt; The Coulomb term is computed using the screened interaction read from an external SCR file
        (standard excitonic calculation).
          </li>
          <li>
           2 =&gt; The Coulomb term is computed using a model screening function
        (useful for convergence studies or for reproducing published results).
          </li>
         </ul>
        </p>
        <p>
         The second digit (B) can assume the values 0,1:
         <ul>
          <li>
           0 =&gt;
        Use a diagonal approximation for W_GG' (mainly used for accelerating convergence studies).
          </li>
          <li>
           1 =&gt;
        The Coulomb term is correctly evaluated using the truly non-local W(r,r').
          </li>
         </ul>
        </p>
    varname: bs_coulomb_term
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Bethe-Salpeter COUPLING
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
         The [[bs_coupling]] input variable defines the treatment of the coupling block of the
        [[BETHE_SALPETER]] Hamiltonian. Possible values are 0,1.
         <ul>
          <li>
           0 =&gt;
        The coupling block is neglected (the so-called Tamm-Dancoff approximation). The code runs faster and the Hamiltonian matrix requires
        less memory (factor 4). It is a good approximation for the absorption spectrum
        which only requires the knowledge of Im(\epsilon). The reliability of this
        approximation should be tested in the case of EELF calculations.
          </li>
          <li>
           1 =&gt;
        The coupling term is included (non Tamm-Dancoff approxmation).
          </li>
         </ul>
        </p>
    varname: bs_coupling
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - -.inf
    - .inf
    definition: Bethe-Salpeter Electron-Hole CUTOFF
    dimensions:
    - 2
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
         It is used to define a cutoff in the e-h basis set. Only those transitions whose
        energy is between bs_eh_window(1) and bs_eh_window(2) will be considered during
        the construction of the e-h Hamiltonian.
        </p>
    varname: bs_eh_cutoff
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Bethe-Salpeter EXCHANGE TERM
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p><ul>
        <li>0 =&gt;The exchange term is not calculated. This is equivalent to neglecting local field effects
        in the macroscopic dielectric function.</li>
        <li>1 =&gt;The exchange term is calculated and added to the excitonic Hamiltonian.
         </li></ul></p>
    varname: bs_exchange_term
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    - 0.01
    definition: Bethe-Salpeter FREQuency MESH
    dimensions:
    - 3
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
        <b>bs_freq_mesh(1)</b> defines the first frequency for the calculation of the macroscopic dielectric function.
        <p>
        <b>bs_freq_mesh(2)</b> gives the last frequency for the calculation of the macroscopic dielectric function.
        If zero, <b>bs_freq_mesh(2)</b> is set automatically to MAX(resonant_energy) + 10%.
        <p>
        <b>bs_freq_mesh(3)</b> gives the step of the linear mesh used for evaluating the macroscopic dielectric function.
        </p>
    varname: bs_freq_mesh
    vartype: real
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Bethe-Salpeter HAYdock TERMinator
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99 and [[bs_algorithm]]==2'
    section: vargw
    text: |-
        <p>
         Defines how to terminate the continued fraction expression for the dielectric function.
        The terminator reduces the number of iterations needed to converge by smoothing the oscillation
        in the high energy part of the spectrum
         <ul>
          <li>
           0 =&gt;
        No terminator. The contribution given by the terms missing in the Lanczos chain are set to zero.
          </li>
          <li>
           1 =&gt; Use the terminator function. The particular expression depends on the type of calculation:
        In the resonant-only case, the a_i and b_i coefficients for i &gt; niter,
        are replaced by their values at i=niter.
        Even the coupling block is included, the terminator function described in D. Rocca, R. Gebauer, Y. Saad, S. Baroni, J. Chem. Phys.
        128, 154105 (2008) is used.
          </li>
         </ul>
        </p>
    varname: bs_hayd_term
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 100
    definition: Bethe-Salpeter HAYDOCK Number of Iterations
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99 and [[bs_algorithm]]==2'
    section: vargw
    text: |-
        <p>
         [[bs_haydock_niter]] defines the maximum number of iterations used to calculate the macroscopic dielectric function.
        The iterative algorithm stops when the difference between two consecutive evaluations of the optical
        spectra is less than [[bs_haydock_tol]].
        </p>
    varname: bs_haydock_niter
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.02
    - 0
    definition: Bethe-Salpeter HAYDOCK TOLerance
    dimensions:
    - 2
    excludes: null
    requires: '[[optdriver]] == 99 and [[bs_algorithm]]==2'
    section: vargw
    text: |-
        <p>
         Defines the convergence criterion for the Haydock iterative method.
        The iterative algorithm stops when the difference between two consecutive evaluations of the
        macroscopic dielectric function is less than
         <b>
          bs_haydock_tol(1)
         </b>
         .
        The sign of
         <b>
          bs_haydock_tol(1)
         </b>
         defines how to estimate the convergence error.
        A negative value signals that the converge should be reached for each frequency (strict criterion),
        while a positive value indicates that the converge error is estimated
        by averaging over the entire frequency range (mild criterion).
        </p>
        <p>
        <b>bs_haydock_tol(2)</b> defines the quantity that will be checked for convergence:
         <ul>
          <li>
           0 &rarr; both the real and the imaginary part must converge
          </li>
          <li>
           1 &rarr; only the real part
          </li>
          <li>
           2 &rarr; only the imaginary part
          </li>
         </ul>
        </p>
    varname: bs_haydock_tol
    vartype: real
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Bethe-Salpeter INTERPolation K-point MULTiplication factors
    dimensions:
    - 3
    excludes: null
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    section: vargw
    text: |-
        <p>
         [[bs_interp_kmult]] defines the number of divisions used to generate the dense mesh in the interpolation.
        [[ngkpt]] of the dense mesh =
         <b>
          bs_interp_kmult(:)
         </b>
         * [[ngkpt]] of the coarse mesh.
        </p>
    varname: bs_interp_kmult
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: Bethe-Salpeter INTERPolation Method3 WIDTH
    dimensions: null
    excludes: null
    requires: '[[bs_interp_mode]]==3 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    section: vargw
    text: |-
        Defines the width of the region where divergence treatment is applied for BSE interpolation
    varname: bs_interp_m3_width
    vartype: real
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Bethe-Salpeter INTERPolation METHOD
    dimensions: null
    excludes: null
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    section: vargw
    text: |-
        <p>
         [[bs_interp_method]] selects the method of interpolation:
         <ul>
          <li>
           0 =&gt; Interpolate using Y. Gillet technique with 8 neighbours (see Comput. Phys. Commun. 203, 83 (2016))
          </li>
          <li>
           1 =&gt; Interpolation using Rohlfing & Louie technique (see above-mentioned article and Phys. Rev. B 62, 4927 (2000))
          </li>
         </ul>
        </p>
    varname: bs_interp_method
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Bethe-Salpeter INTERPolation MODE
    dimensions: scalar
    excludes: null
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    section: vargw
    text: |-
        <p>
         [[bs_interp_mode]] selects the mode of interpolation:
         <ul>
          <li>
           0 =&gt; No interpolation. Standard [[BETHE_SALPETER]] computation is performed
          </li>
          <li>
           1 =&gt; Simple interpolation
          </li>
          <li>
           2 =&gt; Treatment of the divergence on the whole set of dense k-points
          </li>
          <li>
           3 =&gt; Treatment of the divergence along the diagonal in k-space and simple interpolation elsewhere.
          </li>
         </ul>
        </p>
    varname: bs_interp_mode
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Bethe-Salpeter INTERPolation PREParation
    dimensions: scalar
    excludes: null
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_coupling]]==0'
    section: vargw
    text: |-
        <p>
         [[bs_interp_prep]] allows to trigger the preparation of the interpolation with method 2 or method 3.
        It generates the decomposition of BSR in a,b,c coefficients used for the interpolation.
        </p>
    varname: bs_interp_prep
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Bethe-Salpeter INTERPolation Rohlfing & Louie NeighBour
    dimensions: null
    excludes: null
    requires: '[[bs_interp_mode]] > 0 and [[bs_algorithm]]==2 and [[bs_interp_method]]
        == 1 and [[bs_coupling]]==0'
    section: vargw
    text: |-
        Gives the index of the neighbour that is used for Rohlfing & Louie method
    varname: bs_interp_rl_nb
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Bethe-Salpeter Lowest Occupied BAND
    dimensions:
    - '[[nsppol]]'
    excludes: null
    requires: '[[optdriver]] == 99'
    section: vargw
    text: |-
        <p>
         This variable defines the index of the lowest occupied band used for the construction of the electron-hole basis set.
        For spin polarized calculations, one must provide two separated indices for spin up and spin down.
        An additional cutoff energy can be applied by means of the bs_eh_window input variable.
        </p>
    varname: bs_loband
    vartype: integer
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Bethe-Salpeter Number of States
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] == 99 and [[bs_algorithm]] in [2,3]'
    section: vargw
    text: |-
        <p>
         [[bs_nstates]] defines the maximum number of excitonic states calculated in
        the direct diagonalization of the excitonic matrix or in the conjugate-gradient method.
        The number of states should be sufficiently large
        for a correct description of the optical properties in the frequency range of interest.
        </p>
    varname: bs_nstates
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: BUIT-IN TEST number
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
        When [[builtintest]] is non-zero, the input file is a special one, that runs very quickly,
        and that is accompanied by a specific analysis by ABINIT, at the end of the run, against
        a hard-coded value of total energy (and possibly stresses, forces ...).
        The echo of the analysis is done in the STATUS file.
        In particular, such built-in tests can be used to check quickly
        whether ABINIT fallbacks have been connected or not (bigdft, etsf_io, libxc, wannier90).
        At present, [[builtintest]]=1 ... 7 are allowed. See more information in tests/built-in/README .
        </p>
    varname: builtintest
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    definition: BoX CuT-off MINimum for the Double Grid (PAW)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         The box cut-off ratio is the ratio between the wavefunction plane wave
        sphere radius, and the radius of the sphere that can be inserted in the FFT box,
        in reciprocal space.
         <br />
         If the density was generated only from wavefunctions,
        this ratio should be at least two in order for the density to be exact. If one
        uses a smaller ratio, one will gain speed, at the expense of accuracy. In case
        of pure ground state calculation (e.g. for the determination of geometries),
        this is sensible. However, the wavefunctions that are obtained CANNOT be used
        for starting response function calculation.
         <br />
         However, some augmentation charge is always added in PAW, and even with the box cut-off
        ratio larger than two, the density is never exact. Sometimes, this ratio must be
        much larger than two for the computation to be converged at the
        required level of accuracy.
        </p>
    varname: bxctmindg
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Contour Deformation Custom Imaginary Frequencies
    dimensions: scalar
    excludes: null
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[gwcalctyp]] in [2,9,12,19,22,29]
    section: vargw
    text: |-
        <p>
         [[cd_customnimfrqs]] lets the user define the grid points along the imaginary axis by hand. Set this
        to the number of frequencies you want. The frequencies are specified with [[cd_imfrqs]].
        </p>
    varname: cd_customnimfrqs
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Contour Deformation Imaginary Frequency integration Method
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4  and [[gwcalctyp]] in [2,9,12,19,22,29]'
    section: vargw
    text: |-
        <p>
         [[cd_frqim_method]] defines the choice of integration method along the imaginary frequency axis
        for Contour Deformation calculations. The default method is very robust, fast and optimal for the
        vast majority of cases. However, for very accurate (&ldquo;paranoid level&rdquo;) convergence studies,
        ABINIT offers the possibility of a variety of methods and grids. Note that as one starts to change
        the defaults, one needs to carefully consider the grid used. Therefore we recommend that in
        addition to reading the information below, the user reads the description of the
        input variables [[freqim_alpha]],
        [[nfreqim]], [[ppmfrq]],
        [[gw_frqim_inzgrid]].
        </p>
        <p>
         The integration to be performed for each matrix element of the self energy along the imaginary axis is of the form:
        </p>
        <p align="center">
         <img style="width: 461px; height: 49px;" src="../vargw_img/self_energy_cd.png" />
        </p>
        <p>
         Where
         <span style="font-family:Times,Serif">
          <i>
           &omega;
          </i>
         </span>
         is the frequency point along the real axis,
         <span style="font-family:Times,Serif">
          <i>
           &epsilon;
           <sub>
            s
           </sub>
          </i>
         </span>
         is an eigenvalue,
        and
         <span style="font-family:Times,Serif">
          <i>
           i&omega;'
          </i>
         </span>
         is the variable along the
        imaginary axis. Thus the function to be integrated
        is a Lorentzian weight function centred on the origin (whose FWHM is decided by
        |
         <span style="font-family:Times,Serif">
          <i>
           &omega; - &epsilon;
           <sub>
            s
           </sub>
          </i>
         </span>
         |),
        times a function. The function is related to the inverse dielectric matrix. It might have a peaked structure near the origin and is very smooth otherwise. the function decays
        asymptotically as
         <span style="font-family:Times,Serif">
          1 /
          <i>
           i&omega;'
          </i>
         </span>
         , so the whole
        integral converges as this to the third power.
         <ul>
          <li>
           <b>
            cd_frqim_method = 1 - Histogram:
           </b>
           This is the
           <b>
            default
           </b>
           method where the function
           <span style="font-family:Times,Serif">
            <i>
             f(i&omega;')
            </i>
           </span>
           is approximated by a histogram,
        and the Lorentzian is integrated analytically in each sub-interval. See the section on grids
        below for a description of the default grid. This method combined with the default grid is the
        fastest and optimised for the use of few points along the imaginary axis.
          </li>
          <li>
           <b>
            cd_frqim_method = 2 - Trapezoid:
           </b>
           The next step up from the histogram approximation in the previous
        method. The integration region is transformed
           <span style="font-family:Times,Serif">
            <i>
             [0,&#8734;[ &rarr; [0,1]
            </i>
           </span>
           with a proper
        weight depending on the width of the Lorentzian. In this space
           <span style="font-family:Times,Serif">
            <i>
             f(i&omega;')
            </i>
           </span>
           is approximated by a linear function between grid points (trapezoids), and the integrand is
        integrated analytically in each sub-interval. This method tends to slightly overestimate contributions
        while the default method tends to slightly underestimate them, so the results from methods
        1 and 2 should bracket the converged values. The asymptotic behaviour is explicitly taken
        into account by a fit using the last two grid points.
          </li>
          <li>
           <b>
            cd_frqim_method = 3, 4, 5 - Natural Spline:
           </b>
           The function is transfomed
           <span style="font-family:Times,Serif">
            <i>
             [0,&#8734;[ &rarr; [0,1]
            </i>
           </span>
           . In this space
           <span style="font-family:Times,Serif">
            <i>
             f(i&omega;')
            </i>
           </span>
           is approximated by a natural spline function whose starting and ending sections are linear. This transform is chosen so that the function should approach a linear function asymptotically as the integration interval approaches 1, so that the asymptotic behaviour is automatically taken into account. For each Lorentzian width
        (determined by |
           <span style="font-family:Times,Serif">
            <i>
             &omega; - &epsilon;
             <sub>
              s
             </sub>
            </i>
           </span>
           |)
        the integrand is appropriately scaled in the interval
           <span style="font-family:Times,Serif">
            <i>
             [0,1]
            </i>
           </span>
           , and a nested Gauss-Kronrod (GK)
        numerical integration rule is performed. The integrand is evaluated at the GK nodes by means
        of a spline-fit. The order of the GK rule is controlled by the index of the method:
           <ul>
            <li>
             <b>
              3 =&gt; Gauss  7 point, Kronrod 15 point rule
             </b>
            </li>
            <li>
             <b>
              4 =&gt; Gauss 11 point, Kronrod 23 point rule
             </b>
            </li>
            <li>
             <b>
              5 =&gt; Gauss 15 point, Kronrod 31 point rule
             </b>
            </li>
           </ul>
           There is rarely any difference to machine precision between these rules, and the code will
        issue a warning if a higher-order rule is recommended.
          </li>
         </ul>
        </p>
        <p>
         <b>
          Grids for the integral along the imaginary axis:
         </b>
        </p>
        <p>
         All the methods above should execute no matter what grid is used along the imaginary axis, so this
        is very much under the control of the user. The only requirement is that the grid be strictly increasing.
        The point at zero frequency is assumed to lie on the real axis, so the calculation of that point
        is controlled by [[nfreqre]] and corresponding variables. We highly
        recommend extracting various elements of the dielectric matrix from the _SCR file using
        the
         <b>
          Mrgscr
         </b>
         utility and plotting them for visual inspection.
        </p>
        <p>
         <ul>
          <li>
           <b>
            Default
           </b>
           - The default grid is an exponentially increasing grid given by the formula:
           <p align="center">
            <img style="width: 309px; height: 46px;" src="../vargw_img/cd_default_grid.png" />
           </p>
           Here
           <span style="font-family:Times,Serif">
            <i>
             &omega;
             <sub>
              p
             </sub>
            </i>
           </span>
           is the
        plasma frequency (by default determined by the average density of the system, but this
        can be overridden by setting [[ppmfrq]]).
           <span style="font-family:Times,Serif">
            <i>
             N
            </i>
           </span>
           is the total number of grid points
        (set by [[nfreqim]]).
           <span style="font-family:Times,Serif">
            <i>
             &alpha;
            </i>
           </span>
           is a parameter which determines
        how far out the final grid point will lie. The final point will be at
           <span style="font-family:Times,Serif">
            <i>
             &alpha;&middot;&omega;
             <sub>
              p
              <sub>
              </sub>
             </sub>
            </i>
           </span>
           (the default is
           <span style="font-family:Times,Serif">
            <i>
             &alpha; = 5
            </i>
           </span>
           ,
        and was hard-coded in older versions of ABINIT).
        This grid is designed so that approximately half the grid points are always distributed
        to values lower than the plasma frequency, in order to resolve any peaked structure. If one
        seeks to increase the outermost reach by increasing [[ppmfrq]]
        one must simultaneously take care to increase [[nfreqim]]
        in order to have the appropriate resolution for the low-frequency region.
        In more recent versions of ABINIT one can also simply adjust the parameter
           <span style="font-family:Times,Serif">
            <i>
             &alpha;
            </i>
           </span>
           by using
        [[freqim_alpha]]. This grid is optimised for
        speed and accurate results with few grid points for
           <b>
            cd_frqim_method = 1
           </b>
           .
          </li>
          <li>
           <b>
            Inverse z transform
           </b>
           - This grid is activated by the use of the variable
        [[gw_frqim_inzgrid]]. This is the standard
           <span style="font-family:Times,Serif">
            <i>
             [0,&#8734;[ &rarr; [0,1]
            </i>
           </span>
           transform
        using the formula:
           <p align="center">
            <img style="width: 122px; height: 38px;" src="../vargw_img/cd_inzgrid.png" />
           </p>
           Here
           <span style="font-family:Times,Serif">
            <i>
             &omega;
             <sub>
              p
             </sub>
            </i>
           </span>
           is the
        plasma frequency (default can be overridden by setting [[ppmfrq]]).
        The grid points are then picked by an equidistant grid (number of points set by
        [[nfreqim]]) in the interval
           <span style="font-family:Times,Serif">
            <i>
             z &sub; [0,1]
            </i>
           </span>
           . This grid can easily
        be uniquely converged by just increasing [[nfreqim]]. Again
        the points are distributed so that approximately half of them lie below the plasma frequency.
          </li>
          <li>
           <b>
            User defined
           </b>
           - The user can also define their own grid using the variables [[cd_customnimfrqs]]
           and [[cd_imfrqs]]
           .
           <i>
            With great power comes great responsibility!
           </i>
          </li>
         </ul>
        </p>
        <p>
         The
         <b>
          Mrgscr
         </b>
         utility is handy in optimising the numerical effort expended in convergence studies.
        By estimating the densest grid one can afford to calculate in the SCR file, and successively removing
        frequencies from a single file (using the utility), one only needs to perform the screening
        calculation
         <b>
          once
         </b>
         on the dense mesh for a given convergence study. One can also use the utility to
        merge independent screening calculations over q-points and frequency sections.
        </p>
    varname: cd_frqim_method
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Contour Deformation Full Grid in complex plane
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,9,12,19,22,29]'
    section: vargw
    text: |-
        <p>
         [[cd_full_grid]] enables the calculation of the screening [both chi0 and epsilon^(-1)] on a grid in the first
        quadrant of the complex plane. The grid is determined by the (tensor) product of the grid in real frequency and
        the grid in imaginary frequency. In the SUS and SCR files the grid points are stored as follows:
         <pre>
          <b>
           Index:
          </b>
          1   . . .   nfreqre   nfrqre+1 . . . nfreqre+nfreqim   nfreqre+nfreqim+1 . . . nfreqre*nfreqim
          <b>
           Entry:
          </b>
          | purely real freq.  |     purely imaginary freq.     |      gridpoints in complex plane        |
         </pre>
         The grid in the complex plane is stored looping over the real dimension as the inner loop and the imaginary as
        the outer loop. The contents of the generated SUS and SCR files can be extracted for visualisation and further
        analysis with the
         <b>
          Mrgscr
         </b>
         utility.
        </p>
    varname: cd_full_grid
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 100.0
    definition: Contour Deformation tangent grid Halfway Frequency
    dimensions: scalar
    excludes: null
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[gwcalctyp]] in [2,9,12,19,22,29]
    section: vargw
    text: |-
        <p>
         [[cd_halfway_freq]] determines the frequency where half of the number of points defined in
        [[nfreqre]] are used up. The tangent transformed grid is approximately
        linear up to this point. To be used in conjunction with [[gw_frqre_tangrid]].
        </p>
    varname: cd_halfway_freq
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Contour Deformation Imaginary Frequencies
    dimensions:
    - '[[cd_customnimfrqs]]'
    excludes: null
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,9,12,19,22,29] and
        [[cd_customnimfrqs]] != 0'
    section: vargw
    text: |-
        <p>
         [[cd_imfrqs]] specifies the grid points for the imaginary axis.  The number of frequencies
        is set by the value of [[cd_customnimfrqs]]. Example:
         <pre>
        cd_customnimfrqs   5
        nfreqim            5
        cd_imfrqs          0.1  0.2  0.5  1.0  5.0
         </pre>
         If [[nfreqim]] is not equal to
        [[cd_customnimfrqs]] a warning will be issued.
        </p>
        <p>
         <b>
          Use at own risk!
         </b>
         The use of a custom grid makes it your responsibility that the SUS and
        SCR files are valid in self-energy (i.e. [[optdriver]]=4)
        calculations, so caution is advised. Note that frequencies have to be strictly increasing, and the
        point at zero frequency is
         <b>
          not
         </b>
         considered to be part of the imaginary grid, but rather
        the grid along the real axis. The calculation of that point should be controlled by
        [[nfreqre]] and related variables.
        </p>
        <p>
        </p>
    varname: cd_imfrqs
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 1000.0
    definition: Contour Deformation grid Maximum Frequency
    dimensions: scalar
    excludes: null
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[gwcalctyp]] in [2,9,12,19,22,29]
    section: vargw
    text: |-
        <p>
         [[cd_max_freq]] determines the frequency where all the points defined in
        [[nfreqre]] are used up. To be used in conjunction with
        [[gw_frqre_tangrid]].
        </p>
    varname: cd_max_freq
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - '[[nfreqre]]'
    definition: Contour Deformation grid calculate Subset of Frequencies
    dimensions:
    - 2
    excludes: null
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,9,12,19,22,29] and  [[gw_frqre_tangrid]]==0'
    section: vargw
    text: |-
        <p>
         [[cd_subset_freq]] Specifies that only a subset of the frequencies defined by
        [[nfreqre]] are to be calculated. The first index is the start and
        the second the end, with index number 1 always being the origin. For example a calculation with
         <b>
          [[nfreqre]]=100
         </b>
         could be separated into two datasets with:
         <pre>
        subset_freq1   1   50
        subset_freq2   51  100
         </pre>
         Any resulting susceptibility (_SUS) and screening (_SCR) files can then be merged with the
         <b>
          mrgscr
         </b>
         utility.
        </p>
    varname: cd_subset_freq
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usefock]] == 1': 2
        defaultval: 0
    definition: Conjugate Gradient TYpe used for Hartree Fock exact exchange
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Gives how is calculated Fock exact exchange contribution in the conjugate gradient,
        in the SCF case.
         <br />
        The value 2 corresponds to calculate the Fock
        exact exchange contribution each time in the conjugate gradient. The value 1 corresponds to calculate the Fock
        exact exchange contribution only for the initial guess (not for the gradient direction) in the conjugate gradient
        </p>
    varname: cgtyphf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: CHARGE
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Used to establish charge balance between
        the number of electrons filling the bands and the
        nominal [[charge]] associated with the atomic cores.
         <br />
         The code adds up the number of valence electrons
        provided by the pseudopotentials of each type
        (call this "zval"), then add [[charge]], to get the
        number of electrons per unit cell,
        [[nelect]].
         <br />
         Then, if [[iscf]] is positive,
        the code adds up the band occupancies (given in
        array [[occ]]) for all bands at each k point,
        then multiplies
        by the k point weight [[wtk]] at each k point.
        Call this sum "nelect_occ" (for the number of electrons
        from occupation numbers).  It is then
        required that:
         <br />
         nelect_occ = nelect
         <br />
         To treat a neutral
        system, which is desired in nearly all cases, one must
        use [[charge]]=0.  To treat a system missing one electron
        per unit cell, set [[charge]]=+1.
        </p>
    varname: charge
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: spatially varying CHEMical POTential
    dimensions:
    - 3
    -   -   - nzchempot
    -   -   - ntype
    excludes: null
    requires: '[[nzchempot]]/=0'
    section: vargeo
    text: |-
        For each type of atoms, from 1 to [[ntypat]], specifies the spatially varying chemical potential, through the specification of [[nzchempot]] triplets of real numbers. They give data for [[nzchempot]] delimiting planes, all parallel to each other, each determined by its z reduced coordinate.

        The first real number is the z reduced coordinate of the delimiting plane. The second real number is the value of the chemical potential for this type of atom on this plane. The third real number is the derivative of the chemical potential fior this type of atom with respect to the z reduced coordinate, evaluated on this plane.

        In the space between delimiting planes, a piecewise cubic polynomial interpolation is determined : the cubic polynomial between two delimiting planes will have the imposed chemical potentials and derivatives on the two delimiting planes.

        The z reduced coordinates must be ordered in increasing values, and cannot span more than 1.0 . There is an automatic periodic boundary condition imposed. Specifying two identical z reduced coordinates is allowed, and means that the first one applies to the adjacent space with lower values of z, while the second applies to the adjacent space with higher values of z.

        When the spatial chemical potential is defined only for one type of atom (and no chemical potential is present for the other atoms), simply set the related values to *0.0 in the [[chempot]] array.

        In the present input array, reduced positions, energies and derivatives of energies are mixed. Hence, although the chemical potential is an energy, one cannot use the usual energy definitions (i.e. the chemical potential is always to be input in Hartree atomic units).
    varname: chempot
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: CHecK whether the user want to EXIT
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If [[chkexit]] is 1 or 2, ABINIT
        will check whether the user wants to interrupt the run (using the keyword
        "exit" on the top of the input file or creating a file
        named "abinit.exit": see the
         <a href="../../users/abinit_help.html#chkexit">
          end of section 3.2
         </a>
         of abinit_help).
        </p>
        <p>
         If [[chkexit]]=0, the check is not performed at all
        </p>
        <p>
         If [[chkexit]]=1, the check is not performed frequently (after each SCF step)
        </p>
        <p>
         If [[chkexit]]=2, the check is performed frequently
        (after a few bands, at each k point)
        </p>
        <p>
         In all cases, the check is performed at most every 2 seconds of CPU time.
        </p>
    varname: chkexit
    vartype: integer
- !variable
    characteristics:
    - '[[SYMMETRY_FINDER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: CHecK whether the cell is PRIMitive
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If the symmetry finder is used
        (see [[nsym]]), a non-zero
        value of [[chkprim]] will make the code stop if a non-primitive
        cell is used. If [[chkprim]]=0, a warning is issued, but the run
        does not stop.
        </p>
        <p>
         If you are generating the atomic and cell geometry using
        [[spgroup]], you might
        generate a PRIMITIVE cell using
        [[brvltt]]=-1 .
        </p>
    varname: chkprim
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: CHecK SYMmetry BREAKing
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This variable governs the behaviour of the code when there are potential
        source of symmetry breaking, related e.g. to the k point grid or the presence of
        non-symmorphic translations which might not be coherent with the exchange-correlation grid.
        </p>
        <p>
         When [[chksymbreak]]=1, the code stops (or issue a warning) if :
         <ul>
          <li>
           (1) The k point grid is non-symmetric, in case
           [[kptopt]] =1, 2, or 4 ;
          </li>
          <li>
           (2) The non-symmorphic translation part of the symmetry operations has components that are not zero,
        or simple fractions, with 2, 3, 4, 6, 8 or 12 as denominators.
          </li>
         </ul>
         <br />
         When [[chksymbreak]] is zero, there is no such check.
         <br />
         When [[chksymbreak]] is minus 1, the code stops if the condition (1) is met, but in case the condition (2) is met, there will be a trial
        to shift the atomic coordinates such as to obtain symmetry operations with the adequate non-symmorphic part.
        </p>
        <p>
         Explanation :
         <br />
         In the ground-state calculation, such breaking of the symmetry is usually harmless. However, if the user is doing a
        calculation of phonons using DFPT ([[rfphon]]=1), the convergence with respect to the number of k points will
        be much worse with a non-symmetric grid than with a symmetric one. Also, if the user is doing a [[GW]] calculation, the
        presence of non-symmorphic translations that are not coherent with the FFT grid might cause
        problems.
        In the [[GW]] part, indeed, one needs to reconstruct the wavefunctions in the full Brillouin zone for
        calculating both the polarizability and the self-energy.
        The wavefunctions in the full Brillouin zone are obtained from the irreducible wedge by applying the symmetry
        operations of the space group of the crystal.
        In the present implementation, the symmetrization of the wavefunctions is done in real space on the FFT mesh
        that, therefore, has to be coherent both with the rotational part as well as with the fractional translation
        of each symmetry operation.
        If the condition (2) is met, the [[GW]] code will not be able to find a symmetry-preserving FFT mesh.
         <br />
         So, it was decided to warn the user about these possible problems already at the level of the ground state calculations,
        although such warning might be irrelevant.
         <br />
         If you encounter a problem outlined above, you have two choices : change your atomic positions (translate them) such that the origin
        appears as the most symmetric point ; or ignore the problem, and set [[chksymbreak]]=0 .
        </p>
    varname: chksymbreak
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'CHarge NEUTrality treatment '
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        Set the treatment of the Charge Neutrality requirement for the effective charges.
        Same meaning as the corresponding anaddb variable.
    varname: chneut
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 7
    definition: 'Climbing-Image Nudged Elastic Band: STARTing iteration'
    dimensions: scalar
    excludes: null
    requires: '[[imgmov]]== 5 and [[neb_algo]]==2'
    section: varrlx
    text: |-
        <p>
         Gives the index of the first CI-NEB iteration..
         <br />
         The CI-NEB method constitutes a small modification to the NEB method allowing a rigorous
        convergence to the saddle point. As the image with the highest energy has to be identified,
        the calculation begins with several iterations of the standard NEB algorithm.
        The effective CI-NEB begins at the [[cineb_start]] iteration.
         <br />
         <i>
          See: J. Chem. Phys. 113, 9901 (2000).
         </i>
        </p>
    varname: cineb_start
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: CPU time limit in Hours
    dimensions: scalar
    excludes: specified([[cpum]]) or specified([[cpus]])
    requires: null
    section: vargs
    text: |-
        <p>
        Only one of the three real parameters [[cpus]], [[cpum]] and [[cpuh]] can be defined in the input file to set up a CPU time limit.
        When the job reaches that limit, it will try to end smoothly.
        However, note that this might still take some time.
        If the user want a firm CPU time limit, the present
        parameter must be reduced sufficiently. Intuition
        about the actual margin to be taken into account
        should come with experience ...
         <br />
        A zero value has no action of the job.
        </p>
    varname: cpuh
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: CPU time limit in Minutes
    dimensions: scalar
    excludes: specified([[cpum]]) or specified([[cpus]])
    requires: null
    section: vargs
    text: |-
        <p>
        Only one of the three real parameters [[cpus]], [[cpum]] and [[cpuh]] can be defined in the input file to set up a CPU time limit.
        When the job reaches that limit, it will try to end smoothly.
        However, note that this might still take some time.
        If the user want a firm CPU time limit, the present
        parameter must be reduced sufficiently. Intuition
        about the actual margin to be taken into account
        should come with experience ...
         <br />
        A zero value has no action of the job.
        </p>
    varname: cpum
    vartype: real
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: CPU time limit in seconds
    dimensions: scalar
    excludes: specified([[cpum]]) or specified([[cpus]])
    requires: null
    section: vargs
    text: |-
        <p>
         Only one of the three real parameters [[cpus]], [[cpum]] and [[cpuh]] can be defined in the input file to set up a CPU time limit.
        When the job reaches that limit, it will try to end smoothly.
        However, note that this might still take some time.
        If the user want a firm CPU time limit, the present
        parameter must be reduced sufficiently. Intuition
        about the actual margin to be taken into account
        should come with experience ...
         <br />
        A zero value has no action of the job.
        </p>
    varname: cpus
    vartype: real
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    definition: '3rd Derivative of Energy, mixed PERTurbation 1: limits of
        ATomic POLarisations'
    dimensions:
    - 2
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Controls the range of atoms for which displacements will be considered
        in non-linear computations (using the 2n+1 theorem), for the 1st perturbation.<br />
        May take values from 1 to [[natom]], with
        <b>d3e_pert1_atpol</b>(1)&lt;=<b>d3e_pert1_atpol</b>(2).<br />
        See [[rfatpol]] for additional details.
        </p>
    varname: d3e_pert1_atpol
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 1: DIRections'
    dimensions:
    - 3
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Gives the directions to be considered in non-linear computations
        (using the 2n+1 theorem), for the 1st perturbation.<br />
        The three elements corresponds to the three primitive
        vectors, either in real space (atomic displacement),
        or in reciprocal space (electric field perturbation).<br />
        See [[rfdir]] for additional details.
        </p>
    varname: d3e_pert1_dir
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 1: ELectric
        FielD'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Turns on electric field perturbation in non-linear computation, as 1st perturbation.
        Actually, such calculations requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the electric field perturbation itself.<br />
        See [[rfelfd]] for additional details.
        </p>
    varname: d3e_pert1_elfd
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 1: PHONons'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Turns on atomic displacement perturbation in non-linear computation, as 1st perturbation.<br />
        See [[rfphon]] for additional details.
        </p>
    varname: d3e_pert1_phon
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    definition: '3rd Derivative of Energy, mixed PERTurbation 2: limits of
        ATomic POLarisations'
    dimensions:
    - 2
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Controls the range of atoms for which displacements will be considered
        in non-linear computations (using the 2n+1 theorem), for the 2nd perturbation.<br />
        May take values from 1 to [[natom]], with
        <b>d3e_pert2_atpol</b>(1)&lt;=<b>d3e_pert2_atpol</b>(2).<br />
        See [[rfatpol]] for additional details.
        </p>
    varname: d3e_pert2_atpol
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 2: DIRections'
    dimensions:
    - 3
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Gives the directions to be considered in non-linear computations
        (using the 2n+1 theorem), for the 2nd perturbation.<br />
        The three elements corresponds to the three primitive
        vectors, either in real space (atomic displacement),
        or in reciprocal space (electric field perturbation).<br />
        See [[rfdir]] for additional details.
        </p>
    varname: d3e_pert2_dir
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 2: ELectric
        FielD'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Turns on electric field perturbation in non-linear computation, as 2nd perturbation.
        Actually, such calculations requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the electric field perturbation itself.<br />
        See [[rfelfd]] for additional details.
        </p>
    varname: d3e_pert2_elfd
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 2: PHONons'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Turns on atomic displacement perturbation in non-linear computation, as 2nd perturbation.<br />
        See [[rfphon]] for additional details.
        </p>
    varname: d3e_pert2_phon
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    definition: '3rd Derivative of Energy, mixed PERTurbation 3: limits of
        ATomic POLarisations'
    dimensions:
    - 2
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Controls the range of atoms for which displacements will be considered
        in non-linear computations (using the 2n+1 theorem), for the 3rd perturbation.<br />
        May take values from 1 to [[natom]], with
        <b>d3e_pert3_atpol</b>(1)&lt;=<b>d3e_pert3_atpol</b>(2).<br />
        See [[rfatpol]] for additional details.
        </p>
    varname: d3e_pert3_atpol
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 3: DIRections'
    dimensions:
    - 3
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Gives the directions to be considered in non-linear computations
        (using the 2n+1 theorem), for the 3rd perturbation.<br />
        The three elements corresponds to the three primitive
        vectors, either in real space (atomic displacement),
        or in reciprocal space (electric field perturbation).<br />
        See [[rfdir]] for additional details.
        </p>
    varname: d3e_pert3_dir
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 3: ELectric
        FielD'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Turns on electric field perturbation in non-linear computation, as 3rd perturbation.
        Actually, such calculations requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the electric field perturbation itself.<br />
        See [[rfelfd]] for additional details.
        </p>
    varname: d3e_pert3_elfd
    vartype: integer
- !variable
    characteristics:
    - '[[NONLINEAR]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: '3rd Derivative of Energy, mixed PERTurbation 3: PHONons'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==5 (non-linear response computations)'
    section: varrf
    text: |-
        <p>
        Turns on atomic displacement perturbation in non-linear computation, as 3rd perturbation.<br />
        See [[rfphon]] for additional details.
        </p>
    varname: d3e_pert3_phon
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    definition: electric Displacement field DAMPing parameter
    dimensions: scalar
    excludes: null
    requires: '[[berryopt]] = 6 or 16'
    section: varff
    text: |-
        <p>
         In case [[berryopt]]=6,
        the electric field is updated after each SCF iteration according to
        E_{n+1}= [[ddamp]]*(D - 4*pi*P_{n}) + (1-[[ddamp]])*E_{n}
        where P_{n} and E_{n} are the polarization and electric field after nth SCF iteration.
        [[ddamp]] is a damping parameter used to control the convergence speed.
         <br />
         In case [[berryopt]]=16, the electric field is updated after each SCF iteration according to
        e_{n+1}= [[ddamp]]*(d - p_{n}) + (1-[[ddamp]])*e_{n}
         <br />
         If you have difficulty getting convergence, try to reduce this value or reduce maxestep.
        This parameter is used in finite electric displacement field calculations (berryopt=6,16,17).
        </p>
    varname: ddamp
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: 'Derivative DatabBase: Number of Grid points for Q-PoinTs'
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable is mandatory when [[optdriver]]==7.
        It defines the number of divisions in the (homogeneous) q-mesh
        used to generate the DDB file. See also the description of the [[getddb]] input variable.
    varname: ddb_ngqpt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    - 0.0
    definition: 'Derivative DatabBase: SHIFT of the Q-points '
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vareph
    text: |-
        Only relevant when [[optdriver]]==7.
        It defines the shift in the q-mesh used to generate the DDB file,
        which is defined by the [[ddb_ngqpt]] input variable.
        See [[shiftk]] for more information on the definition.
    varname: ddb_shiftq
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: DELAY between trials to PERMUTE atoms
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Delay (number of time steps) between trials to permute
        two atoms, in
        view of accelerated search of minima. Still in development. See the
        routine moldyn.F90. See also [[signperm]].
        When [[delayperm]] is zero, there is not permutation trials.
        </p>
    varname: delayperm
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[ionmov]]==4 and [[iscf]]==5': '3'
        '[[paral_kgb]]==1': '6'
        defaultval: 2
    definition: DENSity and FORces PREDictor
    dimensions: scalar
    excludes: null
    requires: '[[iscf]] >0'
    section: vardev
    text: |-
        <p>
         Used when [[iscf]]&gt;0, to define:
         <br />
         - the way a change of density is derived from a change of atomic position,
         <br />
         - the way forces are corrected when the SCF cycle is not converged.
         <br />
         <br />
         Supported values :
         <ul>
          <li>
           0 =&gt; density not changed (fixed charge), forces not corrected
          </li>
          <li>
           1 =&gt; density not changed, forces corrected with rigid ion hypothesis (atomic charge moved with atom)
          </li>
          <li>
           2 =&gt; density changed and forces corrected with rigid ion hypothesis (atomic charge moves with atom)
          </li>
          <li>
           3 =&gt; density changed and forces corrected with a different implementation of the rigid ion hypothesis
          </li>
          <li>
           4 =&gt; density not changed, forces corrected with the use of Harris functional formula (*)
          </li>
          <li>
           5 =&gt; density changed using D. Alfe 2nd-order algorithm (**), forces not corrected
          </li>
          <li>
           6 =&gt; density changed using D. Alfe 2nd-order algorithm (**) and forces corrected with the use of Harris functional formula (*)
          </li>
         </ul>
         No meaning for RF calculations.
         <br />
         <br />
         For the time being,
         <br />
         - the choice 3 must be used with [[ionmov]]=4
        and [[iscf]]=5.
         <br />
         - the choices 4, 5 or 6 must be used when band-FFT parallelism is selected.
         <br />
         Otherwise, use the choice 2.
         <br />
         <br />
         <b>
          (*)
         </b>
         <u>
         Note concerning the use of [[densfor_pred]]=4 or 6 (correction of forces)
         </u>
         :
         <br />
         The force on the atom located at R is corrected by the addition of the following term:
         <br />
         <i>
          F_residual=Int[dr.V_residual.dRho_atomic/dR]
         </i>
         ,  where Rho_atomic is an atomic (spherical) density.
         <br />
         - When such an atomic density (Rho_atomic) is found in the pseudopotential or PAW file, it is used. If not, a gaussian density
        (defined by [[densty]] parameter) is used.
         <br />
         - When SCF mixing is done on the density ([[iscf]]&gt;=10), the potential residual (V_residual)
        is obtained from the density residual with the first order formula
         <i>
          V_residual=dV/drho.Rho_residual
         </i>
         and uses the exchange-correlation kernel
         <i>
          dVxc/drho=Kxc
         </i>
         which computation is time-consuming for GGA functionals.
        By default the LDA exchange-correlation kernel is used (even for GGA, for which it seems to give a reasonable accuracy).
        Using the exact GGA exchange correlation kernel is always possible by giving a negative value to [[densfor_pred]].
         <br />
         <br />
         <b>
          (**)
         </b>
         <u>
          Note concerning the use of [[densfor_pred]]=5 or 6 (density prediction)
         </u>
         :
         <br />
         The algorithm is described in
         <i>
          Computer Physics Communications
          <b>
           118
          </b>
          (1999) 31-33
         </i>
         .
        It uses an atomic (spherical) density. When such an atomic density is found in the pseudopotential or PAW file, it is used. If not, a gaussian density
        (defined by [[densty]] parameter) is used.
         <br />
         Also note that, to be efficient, this algorithm requires a minimum convergence of the SCF cycle;
        Typically, vres2 (or nres2) has to be small enough (10
         <sup>
          -4
         </sup>
         ...10
         <sup>
          -5
         </sup>
         ).
        </p>
    varname: densfor_pred
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: initial DENSity for each TYpe of atom
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Gives a rough description
        of the initial GS density, for each type of atom.
        This value is only used to create
        the first exchange and correlation potential,
        and is not used anymore afterwards.
        For the time being, it corresponds to an average
        radius (a.u.) of the density, and is used to generate
        a gaussian density. If set to 0.0d0, an optimized value is used.
         <br />
         No meaning for RF calculations.
        </p>
    varname: densty
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: Displacement FIELD
    dimensions:
    - 3
    excludes: null
    requires: '[[berryopt]] = 6, [[efield]]'
    section: varff
    text: |-
        <p>
         In case [[berryopt]]=6,
        [[dfield]] specifies the (unreduced) finite electric displacement field vector, in atomic units, that is to be imposed as a constraint during the calculation.
        </p>
    varname: dfield
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: DFPT SCISSor operator
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         It is the value of the "scissors operator", the
        shift of conduction band eigenvalues,
        used in response function calculations.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         Typical use is for response to electric field ([[rfelfd]]=3),
        but NOT for d/dk ([[rfelfd]]=2) and phonon responses.
        </p>
    varname: dfpt_sciss
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 2.2
    definition: DIElectric matrix Energy CUToff
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Kinetic energy cutoff that controls the number
        of planewaves used to represent the dielectric matrix:
         <br />
         (1/2)[(2 Pi)*(Gmax)]
         <sup>
          2
         </sup>
         =[[ecut]] for Gmax.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[diecut]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         All planewaves inside this "basis sphere" centered
        at G=0 are included in the basis.
        This is useful only when [[iprcel]]&gt;=21, which means that
        a preconditioning scheme based on the dielectric matrix
        is used.
         <br />
         NOTE : a negative [[diecut]] will define the same dielectric
        basis sphere as the corresponding positive value,
        but the FFT grid will be identical to the one used
        for the wavefunctions.
        The much smaller FFT grid, used when [[diecut]] is positive,
        gives exactly the same results.
         <br />
         No meaning for RF calculations yet.
        </p>
    varname: diecut
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    definition: DIElectric matrix GAP
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives a rough estimation of the dielectric gap
        between the highest energy level computed in the run,
        and the set of bands not represented.
        Used to extrapolate dielectric matrix when [[iprcel]] &gt;= 21.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[diegap]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         No meaning for RF calculations yet.
        </p>
    varname: diegap
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    definition: DIElectric matrix LAMbda
    dimensions: scalar
    excludes: null
    requires: '[[iprcel]] >= 21'
    section: vargs
    text: |-
        <p>
         Gives the amount of occupied states with mean energy given by the
        highest level computed in the run, included
        in the extrapolation of the dielectric matrix.
         <br />
         No meaning for RF calculations yet.
        </p>
    varname: dielam
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0774841d0
    definition: model DIElectric screening LeNGth
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Used for screening length (in Bohr) of the model
        dielectric function, diagonal in reciprocal space.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstrom), although Angstrom can be specified,
        if preferred, since [[dielng]] has the
        '[[LENGTH]]' characteristics.
         <br />
         This model dielectric function is as follows (K being a wavevector) :
         <pre>
                 (     1        +     [[dielng]]<sup>2</sup>* K<sup>2</sup>   )
        diel(K)= ------------------------------------
                 ( 1/[[diemac]] + [[dielng]]<sup>2</sup> * K<sup>2</sup> ) * [[diemix]]
         </pre>
         The inverse of this model dielectric function will be
        applied to the residual, to give the preconditioned
        change of potential. Right at K=0, diel(K) is imposed to be 1.
        </p>
        <p>
         If the preconditioning were perfect,
        the change of potential would lead to an exceedingly fast solution
        of the self-consistency problem (two or three steps).
        The present model dielectric function is excellent for
        rather homogeneous unit cells.
         <br />
         When K-&gt;0 , it tends to the macroscopic dielectric
        constant, eventually divided by the mixing factor [[diemix]]
        (or
         [[diemixmag]]
         </a>
         for magnetization).
         <br />
         For metals, simply put [[diemac]] to a very large value (10^6 is OK)
         <br />
         The screening length [[dielng]] governs the length scale
        to go from the macroscopic regime to the microscopic
        regime, where it is known that the dielectric function
        should tend to 1. It is on the order of 1 Bohr for
        metals with medium density of states at the Fermi level,
        like Molybdenum, and for Silicon. For metals with a
        larger DOS at the Fermi level (like Iron),
        the screening will be more effective, so that [[dielng]]
        has to be decreased by a factor of 2-4.
         <br />
         This works for GS and RF calculations.
        </p>
    varname: dielng
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1000000.0
    definition: model DIElectric MACroscopic constant
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         A rough knowledge of the macroscopic dielectric constant [[diemac]]
        of the system is a useful help to speed-up the SCF procedure:
        a model dielectric function,
        see the keyword [[dielng]], is used for that
        purpose.  It is especially
        useful for speeding up the treatment of rather homogeneous unit cells.
        </p>
        <p>
         Some hint :
         <br />
         The value of [[diemac]] should usually be bigger than 1.0d0,
        on physical grounds.
         <br />
         For metals, simply put [[diemac]] to a very large value (the default 10
         <sup>
          6
         </sup>
         is OK)
         <br />
         For silicon, use 12.0 . A similar value is likely to work well for
        other semiconductors
         <br />
         For wider gap insulators, use 2.0 ... 4.0
         <br />
         For molecules in an otherwise empty big box, try 1.5 ... 3.0
         <br />
         Systems that combine a highly polarisable part and some vacuum are rather
        badly treated by the model dielectric function. One has to use the
        "extrapolar" technique, activated by the  input variable
        [[iprcel]].
         <br />
         In sufficiently homogeneous systems, you might have to experiment
        a bit to find the best [[diemac]]. If you let [[diemac]]
        to its default value, you might even never obtain the self-consistent convergence !
         <br />
         For response function calculations, use the same
        values as for GS. The improvement in speed can be considerable
        for small (but non-zero) values of the wavevector.
        </p>
    varname: diemac
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==0 or [[iprcel]] !=0': 1.0
        '[[usepaw]]==1 or [[iprcel]]==0': 0.7
        defaultval: null
    definition: model DIElectric MIXing factor
    dimensions: scalar
    excludes: null
    requires: '[[diemix]] &gt;= 0.0 and [[diemix]] &lt;=  1.0'
    section: vargs
    text: |-
        <p>
         Gives overall factor of the preconditioned
        residual density/potential to be transferred in the SCF cycle.
         <br />
         It should be between 0.0 and 1.0 .
         <br />
         If the model dielectric function were perfect, [[diemix]]
        should be 1.0 . By contrast, if the model dielectric function
        does nothing (when [[diemac]]=1.0d0 or [[dielng]]
        is larger than the
        size of the cell), [[diemix]] can be used
        to damp the amplifying factor inherent to the SCF loop.
         <br />
         For molecules, a value on the order 0.5 or 0.33 is rather usual.
         <br />
         When mod([[iscf]],10)=3, 4 ,5 or 7, [[diemix]]
        is only important at the
        few first iterations when anharmonic effects are important,
        since these schemes compute their own mixing factor
        for self-consistency.
         <br />
         Also note that a different value of diemix can be used for the magnetization
        (see [[diemixmag]]).
        </p>
    varname: diemix
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        70 < [[iprcel]] and [[iprcel]] < 80: '[[diemix]]'
        '[[iprcel]]==0': '[[diemix]]'
        '[[iscf]]<10': '[[diemix]]'
        defaultval: -[[diemix]]
    definition: model DIElectric MIXing factor for the MAGgnetization
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives overall factor of the preconditioned
        residual magnetization/magnetic field to be transferred in the SCF cycle (see
         [[diemix]] for further information).
         <br />
         For the time being, apply only when the SCF mixing is done on the density
        ([[iscf]]&gt;=10).
         <br />
         <br />
         A negative value of diemixmag means that magnetization is only preconditionned by ABS(diemixmag),
        without the use of any preconditionner.
         <br />
         <br />
         When SCF cycle has some difficulties to converge, changing the value of [[diemixmag]]
        can have a positive effect.
         <br />
         In particular [[diemixmag]]=-4 is a good choice
        (i.e. diemixmag=4, no other preconditionner on magnetization).
        </p>
    varname: diemixmag
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 8
    definition: Direct Inversion in the Iterative Subspace MEMORY
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the maximum number of "time" steps for which the
        forces and stresses are stored, and taken into account in the
        DIIS algorithm ([[ionmov]]=20)
        to find zero-force and stress configurations.
        </p>
    varname: diismemory
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: 'DILATation : MaXimal value'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the maximal permitted scaling of
        the lattice parameters when the cell shape and
        dimension is varied (see variable [[optcell]]).
        It is used to define the sphere of plane waves
        and FFT box coherent with the possible modifications
        of the cell ([[ionmov]]==2 and
        [[optcell] /=0).
        For these definitions, it is equivalent
        to changing [[ecut]] by multiplying it by [[dilatmx]]
         <sup>
          2
         </sup>
         (the result is an "effective ecut", called internally "ecut_eff",
        other uses of [[ecut]] being not modified
        when [[dilatmx]]&gt;1.0 .
         <br />
         Using [[dilatmx]]&lt;1.0 is equivalent to changing
        [[ecut]]
         in all its uses. This is allowed, although its meaning
        is no longer related to a maximal expected scaling.
         <br />
         Setting [[dilatmx]] to a large value leads to waste
        of CPU time and memory. Supposing you think that the
        optimized [[acell]] values might be 10%
        larger than your
        input values, use simply [[dilatmx]] 1.1 . This will already
        lead to an increase of the number of planewaves by a factor
        (1.1)
         <sup>
          3
         </sup>
         =1.331 , and a corresponding increase in CPU time
        and memory.
         <br />
         It is possible to use [[dilatmx]] when
        [[optcell]] =0, but
        a value larger than 1.0 will be a waste.
        </p>
    varname: dilatmx
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'DIPole-DIPole interaction '
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable defines the treatment of the dipole-dipole interaction.
        Same meaning as the corresponding anaddb variable
    varname: dipdip
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: -10.0
    definition: initial Density MATrix for PAW+U
    dimensions:
    - 2*max([[lpawu]])+1
    - 2*max([[lpawu]])+1
    - max([[nsppol]], [[nspinor]])
    - '[[natpawu]]'
    excludes: null
    requires: '[[usepaw]]==1 and [[usepawu]]==1 and [[usedmatpu]]!=0'
    section: varpaw
    text: |-
        <p>
         For Ground state calculations only.
         <br />
         Gives the value of an initial density matrix used in LDA+U and kept
        fixed during the first abs([[usedmatpu]]) SCF iterations.
         <br />
         Only components corresponding to [[lpawu]] angular momentum are requested.
         <br />
         Restriction: In order to use dmatpawu, [[lpawu]] must be identical for all atom types (or -1).
         <br />
         The occupation matrix is in the basis of real spherical harmonics Slm (note that this differs from the choice made when
         [[prtdosm]]=1
         , that is in the basis of complex spherical harmonics).
        Their are ordered by increasing m, and are defined e.g. in
        the article
        "Evaluation of the rotation matrices in the basis of real spherical harmonics",
        by Miguel A. Blancoa, M. Floreza, M. Bermejo,
        Journal of Molecular Structure (Theochem) 419, 19 (1997), that can be downloaded from
         <a href="http://azufre.quimica.uniovi.es/articles/Theochem419-19-ov-BF97-rotation-matrices.pdf">
          <!-- &lt;a href="http://www.unioviedo.es/qcg/art/Theochem419-19-ov-BF97-rotation-matrices.pdf"&gt; -->
          the author Web site
         </a>
         .
        For the case l=2 (d states), the five columns corresponds respectively to (the normalisation factor has been dropped)
         <br />
         <ul>
          <li>
           m=-2, xy
          </li>
          <li>
           m=-1, yz
          </li>
          <li>
           m=0, 3z^2-r^2
          </li>
          <li>
           m=1, xz
          </li>
          <li>
           m=2, x^2-y^2
          </li>
         </ul>
         <br />
         [[dmatpawu]] must always be given as a "spin-up" occupation matrix (and eventually a "spin-down" matrix).
        Be aware that its physical meaning depends on the magnetic properties imposed to the system
        (with [[nsppol]],
        [[nspinor]],
        [[nspden]]):
         <br />
         <ul>
          <li>
           <b>
            Non-magnetic system
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=1):
           <br />
           One (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrix is given for each atom on which +U is applied.
           <br />
           It contains the "spin-up" occupations.
          </li>
          <li>
           <b>
            Ferromagnetic spin-polarized (collinear) system
           </b>
           ([[nsppol]]=2,
        [[nspinor]]=1,
        [[nspden]]=2):
           <br />
           Two (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrices are given for each atom on which +U is applied.
           <br />
           They contain the "spin-up" and "spin-down" occupations.
          </li>
          <li>
           <b>
            Anti-ferromagnetic spin-polarized (collinear) system
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=2):
           <br />
           One (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrix is given for each atom on which +U is applied.
           <br />
           It contains the "spin-up" occupations.
          </li>
          <li>
           <b>
            Non-collinear magnetic system
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=2,
        [[nspden]]=4):
           <br />
           Two (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrices are given for each atom on which +U is applied.
           <br />
           They contains the "spin-up" and "spin-down" occupations
        (defined as n_up=(n+|m|)/2 and n_dn=(n-|m|)/2), where m is the integrated magnetization vector).
           <br />
           The direction of the magnetization (which is also the direction of n_up and n_dn) is given by
        [[spinat]].
           <br />
           <i>
            Warning: unlike collinear case, atoms having the same magnetization magnitude with different directions
        must be given the same occupation matrix;
            <br />
            the magnetization will be oriented by the value of [[spinat]]
        (this is the case for antiferro-magnetism).
           </i>
          </li>
          <li>
           <b>
            Non-collinear magnetic system with zero magnetization
           </b>
           ([[nsppol]]=1,
        [[nspinor]]=2,
        [[nspden]]=1):
           <br />
           Two (2lpawu+1)x(2lpawu+1) [[dmatpawu]] matrices are given for each atom on which +U is applied.
           <br />
           They contain the "spin-up" and "spin-down" occupations;
           <br />
           But, as "spin-up" and "spin-down" are constrained identical, the "spin-down" one is ignored by the code.
          </li>
         </ul>
         <br />
        </p>
    varname: dmatpawu
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: Density MATrix for PAW+U OPTion
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    section: varpaw
    text: |-
        <p>
         This option governs the way occupations of localized atomic levels are computed:
         <br />
         <ul>
          <li>
           [[dmatpuopt]]=1: atomic occupations are projections on atomic orbitals (Eq. (6) of PRB 77, 155104 (2008)).
           <br />
          </li>
          <li>
           [[dmatpuopt]]=2: atomic occupations are integrated values in PAW spheres
        of angular-momentum-decomposed charge densities (Eq. (7) of PRB 77, 155104 (2008)).
           <br />
          </li>
          <li>
           [[dmatpuopt]]=3: only for tests
           <br />
          </li>
          <li>
           [[dmatpuopt]]=4: Extrapolations of occupancies outside the PAW-sphere. This Definition gives normalized operator for occupation.
           <br />
          </li>
         </ul>
         In the general case [[dmatpuopt]]=2 is suitable. The use of [[dmatpuopt]]=1
        is restricted to PAW datasets in which the first
        atomic wavefunction of the correlated subspace is a normalized atomic eigenfunction.
        </p>
    varname: dmatpuopt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Density MATrix for paw+U, DIAGonalization
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and [[usepawu]]==1 and [[nspden]] != 4'
    section: varpaw
    text: |-
        <p>
         Relevant only  for Ground-State calculations.
         <br />
         This option can be used to diagonalize the occupation matrix Nocc_{m,m_prime}.
         <br />
         Relevant values are:
         <br />
         <ul>
          <li>
           0: desactivated.
          </li>
          <li>
           1: occupation matrix is diagonalized and printed in log file at each SCF cycle
        (eigenvectors are also given in the log file).
          </li>
          <li>
           2: for testing purpose.
          </li>
         </ul>
        </p>
    varname: dmatudiag
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'Dynamical Mean Fied Theory: Double Counting'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Value of double counting used for DMFT. Only value 1 is activated for the moment and is the FLL double counting.
        </p>
    varname: dmft_dc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: ENTROPY'
    dimensions: null
    excludes: null
    requires: '[[usedmft]]==1 and [[dmft_solv]]==5'
    section: vardev
    text: |-
        If 1, enable the calculation of the entropy  within the DMFT framework and so allows the calculation of the total energy (free energy).
        In the current implementation, this is only possible with [[dmft_solv]]=5 (Continuous Time Quantum Monte Carlo).
        See also the input variable [[dmft_nlambda]].
    varname: dmft_entropy
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: number of ITERation'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Number of iterations for the DMFT inner loop.
        </p>
    varname: dmft_iter
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.3
    definition: 'Dynamical Mean Fied Theory: MiXing parameter for the SelF
        energy'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Mixing parameter for the simple mixing of the self-energy.
        </p>
    varname: dmft_mxsf
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 6
    definition: 'Dynamical Mean Fied Theory: Number of LAMBDA points'
    dimensions: scalar
    excludes: null
    requires: '[[usedmft]]==1 and [[dmft_entropy]]==1'
    section: vardev
    text: |-
        [[dmft_nlambda]] gives the number of integration points for the thermodynamical integration in case of free energy calculation within DMFT.
        Its value must be greater or equal to 3.
    varname: dmft_nlambda
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Number of frequency omega (W)
        in the LInear mesh'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Number of Matsubara frequencies (linear  mesh)
        </p>
    varname: dmft_nwli
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Number of frequency omega (W)
        in the log mesh'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Number of frequencies in the log mesh.
        </p>
    varname: dmft_nwlo
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Read Occupations (Non Diagonal)'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Flag to read/write Occupations as computed in DMFT. This flag is useful
        to restart a DFT+DMFT calculation with self-consistency over electronic density.
        The occupations are written each time a DMFT loop is finished. So if the calculation stops
        because the time limit is reached, this option offers the possibility to restart the self-consistent loop
        over density at the point where it stopped (assuming a restart with the wave functions, see [[getwfk]]).
         <ul>
          <li>
           0=&gt;  Occupations are written but never read.
          </li>
          <li>
           1=&gt;  Occupations are read from I_DMFTOCCND, where I is the root for input files.
          </li>
          <li>
           2=&gt;  Occupations are read from O_DMFTOCCND, where O is the root for output files.
          </li>
         </ul>
         An alternative and more simple way to restart a DFT+DMFT calculation is to use the density file (obtained with [[prtden]]=1
        or [[prtden]]=-1) and the self-energy (see [[dmft_rslf]]).
        </p>
    varname: dmft_read_occnd
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Read SeLF energy'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Flag to read/write Self-Energy. If put to one, self-energy is written and read at each DFT iteration.
        </p>
    varname: dmft_rslf
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    definition: 'Dynamical Mean Fied Theory: choice of SOLVer'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Choice of solver for the Impurity model.
         <ul>
          <li>
           0=&gt; No solver and U=0, J=0 (see [[upawu]] and [[jpawu]]).
          </li>
          <li>
           1=&gt; LDA+U self-energy is used (for testing purpose)
          </li>
          <li>
           2=&gt; Hubbard one solver. The Hubbard one solver is an approximation which gives a rough description of correlated Mott insulators. It should not be used for metals.
          </li>
          <li>
           5=&gt; Use the Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb of ABINIT
            in the density density representation,
        CTQMC calculations are much more time consuming that Hubbard I calculations. Nevertheless, the calculation is fully parallelised.
          </li>
          <li>
           6=&gt; Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb of TRIQS
            in the density density representation.
          </li>
          <li>
           7=&gt; Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb of TRIQS
            with the rotationally invariant formulation.
          </li>
         </ul>
         <br />
         The CT Hyb algorithm is described in
           <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.97.076405">
            Phys. Rev. Lett 97, 076405, (2006) </a>.
            For a discussion  of density-density approximation with respect
            with the rotationnally invariant formulation, see e.g.
           <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.86.155107">
             Phys. Rev. B 86, 155107 (2012)
           </a>.
         <br />
         The ABINIT/CT Hyb implementation is discussed in
           <a href="http://dx.doi.org/10.1016/j.cpc.2016.04.003">
              http://dx.doi.org/10.1016/j.cpc.2016.04.003 </a>.
         <br />
         The TRIQS/CT Hyb implementation is described in
           <a href="http://dx.doi.org/10.1016/j.cpc.2015.10.023">
            Comp. Phys. Comm. 200, 274 (2016)
           </a>. Before using it, it has to be installed following
            instructions at https://triqs.ipht.cnrs.fr/1.3/applications/cthyb/install.html.
            The current interface is valid for TRIQS 1.3 and TRIQS/CTHYB 1.3.
         <br />
         See the useful variables for CT-QMC solver :
        [[dmftctqmc_basis]],
        [[dmftctqmc_check]],
        [[dmftctqmc_correl]],
        [[dmftctqmc_gmove]],
        [[dmftctqmc_grnns]],
        [[dmftctqmc_meas]],
        [[dmftctqmc_mrka]],
        [[dmftctqmc_mov]],
        [[dmftctqmc_order]],
        [[dmftctqmc_triqs_nleg]],
        [[dmftqmc_l]],
        [[dmftqmc_n]],
        [[dmftqmc_seed]],
        [[dmftqmc_therm]]
        </p>
    varname: dmft_solv
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: t2g orbitals'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Can be set to 1 only if in cubic symmetry. It enables one to carry a DFT+DMFT calculations only on t2g orbitals.
        </p>
    varname: dmft_t2g
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-4
    definition: 'Dynamical Mean Fied Theory: Tolerance on LDA correlated electron
        occupation matrix for the definition of the frequency grid'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         The LDA occupation matrix for correlated electrons can be computed directly. It can be compared to the calculation of the same quantity using LDA Green's function, a sum over Matsubara frequencies and
         a projection over correlated orbitals.
         Because the Matsubara grid is finite, the two quantities differ. If this difference is larger than dmft_tolfreq, then the code stops and an error message is given.
        </p>
    varname: dmft_tolfreq
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-5
    definition: 'Dynamical Mean Fied Theory: Tolerance on Local Charge for
        convergence of the DMFT loop'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Tolerance for the variation of Local Charge during iterations of the DMFT Loop.
         <br />
         The default value is good for fast calculations. However, to obtain good convergence of the DFT Loop,
        the DMFT Loop needs a better convergence criterion.
        </p>
    varname: dmft_tollc
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Field Theory: BAND: Final'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         [[dmftbandf]] is the last band taken into account in the Projected Local
        Orbitals scheme of DFT+DMFT. With [[dmftbandi]], they define the energy window used to define Wannier Functions.
        (see  Amadon, B., Lechermann, F., Georges, A., Jollet, F., Wehling, T. O., and Lichtenstein, A. I. Phys. Rev. B 77(20), (2008).)
        </p>
    varname: dmftbandf
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Field Theory: BAND: Initial'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         [[dmftbandi]] is the first band taken into account in the Projected Local
        Orbitals scheme of LDA+DMFT. With [[dmftbandf]], they define the energy window used to define Wannier Functions.
        (see  Amadon, B., Lechermann, F., Georges, A., Jollet, F., Wehling, T. O., and Lichtenstein, A. I. Phys. Rev. B 77(20), (2008).)
        </p>
    varname: dmftbandi
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: CHECKs'
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
        Only for developer purposes.
         (Introduced by B. Amadon, v6.1.0)
        </p>
    varname: dmftcheck
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo basis'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Choose the basis to perform CTQMC calculation.
         <ul>
          <li>
           0=&gt;  Use the local basis in the spherical harmonics basis. Can be useful if the Hamiltonian has weak off diagonal terms
           and for this reason, one want to keep the original basis for simplicity and for physical insight.
          </li>
          <li>
           1=&gt;  Default value, diagonalize the local Hamiltonian (but only if it is not diagonal). The best choice in general.
          </li>
          <li>
           2=&gt;  Diagonalise the local correlated occupation matrix. Can lead to non diagonal Hamiltonian that
           cannot be handled by CTQMC. This option should be thus avoided.
          </li>
         </ul>
        </p>
    varname: dmftctqmc_basis
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo check'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Check the fast calculations during the Monte Carlo simulation with very slow but robust methods.
        Should only be used for debugging.
         <ul>
          <li>
           0=&gt;  No check.
          </li>
          <li>
           1=&gt;  Check the overlap calculations (Impurity operator).
          </li>
          <li>
           2=&gt;  Check the update of M matrix calculation (Bath operator).
          </li>
          <li>
           3=&gt;  Check both.
          </li>
         </ul>
        </p>
    varname: dmftctqmc_check
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo CORRelations'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Flag to compute statistics about segments and anti-segments during the simulation.
        Slow down the simulation.
         <ul>
          <li>
           0=&gt;  Nothing done
          </li>
          <li>
           1=&gt;  Calculations performed and written in "Correlation.dat" file
          </li>
         </ul>
        </p>
    varname: dmftctqmc_correl
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo Global MOVEs'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Default is no global moves.
        The value of this variable is the modulo used to try a global move.
        A value of 5000 means that a global move is tried every 5000 Monte Carlo sweep.
        </p>
    varname: dmftctqmc_gmove
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo GReeNs NoiSe'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Compute the statistical noise for each time slice of each green function.
        This is a good approximation only if there is enough Monte Carlo sweeps per cpu.
         <ul>
          <li>
           0=&gt;  Nothing
          </li>
          <li>
           1=&gt;  Do it and write the noise in the "Gtau.dat" file.
          </li>
         </ul>
        </p>
    varname: dmftctqmc_grnns
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo MEASurements'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         The modulo used to measure the interaction energy and the number of electrons.
        Example : 2 means the measure is perform every two sweeps.
        </p>
    varname: dmftctqmc_meas
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo MOVie'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Print a latex file per cpu displaying the full simulation.
        This option should only be use with very small number (&lt;1000) of Monte Carlo sweeps since it requires a lot of I/O band width.
         <ul>
          <li>
           0=&gt;  Nothing
          </li>
          <li>
           1=&gt;  Write the "Movie_id.dat" file where id is the MPI rank of each process
          </li>
         </ul>
        </p>
    varname: dmftctqmc_mov
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo MARKov Analysis'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Measure the time evolution of the number of electrons for each orbital and perform a fourier transform.
        The result can be plotted using the "Markov_id.dat" file
         <ul>
          <li>
           0=&gt;  Nothing
          </li>
          <li>
           1=&gt;  Do it and write the noise in the "Markov_id.dat" file where id is the rank of each MPI process.
          </li>
         </ul>
        </p>
    varname: dmftctqmc_mrka
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo perturbation ORDER'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Print a file containing the statistic distribution of the number of segments per orbital.
        The maximal order taken into account [[dmftctqmc_order]] : 50 means that we have the statistic distribution from 0 to 50 segments.
        The result is written in the "Perturbation.dat" file.
        </p>
    varname: dmftctqmc_order
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: 'Dynamical Mean Fied Theory: Continuous Time Quantum Monte
        Carlo perturbation of TRIQS, Number of LEGendre polynomials'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==6 or 7'
    section: vardev
    text: |-
        <p>
         <br />
         Specify the number of Legendre polynomials used for the calculation of Green's function in CTQMC code from the library TRIQS.
         Default is 30. The value of coefficients are given in file whose name ending is "Legendre_coefficient.dat".
         (see also <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.84.075145"> Phys. Rev. B 84, 075145 (2010))
         </a>
        </p>
    varname: dmftctqmc_triqs_nleg
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Dynamical Mean Fied Theory: Quantum Monte Carlo time sLices'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]>=4'
    section: vardev
    text: |-
        <p>
         <br />
         Number of time slices used to represent the time green function.
        This value should be carefully chosen according to Niquist frequency and the [[tsmear]] value.
        </p>
    varname: dmftqmc_l
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: 'Dynamical Mean Fied Theory: Quantum Monte Carlo sweeps'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]>=4'
    section: vardev
    text: |-
        <p>
         <br />
         Number of Monte Carlo sweeps. Should be at least 10^6.
        </p>
    varname: dmftqmc_n
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[jdtset]]'
    definition: 'Dynamical Mean Fied Theory: Quantum Monte Carlo seed'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]>=4'
    section: vardev
    text: |-
        <p>
         <br />
         Seed to initilize the random number generator.
         <br />
         Should not be relevant except for testing purpose.
         <br />
         NOTE : If the CT-QMC ([[dmft_solv]]=5) is used on many CPUs, each CPU initializes its random number generator with dmftqmc_seed+rank where rank is the rank of the cpu in the MPI communicator.
        </p>
    varname: dmftqmc_seed
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1000
    definition: 'Dynamical Mean Fied Theory: Quantum Monte Carlo THERMalization'
    dimensions: scalar
    excludes: null
    requires: '[[dmft_solv]]==5'
    section: vardev
    text: |-
        <p>
         <br />
         Number of Monte Carlo sweeps for the thermalization
        </p>
    varname: dmftqmc_therm
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: DOS Delta in Energy
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Defines the linear grid resolution (energy increment) to be used for the
        computation of the Density-Of-States, when [[prtdos]]
        is non-zero.
         <br />
         If [[dosdeltae]] is set to zero (the default value), the actual
        increment is 0.001 Ha if [[prtdos]]=1, and
        the much smaller value 0.00005 Ha if [[prtdos]]=2.
        This different default value arises because the [[prtdos]]=1 case,
        based on a smearing technique, gives a quite smooth DOS, while the DOS from the
        tetrahedron method, [[prtdos]]=2, is rapidly varying.
        </p>
    varname: dosdeltae
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    definition: Delta Time for IONs
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Used for controlling ion time steps.
        If [[ionmov]] is set to 1, 6 or 7, then
        molecular dynamics is&nbsp;
        used to update atomic positions in response to
        forces. The parameter [[dtion]] is a time step in
        atomic units of time. (One atomic time unit is
        2.418884e-17 seconds, which is the value of
        Planck's constant in hartree*sec.)
        In this case the atomic masses, in amu (given in array "
        [[amu]] "),
        are used in Newton's equation and the viscosity (for
        [[ionmov]] =1)
        and number of time steps are provided to the code using input
        variables "[[vis]]" and "[[ntime]]".
        The code actually converts
        from masses in amu to masses in atomic units (in units
        of electron masses) but the user enters masses in
        [[amu]] .
        (The conversion from amu to atomic units (electron
        masses) is 1822.88851 electron masses/amu.)
         <br />
         A typical good value for [[dtion]] is about 100.
        The user must try several values
        for [[dtion]] in order to establish the stable and efficient
        choice for the accompanying amu, atom types and positions,
        and [[vis]] (viscosity).
         <br />
         For quenched dynamics ([[ionmov]]=7), a
        larger time step might
        be taken, for example 200.
         <br />
         No meaning for RF calculations.
        </p>
    varname: dtion
    vartype: real
- !variable
    characteristics: null
    commentdefault: if [[imgmov]] in [2,5] (String Method, NEB), <b>dynimage(1)</b>=0 and <b>dynimage([[nimage]])</b>=0.
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 1
    definition: DYNamics of the IMAGE
    dimensions:
    - '[[nimage]]'
    excludes: null
    requires: null
    section: varrlx
    text: |-
        This input variable is relevant when sets of images are activated (see
        [[imgmov]]). Not all images might be required to evolve from one time step to the other.

        Indeed, in the String Method or the Nudged Elastic Band, one might impose that the extremal configurations of the string are fixed.
        In case the [[dynimage]](iimage)=0, the image with index "iimage" will be consider as fixed.
        Thus, there is no need to compute forces and stresses for this image at each time step. The purpose of defining extremal images is to make the input/output easier.
         <br />
         <br />
         In order to save CPU time, the computation of properties of static images ([[dynimage]](iimage)=0)
        can be avoided: see [[istatimg]] keyword.
    varname: dynimage
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Energy CUToff
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Used for kinetic energy cutoff
        which controls number
        of planewaves at given k point by:
         <br />
         (1/2)[(2 Pi)*(k+Gmax)]
         <sup>
          2
         </sup>
         =[[ecut]] for Gmax.
         <br />
         All planewaves inside this "basis sphere" centered
        at k are included in the basis (except if [[dilatmx]]
        is defined).
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[ecut]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         This is the single parameter which can have an enormous
        effect on the quality of a calculation; basically the larger
        [[ecut]] is, the better converged the calculation is.  For fixed
        geometry, the total energy MUST always decrease as [[ecut]] is
        raised because of the variational nature of the problem.
        </p>
        <p>
         <i>
          Usually one runs at least several calculations at various [[ecut]]
        to investigate the convergence needed for reliable results.
         </i>
        </p>
        <p>
         For k-points whose coordinates are build from 0 or 1/2,
        the implementation of time-reversal symmetry that links
        coefficients of the wavefunctions in reciprocal space
        has been realized. See the input variable [[istwfk]].
        If activated (which corresponds to the Default mode),
        this input variable [[istwfk]] will allow to
        divide the number of plane wave (npw) treated explicitly
        by a factor of two. Still, the final result should be identical with
        the 'full' set of plane waves.
        </p>
        <p>
         See the input variable [[ecutsm]], for the
        smoothing of the kinetic energy, needed to optimize unit cell parameters.
        </p>
    varname: ecut
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Energy CUT-off for EPSilon (the dielectric matrix)
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 or [[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[ecuteps]] determines the cut-off energy of the planewave set used to represent the
        independent-particle susceptibility $\chi^{0}_{KS}$, the dielectric matrix $\epsilon$, and its inverse.
         <br />
         It is not worth to take [[ecuteps]] bigger than four times [[ecutwfn]],
        this latter limit corresponding to the highest Fourier components of a wavefunction convoluted with itself.
        Usually, even twice the value of [[ecutwfn]] might overkill. A value of [[ecuteps]]
        between 5 and 10 Hartree often (but not always) leads to converged results (at the level of 0.01 eV for the energy gap).
        In any case, a convergence study is worth.
        </p>
    varname: ecuteps
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Energy CUT-off for SIGma eXchange
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[ecutsigx]] determines the cut-off energy of the planewave set used to generate the
        exchange part of the self-energy operator. For norm-conserving calculations, it is pointless
        to have [[ecutsigx]] bigger than 4*[[ecut]],
        while for PAW calculations, the maximal useful value is
        [[pawecutdg]]. Thus, if you do not care about CPU time, please use these
        values. If you want to spare some CPU time, you might try to use a value between [[ecut]] and these
        upper limits.
        </p>
    varname: ecutsigx
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Energy CUToff SMearing
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         This input variable is important when performing
        relaxation of unit cell
        size and shape (non-zero [[optcell]]).
        Using a non-zero
        [[ecutsm]], the total energy curves as a function of
        [[ecut]], or [[acell]],
        can be smoothed,
        keeping consistency with
        the stress (and automatically including the Pulay stress). The
        recommended
        value is 0.5 Ha. Actually, when [[optcell]]/=0,
        ABINIT requires
        [[ecutsm]] to be larger than zero. If you want to optimize cell
        shape and size without
        smoothing the total energy curve (a dangerous thing to do), use a very
        small [[ecutsm]],
        on the order of one microHartree.
        </p>
        <p>
         Technical information :
         <br />
         See Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995)
        for a related method.
         <br />
         [[ecutsm]] allows to define an effective kinetic energy for plane
        waves, close to, but
        lower than the
        maximal kinetic energy [[ecut]]. For
        kinetic
        energies less than [[ecut]]-[[ecutsm]],
        nothing is modified,
        while between [[ecut]]-[[ecutsm]] and
        [[ecut]] ,
        the kinetic energy is multiplied by:
         <br />
         1.0 / ( x
         <sup>
          2
         </sup>
         (3+x-6x
         <sup>
          2
         </sup>
         +3x
         <sup>
          3
         </sup>
         ))
         <br />
         where x = ([[ecut]] - kinetic_energy)/[[ecutsm]]
         <br />
         Note that x
         <sup>
          2
         </sup>
         ( 3+x-6x
         <sup>
          2
         </sup>
         +3x
         <sup>
          3
         </sup>
         ) is 0 at
        x=0, with vanishing derivative,
        and that at x=1 , it is 1, with also vanishing derivative.
         <br />
         If [[ecutsm]] is zero, the unmodified kinetic energy is used.
         <br />
         [[ecutsm]] can be specified in Ha (the default), Ry, eV or Kelvin,
        since
        [[ecutsm]] has the
        '[[ENERGY]]'
        characteristics.
        (1 Ha=27.2113845 eV).
         <br />
         A few test for Silicon (diamond structure, 2 k-points) have
        shown 0.5 Ha to be largely enough for [[ecut]]
        between 2Ha and 6Ha,
        to get smooth curves. It is likely that this value is OK
        as soon as [[ecut]] is larger than 4Ha.
        </p>
    varname: ecutsm
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[optdriver]] in [3, 4]': '[[ecut]]'
        defaultval: 0.0
    definition: Energy CUT-off for WaveFunctions
    dimensions: scalar
    excludes: null
    requires: ' [[optdriver]]==3 or [[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[ecutwfn]] determines the cut-off energy of the planewave set used to represent the wavefunctions
        in the formula that generates the independent-particle susceptibility $\chi^{0}_{KS}$
        (for [[optdriver]]=3), or the
        self-energy (for [[optdriver]]=4).
         <br />
         Usually, [[ecutwfn]] is smaller than [[ecut]],
        so that the wavefunctions are filtered, and some components are ignored.
        As a side effect, the wavefunctions are no more normalized, and also, no more orthogonal.
        Also, the set of plane waves can be much smaller for [[optdriver]]=3,
        than for [[optdriver]]=4, although a convergence
        study is needed to choose correctly both values.
        </p>
        <p>
         The size of this set of planewaves is [[npwwfn]].
        </p>
    varname: ecutwfn
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: EFFective MASS
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         This parameter allows to change the electron mass, with respect to its
        experimental value.
        </p>
    varname: effmass
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: Electric FIELD
    dimensions:
    - 3
    excludes: null
    requires: '[[berryopt]] = 4 or 6'
    section: varff
    text: |-
        <p>
         In case [[berryopt]]=4,
        a finite electric field calculation is performed. The value
        of this electric field, and its direction is determined by [[efield]].
        It must be given in atomic units (1 a.u. of electric field= 514220624373.482 V/m, see note below),
        in cartesian coordinates.
        </p>
        <p>
         References for the calculation under electric field (based on multi k point Berry phase) :
         <ul>
          <li>
           Nunes and Vanderbilt, PRL 73, 712 (1994) : real-space version of the finite-field Hamiltonian
          </li>
          <li>
           Nunes and Gonze, PRB 63, 155107 (2001) : reciprocal-space version of the finite-field Hamiltonian
        (the one presently implemented), and extensive theoretical analysis
          </li>
          <li>
           Souza, Iniguez and Vanderbilt, PRL 89, 117602 (2003) : implementation of the finite-field Hamiltonian
        (reciprocal-space version)
          </li>
          <li>
           Zwanziger, Galbraith, Kipouros, Torrent, Giantomassi and Gonze, Comp. Mater. Sci. 58, 113 (2012) : extension
        to PAW formalism
          </li>
         </ul>
         See also Umari, Gonze, Pasquarello, PRL 90, 027401 (2003).
        </p>
        <p>
         The atomic unit of electric field strength is :
        e_Cb/(4 pi eps0 a0**2), where e_Cb is the electronic charge in Coulomb (1.60217653e-19),
        eps0 is the electric constant (8.854187817d-12 F/m), and a0 is the Bohr radius
        in meter (0.5291772108e-10).
        </p>
    varname: efield
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: EFfective MASs
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Turns on effective mass tensor calculations.
         Such calculations requires the non-self-consistent calculation
         of derivatives with respect to k, in the same dataset.
         It must therefore be used with [[rfelfd]]=2.
         <br />
         <ul>
          <li>
           0=&gt;no effective mass tensor calculation
          </li>
          <li>
           1=&gt;effective mass tensor calculation
          </li>
         </ul>
        </p>

        <p>
        At the present time, both norm-conserving (NC) and PAW calculations are supported.
        Also, for PAW calculations only, [[nspinor]]==2 and [[pawspnorb]]==1
        (i.e. spin-orbit (SO) calculations) is supported. NC SO calculations are NOT currently
        supported. Also, for both NC and PAW, [[nspden]]/=1 and [[nsppol]]/=1 are NOT supported.
        </p>
    varname: efmas
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: The full range of band available in the calculation for each k-point.
    definition: EFfective MASs, BANDS to be treated.
    dimensions:
    - 2
    - '[[nkpt]]'
    excludes: null
    requires: '[[efmas]]==1'
    section: varrf
    text: |-
        <p>
        This variable controls the range of bands for which the effective mass is to be calculated.
        If a band is degenerate, all other bands of the degenerate group will automatically be treated,
        even if they were not part of the user specified range.
        </p>
    varname: efmas_bands
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: EFfective MASs, CALCulate along DIRectionS
    dimensions: scalar
    excludes: null
    requires: '[[efmas]]==1'
    section: varrf
    text: |-
        <p>
        Allows the user to calculate the scalar effective mass of all bands specified by [[efmas_bands]] along
        specific directions in reciprocal space. This is particularly useful when considering degenerate bands,
        which are usually warped, and thus cannot have their dispersion (hessian) and effective mass expressed as
        a tensor. This allows the user to see the more complex angular behavior of effective masses in these cases,
        for instance.
        </p>

        <p>
        When [[efmas_calc_dirs]]==0, no directions are read from the input file (using [[efmas_dirs]]) and the
        effective masses along the 3 cartesian directions are output by default.
        </p>

        <p>
        When [[efmas_calc_dirs]]==1, 2 or 3, [[efmas_n_dirs]] directions are read from [[efmas_dirs]], assuming
        cartesian, reduced or angular (theta,phi) coordinates, respectively. In the case [[efmas_calc_dirs]]==3,
        2 real values per directions are read, whereas 3 real values are read in the two other cases.
        </p>
    varname: efmas_calc_dirs
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: EFfective MASs, activate DEGenerate formalism
    dimensions: scalar
    excludes: null
    requires: '[[efmas]]>0'
    section: varrf
    text: |-
        <p>
        Activate (==1) or not (==0) the treatment of degenerate bands (within a criterion [[efmas_deg_tol]])
        using the transport equivalent effective mass idea
        (see <a href="http://doi.org/10.1103/PhysRevB.89.155131">PRB 89 155131 (2014)</a>).
        </p>
    varname: efmas_deg
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-5
    definition: EFfective MASs, DEGeneracy TOLerance
    dimensions: scalar
    excludes: null
    requires: '[[efmas_deg]]==1'
    section: varrf
    text: |-
        <p>
        Energy difference below which 2 bands are considered degenerate
        (and treated using the formalism activated with [[efmas_deg]]==1).
        [[efmas_deg_tol]] has the '[[ENERGY]]' characteristics.
        </p>
    varname: efmas_deg_tol
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 3
    definition: EFfective MASs, DIMension of the effective mass tensor
    dimensions: scalar
    excludes: null
    requires: '[[efmas]]==1'
    section: varrf
    text: |-
        <p>
        For 2D or 1D systems, the band dispersion goes to 0 perpendicular to the system,
        which causes the inverse effective mass to be singular, i.e. the effective mass
        to be NaN. This keyword circumvents the problem by eliminating the troublesome dimensions
        from the inverse effective mass.
        </p>

        <p>
        In 2D, the Z axis is ignored and, in 1D, the Z and Y axis are ignored.
        </p>

        <p>
        Also, note that in the 2D degenerate case, a subtlety arises: the 'transport equivalent'
        effective mass does not determine the scale of the transport tensors (conductivity and others).
        Therefore, for this specific case, the factor by which these transport tensors should be scaled
        once determined from the 'transport equivatlent' effective mass tensor is output separately on
        the line immediately after the effective mass.
        </p>
    varname: efmas_dim
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: EFfective MASs, DIRectionS to be calculated
    dimensions:
    - 3 or 2
    - '[[efmas_n_dirs]]'
    excludes: null
    requires: '[[efmas_calc_dirs]]>0'
    section: varrf
    text: |-
        <p>
        List of [[efmas_n_dirs]] directions to be considered according to the value of [[efmas_calc_dirs]].
        The directions are specified by 3 real values if [[efmas_calc_dirs]]==1 or 2 and by
        2 real values if [[efmas_calc_dirs]]==3.
        </p>
    varname: efmas_dirs
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: EFfective MASs, Number of DIRectionS
    dimensions: scalar
    excludes: null
    requires: '[[efmas_calc_dirs]]>0'
    section: varrf
    text: |-
        <p>
        Number of directions in [[efmas_dirs]], to be considered according to [[efmas_calc_dirs]].
        </p>
    varname: efmas_n_dirs
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 1000
    definition: EFfective MASs, Number of points for integration w/r to THETA
    dimensions: scalar
    excludes: null
    requires: '[[efmas]]==1 and [[efmas_band]]==(degenerate band index)'
    section: varrf
    text: |-
        <p>
        When a band is degenerate, the usual definition of effective mass becomes invalid.
        However, it is still possible to define a 'transport equivalent mass tensor' that
        reproduces the contribution of the band to the conductivity tensor.
        To obtain this tensor, an integration over the solid sphere is required.
        The default value gives a tensor accurate to the 4th decimal in Ge.
        </p>
    varname: efmas_ntheta
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    - 0
    definition: Electron bands INTERPOolation
    dimensions:
    - 4
    excludes: null
    requires: null
    section: varbas
    text: |-
        This variable activates the interpolation of the electronic eigenvalues.
        It can be used to interpolate KS eigenvalues at the end of the GS run or to interpolate GW energies in sigma calculations ([[optdriver]] = 4).
        The k-path can be specified with [[kptbounds]] and [[nkpath]].

        einterp consists of 4 entries.
        The first element specificies the interpolation method.

        <ul>
        <li> 0 --> No interpolation (default) </li>
        <li> 1 --> Star-function interpolation (Shankland-Koelling-Wood Fourier interpolation scheme,
            see <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.2721"> PRB 38 2721</a>
        </li>
        <li> 2 --> B-spline interpolation. </li>
        </ul>

        The meaning of the other entries depend on the interpolation technique selected.
        <br>

        In the case of star-function interpolation:

        <ul>
        <li> einterp(2): Number of star-functions per ab-initio k-point </li>
        <li> einterp(3): If non-zero, activate Fourier filtering according to Eq 9 of
        <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.61.1639"> PRB 61 1639</a>.
        In this case, rcut is given by einterp(2) * Rmax where Rmax is the maximum length of the lattice vectors included in the star expansion </li>
        <li> einterp(4): Used if einterp(2) /= 0. It defines rsigma in Eq 9</li>
        </ul>
        <br>

        For B-spline interpolation:

        einterp(2:4): Order of B-spline for the three reduced directions. Cubic spline (3) is the recomended value.
    varname: einterp
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: 'ELectron-PHonon interaction at 2nd order : IMAGina y shoft
        of the DENominator'
    dimensions: scalar
    excludes: null
    requires: '[[ieig2rf]] != 0'
    section: varrf
    text: |-
        <p>
        that is, if the user is performing performing second-order eigenvalue calculations using response-functions.
         <br />
         <br />
         The variable [[elph2_imagden]] determines the imaginary shift of the denominator of the sum-over-states
        in the perturbation denominator, (e_{nk}-e_{n'k'}+i [[elph2_imagden]]).
        One should use a width comparable with the Debye frequency or the maximum phonon frequency.
         <br />
         Can be
        specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
        </p>
    varname: elph2_imagden
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: ENergy UNITs
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Governs the units to be used for
        output of eigenvalues (and eventual phonon frequencies)
         <ul>
          <li>
           0=&gt;print eigenvalues in hartree;
          </li>
          <li>
           1=&gt;print eigenvalues in eV;
          </li>
          <li>
           2=&gt;print eigenvalues in both hartree and eV.
          </li>
         </ul>
         If phonon frequencies are to be computed :
         <ul>
          <li>
           0=&gt; phonon frequencies in Hartree and cm-1;
          </li>
          <li>
           1=&gt; phonon frequencies in eV and THz;
          </li>
          <li>
           2=&gt; phonon frequencies in hartree, eV, cm-1, Thz and Kelvin.
          </li>
         </ul>
        </p>
    varname: enunit
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: 'Electron-PHonon: EXTRA ELectrons'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: null
    varname: eph_extrael
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: 'Electron-PHonon: Fermi Energy'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable can be used to change the value of the Fermi level
        when performing electron-phonon calculations with [[optdriver]]==7.
        This variable has effect only if set to a non-zero value.
        See also [[eph_extrael]].
    varname: eph_fermie
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01 Hartree
    definition: 'Electron-Phonon: Fermi Surface Energy WINdow'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable defines the energy window around the Fermi level
        used for e-ph calculations ([[optdriver]] = 7).
        Only the states located in the energy range
        [efermi - eph_fsewin, efermi + eph_fsewin] are included in the e-ph calculation.

        <p>
        Related input variables: [[eph_intmeth]], [[eph_fsmear]], [[eph_extrael]] and [[eph_fermie]].
        </p>
    varname: eph_fsewin
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01 Hartree
    definition: 'Electron-PHonon: Fermi surface SMEARing'
    dimensions: scalar
    excludes: null
    requires: '[[eph_intmeth]] == 1'
    section: vareph
    text: |-
        This variable defines the gaussian broadening used for the
        integration over the Fermi surface when [[eph_intmeth]] == 1.
    varname: eph_fsmear
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: 'Electron-Phonon: INTegration METHod'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable defines the technique for the integration on the Fermi surface of electron-phonon quantities.
        <p>
        1 for Gaussian technique with broadening factor [[eph_fsmear]].
        2 for tetrahedron method.
        </p>

        See also [[eph_fsewin]], [[eph_extrael]] and [[eph_fermie]].
    varname: eph_intmeth
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.1
    definition: MU STAR
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        Average electron-electron interaction strength, for the computation of the superconducting Tc using Mc-Millan's formula.
    varname: eph_mustar
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Number of Grid Q-Points in FINE grid.
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable activates the interpolation of the first-order variation of the self-consistent potential in the electron-phonon code.
        If eph_nqgpt_fine differs from [0, 0, 0], the code will use the Fourier transform to interpolate the DFPT potentials on this fine
        q-mesh starting from the irreducible set of q-points read from
        the DDB file. This approach is similar to the one used
        to interpolate the interatomic force constants in q-space.
        If eph_ngqpt_fine is not given, the EPH code uses the list of irreducible q-points reported in the DDB file (default behavior).
    varname: eph_ngqpt_fine
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'Electron-PHonon: Task'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
        When [[optdriver]]==7, select the task to be performed.
         The choice is among :
         <br />
         [[eph_task]]=1 : phonon linewidth
         <br />
         [[eph_task]]=2 : electron-phonon coupling elements
        </p>
    varname: eph_task
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Electron-PHonon: TRANSPORT flag'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        NB - this does not work yet.
        This variable can be used to turn on the calculation of transport
        quantities in the eph module of abinit. Value of 1 corresponds to
        elastic LOVA as in the PRB by Savrasov and Savrasov
    varname: eph_transport
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Energy SHIFT
    dimensions: scalar
    excludes: null
    requires: '[[wfoptalg]]==3'
    section: vardev
    text: |-
        <p>
        [[eshift]] gives the shift of the energy used in the
        shifted Hamiltonian squared.
        The algorithm will determine eigenvalues and eigenvectors centered
        on [[eshift]].
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
        </p>
    varname: eshift
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    definition: Eigenvalue SMEARing
    dimensions: scalar
    excludes: null
    requires: '[[smdelta]] != 0'
    section: varrf
    text: |-
        <p>
        that is, if the user is performing simulations of the electronic lifetimes induced by the electron-phonon coupling.
         <br />
         <br />
         The variable [[esmear]] determines the width of the functions approximating the delta function, \delta(e_{nk}-e_{n'k'}),
        present in the expression of the lifetimes. One should use a width comparable with the Debye frequency or the maximum phonon frequency.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
        </p>
    varname: esmear
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.25
    definition: EXCHange MIXing
    dimensions: scalar
    excludes: null
    requires: '[[useexexch]] == 1'
    section: vardev
    text: |-
        <p>
         [[exchmix]] allows to tune the ratio of exact exchange when
        [[useexexch]] is used. The default value of 0.25 corresponds to PBE0.
        </p>
    varname: exchmix
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: EXCHange N2 and N3 Dimensions
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         If [[exchn2n3d]] is 1, the internal representation of the FFT arrays
        in reciprocal space will be array(n1,n3,n2), where the second and
        third dimensions have been switched. This is to allow to be coherent with the
        [[exchn2n3d]]=4xx FFT treatment.
        </p>
    varname: exchn2n3d
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: flag - EXTRAPolation of the Wave-Functions
    dimensions: scalar
    excludes: null
    requires: '[[densfor_pred]]==5 or [[densfor_pred]]==6'
    section: vardev
    text: |-
        <p>
        This flag activates the extrapolation of wave-functions from one Molecular Dynamics (or Structural Relaxation) step to another.
        The wave functions are extrapolated using 2nd-order algorithm of Arias, Payne and Joannopoulos
         (PRB 45, 1538 (1992)).<br>
         Note that, when activated, this extrapolation requires non-negligible additional memory resources
         as the wave functions are stored for the two previous time steps. Also, it can only be activated
         if a consistent density extrapolation is activated (see [[densfor_pred]]).<br>
        ABINIT 7.10: this option is <b>under development</b> and might give wrong results.
        </p>
    varname: extrapwf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.625 for d electron
    - 0.6681 for f electron
    definition: F4 Over F2 ratio of Slater integrals
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and ([[usepawu]]==1 or [[usedmft]]==1)'
    section: varpaw
    text: |-
        <p>
        This gives the ratio of Slater Integrals F4 and F2.
        It is used in DFT+U or DFT+DMFT for the calculation of the orbital
        dependent screened coulomb interaction.
        </p>
    varname: f4of2_sla
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.4943
    definition: F6 Over F2 ratio of Slater integrals
    dimensions: scalar
    excludes: null
    requires: ([[usepawu]]==1 or [[usedmft]]==1) and [[lpawu]]=3
    section: varpaw
    text: |-
        <p>
        Gives the ratio of Slater Integrals F6 and F2.
        It is used with [[f4of2_sla]]==3 in DFT+U or DFT+DMFT for the calculation of the orbital dependent screened coulomb interaction.
        </p>
    varname: f6of2_sla
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[occopt]]==1': 0.125
        '[[occopt]]>2': 0.5
        '[[usewvl]]==1': 0.0
        defaultval: 0.0
    definition: Factor for the number of BANDs
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Governs the number of bands to be used in the code in the case
        the parameter [[nband]] is not defined in the input file
        (which means that [[occopt]] is not equal to 0 or 2).
        </p>
        <p>
         In case [[fband]] is 0.0d0, the code computes from
        the pseudopotential files and the geometry data
        contained in the input file, the number of electrons
        present in the system. Then, it computes the minimum
        number of bands that can accommodate them, and use
        that value for [[nband]].
         <br />
         In case [[fband]] differs from
        zero, other bands will be added, just
        larger than [[fband]] times the number of atoms.
        This parameter is not echoed in the top of the main
        output file, but only the parameter [[nband]] that it allowed
        to compute. It is also not present in the dtset array (no internal).
         <br />
         The default values are chosen such as to give naturally some
        conduction bands. This improves the robustness of the code,
        since this allows to identify lack of convergence coming from
        (near-)degeneracies at the Fermi level. In the metallic
        case, the number of bands generated might be too small
        if the smearing factor is large. The occupation numbers
        of the higher bands should be small enough such as to
        neglect higher bands. It is difficult to automate
        this, so a fixed default value has been chosen.
        </p>
    varname: fband
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: FERMI Energy for printing the NESTing function
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         This input variable is only effective when [[prtnest]]=1. The energy is relative to the calculated fermi energy.
        </p>
    varname: fermie_nest
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[FFTW3]] and [[usedmft]]==0': 312
        '[[paral_kgb]]==1': 401
        defaultval: 112
    definition: Fast Fourier Transform ALGorithm
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         This keyword is
         <b>
          irrelevant
         </b>
         when Fast Fourier Transforms are done using
         <b>
          Graphics Processing Units
         </b>
         (GPU),
        i.e. when [[use_gpu_cuda]]=1 (in that case, it is ignored).
         <br />
         <br />
         Allows to choose the algorithm
        for Fast Fourier Transforms. These have to be used
        when applied to wavefunctions (routine fourwf.F90),
        as well as when
        applied to densities and potentials (routine fourdp.F90).
        Presently, it is the concatenation of three digits,
        labelled (A), (B) and (C).
         <br />
         <br />
         The first digit (A) is to be chosen among 1, 2, 3 and 4 :
         <ul>
          <li>
           1=&gt; use FFT routines written by S. Goedecker.
          </li>
          <li>
           2=&gt; not available anymore
          </li>
          <li>
           3=&gt; use serial or multi-threaded FFTW3 fortran routines (
           <a href="http://www.fftw.org">
            http://www.fftw.org
           </a>
           ).
        Currently implemented with [[fftalg]]=312.
          </li>
          <li>
           4=&gt; use FFT routines written by S. Goedecker, 2002 version, that will
        be suited for MPI and OpenMP parallelism.
          </li>
          <li>
           5=&gt; use serial or multi-threaded MKL routines
        Currently implemented with [[fftalg]]=512.
          </li>
         </ul>
         The second digit (B) is related to fourdp.f :
         <ul>
          <li>
           0=&gt; only use Complex-to-complex FFT
          </li>
          <li>
           1=&gt; real-to-complex is also allowed (only coded for A==1, A==3 and A==5)
          </li>
         </ul>
         The third digit (C) is related to fourwf.f :
         <ul>
          <li>
           0=&gt; no use of zero padding
          </li>
          <li>
           1=&gt; use of zero padding (only coded for A==1, A==4)
          </li>
          <li>
           2=&gt; use of zero padding, and also combines actual
        FFT operations (using 2 routines from S. Goedecker)
        with important pre- and post-processing
        operations, in order to maximize cache data reuse.
        This is very efficient for cache architectures.
        (coded for A==1 and A==4, but A==4 is not yet sufficiently tested)
          </li>
         </ul>
         Internal representation as [[ngfft]](7).
        </p>
    varname: fftalg
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: 'todo: Not yet machine-dependent'
    commentdims: null
    defaultval: 16
    definition: Fast Fourier Transform CACHE size
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Gives the cache size of the current
        machine, in Kbytes.
         <br />
         Internal representation as [[ngfft]](8).
        </p>
    varname: fftcache
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 21
    definition: FFT for GW calculation
    dimensions: scalar
    excludes: null
    requires: ' [[optdriver]]==3 or [[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         The basic ingredients needed to perform both a screening and a sigma calculation are the so-called
        oscillator matrix elements defined as
         <br />
         <br />
        &lt;
         <b>
          k-q
         </b>
         , b1 | e^{-i (
         <b>
          q+G
         </b>
         ).
         <b>
          r
         </b>
         } |
         <b>
          k
         </b>
         b2 &gt;
         <br />
         <br />
         In reciprocal space, this expression is evaluated by a convolution in which the number of reciprocal
        lattice vectors employed to describe the wavefunctions is given
        by [[ecutwfn]].
        In the case of screening calculations, the number of
         <b>
          G
         </b>
         vectors in the above expression is defined
        by [[ecuteps]],
        while [[ecutsigx]] defined the number of
         <b>
          G
         </b>
         used in sigma calculations.
        To improve the efficiency of the code, the oscillator matrix elements are evaluated
        in real space through FFT techniques, and the [[fftgw]] input variable is used to select the FFT
        mesh to be used.
        </p>
        <p>
         [[fftgw]] is the concatenation of two digits, labelled (A) and (B) whose value is internally used
        to define the value of  [[ngfft]](1:3) (see the setmesh.F90 routine).
        </p>
        <p>
         The first digit (A) defines the augmentation of the FFT grid. Possible values are 1, 2 and 3.
         <ul>
          <li>
           0 =&gt; Use the FFT grid specified by the user through [[ngfft]](1:3)
          </li>
          <li>
           1 =&gt; Use a coarse FFT grid which encloses a sphere in reciprocal space whose radius depends
        on the largest value between
        [[ecutwfn]] and [[ecuteps]]
          </li>
          <li>
           2 =&gt;  Use a slightly augmented FFT which is sufficient for the correct treatment of the
        convolution
          </li>
          <li>
           3 =&gt; Doubled FFT grid (same mesh as that used for GS calculations).
          </li>
         </ul>
        </p>
        <p>
         The second digit (B) can be chosen between 0 and 1. It defines whether a FFT grid compatible with all
        the symmetries of the space group must be enforced or not:
         <ul>
          <li>
           0 =&gt; Use the smallest FFT mesh which is compatible with the FFT library (faster, save memory
        but is less accurate)
          </li>
          <li>
           1 =&gt; Enforce a FFT grid which is compatible with all the symmetry operations of the space
        group. This method leads to an increase both of CPU time and memory, but the matrix elements
        are more accurate since the symmetry properties of the system are preserved.
          </li>
         </ul>
         The behaviour of ABINIT before v5.5 corresponds to the default value 11.
        </p>
    varname: fftgw
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 5.0
    definition: FREQuencies along the IMaginary axis ALPHA parameter
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[freqim_alpha]] is used only for numerical integration of the [[GW]] self-energy
        ([[gwcalctyp]]= 2, 12, 22, 9, 19, 29).
         <br />
         [[freqim_alpha]] determines the location of the maximum frequency point along the imaginary axis
        if the default grid is used in Contour Deformation (numerical integration) calculations. It is set
        as
         <span style="font-family:Times,Serif">
          <i>
           &alpha;&middot;&omega;
           <sub>
            p
            <sub>
            </sub>
           </sub>
          </i>
         </span>
         , where
         <span style="font-family:Times,Serif">
          <i>
           &omega;
           <sub>
            p
            <sub>
            </sub>
           </sub>
          </i>
         </span>
         is the plasma frequency
        determined by the average density of the system (this can be set by hand by using the variable [[ppmfrq]]). See the section on grids in the descriptive text for [[cd_frqim_method]] for a detailed description of the formula.
        </p>
    varname: freqim_alpha
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: FREQuencies along the Real axis MAXimum
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         [[freqremax]] is used only for numerical integration of the [[GW]] self-energy
        ([[gwcalctyp]]= 2, 12, 22, 9, 19, 29).
         <br />
         [[freqremax]] sets the maximum real frequency used to calculate the dielectric matrix in order
        to perform the numerical integration of the [[GW]] self-energy.
        [[freqremax]], [[freqremin]] and [[nfreqre]]
        define the spacing of the frequency mesh along the real axis.
        </p>
    varname: freqremax
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: FREQuencies along the Real axis MINimum
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         [[freqremin]] is used only for numerical integration of the [[GW]] self-energy
        ([[gwcalctyp]]= 2, 12, 22, 9, 19, 29).
         <br />
         [[freqremin]] sets the minimum real frequency used to calculate the dielectric matrix in order
        to perform the numerical integration of the [[GW]] self-energy.
        [[freqremin]] can be used to split a wide frequency interval into smaller subintervals that
        can be calculated independently.
        The different subintervals can then be merged together with the
         <b>
          Mrgscr
         </b>
         utility thus obtaining
        a single screening file that can used for self-energy calculations.

        Note that [[freqremax]], [[freqremin]]
        and [[nfreqre]] define the spacing of the frequency mesh along the real axis.
        </p>
    varname: freqremin
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: FREQuencies for the SPectral function MAXimum
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[freqspmax]] sets the maximum real frequency used to calculate the spectral function
        from the [[GW]] Green's function. [[freqspmin]], [[freqspmax]] and
        [[nfreqsp]] define the spacing of an equidistant frequency mesh along
        the real axis. Alternatively, the variables [[gw_customnfreqsp]] and
        [[gw_freqsp]] can be used to make a user-defined grid.
        </p>
    varname: freqspmax
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: -[[freqspmax]]
    definition: FREQuencies for the SPectral function MINimum
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[freqspmin]] sets the minimum real frequency used to calculate the spectral function
        from the [[GW]] Green's function. [[freqspmin]] is set to -[[freqspmax]]
        if left undefined. [[freqspmin]], [[freqspmax]], and
        [[nfreqsp]] define the spacing of an equidistant frequency mesh along
        the real axis. Alternatively, the variables [[gw_customnfreqsp]] and
        [[gw_freqsp]] can be used to make a user-defined grid.
        </p>
    varname: freqspmin
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.001
    definition: internal FRICTION coefficient
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the internal friction coefficient (atomic units)
        for Langevin dynamics (when [[ionmov]]=9):
        fixed temperature simulations with random forces.
        </p>
        <p>
         The equation of motion is :
         <br />
         M
         <sub>
          I
         </sub>
         d
         <sup>
          2
         </sup>
         R
         <sub>
          I
         </sub>
         /dt
         <sup>
          2
         </sup>
         = F
         <sub>
          I
         </sub>
         - [[friction]] M
         <sub>
          I
         </sub>
         dR
         <sub>
          I
         </sub>
         /dt - F_random
         <sub>
          I
         </sub>
         <br />
         where F_random
         <sub>
          I
         </sub>
         is a Gaussian random force with average
        zero,
        and variance 2 [[friction]] M
         <sub>
          I
         </sub>
         kT.
         <br />
         The atomic unit of friction is
        hartrees*electronic mass*(atomic time units)/Bohr
         <sup>
          2
         </sup>
         . See J.
        Chelikowsky, J. Phys. D : Appl Phys. 33(2000)R33.
        </p>
    varname: friction
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: FReeZe FERMI energy
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
        Can be used to suppress artificially the first-order change of
        Fermi energy, in case of Response Function calculation
        for metals at Q=0.
        The input variable [[frzfermi]],
        if set to 1, allows to suppress this contribution, but this is incorrect.
        </p>
    varname: frzfermi
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: (Bohr^2)/Hartree
        value: 1
    definition: Forces to (X) CARTesian coordinates FACTOR
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         The forces multiplied
        by [[fxcartfactor]] will be treated like difference in cartesian coordinates in the
        process of optimization. This is a simple preconditioner.
         <br />
         TO BE UPDATED See ([[ionmov]]=2,
        non-zero
        [[optcell]]).
        For example, the stopping criterion defined by
        [[tolmxf]] relates to these scaled
        stresses.
        </p>
    varname: fxcartfactor
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Genetic Algorithm selection
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Choosing method to make the structure selection. Only the enthalpy is used now but we
        plan to include, energy, electronic band gap and alchemical potentials. Right now only value of 1 (enthalpy)
        works.
        </p>
    varname: ga_algor
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Genetic Algorithm FITNESS function selection
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Different methodologies to perform the roulette-wheel selection of parents. Even though, the
        objective function is the crystalline enthalpy (H_i), the weight of the population elements to be chosen from
        in a roulette-wheel selection can be given through different functions. We consider the following cases.
         <br />
         1. F = H_i / Sum H_i
         <br />
         2. F = exp(-(H_i-H_min)) / Sum exp(-(H_i-H_min))
         <br />
         3. F = (1/n_i) / Sum (1/n_i). Where n_i is the position in the ordered list of enthalpies
        </p>
    varname: ga_fitness
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Genetic Algorithm Number of RULES
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Different genetic rules have been implemented and the user has the change to choose between any of them.
        Right now we have 4 rules. See
        [[ga_rules]]
        </p>
    varname: ga_n_rules
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.2
    definition: Genetic Algorithm OPTIMAL PERCENT
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Percentage of the population that according to the fitness function passes
        to the following iteration.
        </p>
    varname: ga_opt_percent
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Genetic Algorithm RULES
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Different genetic rules have been implemented and the user has the change to choose between any of them.
        The chosen number of rules have been defined in
        [[ga_n_rules]
         <br />
         <br />
         Implemented rules are
         <br />
         1) crossover. Two parents are randomly chosen and two springs are mixed from the two by (a) choosing randomly (through
        Fitness function) two parents and then randomly rotating and shifting the coordinates withing that particular cell.
        (b) Slice every one of the unit cell of the parents along a random direction and creating the spring offs from the
        pieces of the two parents.
         <br />
         2) Vector flip mutation. From the coordinates from a given parent, a piece of it is inverted.
         <br />
         3) random strain.  A random anisotropic deformation is given to the unit cell.
         <br />
         4) Coordinates mutation of 1/4 of the whole coordinates.
         <br />
        </p>
    varname: ga_rules
    vartype: integer
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    definition: GENerator of the translation for Anti-FerroMagnetic space group
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         This input variable might be used to define a Shubnikov type IV magnetic space group (anti-ferromagnetic
        space group). The user is advised to consult
        "The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford."
         <br />
         A Shubnikov type IV magnetic space group might be defined by its Fedorov space group
        (set of spatial symmetries, that do not change the magnetization), and
        one translation associated with a change of magnetization.
        [[genafm]] is precisely this translation, in reduced coordinates (like [[xred]])
         <br />
         Thus, one way to specify a Shubnikov IV magnetic space group, is to define both
        [[spgroup]] and [[genafm]]. Alternatively, one might
        define [[spgroup]] and [[spgroupma]],
        or define by hand the set of symmetries, using [[symrel]],
        [[tnons]] and [[symafm]]
        </p>
    varname: genafm
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the first-order density from _DEN file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Relevant only for non self consistent RF calculations (e.g. to get electron phonon matrix elements)
        or for non linear RF calculations (to get mixed higher order derivatives you need several perturbed
        densities and wave functions).
        Indicate the files from which first-order densities must be obtained,
        in multi-dataset mode (in single dataset mode, use [[ird1den]]).
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: get1den
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'GET the first-order wavefunctions from _1WF file '
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],
        [[irdwfq]], [[ird1wf]], [[irdddk]]. One should first read the
        explanations given for these latter variables.
         <br />
         The
         <b>
          getwfk
         </b>
         ,
         <b>
          getwfq
         </b>
         , [[get1wf]] and
         <b>
          getddk
         </b>
         variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the
         <b>
          getwfk
         </b>
         input variable (the only
        one used in ground-state calculations), but
        the rules for
         <b>
          getwfq
         </b>
         and [[get1wf]] are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If
         <b>
          getwfk
         </b>
         ==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If
         <b>
          getwfk
         </b>
         is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If
         <b>
          getwfk
         </b>
         is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If
         <b>
          getwfk
         </b>
         is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if
         <b>
          getwfk
         </b>
         =0 for that
        initialisation.
        Thanks to this rule, the use of
         <b>
          getwfk
         </b>
         -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: get1wf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the Bethe-Salpeter COUPling block from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the starting coupling block of the excitonic Hamiltonian will be taken from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT coupling
        block is to be taken, as INPUT of the present dataset.
         <br />
         If [[getbscoup]]==0, no such use of previously computed coupling block file is done.
         <br />
         If [[getbscoup]] is positive, its value gives the index of the dataset to be used as input.
         <br />
         If [[getbscoup]] is -1, the output of the previous dataset must be taken, which is a frequently occuring case.
         <br />
         If [[getbscoup]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the coupling block is not initialised from
        a disk file, so that it is as if [[getbscoup]]=0 for that initialisation.
        </p>
    varname: getbscoup
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the Bethe-Salpeter EIGenstates from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the starting excitonic eigenstates are to be taken from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT eigenstates
        are to be taken, as INPUT eigenstates of the present dataset.
         <br />
         If [[getbseig]]==0, no such use of previously computed output eigenstates file is done.
         <br />
         If [[getbseig]] is positive, its value gives the index of the dataset
        from which the output states is to be used as input.
         <br />
         If [[getbseig]] is -1, the output eigenstates of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getbseig]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the eigenstates are not initialised from
        a disk file, so that it is as if [[getbseig]]=0 for that initialisation.
        </p>
    varname: getbseig
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the Bethe-Salpeter RESOnant block from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the starting resonant block of the excitonic Hamiltonian will be taken from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT resonant
        block is to be taken, as INPUT of the present dataset.
         <br />
         If [[getbsreso]]==0, no such use of previously computed resonant block file is done.
         <br />
         If [[getbsreso]] is positive, its value gives the index of the dataset to be used as input.
         <br />
         If [[getbsreso]] is -1, the output of the previous dataset must be taken, which is a frequently occurring case.
         <br />
         If [[getbsreso]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the resonant block is not initialised from
        a disk file, so that it is as if [[getbsreso]]=0 for that initialisation.
        </p>
    varname: getbsreso
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET CELL parameters from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         This variable is typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0),
        since it describes from which dataset [[acell]]
        and
        [[rprim]] are to be taken, as input of the
        present
        dataset. The cell parameters are [[EVOLVING]] variables,
        for which such a chain of calculations is useful.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
        </p>
    varname: getcell
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the DDB from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
        This variable should be used when performing electron-phonon
        or temperature-dependence calculations.
        The Born effective charge
        as well as the dielectric tensor will be read from a previous
        DFPT calculations of the electric field at q=Gamma.

        The use of this variable will trigger the cancellation of a
        residual dipole that leads to an unphysical divergence of the
        GKK with vanishing q-points.

        The use of this variable greatly improves the k-point convergence
        speed as the density of the k-point grid required to obtain the
        fulfillment of the charge neutrality sum rule is usually prohibitively
        large.

         <br />
         If [[getddb]]==0, no such use of previously computed Born effective charge
         and dielectric tensor is done.
         <br />
         If [[getddb]] is positive, its value gives the index of the dataset
        from which the output density is to be used as input.
         <br />
         If [[getddb]] is -1, the output density of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getddb]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getddb
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the ddk wavefunctions from _1WF file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],[[irdwfq]],[[ird1wf]],[[irdddk]].
         One should first read the
        explanations given for these latter variables.
         <br />
         The
         <b>
          getwfk
         </b>
         ,
         <b>
          getwfq
         </b>
         ,
         <b>
          get1wf
         </b>
         and [[getddk]] variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the
         <b>
          getwfk
         </b>
         input variable (the only
        one used in ground-state calculations), but
        the rules for
         <b>
          getwfq
         </b>
         and
         <b>
          get1wf
         </b>
         are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If
         <b>
          getwfk
         </b>
         ==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If
         <b>
          getwfk
         </b>
         is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If
         <b>
          getwfk
         </b>
         is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If
         <b>
          getwfk
         </b>
         is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if
         <b>
          getwfk
         </b>
         =0 for that
        initialisation.
        Thanks to this rule, the use of
         <b>
          getwfk
         </b>
         -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getddk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the DENsity from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a ground-state
        calculation, if [[iscf]]&lt;0 (non-SCF calculation),
        to indicate that the starting density is to be taken
        from the output of a previous dataset.
        It is used to chain the calculations,
        since it describes from which dataset the OUTPUT density
        are to be taken, as INPUT density of the present dataset.
         <br />
         If [[getden]]==0, no such use of previously computed output
        density file is done.
         <br />
         If [[getden]] is positive, its value gives the index of the dataset
        from which the output density is to be used as input.
         <br />
         If [[getden]] is -1, the output density of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getden]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior
        to the first), the density is not initialised from
        a disk file, so that it is as if [[getden]]=0 for that
        initialisation.
        Thanks to this rule, the use of [[getden]] -1 is rather
        straightforward : except for the first density, that
        is not initialized by reading a disk file, the output
        density of one dataset is input of the next one.
         <br />
         Be careful : the output density file of a run with
        non-zero [[ionmov]] does not have the proper name (it has a "TIM"
        indication) for use as an input of an [[iscf]]&lt;0 calculation.
         <br />
         One should use the output density of a [[ionmov]]==0 run.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the GAMma phonon data EIG2NKQ from dataset
    dimensions: scalar
    excludes: null
    requires: '[[ieig2rf]] != 0 and [[qpt]] != (0.0,0.0,0.0)'
    section: vardev
    text: |-
        <p>
         Relevant for second-order
        eigenvalue calculations using response-functions ([[ieig2rf]] != 0), and only
        for non-zero wavevectors [[qpt]].
         <br>
         From the electron-phonon matrix elements at some wavevector only, it is not possible to determine the Debye-Waller contribution : one has to know also the q=Gamma electron-phonon matrix elements.
         <br />
         The variable [[getgam_eig2nkq]] allows to transmit the information about the second-order derivatives of the
        eigenvalues for q=Gamma from the dataset where the calculation at Gamma was done, to the datasets
        for other wavevectors.
        </p>
    varname: getgam_eig2nkq
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the Haydock restart file from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (multi-dataset mode) and, in the case of a Bethe-Salpeter
        calculation to indicate that the Haydock iterative technique will be restarted from the output of a previous dataset.
         <br />
         If [[gethaydock]]==0, no such use of previously computed coupling block file is done.
         <br />
         If [[gethaydock]] is positive, its value gives the index of the dataset to be used as input.
         <br />
         If [[gethaydock]] is -1, the output of the previous dataset must be taken, which is a frequently occuring case.
         <br />
         If [[gethaydock]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior to the first), the coupling block is not initialised from
        a disk file, so that it is as if [[gethaydock]]=0 for that initialisation.
        </p>
    varname: gethaydock
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET OCC parameters from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         This variable is typically used to chain the calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0),
        since it describes from which dataset the array [[occ]]
        is to be taken, as input of the present
        dataset. The occupation numbers are [[EVOLVING]] variables,
        for which such a chain of calculations is useful.
         <br />
         If [[getocc]]==0, no such use of previously computed output occupations is done.
         <br />
         If [[getocc]] is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If [[getocc]] is -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getocc]] is a negative number, it indicates the number
        of datasets to go backward to find the needed data.
        In this case, if one refers to a non existent data set (prior to the first), the date is not initialised from a disk file, so that it is as if [[getocc]]==0 for that initialisation.
         <br />
         NOTE that a non-zero [[getocc]] MUST be used with [[occopt]]==2,
        so that the number of bands has to be initialized for
        each k point. Of course, these numbers of bands must be
        identical to the numbers of bands of the dataset from which
        [[occ]] will be copied. The same is true for the number of k points.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getocc
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET QuasiParticle Structure
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Used when [[ndtset]]&gt;0
        (multi-dataset mode) and [[optdriver]]=3, or 4
        (screening or sigma step of a [[GW]] calculation),
        to indicate that the eigenvalues and possibly the wavefunctions have to be
        taken from a previous quasiparticle calculation (instead of the usual LDA starting
        point). This is to achieve quasiparticle self-consistency.
        See also [[irdqps]]
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getqps
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET SCReening (the inverse dielectric matrix) from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Used when [[ndtset]]&gt;0
        (multi-dataset mode) and [[optdriver]]=4
        (sigma step of a [[GW]] calculation),
        to indicate that the dielectric matrix (_SCR file) is to be taken
        from the output of a previous dataset.
        It is used to chain the calculations,
        since it describes from which dataset the OUTPUT dielectric matrix
        is to be taken, as INPUT of the present dataset.
         <br />
         If [[getscr]]==0, no such use of previously computed output
        _SCR file is done.
         <br />
         If [[getscr]] is positive, its value gives the index of the dataset
        from which the output _SCR file is to be used as input.
         <br />
         If [[getscr]] is -1, the output _SCR file of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getscr]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior
        to the first), the _SCR file is not initialised from
        a disk file, so that it is as if [[getscr]]=0 for that
        initialisation.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getscr
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET SUSCEPtibility (the irreducible polarizability) from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Used when [[ndtset]]&gt;0
        (multi-dataset mode) and [[optdriver]]=4
        (sigma step of a [[GW]] calculation),
        to indicate that the irreducible polarizability (_SUSC file) is to be taken
        from the output of a previous dataset.
        It is used to chain the calculations, since it describes from which dataset the OUTPUT susceptibility
        is to be taken, as INPUT of the present dataset.
        Performing a [[GW]] calculations starting from the _SUSC file instead of the _SCR file presents
        the advantage that starting from the irreducible polarizability, one can calculate the screened interaction
        using different expressions without having to perform a screening calculation from scratch.
        For example, it is possible to apply a cutoff to the Coulomb interaction in order
        to facilitate the convergence of the [[GW]] correction with respect to the size of the supercell
        (see [[vcutgeo]] and [[icutcoul]])
         <br />
         If [[getsuscep]]==0, no such use of previously computed output _SUSC file is done.
         <br />
         If [[getsuscep]] is positive, its value gives the index of the dataset
        from which the output _SUSC file is to be used as input.
         <br />
         If [[getsuscep]] is -1, the output _SUSC file of the previous dataset
        must be taken, which is a frequently occurring case.
         <br />
         If [[getsuscep]] is a negative number, it indicates the number
        of datasets to go backward to find the needed file.
        In this case, if one refers to a non existent data set (prior
        to the first), the _SUSC file is not initialised from
        a disk file, so that it is as if [[getsuscep]]=0 for that
        initialisation.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getsuscep
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET VEL from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         These variables are typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0)
        since they describe from which dataset the corresponding
        output variables are to be taken, as input of the present
        dataset. The atomic positions and velocities are [[EVOLVING]] variables,
        for which such a chain of calculation is useful.
         <br />
         Note that the use of
         <b>
          getxcart
         </b>
         and
         <b>
          getxred
         </b>
         differs when
        [[acell]] and [[rprim]]
        are different from one dataset
        to the other.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
         <br />
         Note :
         <b>
          getxred
         </b>
         and
         <b>
          getxcart
         </b>
         cannot be simultaneously
        non-zero for the same dataset. On the other hand the use of
        [[getvel]] with
         <b>
          getxred
         </b>
         is allowed, despite the different
        coordinate system.
        </p>
    varname: getvel
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Integer that governs the ReaDing of _1WF files '
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],[[irdwfq]],[[ird1wf]], or [[irdddk]].
         One should first read the
        explanations given for these latter variables.
         <br />
         The [[getwfk]],
         <b>
          getwfq
         </b>
         ,
         <b>
          get1wf
         </b>
         and
         <b>
          getddk
         </b>
         variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the [[getwfk]] input variable (the only
        one used in ground-state calculations), but
        the rules for
         <b>
          getwfq
         </b>
         and
         <b>
          get1wf
         </b>
         are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If [[getwfk]]==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If [[getwfk]] is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If [[getwfk]] is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If [[getwfk]] is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if [[getwfk]]=0 for that
        initialisation.
        Thanks to this rule, the use of [[getwfk]] -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getwfk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET the fine grid wavefunctions from _WFK file
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to
        [[irdwfkfine]]. One should first read the
        explanations given for these latter variables.
        <br />
        The [[getwfkfine]] variables is typically used to chain the calculations
        in the multi-dataset mode, since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
        <br />
        If [[getwfkfine]]==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
        <br />
        If [[getwfkfine]] is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
        <br />
        If [[getwfkfine]] is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
        <br />
        If [[getwfkfine]] is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if [[getwfkfine]]=0 for that
        initialisation.
        Thanks to this rule, the use of [[getwfkfine]] -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
        <br />
        NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
        <pre>
         ndtset 3   jdtset 1 2 4  getXXX -1
        </pre>
        refers to dataset 2 when dataset 4 is initialized.

        Response-function calculation :
        <ul>
         <li>
          one and only one of [[getwfkfine]] or [[irdwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[getwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/abinit_help.html#4">
           section 4
          </a>
          of abinit_help).
         </li>
         <li>
          Reading the fine grid wavefunction will trigger the k-points interpolation technique of the temperature dependent
        calculations.
         </li>
        </ul>
        Bethe-Salpeter calculation :
        <ul>
         <li>
          one and only one of [[getwfkfine]] or [[irdwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[getwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/abinit_help.html#4">
           section 4
          </a>
          of abinit_help).
         </li>
         <li>
          This variable or [[irdwfkfine]] is mandatory when [[bs_interp_mode]] == 1
         </li>
        </ul>
        <b>
         This variable is experimental. In development.
        </b>
    varname: getwfkfine
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'GET the wavefunctions from _WFQ file '
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Eventually used when [[ndtset]]&gt;0
        (in the multi-dataset mode), to indicate
        starting wavefunctions, as an alternative to [[irdwfk]],[[irdwfq]],[[ird1wf]] or [[irdddk]].
         One should first read the
        explanations given for these latter variables.
         <br />
         The
         <b>
          getwfk
         </b>
         , [[getwfq]],
         <b>
          get1wf
         </b>
         and
         <b>
          getddk
         </b>
         variables are typically
        used to chain the calculations in the multi-dataset mode,
        since they describe from which dataset the OUTPUT
        wavefunctions are to be taken, as INPUT wavefunctions
        of the present dataset.
         <br />
         <br />
         We now focus on the
         <b>
          getwfk
         </b>
         input variable (the only
        one used in ground-state calculations), but
        the rules for [[getwfq]] and
         <b>
          get1wf
         </b>
         are similar, with _WFK
        replaced by _WFQ or _1WF.
         <br />
         If
         <b>
          getwfk
         </b>
         ==0, no use of previously computed output
        wavefunction file appended with _DSx_WFK is done.
         <br />
         If
         <b>
          getwfk
         </b>
         is positive, its value gives the index of the dataset
        for which the output wavefunction file appended with _WFK
        must be used.
         <br />
         If
         <b>
          getwfk
         </b>
         is -1, the output wf file with _WFK
        of the previous dataset must be taken,
        which is a frequently occurring case.
         <br />
         If
         <b>
          getwfk
         </b>
         is a negative number, it indicates the number
        of datasets to go backward to find the needed wavefunction file.
        In this case, if one refers to a non existent data set (prior
        to the first), the wavefunctions are not initialised from
        a disk file, so that it is as if
         <b>
          getwfk
         </b>
         =0 for that
        initialisation.
        Thanks to this rule, the use of
         <b>
          getwfk
         </b>
         -1 is rather
        straightforward : except for the first wavefunctions, that
        are not initialized by reading a disk file, the output
        wavefunction of one dataset is input of the next one.
         <br />
         In the case of a ddk calculation in a multi dataset
        run, in order to compute
        correctly the localisation tensor, it is mandatory to
        declare give getddk the value of the current dataset
        (i.e. getddk3 3 ) - this is a bit strange and
        should be changed in the future.
         <br />
         NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
        it is not the number to be subtracted from the current dataset to find the proper dataset.
        As an example :
         <pre>
          ndtset 3   jdtset 1 2 4  getXXX -1
         </pre>
         refers to dataset 2 when dataset 4 is initialized.
        </p>
    varname: getwfq
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET XCART from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         These variables are typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0)
        since they describe from which dataset the corresponding
        output variables are to be taken, as input of the present
        dataset. The atomic positions and velocities are [[EVOLVING]] variables,
        for which such a chain of calculation is useful.
         <br />
         Note that the use of [[getxcart]] and
         <b>
          getxred
         </b>
         differs when
        [[acell]] and [[rprim]]
        are different from one dataset
        to the other.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
         <br />
         Note :
         <b>
          getxred
         </b>
         and [[getxcart]] cannot be simultaneously
        non-zero for the same dataset. On the other hand the use of
         <b>
          getvel
         </b>
         with
         <b>
          getxred
         </b>
         is allowed, despite the different
        coordinate system.
        </p>
    varname: getxcart
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GET XRED from ...
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         These variables are typically used to chain the
        calculations,
        in the multi-dataset mode ([[ndtset]]&gt;0)
        since they describe from which dataset the corresponding
        output variables are to be taken, as input of the present
        dataset. The atomic positions and velocities are [[EVOLVING]] variables,
        for which such a chain of calculation is useful.
         <br />
         Note that the use of
         <b>
          getxcart
         </b>
         and [[getxred]] differs when
        [[acell]] and [[rprim]]
        are different from one dataset
        to the other.
         <br />
         If ==0, no use of previously computed values must occur.
         <br />
         If it is positive, its value gives the index of the dataset
        from which the data are to be used as input data.
        It must be the index of a dataset already computed in the
        SAME run.
         <br />
         If equal to -1, the output data of the previous dataset
        must be taken, which is a frequently occurring case.
        However, if the first dataset is treated, -1 is equivalent
        to 0, since no dataset has yet been computed in the same run.
         <br />
         If another negative number, it indicates the number
        of datasets to go backward to find the needed data
        (once again, going back beyond the first dataset is equivalent
        to using a null get variable).
         <br />
         Note : [[getxred]] and
         <b>
          getxcart
         </b>
         cannot be simultaneously
        non-zero for the same dataset. On the other hand the use of
         <b>
          getvel
         </b>
         with [[getxred]] is allowed, despite the different
        coordinate system.
        </p>
    varname: getxred
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Geometry Optimization PRECONditioner equations
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Set the kind of preconditioner to be used for Geometry Optimization
         <br />
         (Note : Under development now (2011.05.20))
         <ul>
          <li>
           [[goprecon]]=0 : No preconditioner
          </li>
          <li>
           [[goprecon]]=[1-9] : Linear preconditioner
          </li>
          <li>
           [[goprecon]]=[11-19] : Non-linear preconditioner
          </li>
         </ul>
         <br />
        </p>
    varname: goprecon
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Geometry Optimization PREconditioner PaRaMeters equations
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Set the paramenters use by the preconditioner to be
        used for Geometry Optimization
         <br />
         (Note : Under development now (2011.06.06))
        </p>
    varname: goprecprm
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - -1
    - -1
    - -1
    - -1
    - -1
    definition: 'GPU: choice of DEVICES on one node'
    dimensions:
    - 5
    excludes: null
    requires: '[[use_gpu_cuda]]==1 (CUDA functionality)'
    section: varpar
    text: |-
        <p>
         To be used when several GPU devices are present on each node, assuming the same number of devices on all nodes.
        <br />
         Allows to choose in which order the GPU devices are chosen and distributed among MPI processes (see examples below). When the default value (-1) is set, the GPU devices are chosen by order of performance (FLOPS, memory).
        <br /><br />
        Examples:
        <ul>
        <li>2 GPU devices per node, 4 MPI processes per node,  <b>gpu_device</b>=[-1,-1,-1,-1,-1] (default):<br />MPI processes 0 and 2 use the best GPU card, MPI processes 1 and 3 use the slowest GPU card.</li>
        <li>3 GPU devices per node, 5 MPI processes per node,  <b>gpu_device</b>=[1,0,2,-1,-1]:<br />MPI processes 0 and 3 use GPU card 1, MPI processes 1  and 4 use GPU card 0, MPI process 2 uses GPU card 2.</li>
        <li>3 GPU devices per node, 5 MPI processes per node,  <b>gpu_device</b>=[0,1,-1,-1,-1]:<br />MPI processes 0, 2 and 4 use GPU card 0, MPI processes 1 and 3 use GPU card 1;  the 3rd GPU card is not used.</li>
        </ul>
        GPU card are numbered starting from 0; to get the GPU devices list, type "nvidia-smi" or "lspci | grep -i nvidia".
        </p>
    varname: gpu_devices
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2000000
    definition: 'GPU (Cuda): LINear ALGebra LIMIT'
    dimensions: scalar
    excludes: null
    requires: '[[use_gpu_cuda]]==1 (CUDA functionality)'
    section: varpar
    text: |-
        <p>
         Use of linear algebra and matrix algebra on GPU is only efficient if the size of the involved matrices is large enough.
        The [[gpu_linalg_limit]] parameter defines the threshold above which linear (and matrix) algebra operations
        are done on the Graphics Processing Unit.
         <br />
         The considered matrix size is equal to:
         <br />
         <li>
          SIZE=([[mpw]]*[[nspinor]]/
        [[npspinor]])*
        ([[npband]]*[[bandpp]])**2
         </li>
         <br />
         When SIZE&gt;=[[gpu_linalg_limit]], [[wfoptalg]] parameter is
        automatically set to 14 which corresponds to the use of LOBPCG algorithm for the calculation of the eigenstates.
        </p>
    varname: gpu_linalg_limit
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW CUSTOM SPectral FREQuencies
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4 and [[gwcalctyp]] in [2,9,12,19,22,29]'
    section: vargw
    text: |-
        <p>
         [[gw_customnfreqsp]] lets the user define the grid points along the real frequency axis by hand
        for the calculation of the self-energy along the real axis. Set this to the number of frequencies
        you want. The frequencies are specified with [[gw_freqsp]].
        </p>
    varname: gw_customnfreqsp
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: !range
        start: 1
        stop: '[[gw_customnfreqsp]]'
    definition: GW SPectral FREQuencies
    dimensions:
    - '[[gw_customnfreqsp]]'
    excludes: null
    requires: '[[optdriver]]==4 and [[gw_customnfreqsp]] > 0 '
    section: vargw
    text: |-
        <p>
         [[gw_freqsp]] specifies the grid points for the real frequency axis when the real and imaginary
        (spectral funtion) parts of sigma are calculated explicitly for post-processing or plotting.
        Only activated if
        [[gw_customnfreqsp]] is not equal to 0. The number of frequencies
        is set by the value of [[gw_customnfreqsp]]. Example:
         <pre>
        gw_customnfreqsp   5
        nfreqsp            5
        gw_freqsp         -0.5  -0.1  0.0  1.0  10.0 eV
         </pre>
         If [[nfreqsp]] is not equal to
        [[gw_customnfreqsp]] a warning will be issued.
        </p>
    varname: gw_freqsp
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Contour Deformation Imaginary Frequencies Inverse Z Grid
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4] and [[gwcalctyp]] in [2,9,12,19,22,29]'
    section: vargw
    text: |-
        <p>
         [[gw_frqim_inzgrid]] creates gridpoints along the
        <b>
          imaginary
         </b>
         frequency axis by using an
        equidistant grid in the variable
         <span style="font-family:Times,Serif">
          <i>
           z &sub; [0,1]
          </i>
         </span>
         where the transform is:
        </p>
        <p align="center">
         <img style="width: 122px; height: 38px;" src="../vargw_img/cd_inzgrid.png" />
        </p>
        <p>
         Here
         <span style="font-family:Times,Serif">
          <i>
           &omega;
           <sub>
            p
           </sub>
          </i>
         </span>
         is the
        plasma frequency (default can be overridden by setting [[ppmfrq]]).
        The equidistant grid in z is determined uniquely by [[nfreqim]]) and
        the points are distributed so that half of them lie below the plasma frequency.
        </p>
    varname: gw_frqim_inzgrid
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Contour Deformation Real Frequencies Inverse Z Grid
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4] and [[gwcalctyp]] in [2,9,12,19,22,29]'
    section: vargw
    text: |-
        <p>
         [[gw_frqre_inzgrid]] creates grid points along the
         <b>
          real
         </b>
         frequency axis by using an
        equidistant grid in the variable
         <span style="font-family:Times,Serif">
          <i>
           z &sub; [0,1]
          </i>
         </span>
         where the transform is:
        </p>
        <p align="center">
         <img style="width: 122px; height: 38px;" src="../vargw_img/cd_inzgrid_re.png" />
        </p>
        <p>
         Here
         <span style="font-family:Times,Serif">
          <i>
           &omega;
           <sub>
            p
           </sub>
          </i>
         </span>
         is the
        plasma frequency (default can be overridden by setting [[ppmfrq]]).
        The equidistant grid in z is determined uniquely by
        [[nfreqre]] ) and
        the points are distributed so that half of them lie below the plasma frequency. This is useful in
        conjuction with [[gw_frqim_inzgrid]] if one needs to use a grid
        which maps
         <span style="font-family:Times,Serif">
          <i>
           [0,&#8734;[ &rarr; [0,1]
          </i>
         </span>
         . Note that
        typically
         <i>
          many
         </i>
         more points are needed along the real axis in order to properly resolve
        peak structures. In contrast, both the screening and self-energy are very smooth along the
        imaginary axis. Also, please note that this is
         <b>
          not
         </b>
         an efficient grid for
         <b>
          standard
         </b>
         Contour Deformation calculations, where typically only a smaller range of frequencies near the
        origin is required. The maximum value needed along the real frequency axis is output in the
        logfile during Contour Deformation sigma calculations.
        </p>
    varname: gw_frqre_inzgrid
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Contour Deformation Use Tangent Grid
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4] and [[gwcalctyp]] in [2,9,12,19,22,29]'
    section: vargw
    text: |-
        <p>
         [[gw_frqre_tangrid]] defines a nonuniform grid to be used in frequency, with stepsize increasing
        proportional to tan(x). This makes the grid approximately linear to start with, with a rapid increase
        towards the end. Also, this is the grid which gives equal importance to each point used in the integration
        of a function which decays as 1/x^2. To be used in conjunction with [[nfreqre]],
        [[cd_max_freq]] and [[cd_halfway_freq]]
         which determine the parameters of the transformed grid.
        </p>
    varname: gw_frqre_tangrid
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Invalid Frequency for Hybertsen-Louie PPM
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4] and [[ppmodel]] in [2]'
    section: vargw
    text: |-
        <p>
         [[gw_invalid_freq]] sets the procedure to follow when a PPM frequency is invalid (negative or imaginary).
          <ul>
            <li>
              [[gw_invalid_freq]]=0 : Drop them as proposed in Appendix B of PRB 34, 8, 5390, 1986.
            </li>
            <li>
              [[gw_invalid_freq]]=1 : Set them to 1 hartree, as done for the PPM of Godby-Needs.
            </li>
            <li>
              [[gw_invalid_freq]]=2 : Set them to infinity.
            </li>
          </ul>
        </p>
    varname: gw_invalid_freq
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GW, Number of Q-points for the Long Wave-Length Limit
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4,99]'
    section: vargw
    text: |-
        <p>
         Only relevant if [[optdriver]]=3,4,99 that is, screening, sigma or [[BETHE_SALPETER]]
        calculations, although the actual meaning of the variable depends on the particular run-level (see
        discussion below).
        </p>
        <p>
         [[gw_nqlwl]] defines the number of directions in reciprocal space used to describe the non-analytical behaviour
        of the heads (G = G'=0) and the wings (G=0 or G'=0) of the dielectric matrix in the optical limit
        (i.e. for q tending to zero).
        The number of directions is specified by the additional variable [[gw_qlwl]].
        </p>
        <p>
         When [[optdriver]]=3, [[gw_nqlwl]] and
         <b>
          gw_qlwl
         </b>
         define
        the set of "small" q that will be calculated and stored in the final SCR file. Therefore, the two
        variables can be used to analyze how the optical spectra depend on the direction
        of the incident phonon (useful especially in anisotropic systems).
        </p>
        <p>
         When [[optdriver]]=4, [[gw_nqlwl]] and
         <b>
          gw_qlwl
         </b>
         can be used
        to specify the heads and the wings to be used to perform the quadrature of the correlated
        part of the self-energy in the small region around the origin.
        (NB: not yet available, at present the quadrature is performed using a single direction in q-space)
        </p>
        <p>
         When [[optdriver]]=99, [[gw_nqlwl]] and
         <b>
          gw_qlwl
         </b>
         define
        the set of directions in q-space along which the macroscopic dielectric function is evaluated.
        By default the [[BETHE_SALPETER]] code calculates the macroscopic dielectric function using six different
        directions in q-space (the three basis vectors of the reciprocal lattice and the three Cartesian axis).
        </p>
    varname: gw_nqlwl
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: GW Number of self-consistent STEPS
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==8'
    section: vargw
    text: |-
        <p>
         Gives the maximum number of self-consistent [[GW]] cycles (or "iterations").
        in which G and/or W will be updated until the quasi-particle energies are converged
        within [[gw_toldfeig]].
        [[gwcalctyp]] and [[gw_sctype]] are
        used to define the type of self-consistency.
        </p>
    varname: gw_nstep
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1.0E-5
    - 2.0E-5
    - 3.0E-5
    definition: GW, Q-points for the Long Wave-Length Limit
    dimensions:
    - 3
    - '[[gw_nqlwl]]'
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         When [[optdriver]]=3,
        [[gw_qlwl]] defines the set of q-points around Gamma that are considered during the evaluation
        of the non-analytical behaviour of the dielectric matrix. Optical spectra (with and without
        non-local field effects) are evaluated for each direction specified by [[gw_qlwl]].
        </p>
        <p>
        </p>
    varname: gw_qlwl
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW Policy for K-point and Bands selection
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[gw_qprange]] is active only when [[nkptgw]] is equal to zero (default value).
        This variable simplifies the specification of the list of kpoints and of the bands to be used
        for the computation of the quasi-particle corrections.
        The possible values are:
         <ul>
          <li>
           0    =&gt; Compute the QP corrections only for the fundamental and the optical gap
          </li>
          <li>
           +num =&gt; Compute the QP corrections for all the k-points in the irreducible zone.
        and include `num` bands above and below the Fermi level.
          </li>
          <li>
           -num =&gt; Compute the QP corrections for all the k-points in the irreducible zone.
        Include all occupied states and `num` empty states.
          </li>
         </ul>
         The default value is 0 and is very handy for one-shot calculations.
        It is important to stress, however, that the position of the optical/fundamental gaps is deduced from the energies computed
        on the k-mesh used for the WFK file. Therefore the computed gaps might differ from the correct ones that can only be
        obtained with an appropriate sampling of the irreducible zone.

        Positive values are useful if we do not know the position of the [[GW]] HOMO, LOMO and we want to investigate
        the effect of the [[GW]] corrections on the states close to the gap
        Negative values are usually used for self-consistent calculations

        Note that, in the case of self-consistency or symsigma=1, the code might change the bands range
        so that all the degenerate states are included.

        Note also that [[kptgw]], and
         [[bdgw]]
         are ignored when this options is used.
        If you want to select manually the list of k-points and bands, you have
        to provide the three variables [[nkptgw]], [[kptgw]], and [[bdgw]].
        </p>
    varname: gw_qprange
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GW, Self-Consistency TYPE
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         This variable is used to partially define the kind of self-consistency for [[GW]] calculations.
        The other piece of information is given by [[gwcalctyp]]
        that defines the particular approximation for the self-energy operator as well as whether the
        wavefunctions have to replaced by quasi-particle amplitudes.
        </p>
        <p>
         If [[gw_sctype]] is specified in the input file, the code will perform an iterative update
        of the quantities entering the [[GW]] equations until the quasi-particle energies are converged
        within [[gw_toldfeig]]. The maximum number of iterations is
        specified by [[gw_nstep]].
        Possible values are:
         <ul>
          <li>
           1 =&gt; standard one-shot method (one screening calculation followed by a single sigma run)
          </li>
          <li>
           2 =&gt; self-consistency only on W (iterative update of W followed by a sigma run in which G
        is approximated with the Kohn-Sham independent-particle Green's function G0)
          </li>
          <li>
           3 =&gt; self-consistency only of G (a single screening calculation to obtain the Kohn-Sham
        polarizability followed by an iterative update of the Green's functions in the self-energy)
          </li>
          <li>
           4 =&gt; fully self-consistent algorithm (iterative update of both G and W)
          </li>
         </ul>
         It is possible to initialize the self-consistent procedure by reading a previously calculated
        SCR or SUSC file via the variables [[getscr]] or
        [[getsuscep]], respectively.
        [[getqps]] can be used to read a previous QPS file thus initializing
        the Green functions to be used in the first self-consistent iteration.
        </p>
    varname: gw_sctype
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW, treatment of the ...
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4 and [[usepaw]]==1'
    section: vargw
    text: |-
        <p>
         Only available for PAW and relevant if [[optdriver]]=4 that is, sigma calculations.
        </p>
        <p>
         Theoretical introduction: [[GW]] calculations performed on top of electronic calculations relying
        when the frozen-core approximation is used to separate inner-core electrons from valence electrons,
        only the contribution to the self-energy arising from valence electrons is explicitly accounted for.
        In the standard approach based on pseudopotentials the contribution to the self-energy due to core electrons is approximated
        by means of the KS exchange-correlation potential generated by the core density.
        In the case of [[GW]] calculations employing the PAW method, the core contribution to the self-energy
        can be more accurately estimated in terms of the Fock operator generated by the core wavefunctions.
        In the simplest approach, the only ingredients required for this more refined treatment are the wave
        functions of the core electrons in the reference atomic configuration that are calculated during the
        generation of the PAW setup. This is a good approximation provided that the core wave functions
        are strictly localized inside the PAW spheres.
        </p>
        <p>
         [[gw_sigxcore]] defines the approximation used to evaluate the core contribution to sigma.
         <ul>
          <li>
           [[gw_sigxcore]] = 0, standard approach, the core contribution is approximated with vxc.
          </li>
          <li>
           [[gw_sigxcore]] = 1, the core term is approximated with the Fock operator inside the PAW spheres.
          </li>
         </ul>
        </p>
        <p>
        </p>
    varname: gw_sigxcore
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 0.1
    definition: GW TOLerance on the DiFference of the EIGenvalues
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==8'
    section: vargw
    text: |-
        <p>
         Sets a tolerance for absolute differences of QP energies that will cause one self-consistent [[GW]] cycle to stop.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          toldfe
         </b>
         has the '[[ENERGY]]' characteristics (1 Ha=27.2113845 eV)
         <br />
        </p>
    varname: gw_toldfeig
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW CALCulation TYPe
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         [[gwcalctyp]] governs the choice between the different capabilities of the [[GW]] code.
         <ul>
          <li>
           0 &#60;&#61; [[gwcalctyp]] &#60;&#61;  9 : standard "1 shot" quasiparticle method
          </li>
          <li>
           10 &#60;&#61; [[gwcalctyp]] &#60;&#61; 19 : self-consistent quasiparticle method on energies only
          </li>
          <li>
           20 &#60;&#61; [[gwcalctyp]] &#60;&#61; 29 : self-consistent quasiparticle method on energies and wavefunctions
          </li>
         </ul>
        </p>
        <p>
         <ul>
          <li>
           [[gwcalctyp]] &#61; 0, 10, or 20 : standard Plasmon-Pole model [[GW]] calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 1 : [[GW]] calculation where the self-energy along the real axis is obtained by performing the analytic continuation from the imaginary axis to the full complex plane via the Pade approximant. Only available for standard "1 shot" quasiparticle method.
          </li>
          <li>
           [[gwcalctyp]] &#61; 2, 12, or 22 : [[GW]] calculation using numerical integration
        (contour deformation method, see e.g. S. Lebegue
           <i>
            et al.
           </i>
           PRB
           <b>
            67
           </b>
           , 155208 (2003).)
          </li>
          <li>
           [[gwcalctyp]] &#61; 5, 15, or 25 : Hartree-Fock calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 6, 16, or 26 : Screened Exchange calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 7, 17, or 27 : COHSEX calculation
          </li>
          <li>
           [[gwcalctyp]] &#61; 8, 18, or 28 : model [[GW]] calculation
        following S. Faleev
           <i>
            et al.
           </i>
           PRL
           <b>
            93
           </b>
           , 126406 (2004) using a Plasmon-Pole model
          </li>
          <li>
           [[gwcalctyp]] &#61; 9, 19, or 29 : model [[GW]] calculation
        following S. Faleev
           <i>
            et al.
           </i>
           PRL
           <b>
            93
           </b>
           , 126406 (2004) using numerical integration
        (contour deformation method)
          </li>
         </ul>
        </p>
        <p>
         Also
         <ul>
          <li>
           [[gwcalctyp]] &#61; 105,125 : HSE06 calculations (1-shot and self-consistent)
          </li>
          <li>
           [[gwcalctyp]] &#61; 205,225 : PBE0 calculations  (1-shot and self-consistent)
          </li>
          <li>
           [[gwcalctyp]] &#61; 305,325 : B3LYP calculations (1-shot and self-consistent)
          </li>
         </ul>
        </p>
    varname: gwcalctyp
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW COMPletness
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         [[gwcomp]] governs the use of an extrapolar approximation. If [[gwcomp]]==1, one improves the completeness
        in a truncated sum over states. In practice, this permits one to reduce quite much the number of
        bands required in the calculation of the screening or of the self-energy.
        The energy parameter
        needed in the extrapolar approximation is set by [[gwencomp]].
        See F. Bruneval, X. Gonze, Phys. Rev. B 78, 085125 (2008) for a description of the methodology.
        </p>
    varname: gwcomp
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 2.0
    definition: GW Energy for COMPletness
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4] and [[gwcomp]]==1'
    section: vargw
    text: |-
        <p>
         [[gwencomp]] sets the energy parameter used in the extrapolar approximation used to improve
        completeness and make the convergence against the number of bands much faster.
        </p>
        <p>
         See F. Bruneval, X. Gonze, Phys. Rev. B 78, 085125 (2008) for a description of the methodology.
        </p>
    varname: gwencomp
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.25
    definition: GW FOCK exchange MIXing parameter
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]=4, [[gwcalctyp]] = 1x5 (HSE) or 2x5 (PBE0).'
    section: vargw
    text: |-
        Mixing parameter of Fock exchange for PBE0 and HSE hybrid-functional calculations via the GW self-energy subroutine. [[gwfockmix]] ranges from 0 (essentially PBE) to 1.
    varname: gwfockmix
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW Gamma
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]=3 or 4 (Sigma calculations)'
    section: vargw
    text: |-
        <p>
         If [[gwgamma]] is 1, the vertex correction will be included leading to what is known as "[[GW]]Gamma" approximation.
        see R. Del Sole, L. Reining, and R. W. Godby, Phys. Rev. B  49, 8024 (1994).
        Note that, in order to include the vertex correction in W, one has to start the sigma calculation
        from the susceptibility file_SUSC instead of the _SCR file (see [[getsuscep]]&nbsp;&nbsp;
        and [[irdsuscep]]&nbsp;&nbsp;)
        Not available for PAW calculations.
        </p>
        <p>
        [[gwgamma]]=-4 activates the bootstrap kernel of Sharma et al. [Phys. Rev. Lett. 107, 186401 (2011)] in the test-charge-test-charge dielectric function [cf. Chen and Pasquarello, Phys. Rev. B 92, 041115(R) (2015)]. A cheaper one-shot variant can be achieved with [[gwgamma]]=-6 using only the head of the kernel.
        </p>
        <p>
        [[gwgamma]]=-8 uses the RPA bootstrap-like kernel (one-shot) [Phys. Rev.  Lett. 115, 137402 (2015), ibid. 114, 146402 (2015)].
        </p>
        </p>
    varname: gwgamma
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GWLS BAND INDEX
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        Governs the DFT eigenstate |e> in which the self-energy will be evaluated, as shown in eq. (7) of  Phys. Rev. B 91, 125120 (2015).
        That is, it is the state to be corrected in the G0W0 scheme.
        </p>
    varname: gwls_band_index
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 3
    definition: GWLS CORRELATION
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        Governs the use of a dielectric model (as explained in section V of Phys. Rev. B 91, 125120 (2015).
        and the use of the Lanczos scheme to solve eqs. (30) and (35) of the same reference at all external [[gw_freqsp]] and integration (as generated from [[gwls_npt_gauss_quad]]) frequencies.
        The different choices are:
        <ul>
        <li> [[gwls_correlation]] == 1 : GWLS calculation WITH the dielectric model and WITHOUT the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 2 : GWLS calculation WITHOUT the dielectric model and WITHOUT the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 3 : GWLS calculation WITH the dielectric model and WITH the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 4 : GWLS calculation WITHOUT the dielectric model and WITH the shift Lanczos technique, </li>
        <li> [[gwls_correlation]] == 5 : Not a GWLS calculation; just calculate and print the eigenvalues of the (static) dielectric matrix (for debugging purposes). </li>
        </ul>
        </p>
        <p>
        The default, ([[gwls_correlation]] == 3), is the most performant option and should be kept by the user.
        Option 1, 2 and 5 are deprecated and will be removed.
        </p>
    varname: gwls_correlation
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: GWLS dielectric model
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        Not used yet.
    varname: gwls_dielectric_model
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GWLS exact EXCHANGE
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        Governs whether the exact exchange for the state to be corrected ([[gwls_band_index]]) is calculated ([[gwls_exchange]]==1) or not ([[gwls_exchange]]==0).
        </p>
    varname: gwls_exchange
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[gwls_band_index]]'
    definition: GWLS FIRST SEED vector
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        This variable sets the band index to be used to generate the first seed vector to be used in the construction of the Lanczos basis for the (static) dielectric matrix in a GWLS calculation.
        See section IV of  Phys. Rev. B 91, 125120 (2015).
        Together with [[gwls_nseeds]], defines the seeds for the Lanczos procedure.
        That is, the states associated to band index [[gwls_first_seed]] to [[gwls_first_seed]]+[[gwls_nseeds]]-1 are used to generate the seed vectors.
        </p>
        <p>
        The default [[gwls_first_seed]]==[[gwls_band_index]] and [[gwls_nseeds]]==1 has been touroughly tested and seems to be the most performant.
        Users should therefore keep the default value.
        </p>
    varname: gwls_first_seed
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 8
    definition: GWLS KMAX for the ANALYTIC term
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        Governs the number of iterations to be done in the shift Lanczos solution of eq. (35) of Phys. Rev. B 91, 125120 (2015) to solve it at all external frequencies requested by the user ([[gw_freqsp]]).
        The default value is converged to a few 10s of meV for all molecules studied so far.
        </p>
    varname: gwls_kmax_analytic
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GWLS KMAX for the COMPLEMENT space.
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        The G0W0 formalism involves the calculation of a summation conceptually linked to the trace of the dielectric matrix (see eq. (38)
        of  Phys. Rev. B 91, 125120 (2015).
        Since the eigenvalues spectrum of the dielectric matrix of formed by a few large discrete eigenvalues and an integrable divergence in the density of eigenvalues around 0, it is expensive to sample accurately this divergence using the exact dielectric operator.
        It this becomes interesting to calculate the 'trace' of the 'exact - model' dielectric matrix in a small basis and add it to the 'trace' of the 'model' dielectric matrix obtained in a large bais.
        In the context where the model dielectric matrix is used in the calculations, [[gwls_sternheimer_kmax]] determines the size of the 'small' basis and [[gwls_kmax_complement]] determines the size of the 'large' basis.
        </p>
        <p>
        For more information on the exact role of these bases and on the model dielectric operator used, see section V of  Phys. Rev. B 91, 125120 (2015).
        </p>
    varname: gwls_kmax_complement
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 16
    definition: GWLS KMAX for the NUMERIC term
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        Governs the number of iterations to be done in the shift Lanczos solution of eq. (30) of  Phys. Rev. B 91, 125120 (2015) to solve it simultaneously at all integration frequencies (generated automatically by the number of points [[gwls_npt_gauss_quad]] to use in the gaussian quadrature) and all external frequencies requested by the user ([[gw_freqsp]]).
        The default value is converged to a few 10s of meV for all molecules studied so far.
        </p>
    varname: gwls_kmax_numeric
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 4
    definition: GWLS KMAX for the calculation of the POLES residue
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        The contour deformation technique, in the G0W0 context, will involve the calculation of pole residues associated to states lying between the one corrected ([[gwls_band_index]]) and the fermi level.
        These residues take the form of a matrix element of the inverse dielectric matrix at a real frequency (see eq. (11) of Phys. Rev. B 91, 125120 (2015)).
        Therefore, the dielectric matrix must be constructed in some basis at these frequencies and inverted to calculate the matrix element.
        The present input variable sets the size of the Lanczos basis to be constructed for this purpose.
        The default value has proven to be very robust for many molecular systems and should therefore be left to the default value by the user.
        </p>
        <p>
        For more information on the Lanczos basis constructed for the calculation of the residues, see section IV of Phys. Rev. B 91, 125120 (2015).
        </p>
    varname: gwls_kmax_poles
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: '*0.0'
    definition: GWLS LIST of the PROJection FREQuencies
    dimensions:
    - '[[gwls_n_proj_freq]]'
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        This variable sets the frequencies to be used to construct the basis in which the Hamiltonian is projected to accelerate the solution of the Sternheimer equations involved by the construction of the dielectric matrix at finite frequencies.
        See section VI of Phys. Rev. B 91, 125120 (2015).
        For most cases, since the frequencies \Infty and (if [[gwls_recycle]]>0) 0.0 are used at no computational cost, [[gwls_n_proj_freq]]==0 (which means no ADDITIONAL frequency is to be used) is fine and no frequencies need to be picked up.
    varname: gwls_list_proj_freq
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: GWLS model parameter
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        This is the width of the lorentzian, in Ha, used to model the frequency dependence of the dielectric matrix in the GWLS calculation
        (see eqs. (12), (13), (14), (15), (16) and (34) of  Phys. Rev. B 91, 125120 (2015)).
        More precisely, this parameter is the value of \alpha used in eq. (34).
        This model is then used to separate the integration over frequencies into a 'model' part (second term of eq. (12)) and a 'exact - model' part (first term of eq. (12)).
        Since the 'model' part can be integrated analytically (see eqs. (15), (16) and (34)), only the the 'exact - model' part needs to be integrated numerically.
        </p>
        <p>
        The only effect of this model is therefore to alleviate the numerical cost of the integration over frequencies in the G0W0 calculation.
        The value of the associated parameter has thus an impact on the convergence rate of the GWLS calculation with respect to the number of frequencies of integration ([[gwls_npt_gauss_quad]]), but no impact on the converged result of the GWLS calculation.
        Typically, the default ([[gwls_model_parameter]]==1.0) is optimal.
        </p>
    varname: gwls_model_parameter
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GWLS Number of PROJection FREQuencies
    dimensions: scalar
    excludes: ''
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        This variable sets the number of frequencies, on top of \Infty and (if [[gwls_recycle]]>0) 0.0, to be used for the construction of the basis in which the hamiltonian is projected to accelerate the solution of the Sternheimer equations involved in the construction of the dielectric matrix at finite frequencies.
        See section VI of  Phys. Rev. B 91, 125120 (2015).
        For most cases, the default ([[gwls_n_proj_freq]]==0) is fine.
    varname: gwls_n_proj_freq
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: 'GWLS Number of PoinTs to use for the GAUSSian QUADrature '
    dimensions: scalar
    excludes: ''
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        This variable defines the number of points used for the numerical integration of the self-energy over frequencies in GWLS computations
        (see eq. (12) of  Phys. Rev. B 91, 125120 (2015)).
        The default is fine for most cases.
    varname: gwls_npt_gauss_quad
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GWLS Number of SEED vectorS
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        This variable sets the number of seed vectors to be used in the construction of the Lanczos basis for the (static) dielectric matrix in a GWLS calculation.
        See section IV of  Phys. Rev. B 91, 125120 (2015).
        Only [[gwls_nseeds]]==1 has been tested for now and users should keep this value.
    varname: gwls_nseeds
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GWLS PRINT level for DEBUGging
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        Influences the level of verbosity for debugging purposes in a GWLS calculation. Users should keep its value at the default.
    varname: gwls_print_debug
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: GWLS RECYCLE
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        <p>
        This variable let the user choose if and how he wants to recycle the solutions of the Sternheimer equations involved in the construction of the static dielectric matrix.
        <ul>
        <li> [[gwls_recycle]]==0 : No recycling of the solutions </li>
        <li> [[gwls_recycle]]==1 : Recycle the solutions. To do so, store them in RAM. </li>
        <li> [[gwls_recycle]]==2 : Recycle the solutions. To do so, store them on disk. </li>
        </ul>
        If the user choose to recycle the solutions, they are used to construct the basis in which the hamiltonian is projected for the solution of the Sternheimer equations involved by the calculation of the dielectric matrix at finite frequencies.
        The other solutions used will be those at \omega \to \Infty (alwyas used) and those at \omega=[[gwls_list_proj_freq]].
        For more information of the basis constructed, see section IV of  Phys. Rev. B 91, 125120 (2015).
        </p>
        <p>
        It is important to note that the solutions rapidly take much space to store.
        Therefore, it is often not possible to store them in RAM in production calculations, yet still desirable to retain them.
        This is when it becomes interesting to store them on disk.
        It is particularly efficient to choose the path of the file to be on disk space local to the processor in large MPI calculations, since each processor need only his own solutions in the construction of the basis.
        </p>
    varname: gwls_recycle
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: GWLS second model parameter
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        Not used yet.
    varname: gwls_second_model_parameter
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: GWLS Kmax
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==66'
    section: vargw
    text: |-
        This variable sets the dimension of the dielectric matrix used in a GWLS calculation (see section IV of  Phys. Rev. B 91, 125120 (2015)).
        Typically converged at a value of a few hundreds to a few thousands for a convergence criterion of 50meV on the  eigenenergies.
    varname: gwls_sternheimer_kmax
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 11
    definition: GW MEMory
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         [[gwmem]] governs the memory strategy during a screening and/or a sigma run.
         <ul>
          <li>
           [[gwmem]] = 1x , the screening matrix are read for all q-vectors and stored in the memory.
          </li>
          <li>
           [[gwmem]] = 0x , the screening matrix are read just a q-vector after another.
           <br />
          </li>
          <li>
           [[gwmem]] = x1 , the real-space wavefunctions are stored in the memory.
          </li>
          <li>
           [[gwmem]] = x0 , the real-space wavefunctions are not stored, but rather recalculated on-fly each abinit needs them using FFTs.
          </li>
         </ul>
         The default is [[gwmem]] = 11, which is the fastest, but also the most memory consuming.
        When experiencing memory shortage, one should try [[gwmem]] = 0.
        The first digit is only meaningful when performing sigma calculations.
        </p>
        <p>
        </p>
    varname: gwmem
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: 'The default value has been changed in v8. From 1 to 2 '
    commentdims: null
    defaultval: 2
    definition: GW PARAllelization level
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: varpar
    text: |-
        <p>
         [[gwpara]] is used to choose between the two different parallelization levels
        available in the [[GW]] code. The available options are:
         <ul>
          <li>
           =1 =&gt; parallelisation on k points
          </li>
          <li>
           =2 =&gt; parallelisation on bands
          </li>
         </ul>
        </p>
        <p>
         Additional notes:
         <br />
         In the present status of the code, only the parallelization over bands ([[gwpara]]=2)
        allows to reduce the memory allocated by each processor.
         <br />
         Using [[gwpara]]=1, indeed, requires the same amount of memory as a sequential run,
        irrespectively of the number of CPUs used.
        </p>
    varname: gwpara
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: GW RPA CORRelation energy
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [1,11,21]'
    section: vargw
    text: |-
        <p>
         [[gwrpacorr]] governs the calculation of the RPA correlation energy.
         <ul>
          <li>
           [[gwrpacorr]] = 0, no RPA correlation energy is calculated
          </li>
          <li>
           [[gwrpacorr]] = 1, the RPA correlation energy is calculated using an exact integration over the coupling constant: it requires one diagonalization of the polarizability matrix
          </li>
          <li>
           [[gwrpacorr]] =
           <i>
            n
           </i>
           &gt; 1, the RPA correlation energy is calculated using
           <i>
            n
           </i>
           values for the coupling constant: it requires
           <i>
            n
           </i>
           inversions of the polarizability matrix
          </li>
         </ul>
        </p>
        <p>
        </p>
    varname: gwrpacorr
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Indices of AToms in CONstraint equations
    dimensions:
    - '[[natcon]]'
    - '[[nconeq]]'
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the indices of the atoms appearing in each of the
        [[nconeq]]
        independent equations constraining the motion of
        atoms during structural optimization or molecular dynamics (see
        [[nconeq]] , [[natcon]],
        and [[wtatcon]]).
         <br />
         (Note : combined with wtatcon to give internal representation of the
        latter - this should be described)
        </p>
    varname: iatcon
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: 'Indices of AToms that are FIXed '
    dimensions:
    - '[[natfix]]'
    excludes: null
    requires: '[[natfix]] > 0'
    section: varrlx
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        </p>
        <p>
         WARNING : The implementation is inconsistent !! For
        [[ionmov]] ==1, the fixing of directions
        was done in cartesian coordinates, while for the other values
        of [[ionmov]], it was done in reduced
        coordinates. Sorry for this.
        </p>
        <p>
         There is no harm in fixing one atom in the three
        directions
        using [[iatfix]], then fixing it again in other directions
        by mentioning it in
         <b>
          iatfixx
         </b>
         ,
         <b>
          iatfixy
         </b>
         or
         <b>
          iatfixz
         </b>
         .
         <br />
         The internal representation of these input data is done
        by the mean of one variable [[iatfix]](3,[[natom]]),
        defined
        for each direction and each atom, being 0 if the atom is
        not fixed along the direction, and 1 if the atom is fixed
        along the direction.
        When some atoms are fixed along 1 or 2 directions, the
        use of symmetries is restricted to symmetry operations
        whose (3x3) matrices [[symrel]] are
        diagonal.
         <br />
         If the geometry builder is used, [[iatfix]] will be related
        to the preprocessed set of atoms, generated by the
        geometry builder. The user must thus foresee the effect
        of this geometry builder (see [[objarf]]).
        </p>
    varname: iatfix
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Indices of AToms that are FIXed along the X direction
    dimensions:
    - '[[natfixx]]'
    excludes: null
    requires: '[[natfixx]] > 0'
    section: varrlx
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed ALONG THE X direction for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        See the variable [[iatfix]] for more information.
        </p>
    varname: iatfixx
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Indices of AToms that are FIXed along the Y direction
    dimensions:
    - '[[natfixy]]'
    excludes: null
    requires: '[[natfixy]] > 0'
    section: varrlx
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed ALONG THE Y direction for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        See the variable [[iatfix]] for more information.
        </p>
    varname: iatfixy
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Indices of AToms that are FIXed along the Z direction
    dimensions:
    - '[[natfixz]]'
    excludes: null
    requires: '[[natfixz]] > 0'
    section: varrlx
    text: |-
        <p>
         Give the index (in the range 1 to
        [[natom]] )
        of each atom which is to
        be held fixed ALONG THE Z direction for structural optimization or molecular dynamics.
        The variable [[iatfix]] lists those fixed in the three directions,
        while the variables [[iatfixx]], [[iatfixy]], and [[iatfixz]], allow to fix some atoms along
        x, y or z directions, or a combination of these.
        See the variable [[iatfix]] for more information.
        </p>
    varname: iatfixz
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !range
        start: 1
        stop: '[[natsph]]'
    definition: Index for the ATomic SPHeres of the atom-projected density-of-states
    dimensions:
    - '[[natsph]]'
    excludes: null
    requires: '[[prtdos]] == 3 or [[pawfatbnd]] in [1,2]'
    section: vargs
    text: |-
        <p>
         [[iatsph]] gives the number of the [[natsph]] atoms around which the sphere
        for atom-projected density-of-states will be build,
        in the [[prtdos]]=3 case.
        The radius of these spheres is given by [[ratsph]].
         <br />
         If [[pawfatbnd]]=1 or 2, it gives the number of the [[natsph]] atoms around which atom-projected band structure will be built.
        </p>
    varname: iatsph
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer governing the internal use of BOXCUT - not a very good choice of variable name
    dimensions: scalar
    excludes: null
    requires: null
    section: varpaw
    text: |-
        <p>
         Concern all summations in the reciprocal space and is
        allowed in PAW and norm-conserving.
         <ul>
          <li>
           if set to 0 all reciprocal space summations are done in a sphere
        contained in the FFT box.
          </li>
          <li>
           if set to 1 all reciprocal space summations are done in the whole
        FFT box (useful for tests).
          </li>
         </ul>
        </p>
    varname: iboxcut
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Coulomb TReaTMenT
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Defines the type of computation used for Hartree potential, local part of pseudo-potential and ion-ion interaction:
        </p>
        <ul>
         <li>
          [[icoulomb]]=0 : usual reciprocal space computation, using 1 / g^2 for the Hartree potential and using Ewald correction.
         </li>
         <li>
          [[icoulomb]]=1 : free boundary conditions are used when the Hartree potential is computed, real space expressions of pseudo-potentials are involved (restricted to GTH pseudo-potentials) and simple coulomb interaction gives the ion-ion energy.
         </li>
        </ul>
    varname: icoulomb
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 6
    definition: Integer that governs the CUT-off for COULomb interaction
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         Many-body calculations for isolated systems present a slow convergence with respect to the size of
        the supercell due to the long ranged Coulomb interaction and the high degree of non-locality of the
        operators involved. A similar issue also occurs in fully periodic systems due to the presence
        of the integrable Coulomb singularity at G=0 that hinders the convergence with respect to the number
        of q-points used to sample the Brillouin zone.
        The convergence can be accelerated by replacing the true bare Coulomb interaction with other
        expressions.
        <p>
        [[icutcoul]] defines the particular expression to be used for the Coulomb term in reciprocal
        space. The choice of [[icutcoul]]  depends on the dimensionality of the system.
        Possible values of [[icutcoul]] are from 0 to 6. The corresponding influential variables are [[vcutgeo]]
        and [[rcut]].
         <ul>
          <li>
           0 =&gt; sphere (molecules but also 3D-crystals)
          </li>
          <li>
           1 =&gt; cylinder (nanowires, nanotubes)
          </li>
          <li>
           2 =&gt; surface
          </li>
          <li>
           3 =&gt; 3D crystal (no cut-off, integration in a spherical mini-Brillouin Zone, legacy value)
          </li>
          <li>
           4 =&gt; ERF, long-range only Coulomb interaction
          </li>
          <li>
           5 =&gt; ERFC, short-range only Coulomb interaction (e.g. as used in the HSE functional)
          </li>
          <li>
           6 =&gt; auxiliary function integration for 3D systems from P. Carrier
           <i>
            et al.
           </i>
           , PRB
           <b>
            75
           </b>
           ,205126 (2007).
          </li>
          <li>
           7 =&gt; auxiliary function for 3D systems of Gygi and Baldereschi [cf. Phys. Rev. B <b>34</b>, 4405 (1986) and Massidda et al., ibid. <b>48</b>, 5058 (1993)].
          </li>
         </ul>
         Note that Spencer and Alavi PRB <b>77</b>, 193110 (2008) showed that the spherical cutoff can efficiently be used also for 3D systems.
        In the latter case, use a negative value for the cutoff radius of the sphere ([[rcut]]&lt;0),
        which is automatically calculated so that the volume enclosed in the sphere is equal to the volume of the solid.
        </p>
    varname: icutcoul
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer for second-order EIGenvalues from Response-Function
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         If [[ieig2rf]] is greater then 0, the code will produce a file, named with the trailing suffix _EIGR2D, containing the second-order electronic eigenvalues for the perturbation. These files are used in the calculation of the thermal correction to the electronic eigenvalues.
         <br />
         <br />
         If [[ieig2rf]] is set to 1, the second-order electronic eigenvalues will be calculated from the DFPT method (Sternheimer).
         <br />
         If [[ieig2rf]] is set to 2, the second-order electronic eigenvalues will be calculated from the Allen-Cardona method. (sum over states)
         <br />
         If [[ieig2rf]] is set to 3, the second-order electronic eigenvalues will be calculated from the DFPT method (sum over states) but using a different part of the code. This is equivalent to [[ieig2rf]] = 1 [debuging]
         <br />
         If [[ieig2rf]] is set to 4, the second-order electronic eigenvalues will be calculated from the dynamical DFPT method (Sternheimer).
         The code will generate _EIGR2D.nc files that contain the electron-phonon matrix element squared on the space orthogonal to the active space.
         The code will also produce _FAN.nc files that contain the electron-phonon matrix elements squared.
         Note that [[ieig2rf]]=4 can only be used if Abinit is compiled with NETCDF support.
         <br />
         If [[ieig2rf]] is set to 5, the second-order electronic eigenvalues will be calculated from the dynamical DFPT method (Sternheimer).
         The code will generate _EIGR2D.nc files that contain the electron-phonon matrix element square on the space orthogonal to the active space.
         The code will also produce _GKK.nc files that contain electron-phonon matrix elements.
         This option is preferable for large system to [[ieig2rf]]=4 as the GKK files take less much less disk space and memory (but run a little bit slower).
         Note that [[ieig2rf]]=5 can only be used if Abinit is compiled with NETCDF support.
         <br />
         Related variables : [[bdeigrf]],[[elph2_imagden]],[[getgam_eig2nkq]],[[smdelta]]
         Related variables : [[bdeigrf]],[[elph2_imagden]],[[getgam_eig2nkq]],[[smdelta]]
        </p>
    varname: ieig2rf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: IMaGe MOVEs
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p> Control the collective changes of images (see [[nimage]],[[npimage]], [[dynimage]],
        [[ntimimage]], [[tolimg]], [[istatimg]], [[prtvolimg]]).
        <br> Similar to [[ionmov]] in spirit, although here, a population
        of self-consistent calculations for different geometries is managed, while with [[ionmov]],
        only one geometry for self-consistent calculation is managed.
        <br> In this respect the maximal number of time step for image propagation is [[ntimimage]],
        corresponding to the input variable [[ntime]] of the single geometry case.
        Also, the stopping criterion is governed by [[tolimg]], corresponding to the
        input variable [[toldfe]] of the single geometry case.
        The stopping  condition is crude: the image propagation is stopped when the mean value (over dynamic images)
        of the absolute difference of total energy (previous and current time step) is less than [[tolimg]].

        <p>Actually, there might be combinations of [[ionmov]] and [[imgmov]]
        in which the two mechanisms are at work.
        Usually, however, only one mechanism will be activated
        (so, usually, either [[ntimimage]] is bigger than one OR [[ntime]] is bigger than one).
        In order for the user to acquire a mental representation of the interplay between [[ionmov]] and [[imgmov]],
        here is a F90 pseudo-code presenting the interplay between the different above-mentioned input variables,
        as well as with the parallelism (see input variable [[npimage]]).
        </p>
        <p><pre>
        do itimimage=1,ntimimage
          do iimage=1,nimage
            (possibly, parallelisation over images)
            do itime=1,ntime
              Compute the forces and stresses for image(iimage)
              Examine whether the stopping criterion defined by tolmxf is fulfilled
              Predict the next geometry for image(iimage) using ionmov
            enddo
          enddo
          Examine whether the stopping criterion defined by tolimg is fulfilled
          Predict the next geometries for all images using imgmov
        enddo
        </pre></p>
        <ul>
          <li>    = 0  => simply <b> copy </b> images from previous timimage step.</li>
          <li>    = 1  => move images according to <b> Steepest Descent </b>
                         following the (scaled) forces, the scaling factor being [[fxcartfactor]]. </li>
          <li>    = 2  => <b> String Method </b> for finding Minimal Energy Path (MEP)
               connecting to minima (see PRB 66, 052301 (2002));
               the algorithm variant can be selected with the [[string_algo]] keyword
               (Simplified String Method by default).
               The solver for the Ordinary Differential Equation (ODE) can be selected with [[mep_solver]]
               (steepest-descent by default). See also [[mep_mxstep]] keyword.</li>
          <li>    = 3  => (tentatively, not yet coded) <b> Metadynamics </b>.</li>
          <li>    = 4  => (tentatively, not yet coded) <b> Genetic Algorithm</b>.</li>
          <li>    = 5  => <b> Nudged Elastic Band (NEB) </b> for finding Minimal Energy Path (MEP)
               connecting two minima;
               the algorithm variant can be selected with the [[neb_algo]] keyword
               (NEB+improved tangent by default).
               The solver for the Ordinary Differential Equation (ODE) can be selected with [[mep_solver]]
               (steepest-descent by default).
               The spring constant connecting images along the path is defined by [[neb_spring]].
               See also [[mep_mxstep]] keyword.</li>
          <li>    = 9 or 13  => <b> Path-Integral Molecular Dynamics </b>
               (see e.g. [D. Marx and M. Parrinello, J. Chem. Phys. 104, 4077 (1996)]).
               Will use 9 for <b>  Langevin thermostat </b> (associated friction coefficient given by [[vis]])
               and 13 for <b>  Nose-Hoover thermostat chains </b>
               (associated input variables are the number of thermostats in the chains, [[nnos]],
               and the masses of these thermostats [[qmass]]).
               [[nimage]] is the Trotter number (no use of [[dynimage]]);
               possible transformations of coordinates are defined by [[pitransform]];
               Fictitious masses of the atoms (possibly different from the true masses given by [[amu]])
               can be specified by [[pimass]].
               At present, it is only possible to perform calculations in the (N,V,T) ensemble ([[optcell]]=0).</li>
          </ul>
          No meaning for RF calculations.
        </p>
    varname: imgmov
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: INCLude VKB
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,99]'
    section: vargw
    text: |-
        <p>
        Possible values of [[inclvkb]] are 0,1,2.
        If [[inclvkb]] is 1 or 2, the commutator of the non-local part of the pseudopotential with the position operator is correctly included in the q =&gt; 0 contribution.
        This is unfortunately time-consuming and in particular when the old algorithm implemented by inclvkb==1 is used (inclvkb=2 is the recommended option).
        When [[inclvkb]] is 0, this contribution is incorrectly
        omitted, but the computation is much faster.
        </p>
        <p>
         The importance of this contribution depends on the number of k points. Turning off [[inclvkb]] is let to the choice of the user.
        </p>
        <p>
        In general, the use of [[inclvkb]]=0 is fine for [[GW]] calculations in crystalline systems provided that the k-point sampling is sufficiently converged.
        <p>
        The use of [[inclvkb]]=2 is strongly recommended for the calculation of optical properties.
        </p>
    varname: inclvkb
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: INTerpolation for eXchange-Correlation
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <ul>
          <li>
           0=&gt; do "usual" xc quadrature on fft grid
          </li>
          <li>
           1=&gt; do higher accuracy xc quadrature using fft grid
        and additional points at the centers of each cube
        (doubles number of grid points)--the high accuracy version
        is only valid for boxcut&gt;=2.  If boxcut &lt; 2, the code stops.
          </li>
         </ul>
         <br />
         For RF calculations only [[intxc]]=0 is allowed yet. Moreover,
        the GS preparation runs (giving the density file and zero-order
        wavefunctions) must be done with [[intxc]]=0
        </p>
        <p>
         Prior to ABINITv2.3, the choice [[intxc]]=1 was favoured (it was the default),
        but the continuation of the development of the code lead to prefer
        the default [[intxc]]=0 . Indeed, the benefit of [[intxc]]=1 is
        rather small, while making it available for all cases is a
        non-negligible development effort. Other targets are prioritary...
        You will notice that many automatic tests use [[intxc]]=1. Please,
        do not follow this historical choice for your production runs.
        </p>
    varname: intxc
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[MPI_IO]] and [[paral_kgb]]==1': 1
        defaultval: 0
    definition: IO MODE
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
        This option selects the format used to produce the output wavefunction files and the files containing
        densities and potentials. It mainly affects the creation of the output files since several parts
        of Abinit are able to read data from files independently of their format (either binary files or netcdf files).
        The possible values are:
        </p>

        <ul>
         <li>
          0 =&gt; Use standard Fortran IO (ok for sequential runs, not suitable for large parallel runs)
         </li>
         <li>
          1 =&gt; Use MPI/IO routines (ok both for sequential and large parallel runs)
         </li>
         <li>
          3 =&gt; Use NetCDF library to produce files according to the ETSF specification
         (ok for sequential, requires netcdf4 + hdf5 + MPI-IO support for large parallel runs)
         </li>
        </ul>
        <br />

        <p>
        By default, Abinit produces Fortran files and uses parallel MPI-IO under the hood when these
        operations cannot be implemented in terms of simple Fortran write/read statements.
        For example, [[paral_kgb]]=1 uses the MPI-IO API provided by your MPI library.
        </p>

        <p>
        In a nutshell, use the default value and make sure that your MPI library supports MPI-IO
        before embarking yourself in large parallel runs (HAVE_MPI_IO should be set to 1 in ~abinit/config.h).
        Many MPI libraries, nowadays, support the MPI-2 standard so it's very likely that your MPI supports
        parallel IO. If you encounter problems, please ask your sysadmin to install a MPI library
        with MPI-IO capabilities.
        </p>
        <p>
        There are cases, however, in which you would like to change the default behaviour.
        For example, you may want to generate WFK or DEN files in etsf-io format because you need
        data in this format.
        In this case, you have to use iomode==3 in the input file to override the default behaviour.
        Note however that you still need parallel IO capabilities enabled in the netcdf library
        if you want to produce netcdf files in parallel with [[paral_kgb]]=1 (i.e. netcdf4 + hdf5 + MPI-IO).
        At present, the internal fallbacks provided by Abinit do not support netcdf4 so you
        have to link against an external netcdf library that supports hdf5+MPI-IO and
        is compatible with the mpif90 used to compile Abinit.
        See ~abinit/doc/build/config-examples/ubu_gnu_4.9_mpich.ac for a typical configuration file.
        </p>

        <p>
        References:
        <ul>
         <li>
         "Specification of an extensible and portable file format for electronic structure and crystallographic data",
        X. Gonze, C.-O. Almbladh, A. Cucca, D. Caliste, C. Freysoldt, M. Marques, V. Olevano, Y. Pouillon,
        M.J. Verstraete, Comput. Mat. Science 43, 1056 (2008)
          </li>
          <li>
           "Sharing electronic structure and crystallographic data with ETSF_IO",
        D. Caliste, Y. Pouillon, M.J. Verstraete, V. Olevano, X. Gonze,
        Comput. Physics Communications 179, 748 (2008)
          </li>
          <li>
           see also
           <a href="http://www.etsf.eu/fileformats">
            http://www.etsf.eu/fileformats
           </a>
           .
          </li>
         </ul>
        </p>
    varname: iomode
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: IONic MOVEs
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
        Choice of algorithm to control the displacements of ions, and eventually (see [[optcell]])
        changes of cell shape and size.
         <ul>
          <li> 0=&gt; Do not move ions; <br /> <br /> </li>
          <li>
           1=&gt; Move atoms using molecular dynamics with
        optional viscous damping (friction linearly proportional
        to velocity). The viscous damping is controlled by the
        parameter "[[vis]]".  If actual undamped molecular dynamics is desired,
        set [[vis]] to 0. The implemented algorithm is the generalisation
        of the Numerov technique (6th order), but is NOT invariant
        upon time-reversal, so that the energy is not conserved.
        The value [[ionmov]]=6 will usually be preferred, although the
        algorithm that is implemented is lower-order. The time step is governed by [[dtion]].  <br />
           <b> Purpose: </b>
           Molecular dynamics (if [[vis]]=0), Structural optimization (if [[vis]]&gt;0) <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           Viscous parameter [[vis]], time step [[dtion]], index of atoms fixed [[iatfix]] <br /> <br /> </li>
          <li>
           2=&gt; Conduct structural optimization using the Broyden-Fletcher-Goldfarb-Shanno minimization (BFGS).
        This is much more efficient for structural optimization than viscous damping, when there are less than
        about 10 degrees of freedom to optimize.  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           3=&gt; Conduct structural optimization using the Broyden-Fletcher-Goldfarb-Shanno minimization (BFGS),
        modified to take into account the total energy as well as the gradients (as in usual BFGS).  <br />
           See the paper by [Schlegel, J. Comp. Chem. 3, 214 (1982)].
        Might be better than [[ionmov]]=2 for few degrees of freedom
        (less than 3 or 4). Can be very unstable - use with caution! <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           4=&gt; Conjugate gradient algorithm for simultaneous optimization of potential and ionic degrees of freedom.
        It can be used with [[iscf]]=2 and [[iscf]]  =5 or 6 (WARNING : this is under development, and does not work very well in many cases).  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           5=&gt; Simple relaxation of ionic positions according to (converged) forces. Equivalent to [[ionmov]]=1 with
        zero masses, albeit the relaxation coefficient is not [[vis]], but [[iprcfc]].  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           6=&gt; Molecular dynamics using the Verlet algorithm, see [Allen &amp; Tildesley "Computer simulation of liquids" 1987, p 81].
        The only related parameter is the time step ([[dtion]]).  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]], index of atoms fixed [[iatfix]] <br /> <br />
          </li>
          <li>
           7=&gt; Quenched Molecular dynamics using the Verlet algorithm, and stopping each atom for which the scalar product
        of velocity and force is negative.  The only related parameter is the time step ([[dtion]]).  The goal is not
        to produce a realistic dynamics, but to go as fast as possible to the minimum. For this purpose, it is advised to set
        all the masses to the same value (for example, use the Carbon mass, i.e. set [[amu]] to 12 for all type of atoms).  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]], index of atoms fixed [[iatfix]] <br /> <br />
          </li>
          <li>
           8=&gt; Molecular dynamics with Nose-Hoover thermostat, using the Verlet algorithm.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step ([[dtion]]), Temperatures ([[mdtemp]]), and thermostat mass ([[noseinert]]).  <br /> <br />
          </li>
          <li>
           9=&gt; Langevin molecular dynamics.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step ([[dtion]]), temperatures ([[mdtemp]]) and friction coefficient ([[friction]]).  <br /> <br />
          </li>
          <li>
           10=&gt; Delocalized internal coordinates. with BFGS simple <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           11=&gt; Delocalized internal coordinates. with BFGS using total energy <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           12=&gt; Isokinetic ensemble molecular dynamics.  The equation of motion of the ions in contact with a thermostat
        are solved with the algorithm proposed by Zhang [J. Chem. Phys. 106, 6102 (1997)],
        as worked out by Minary et al [J. Chem. Phys. 188, 2510 (2003)].  The conservation of the kinetic energy is obtained within machine
        precision, at each step.  <br />
           <s> Related parameters : the time step ([[dtion]]), the temperatures ([[mdtemp]]), and the friction coefficient ([[friction]]).
           </s> <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           13=&gt; Isothermal/isenthalpic ensemble.
        The equation of motion of the ions in contact with a thermostat
        and a barostat are solved with the algorithm proposed by Martyna,
        Tuckermann Tobias and Klein [Mol. Phys., 1996, p. 1117].  <br />
           If optcell=1 or 2, the mass of the barostat ([[bmass]]) must be given in addition.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b>
           The time step ([[dtion]]), the temperatures ([[mdtemp]]), the number of thermostats ([[nnos]]), and the masses of thermostats ([[qmass]]).  <br /> <br />
          </li>
          <li>
           14=&gt; Simple molecular dynamics with a symplectic algorithm proposed
        by S.Blanes and P.C.Moans [called SRKNa14 in Practical symplectic partitioned
        Runge--Kutta and Runge--Kutta--Nystr&ouml;m methods, Journal of Computational
        and Applied Mathematics archive, volume 142,  issue 2  (May 2002), pages 313 - 330]
        of the kind first published by H. Yoshida [Construction of higher order symplectic
        integrators, Physics Letters A, volume 150, number 5 to 7, pages 262 - 268].
        This algorithm requires at least 14 evaluation of the forces (actually 15 are done
        within Abinit) per time step. At this cost it usually gives much better
        energy conservation than the verlet algorithm ([[ionmov]] 6) for a 30 times bigger
        value of [[dtion]]. Notice that the potential energy of the initial atomic configuration is never evaluated using this algorithm.  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           20=&gt; Direct inversion of the iterative subspace.
        Given a starting point [[xred]] that is a vector of length 3*[[natom]]
        (reduced nuclei coordinates), and unit cell parameters ([[rprimd]])
        this routine uses the DIIS (direct inversion of the iterative
        subspace) to minimize the gradient (forces) on atoms. The preconditioning
        used to compute errors from gradients is using an inverse hessian matrix obtained by a BFGS algorithm.
        This method is known to converge to the nearest point where gradients
        vanish. This is efficient to refine positions around a saddle point for instance.  <br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           DIIS memory [[diismemory]] <br /> <br />
          </li>
          <li>
          22=&gt; Conduct structural optimization using the Limited-memory Broyden-Fletcher-Goldfarb-Shanno minimization (L-BFGS).
        The working routines were based on the original implementation of J. Nocera available on netlib.org.
        This algorithm can be much better than the native implementation of BFGS in ABINIT ([[ionmov]]=2)
        when one approaches convergence, perhaps because of better treatment of numerical details.<br />
           <b> Purpose: </b>
           Structural optimization <br />
           <b> Cell optimization: </b>
           Yes (if [[optcell]]/=0) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
          <li>
           23=&gt; Use of Learn on The Fly method (LOTF) for Molecular Dynamics.
        In the framework of isokinetic MD, the atomic forces and positions are computed
        by using LOTF interpolation.  A SCF computation is performed only any [[lotf_nitex]]
        steps. The results of the SCF are used to compute the parameters of a
        short range classical potential (for the moment only the glue potential for gold is implemented).
        Then these parameters are continuously tuned to compute atomic trajectories.
        LOTF has to be enabled at configure time. If LOTF is not enabled and [[ionmov]]=23,
        abinit will set automatically [[ionmov]]=12.  <br />
           The LOTF cycle is divided in the following steps: <br />
           a) Initialization (SFC at t=0) and computation of potential parameters.  <br />
           b) Extrapolation of the atomic forces and positions for [[lotf_nitex]] time step.
        To perform this extrapolation, the potential computed in a) is used (Verlet algorithm).  <br />
           c) SFC at t=[[lotf_nitex]]. Computation of the potential parameters.  <br />
           d) LOTF interpolation, linear interpolation of the potential parameters and computation of the atomic
        forces and positions between t=0 and t=lotf_nitex.  <br /> <br />
           <b> Purpose: </b>
           Molecular Dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           [[dtion]], [[lotf_classic]], [[lotf_nitex]], [[lotf_nneigx]], [[lotf_version]].  <br /> <br />
          </li>
          <li>
          24=&gt; Simple constant energy molecular dynamics using the velocity Verlet symplectic algorithm (second order), see e.g. [E. Hairer et al. Acta Numerica. 12, 399 (2003)].
        The only related parameter is the time step ([[dtion]]).  <br />
           <b> Purpose: </b>
           Molecular dynamics <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]] <br /> <br />
          </li>
          <li>
          25=&gt; Hybrid Monte Carlo sampling of the ionic positions at fixed temperature and unit cell geometry (NVT ensemle). The underlying molecular dynamics corresponds to ionmov=24.
        The related parameters are the time step ([[dtion]]) and thermostat temperature ([[mdtemp]]).  <br />
           <b> Purpose: </b>
           Monte Carlo sampling <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b>
           time step [[dtion]], thermostat temperature [[mdtemp]], <br /> <br />
          </li>
          <li>
           30=&gt; Using a supercell, calculate a self consistent phonon structure
        as in PRL 100 095901 (2008). The initial phonon eigenvectors and
        eigenvalues are read in, and then atoms are displaced according
        to the normal modes populated at a given temperature until
        convergence of the vibrational free energy (or so I hope) <br />
           <b> Purpose: </b>
           Phonon structure <br />
           <b> Cell optimization: </b>
           No (Use [[optcell]]=0 only) <br />
           <b> Related variables: </b> <br /> <br />
          </li>
         </ul>
         <ul>
         </ul>
         <br />
         No meaning for RF calculations.
        </p>
    varname: ionmov
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer for PReConditioning of ELectron response
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Used when [[iscf]]&gt;0, to define the SCF preconditioning scheme.
        Potential-based preconditioning schemes for the SCF loop
        (electronic part) are still a subject of active research.
        The present parameter (electronic part) describes the way the
        change of potential is derived from the residual.
         <br />
         The possible values of [[iprcel]] correspond to :
         <ul>
          <li>
           0 =&gt; model dielectric function described by [[diemac]],
        [[dielng]]
        and [[diemix]].
          </li>
          <li>
           larger or equal to 21 =&gt; will compute the dielectric matrix
        according to [[diecut]], [[dielam]],
        [[diegap]]. This methodology is described in
        P.-M. Anglade, X. Gonze, Phys. Rev. B 78, 045126 (2008).
          </li>
          <li>
           Between 21 and 29 =&gt; for the first few steps
        uses the same as option 0 then compute RPA dielectric function,
        and use it as such.
          </li>
          <li>
           Between 31 and 39 =&gt; for the first few steps
        uses the same as option 0 then compute RPA dielectric function,
        and use it, with the mixing factor [[diemix]].
          </li>
          <li>
           Between 41 and 49 =&gt; compute the RPA dielectric matrix
        at the first step, and recompute it at a later step,
        and take into account the mixing factor [[diemix]].
          </li>
          <li>
           Between 51 and 59 =&gt; same as between 41 and 49, but compute
        the RPA dielectric matrix by another mean
          </li>
          <li>
           Between 61 and 69 =&gt; same as between 41 and 49, but compute
        the electronic dielectric matrix instead of the RPA one.
          </li>
          <li>
           Between 71 and 78 =&gt; STILL UNDER DEVELOPMENT -- NOT USABLE ; Use the modified Kerker preconditioner with a real-space formulation (basic formulation is shown at [[dielng]]). The dielectric matrix is approximated thanks to  [[diemac]] and [[dielng]].  Note that [[diemix]] is also used.
          </li>
          <li>
           79 =&gt; STILL UNDER DEVELOPMENT -- NOT USABLE ; same as previous but with an alternate algorithm.
          </li>
          <li>
           141 to 169 =&gt; same as Between 41 and 69 (but, the dielectric matrix is also recomputed every iprcel modulo 10 step).
          </li>
         </ul>
         <br />
         The computation of the dielectric matrix (for 0 [100]&lt; [[iprcel]] &lt; 70 [100]) is based on the
         <b>
          extrapolar
         </b>
         approximation. This approximation can be tuned with [[diecut]], [[dielam]],
        and [[diegap]]. Yet its accuracy mainly depends on the number of conduction bands included in the system. Having 2 to 10 empty bands in the calculation is
        usually enough (use [[nband]]).
         <br />
         <br />
         NOTES:
         <ul>
          <li>
           The step at which the dielectric matrix is computed or
        recomputed is determined by modulo([[iprcel]],10). The recomputation happens
        just once in the calculation for [[iprcel]] &lt; 100.
          </li>
          <li>
           For non-homogeneous relatively large cells [[iprcel]]=45
        will likely give a large improvement over [[iprcel]]=0.
          </li>
          <li>
           In case of PAW and [[iprcel]]&gt;0, see [[pawsushat]] input variable. By default,
        an approximation (which can be suppressed) is done for the computation of susceptibility matrix.
          </li>
          <li>
           For extremely large inhomogeneous cells where computation of the full dielectric matrix takes too many weeks, 70 &lt; [[iprcel]] &lt; 80 is advised.
          </li>
          <li>
           For [[nsppol]]=2 or
        [[nspinor]]=2 with metallic [[occopt]],
        only
           <b>
            mod(iprcel,100)
           </b>
           &lt;50 is allowed.
          </li>
          <li>
           No meaning for RF calculations yet.
          </li>
          <li>
           The exchange term in the full dielectric matrix diverges for vanishing densities.
        Therefore the values of [[iprcel]] beyond 60 must not be used for cells containing vacuum,
        unless ones computes this matrix for every step ([[iprcel]]=161).
          </li>
         </ul>
        </p>
    varname: iprcel
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer for PReConditioner of Force Constants
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used when [[iscf]]&gt;0, to define the SCF preconditioning scheme.
        Potential-based preconditioning schemes for the SCF loop
        are still under development.
         <br />
         The present parameter (force constant part)
        describes the way a change of force
        is derived from a change of atomic position.
         <br />
         Supported values :
         <ul>
          <li>
           0 =&gt; hessian is the identity matrix
          </li>
          <li>
           1 =&gt; hessian is 0.5 times the identity matrix
          </li>
          <li>
           2 =&gt; hessian is 0.25 times the identity matrix
          </li>
          <li>
           -1=&gt; hessian is twice the identity matrix
          </li>
          <li>
           ... (simply corresponding power of 2 times the identity matrix)
          </li>
         </ul>
         No meaning for RF calculations.
        </p>
    varname: iprcfc
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Index for QPoinT generation
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Only used if [[nqpt]]=1, and
        [[qptopt]]=1 to 4.
        </p>
        <p>
         Defines the index of the Q point to be selected in the list of q points generated by
        [[ngqpt]],
        [[qptrlatt]],
        [[nshiftq]],
        and
        [[shiftq]].
        </p>
        <p>
         If [[iqpt]]=0, then the q point is Gamma (0 0 0).
        </p>
        <p>
         The usual working mode is to define a series of values for [[iqpt]],
        starting with [[iqpt]]=0 or 1 (so through the definition of
         <b>
          iqpt:
         </b>
         ),
        and increasing it by one for each dataset (thanks to
         <b>
          iqpt+
         </b>
         ).
        </p>
    varname: iqpt
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 3
    definition: Integer for the choice of the RANDOM number generator
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         For the time being, only used when [[imgmov]]=9
        (Langevin Path-Integral Molecular Dynamics).
         <br />
         [[irandom]] defines the random number generator.
         <br />
         <br />
         Supported values :
         <ul>
          <li>
           1 =&gt; "uniformrandom", delivered with ABINIT package (initially comes from numerical recipes).
          </li>
          <li>
           2 =&gt; intrinsic Fortran 90 random number generator.
          </li>
          <li>
           3 =&gt; "ZBQ" non-deterministic random number generator by R. Chandler and P. Northrop.
          (Available at <a href="http://www.ucl.ac.uk/~ucakarc/work/index.html#code">).
          </li>
         </ul>
         [[irandom]]=3 is strongly advised when performing Molecular Dynamics restarts (avoids bias).
        </p>
    varname: irandom
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[iscf]] < 0': 1
        defaultval: 0
    definition: Integer that governs the ReaDing of 1st-order DEN file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        If first order density is needed in single dataset mode
        (for example in nonlinear optical response),
        use [[ird1den]]=1 to read first-order densities from _DENx files produced in
        other calculations. In multi-dataset mode use
        [[get1den]].
        </p>
        When iscf &#60; 0, the reading of a DEN file is always enforced.
        </p>
        <p>
         A non-zero value of
         <b>
          ird1den
         </b>
         is treated in the same way
        as other "ird" variables,
        see the
         <a href="../../users/abinit_help.html#4">
          section 4
         </a>
         of abinit_help.
         <br />
        </p>
    varname: ird1den
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Integer that governs the ReaDing of _1WF files '
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only
           <b>
            irdwfk
           </b>
           and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] can be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           only one of
           <b>
            irdwfq
           </b>
           or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
           <b>
            irdwfk
           </b>
           and/or [[getwfk]]
          </li>
          <li>
           if
           <b>
            irdwfq
           </b>
           = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of [[ird1wf]] or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions to zeroes
          </li>
          <li>
           if [[ird1wf]] = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of
           <b>
            irdddk
           </b>
           or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if
           <b>
            irdddk
           </b>
           = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
        </p>
    varname: ird1wf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of COUPling block
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Start the Bethe-Salpeter calculation from the BSC file containing the coupling block produced in a previous run.
        </p>
    varname: irdbscoup
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of BS_EIG file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Start the Bethe-Salpeter calculation from the BS_EIG contining the exciton eigenvectors produced in a previous run.
        </p>
    varname: irdbseig
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of RESOnant block
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Start the Bethe-Salpeter calculation from the BSR file containing the resonat block produced in a previous run.
        </p>
    varname: irdbsreso
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[iscf]] < 0': '1'
        defaultval: 0
    definition: Integer that governs the ReaDing of DDB file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
        This variable should be used when performing electron-phonon
        or temperature-dependence calculations.
        The Born effective charge
        as well as the dielectric tensor will be read from a previous
        DFPT calculations of the electric field at q=Gamma.

        The use of this variable will trigger the cancellation of a
        residual dipole that leads to an unphysical divergence of the
        GKK with vanishing q-points.

        The use of this variable greatly improves the k-point convergence
        speed as the density of the k-point grid required to obtain the
        fulfillment of the charge neutrality sum rule is usually prohibitively
        large.
        </p>
        <p>
         A non-zero value of [[irdddb]] is treated in the same way
        as other "ird" variables,
        see the
         <a href="../../users/abinit_help.html#4">
          section 4
         </a>
         of abinit_help.
         <br />
         <br />
        </p>
    varname: irdddb
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of DDK wavefunctions, in _1WF files
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only
           <b>
            irdwfk
           </b>
           and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] can be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           only one of
           <b>
            irdwfq
           </b>
           or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
           <b>
            irdwfk
           </b>
           and/or [[getwfk]]
          </li>
          <li>
           if
           <b>
            irdwfq
           </b>
           = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of
           <b>
            ird1wf
           </b>
           or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions
        to zeroes
          </li>
          <li>
           if
           <b>
            ird1wf
           </b>
           = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of [[irdddk]] or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if [[irdddk]] = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
        </p>
    varname: irdddk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[iscf]] < 0': '1'
        defaultval: 0
    definition: Integer that governs the ReaDing of DEN file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
        Start the ground-state calculation from the density file of a previous run.
        When iscf &#60; 0, the reading of a DEN file is always enforced.
        </p>
        <p>
         A non-zero value of [[irdden]] is treated in the same way
        as other "ird" variables,
        see the
         <a href="../../users/abinit_help.html#4">
          section 4
         </a>
         of abinit_help.
         <br />
         <br />
        </p>
    varname: irdden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of the HAYDOCK restart file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Used to re-start the Haydock iterative technique from the HAYDR_SAVE file produced in a previous run.
        </p>
    varname: irdhaydock
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of QuasiParticle Structure
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Relevant only when [[optdriver]]=3 or 4.
        Indicate the file from which the eigenvalues and possibly the wavefunctions must be obtained,
        in order to achieve a self-consistent quasiparticle calculations.
        See also [[getqps]]
        </p>
    varname: irdqps
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of the SCReening
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Relevant only when [[optdriver]]=4.
        Indicate the file from which the dielectric matrix must be obtained.
        As alternative, one can use the input variable
        [[getscr]].
         <br />
         When [[optdriver]]=4, at least one of
        [[irdscr]] or [[getscr]]
        (alternatively, [[irdsuscep]] or [[getsuscep]])
        must be non-zero.
        </p>
        <p>
         A non-zero value of [[irdscr]] is treated in the same way as other "ird" variables,
        see the
         <a href="../../users/abinit_help.html#4">
          section 4
         </a>
         of abinit_help.
        </p>
    varname: irdscr
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of the SUSCEPtibility
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Relevant only when [[optdriver]]=4.
        Indicate the file from which the irreducible polarizability must be obtained.
        As alternative, one can use the input variable
        [[getsuscep]].
         <br />
         When [[optdriver]]=4, at least one of
        [[irdsuscep]] or [[getsuscep]]
        (alternatively, [[irdscr]] or [[getscr]])
        must be non-zero.
        </p>
        <p>
         A non-zero value of [[irdsuscep]] is treated in the same way as other "ird" variables,
        see the
         <a href="../../users/abinit_help.html#4">
          section 4
         </a>
         of abinit_help.
        </p>
    varname: irdsuscep
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of _VDW files
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to read previously calculated vdW-DF variables.
        <br />
        Supported values:
        <ul>
         <li>
          0 =&gt; do not read vdW-DF variables
         </li>
         <li>
          1 =&gt; read vdW-DF variables
         </li>
        </ul>
    varname: irdvdw
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of _WFK files
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only [[irdwfk]] and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of [[irdwfk]] or [[getwfk]] can be non-zero
          </li>
          <li>
           if [[irdwfk]] and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if [[irdwfk]] = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of [[irdwfk]] or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if [[irdwfk]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           only one of
           <b>
            irdwfq
           </b>
           or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
        [[irdwfk]] and/or [[getwfk]]
          </li>
          <li>
           if
           <b>
            irdwfq
           </b>
           = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of
           <b>
            ird1wf
           </b>
           or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions
        to 0's.
          </li>
          <li>
           if
           <b>
            ird1wf
           </b>
           = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of
           <b>
            irdddk
           </b>
           or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if
           <b>
            irdddk
           </b>
           = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
        </p>
    varname: irdwfk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of the fine grid _WFK files
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfkfine]].
        <br />
        <br />
        Ground-state calculation :
        <ul>
         <li>
          only [[irdwfkfine]] and [[getwfkfine]] have a meaning
         </li>
         <li>
          at most one of [[irdwfkfine]] or [[getwfkfine]] can be non-zero
         </li>
         <li>
          if [[irdwfkfine]] = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state fine grid calculation (see the
          <a href="../../users/abinit_help.html#4">
           section 4
          </a>
          of abinit_help).
         </li>
        </ul>
        Response-function calculation :
        <ul>
         <li>
          one and only one of [[irdwfkfine]] or [[getwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[irdwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/abinit_help.html#4">
           section 4
          </a>
          of abinit_help).
         </li>
         <li>
          Reading the fine grid wavefunction will trigger the k-points interpolation technique of the temperature dependent
        calculations.
         </li>
        </ul>
        Bethe-Salpeter calculation :
        <ul>
         <li>
          one and only one of [[irdwfkfine]] or [[getwfkfine]] MUST be non-zero
         </li>
         <li>
          if [[irdwfkfine]] = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
          <a href="../../users/abinit_help.html#4">
           section 4
          </a>
          of abinit_help).
         </li>
         <li>
          This variable or [[getwfkfine]] is mandatory when [[bs_interp_mode]] = 1
         </li>
        </ul>
        <b>
         This variable is experimental. In development.
        </b>
    varname: irdwfkfine
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer that governs the ReaDing of _WFQ files
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Indicates eventual starting
        wavefunctions. As alternative, one can use the
        input variables [[getwfk]],
        [[getwfq]], [[get1wf]]
        or [[getddk]].
         <br />
         <br />
         Ground-state calculation :
         <ul>
          <li>
           only
           <b>
            irdwfk
           </b>
           and [[getwfk]] have a meaning
          </li>
          <li>
           at most one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] can be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           and [[getwfk]] are both zero,
        initialize wavefunctions with
        random numbers for ground state calculation.
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
         Response-function calculation :
         <ul>
          <li>
           one and only one of
           <b>
            irdwfk
           </b>
           or [[getwfk]] MUST be non-zero
          </li>
          <li>
           if
           <b>
            irdwfk
           </b>
           = 1 : read ground state k -wavefunctions
        from a disk file appended with _WFK , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           only one of [[irdwfq]] or [[getwfq]] can be non-zero,
        if both of them are non-zero,
        use as k + q file the one defined by
           <b>
            irdwfk
           </b>
           and/or [[getwfk]]
          </li>
          <li>
           if [[irdwfq]] = 1 : read ground state k+q -wavefunctions
        from a disk file appended with _WFQ , produced in a
        previous ground state calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of
           <b>
            ird1wf
           </b>
           or [[get1wf]] can be non-zero
          </li>
          <li>
           if both are zero, initialize first order wavefunctions
        to 0's.
          </li>
          <li>
           if
           <b>
            ird1wf
           </b>
           = 1 : read first-order wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
          <li>
           at most one of
           <b>
            irdddk
           </b>
           or [[getddk]] can be non-zero
          </li>
          <li>
           one of them must be non-zero if an homogeneous
        electric field calculation is done
        (presently, a ddk calculation in the same dataset
        is not allowed)
          </li>
          <li>
           if
           <b>
            irdddk
           </b>
           = 1 : read first-order ddk wavefunctions
        from a disk file appended with _1WFx , produced in a
        previous response function calculation (see the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help).
          </li>
         </ul>
        </p>
    varname: irdwfq
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==1': 17
        '[[usewvl]]==1': 0
        defaultval: 7
    definition: Integer for Self-Consistent-Field cycles
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Controls the self-consistency.
         <br />
         Positive values =&gt;
        this is the usual choice for doing the usual ground state (GS)
        calculations or for structural relaxation, where
        the potential has to be determined self-consistently.
        The choice between different algorithms for SCF is possible :
         <ul>
          <li>
           =0 =&gt; SCF cycle, direct minimization scheme on the gradient of the wavefunctions. This algorithm is faster than diagonalisation and mixing but is working only for systems with a gap. It is implemented only on the wavelet basis set, when [[usewvl]]=1.
          </li>
          <li>
           =1 =&gt; get the largest eigenvalue of the SCF cycle
           <br />
           ([[DEVELOP]] option, used with
        [[irdwfk]]=1 or
           [[irdwfq]]=1)
          </li>
          <li>
           =2 =&gt; SCF cycle, simple mixing of the potential
          </li>
          <li>
           =3 =&gt; SCF cycle, Anderson mixing of the potential
          </li>
          <li>
           =4 =&gt; SCF cycle, Anderson mixing of the potential based on the two previous iterations
          </li>
          <li>
           =5 =&gt; SCF cycle, CG based on the minim. of the energy with respect to the potential
          </li>
          <li>
           =7 =&gt; SCF cycle, Pulay mixing of the potential based on the [[npulayit]] previous iterations
          </li>
          <li>
           =12 =&gt; SCF cycle, simple mixing of the density
          </li>
          <li>
           =13 =&gt; SCF cycle, Anderson mixing of the density
          </li>
          <li>
           =14 =&gt; SCF cycle, Anderson mixing of the density based on the two previous iterations
          </li>
          <li>
           =15 =&gt; SCF cycle, CG based on the minim. of the energy with respect to the density
          </li>
          <li>
           =17 =&gt; SCF cycle, Pulay mixing of the density based on the [[npulayit]] previous iterations
          </li>
          <li>
           Other positive values, including zero ones, are not allowed.
          </li>
         </ul>
        </p>
        <p>
         Such algorithms for treating the "SCF iteration history" should be coupled with accompanying algorithms
        for the SCF "preconditioning". See the input variable [[iprcel]].
        The default value [[iprcel]]=0 is often a good choice, but
        for inhomogeneous systems, you might gain a lot with [[iprcel]]=45.
        </p>
        <p>
         (Warning : if [[iscf]]&gt;10, at present (v4.6), the energy printed at each SCF cycle is not variational -
        this should not affect the other properties, and at convergence, all values are OK)
        </p>
        <p>
         - In the norm-conserving case,
        the default option is [[iscf]]=7, which is a compromise between speed and reliability.
        The value [[iscf]]= 2 is safer but slower.
         <br />
         - In the PAW case, default option is [[iscf]]=17.
        In PAW you have the possibility to mix density/potential on the fine or coarse FFT grid (see [[pawmixdg]]).
         <br />
         - Note that a Pulay mixing ([[iscf]]=7 or 17) with [[npulayit]]
        =1 (resp. 2) is equivalent to an Anderson mixing with [[iscf]]=3 or 13 (resp. 4 or 14).
         <br />
         - Also note that:
         <br />
         * when mixing is done on potential (iscf
         &lt;10), total energy is computed by "direct" decomposition.
         <br />
         * when mixing is done on density (iscf
         &gt;=10), total energy is computed by "double counting" decomposition.
         <br />
         "Direct" and "double counting" decomposition of energy are equal when SCF cycle is converged. Note that,
        when using GGA XC functionals, these decompositions of energy can be slightly different due
        to imprecise computation of density gradients on FFT grid (difference decreases as size of FFT grid increases -
        see [[ecut]] for NC pseudopotentials, [[pawecutdg]] for PAW).
         <br />
         <br />
         Other (negative) options:
         <ul>
          <li>
           = -2 =&gt;
        a non-self-consistent calculation is to be done;
        in this case an electron density rho(r) on a real space grid
        (produced in a previous calculation) will be read from a
        disk file (automatically if [[ndtset]]=0, or
        according to the value of [[getden]]
        if [[ndtset]]/=0).
           <br />
           The name of the density file must be given as indicated
        in the
           <a href="../../users/abinit_help.html#4">
            section 4
           </a>
           of abinit_help.
        [[iscf]]=-2 would be used for
        band structure calculations, to permit computation of
        the eigenvalues of occupied and unoccupied states at
        arbitrary k points in the fixed self consistent potential
        produced by some integration grid of k points.
        Due to this typical use, ABINIT insist that either
        [[prtvol]]&gt;2 or
        [[prteig]] does not vanish
        when there are more than 50 k points.
           <br />
           To compute the eigenvalues
        (and wavefunctions) of unoccupied states in a separate
        (non-selfconsistent) run, the user should
        save the self-consistent rho(r)
        and then run [[iscf]]=-2 for the intended set of k-points and bands.
           <br />
           To prepare a run with [[iscf]]=-2, a density file
        can be produced using the
        parameter [[prtden]] (see its description).
        When a self-consistent set of wavefunctions is already available,
        abinit can be used with
        [[nstep]]=0 (see Test_v2/t47.in),
        and the adequate value of [[prtden]].
          </li>
          <li>
           = -3 =&gt;
        like -2, but initialize [[occ]] and [[wtk]],
        directly or indirectly (using [[ngkpt]] or
        [[kptrlatt]])
        depending on the value of [[occopt]].
           <br />
           For GS, this option
        might be used to generate Density-of-states
        (thanks to [[prtdos]]),
        or to produce STM charge density map (thanks to [[prtstm]]).
           <br />
           For RF, this option is needed to compute the response to ddk perturbation.
          </li>
          <li>
           = -1 =&gt; like -2, but the non-self-consistent calculation
        is followed by the determination of excited states
        within [[TDDFT]]. This is only possible for [[nkpt]]=1,
        with [[kpt]]=0 0 0.
        Note that the oscillator strength needs to be defined with respect to
        an origin of coordinate, thanks to the input variable
        [[boxcenter]]. The maximal
        number of Kohn-Sham excitations to be used to build the
        excited state [[TDDFT]] matrix can be defined by [[td_mexcit]],
        or indirectly by the maximum Kohn-Sham excitation energy
        [[td_maxene]].
          </li>
         </ul>
        </p>
    varname: iscf
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Integer for level of SECURity choice
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         In the presently used algorithms, there is a compromise
        between speed and robustness, that can be tuned by
        using [[isecur]].
         <br />
         If [[isecur]] =0, an extrapolation of out-of-line
        data is allowed, and might save one non-SCF calculation every
        two line minimisation when some stability conditions
        are fulfilled (since there are 2 non-SCF calculations
        per line minimisation, 1 out of 4 is saved)
         <br />
         Using [[isecur]]=1 or higher integers will raise gradually
        the threshold to make extrapolation.
         <br />
         Using [[isecur]]=-2 will allow to save 2 non-SCF calculations
        every three line minimisation, but this can make the
        algorithm unstable. Lower values of [[isecur]] allows
        for more (tentative) savings. In any case, there must
        be one non-SCF computation per line minimisation.
         <br />
         No meaning for RF calculations yet.
        </p>
    varname: isecur
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Integer governing the computation of STATic IMaGes
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         This input variable is relevant when sets of images are activated (see
        [[imgmov]]).
         <br />
         Not all images might be required to evolve from one time step to the other
        (see[[dynimage]]): these are static images.
         <br />
         If [[istatimg]]=0, the total energy of static images is not computed (but static images are
        used to make the dynamic images evolve). This can be useful to save CPU time.
         <br />
         If [[istatimg]]=1, the total energy of static images is computed.
        </p>
    varname: istatimg
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    - '[[NO_MULTI]]'
    commentdefault: Values lower than 10 may not work on some machines.
    commentdims: null
    defaultval: 0
    definition: Integer for STATus file SHiFT
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
        Govern the rate of output of the status file.
        This status file is written when the number of the
        call to the status subroutine is equal to '
         <b>
          istatshft
         </b>
         ' modulo '[[istatr]]', so that
        it is written once every '[[istatr]]' call.
        When '[[istatr]]'=0, there is no writing of a status file (which is the default).
        </p>
    varname: istatr
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Integer for STATus file SHiFT
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Govern the rate of output of the status file.
        This status file is written when the number of the
        call to the status
        subroutine is equal to '[[istatshft]]' modulo '
         <b>
          istatr
         </b>
         ', so that
        it is written once every '
         <b>
          istatr
         </b>
         ' call.
        There is also a writing for each of the 5 first calls,
        and the 10th call.
        </p>
    varname: istatshft
    vartype: integer
- !variable
    characteristics: null
    commentdefault: 'For RF calculations, the Default is not used : <b>istwfk</b>
        is forced to be 1 deep inside the code, for all k points. For spin-orbit
        calculations ([[nspinor]]=2), <b>istwfk</b> is also forced to be 1,
        for all k points.'
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: Integer for choice of STorage of WaveFunction at each k point
    dimensions:
    - '[[nkpt]]'
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Control the way the
        wavefunction for each k-point is stored inside ABINIT,
        in reciprocal space.
         <br />
         For the GS calculations, in the "cg" array containing the
        wavefunction coefficients, there is for each k-point
        and each band, a segment cg(1:2,1:npw). The 'full' number
        of plane wave is determined by [[ecut]].
        However, if the k-point coordinates are build
        only from zeroes and halves (see list below),
        the use of time-reversal symmetry (that connects coefficients)
        has been implemented, in order to use real-to-complex
        FFTs (see [[fftalg]]), and to treat explicitly only half
        of the number of plane waves (this being used as 'npw').
         <br />
         For the RF calculations, there is not only the "cg"
        array, but also the "cgq" and "cg1" arrays. For the
        time-reversal symmetry to decrease the number of
        plane waves of these arrays, the q vector MUST be (0 0 0).
        Then, for each k point, the same rule as for the
        RF can be applied.
         <br />
         WARNING (991018) : for the time being, the time-reversal
        symmetry cannot be used in the RF calculations.
         <ul>
          <li>
           1=&gt; do NOT take advantage of the time-reversal symmetry
          </li>
          <li>
           2=&gt; use time-reversal symmetry for k=( 0   0   0 )
          </li>
          <li>
           3=&gt; use time-reversal symmetry for k=(1/2  0   0 )
          </li>
          <li>
           4=&gt; use time-reversal symmetry for k=( 0   0  1/2)
          </li>
          <li>
           5=&gt; use time-reversal symmetry for k=(1/2  0  1/2)
          </li>
          <li>
           6=&gt; use time-reversal symmetry for k=( 0  1/2  0 )
          </li>
          <li>
           7=&gt; use time-reversal symmetry for k=(1/2 1/2  0 )
          </li>
          <li>
           8=&gt; use time-reversal symmetry for k=( 0  1/2 1/2)
          </li>
          <li>
           9=&gt; use time-reversal symmetry for k=(1/2 1/2 1/2)
          </li>
          <li>
           0=&gt; (preprocessed) for each k point, choose automatically
        the appropriate time-reversal option when it is allowed,
        and chose [[istwfk]]=1 for all the other k points.
          </li>
         </ul>
        </p>
    varname: istwfk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: Default corresponds to Teter parametrization. However, if all the pseudopotentials have the same value of pspxc, the initial value of ixc will be that common value
    commentdims: null
    defaultval: 1
    definition: Integer for eXchange-Correlation choice
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Controls the choice of exchange and correlation (xc). The list of XC functionals is given
        below. Positive values are for ABINIT native library of XC functionals, while negative values are for calling
        the much wider set of functionals from the ETSF LibXC library (by M. Marques), also available at the
         <a href="http://www.etsf.eu/resources/software/libraries_and_tools">
          ETSF library Web page
         </a>
         <br />
         Note that the choice made here should agree with the choice
        made in generating the original pseudopotential, except
        for [[ixc]]=0 (usually only used for debugging).
        A warning is issued if this is not the case.
        However, the choices [[ixc]]=1, 2, 3 and 7 are fits to the same data, from
        Ceperley-Alder, and are rather similar, at least for spin-unpolarized systems.
         <br />
         The choice between the non-spin-polarized and spin-polarized case
        is governed by the value of [[nsppol]] (see below).
        </p>
        <p>
        </p>
        <p>
         <b>
          Native ABINIT XC functionals
         </b>
        </p>
        <p>
         <br />
         NOTE : in the implementation of the spin-dependence of these
        functionals, and in order to avoid divergences in their
        derivatives, the interpolating function between spin-unpolarized
        and fully-spin-polarized function has been slightly modified,
        by including a zeta rescaled by 1.d0-1.d-6. This should affect
        total energy at the level of 1.d-6Ha, and should
        have an even smaller effect on differences of energies, or derivatives.
         <br />
         The value [[ixc]]=10 is used internally : gives the difference between [[ixc]]=7 and
        [[ixc]]=9, for use with an accurate RPA correlation energy.
        </p>
        <p>
         <ul>
          <li>
           0=&gt; NO xc;
          </li>
         </ul>
         <ul>
          <li>
           1=&gt; LDA or LSD, Teter Pade parametrization (4/93, published in S. Goedecker, M. Teter, J. Huetter, Phys.Rev.B54, 1703 (1996)), which
        reproduces Perdew-Wang (which reproduces Ceperley-Alder!).
          </li>
          <li>
           2=&gt; LDA, Perdew-Zunger-Ceperley-Alder (no spin-polarization)
          </li>
          <li>
           3=&gt; LDA, old Teter rational polynomial parametrization (4/91)
        fit to Ceperley-Alder data (no spin-polarization)
          </li>
          <li>
           4=&gt; LDA, Wigner functional (no spin-polarization)
          </li>
          <li>
           5=&gt; LDA, Hedin-Lundqvist functional (no spin-polarization)
          </li>
          <li>
           6=&gt; LDA, "X-alpha" functional (no spin-polarization)
          </li>
          <li>
           7=&gt; LDA or LSD, Perdew-Wang 92 functional
          </li>
          <li>
           8=&gt; LDA or LSD, x-only part of the Perdew-Wang 92 functional
          </li>
          <li>
           9=&gt; LDA or LSD, x- and RPA correlation part of the Perdew-Wang 92 functional
          </li>
         </ul>
         <ul>
          <li>
           11=&gt; GGA, Perdew-Burke-Ernzerhof GGA functional
          </li>
          <li>
           12=&gt; GGA, x-only part of Perdew-Burke-Ernzerhof GGA functional
          </li>
          <li>
           13=&gt; GGA potential of van Leeuwen-Baerends, while for energy, Perdew-Wang 92 functional
          </li>
          <li>
           14=&gt; GGA, revPBE of Y. Zhang and W. Yang, Phys. Rev. Lett. 80, 890 (1998)
          </li>
          <li>
           15=&gt; GGA, RPBE of B. Hammer, L.B. Hansen and J.K. Norskov, Phys. Rev. B 59, 7413 (1999)
          </li>
          <li>
           16=&gt; GGA, HTCH93 of F.A. Hamprecht, A.J. Cohen, D.J. Tozer, N.C. Handy, J. Chem. Phys. 109, 6264 (1998)
          </li>
          <li>
           17=&gt; GGA, HTCH120 of A.D. Boese, N.L. Doltsinis, N.C. Handy, and M. Sprik, J. Chem. Phys 112, 1670 (1998) - The usual HCTH functional.
          </li>
          <li>
           18=&gt; (NOT AVAILABLE : used internally for GGA BLYP pseudopotentials from
        M. Krack, see Theor. Chem. Acc. 114, 145 (2005),
        available from the
           <a href="https://github.com/cp2k/cp2k/tree/master/potentials/Goedecker/abinit/blyp">
            CP2K repository
           </a>
           - use the LibXC instead, with [[ixc]]=-106131.
          </li>
          <li>
           19=&gt; (NOT AVAILABLE : used internally for GGA BP86 pseudopotentials from
        M. Krack, see Theor. Chem. Acc. 114, 145 (2005),
        available from the
           <a href="https://github.com/cp2k/cp2k/tree/master/potentials/Goedecker/abinit/bp">
            CP2K repository
           </a>
           - use the LibXC instead, with [[ixc]]=-106132.
          </li>
         </ul>
         <ul>
          <li>
           20=&gt; Fermi-Amaldi xc ( -1/N Hartree energy, where N is the
        number of electrons per cell ; G=0 is not taken
        into account however), for [[TDDFT]] tests.
        No spin-pol. Does not work for RF.
          </li>
          <li>
           21=&gt; same as 20, except that the xc-kernel is the LDA ([[ixc]]=1) one,
        for [[TDDFT]] tests.
          </li>
          <li>
           22=&gt; same as 20, except that the xc-kernel is the Burke-Petersilka-Gross
        hybrid, for [[TDDFT]] tests.
          </li>
          <li>
           23=&gt; GGA of Z. Wu and R.E. Cohen, Phys. Rev. 73, 235116 (2006).
          </li>
          <li>
           24=&gt; GGA, C09x exchange of V. R. Cooper, PRB 81, 161104(R) (2010).
          </li>
          <li>
           26=&gt; GGA, HTCH147 of A.D. Boese, N.L. Doltsinis, N.C. Handy, and M. Sprik, J. Chem. Phys 112, 1670 (1998).
          </li>
          <li>
           27=&gt; GGA, HTCH407 of A.D. Boese, and N.C. Handy, J. Chem. Phys 114, 5497 (2001).
          </li>
          <li>
           28=&gt; (NOT AVAILABLE : used internally for GGA OLYP pseudopotentials from
        M. Krack, see Theor. Chem. Acc. 114, 145 (2005),
        available from the
           <a href="https://github.com/cp2k/cp2k/tree/master/potentials/Goedecker/abinit/olyp">
            CP2K repository
           </a>
           - use the LibXC instead, with [[ixc]]=-110131.
          </li>
         </ul>
         <ul>
          <li>
           40=&gt; Hartree-Fock
          </li>
          <li>
           41=&gt; PBE0, J.P. Perdew, M. Ernzerhof and K. Burke, J. Chem. Phys. 105, 9982 (1996)
          </li>
          <li>
           42=&gt; PBE0-1/3, C.A. Guido, E. Bremond, C. Adamo and P. Cortona, J. Chem. Phys. 138, 021104 (2013)
          </li>
         </ul>
        </p>
        <p>
         <b>
          ETSF Lib XC functionals
         </b>
        </p>
        <p>
         Note that you must compile ABINIT with the LibXC plug-in in order to be able to access these functionals.
         <br />
         The LibXC functionals are accessed by
         <b>
          negative values
         </b>
         of [[ixc]].
        The LibXC contains functional forms for either exchange-only functionals, correlation-only functionals,
        or combined exchange and correlation functionals. Each of them is to be specified by a three-digit number.
        In case of a combined exchange and correlation functional, only one such three-digit number has to be specified as value of [[ixc]],
        with a minus sign (to indicate that it comes from the LibXC).
        In the case of separate exchange functional (let us represent its identifier by XXX) and
        correlation functional (let us represent its identified by CCC),
        a six-digit number will have to be specified for [[ixc]], by concatenation, be it XXXCCC or CCCXXX.
        As an example, [[ixc]]=-020 gives access to the Teter93 LDA, while
        [[ixc]]=-101130 gives access to the PBE GGA.
        In version 0.9 of LibXC (December 2008), there are 16 three-dimensional (S)LDA functionals (1 for X, 14 for C, 1 for combined XC),
        and there are 41 three-dimensional GGA (23 for X, 8 for C, 10 for combined XC).
        Note that for a meta-GGA, the kinetic energy density is needed. This means having [[usekden]]=1 .
        </p>
        <p>
        </p>
        <p>
         (S)LDA functionals (do not forget to add a minus sign, as discussed above)
        </p>
        <p>
         <ul>
          <li>
           001=&gt; XC_LDA_X
        [PAM Dirac, Proceedings of the Cambridge Philosophical Society 26, 376 (1930);
        F Bloch, Zeitschrift fuer Physik 57, 545 (1929)
        ]
          </li>
          <li>
           002=&gt; XC_LDA_C_WIGNER Wigner parametrization
        [EP Wigner, Trans. Faraday Soc. 34, 678 (1938)
        ]
          </li>
          <li>
           003=&gt; XC_LDA_C_RPA Random Phase Approximation
        [M Gell-Mann and KA Brueckner, Phys. Rev. 106, 364 (1957)
        ]
          </li>
          <li>
           004=&gt; XC_LDA_C_HL Hedin &amp; Lundqvist
        [L Hedin and BI Lundqvist, J. Phys. C 4, 2064 (1971)
        ]
          </li>
          <li>
           005=&gt; XC_LDA_C_GL !  Gunnarson &amp; Lundqvist
        [O Gunnarsson and BI Lundqvist, PRB 13, 4274 (1976)
        ]
          </li>
          <li>
           006=&gt; XC_LDA_C_XALPHA  !  Slater's Xalpha
        ]
          </li>
          <li>
           007=&gt; XC_LDA_C_VWN !  Vosko, Wilk, &amp; Nussair
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           008=&gt; XC_LDA_C_VWN_RPA !  Vosko, Wilk, &amp; Nussair (RPA)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           009=&gt; XC_LDA_C_PZ !  Perdew &amp; Zunger
        [Perdew and Zunger, Phys. Rev. B 23, 5048 (1981)
        ]
          </li>
          <li>
           010=&gt; XC_LDA_C_PZ_MOD !  Perdew &amp; Zunger (Modified)
        [Perdew and Zunger, Phys. Rev. B 23, 5048 (1981)
        Modified to improve the matching between the low and high rs part
        ]
          </li>
          <li>
           011=&gt; XC_LDA_C_OB_PZ !  Ortiz &amp; Ballone (PZ)
        [G Ortiz and P Ballone, Phys. Rev. B 50, 1391 (1994) ;
        G Ortiz and P Ballone, Phys. Rev. B 56, 9970(E) (1997) ;
        Perdew and Zunger, Phys. Rev. B 23, 5048 (1981)
        ]
          </li>
          <li>
           012=&gt; XC_LDA_C_PW !  Perdew &amp; Wang
        [JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992)
        ]
          </li>
          <li>
           013=&gt; XC_LDA_C_PW_MOD !  Perdew &amp; Wang (Modified)
        [JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992) ;
        Added extra digits to some constants as in the PBE routine
        see
           <a href="https://www.chem.uci.edu/~kieron/dftold2/pbe.php">
            https://www.chem.uci.edu/~kieron/dftold2/pbe.php
           </a>
           (at some point it was available at http://dft.uci.edu/pbe.php)
        ]
          </li>
          <li>
           014=&gt; XC_LDA_C_OB_PW !  Ortiz &amp; Ballone (PW)
        [G Ortiz and P Ballone, Phys. Rev. B 50, 1391 (1994) ;
        G Ortiz and P Ballone, Phys. Rev. B 56, 9970(E) (1997) ;
        JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992)
        ]
          </li>
          <li>
           017=&gt; XC_LDA_C_vBH !  von Barth &amp; Hedin
        [U von Barth and L Hedin, J. Phys. C: Solid State Phys. 5, 1629 (1972)
        ]
          </li>
          <li>
           020=&gt; XC_LDA_XC_TETER93 !  Teter 93 parametrization
        [S Goedecker, M Teter, J Hutter, PRB 54, 1703 (1996)
        ]
          </li>
          <li>
           022=&gt; XC_LDA_C_ML1 !  Modified LSD (version 1) of Proynov and Salahub
        [EI Proynov and D Salahub, Phys. Rev. B 49, 7874 (1994)
        ]
          </li>
          <li>
           023=&gt; XC_LDA_C_ML2 !  Modified LSD (version 2) of Proynov and Salahub
        [EI Proynov and D Salahub, Phys. Rev. B 49, 7874 (1994)
        ]
          </li>
          <li>
           024=&gt; XC_LDA_C_GOMBAS !  Gombas parametrization
        [P. Gombas, Pseudopotentials (Springer-Verlag, New York, 1967)
        ]
          </li>
          <li>
           025=&gt; XC_LDA_C_PW_RPA !  Perdew &amp; Wang fit of the RPA
        [JP Perdew and Y Wang, Phys. Rev. B 45, 13244 (1992)
        ]
          </li>
          <li>
           027=&gt; XC_LDA_C_RC04 !  Ragot-Cortona
        [S Ragot and P Cortona, J. Chem. Phys. 121, 7671 (2004)
        ]
          </li>
          <li>
           028=&gt; XC_LDA_C_VWN_1 !  Vosko, Wilk, &amp; Nussair (1)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           029=&gt; XC_LDA_C_VWN_2 !  Vosko, Wilk, &amp; Nussair (2)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           030=&gt; XC_LDA_C_VWN_3 !  Vosko, Wilk, &amp; Nussair (3)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
          <li>
           031=&gt; XC_LDA_C_VWN_4 !  Vosko, Wilk, &amp; Nussair (4)
        [SH Vosko, L Wilk, and M Nusair, Can. J. Phys. 58, 1200 (1980)
        ]
          </li>
         </ul>
        </p>
        <p>
         GGA functionals (do not forget to add a minus sign, as discussed above)
        </p>
        <p>
         <ul>
          <li>
           84=&gt; XC_GGA_C_OP_XALPHA !  one-parameter progressive functional (G96 version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           85=&gt; XC_GGA_C_OP_G96 !  one-parameter progressive functional (G96 version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           86=&gt; XC_GGA_C_OP_PBE !  one-parameter progressive functional (PBE version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           87=&gt; XC_GGA_C_OP_B88 !  one-parameter progressive functional (B88 version)
        [T Tsuneda, T Suzumura, and K Hirao, J. Chem. Phys. 111, 5656 (1999)
        ]
          </li>
          <li>
           88=&gt; XC_GGA_C_FT97 !  Filatov &amp; Thiel correlation
        [M Filatov &amp; W Thiel, Int. J. Quant. Chem. 62, 603-616 (1997) ; M Filatov &amp; W Thiel, Mol Phys 91, 847 (1997)
        ]  WARNING : this functional is not tested. Use at your own risks.
          </li>
          <li>
           89=&gt; XC_GGA_C_SPBE !  PBE correlation to be used with the SSB exchange
        [M Swart, M Sola, and FM Bickelhaupt, J. Chem. Phys. 131, 094103 (2009)
        ]
          </li>
          <li>
           90=&gt; XC_GGA_X_SSB_SW  !  Swarta, Sola and Bickelhaupt correction to PBE
        [M Swart, M Sola, and FM Bickelhaupt, J. Comp. Meth. Sci. Engin. 9, 69 (2009)
        ]
          </li>
          <li>
           91=&gt; XC_GGA_X_SSB   !  WARNING : This functional gives NaN on IBM (XG20130608).  Swarta, Sola and Bickelhaupt
        [M Swart, M Sola, and FM Bickelhaupt, J. Chem. Phys. 131, 094103 (2009)
        ]
          </li>
          <li>
           92=&gt; XC_GGA_X_SSB_D  !  WARNING : This functional gives NaN on IBM (XG20130608).  Swarta, Sola and Bickelhaupt dispersion
        [M Swart, M Sola, and FM Bickelhaupt, J. Chem. Phys. 131, 094103 (2009)
        ]
          </li>
          <li>
           93=&gt; XC_GGA_XC_HCTH_407P  !   HCTH/407+
        [AD Boese, A Chandra, JML Martin, and Dominik Marx, J. Chem. Phys. 119, 5965 (2003)
        ]
          </li>
          <li>
           94=&gt; XC_GGA_XC_HCTH_P76  !   HCTH p=7/6
        [G Menconi, PJ Wilson, and DJ Tozer, J. Chem. Phys. 114, 3958 (2001)
        ]
          </li>
          <li>
           95=&gt; XC_GGA_XC_HCTH_P14  !   HCTH p=1/4
        [G Menconi, PJ Wilson, and DJ Tozer, J. Chem. Phys. 114, 3958 (2001)
        ]
          </li>
          <li>
           96=&gt; XC_GGA_XC_B97_GGA1  !  Becke 97 GGA-1
        [AJ Cohen and NC Handy, Chem. Phys. Lett. 316, 160-166 (2000)
        ]
          </li>
          <li>
           97=&gt; XC_GGA_XC_HCTH_A  !  HCTH-A
        [FA Hamprecht, AJ Cohen, DJ Tozer, and NC Handy, J. Chem. Phys. 109, 6264 (1998)
        ]
          </li>
          <li>
           98=&gt; XC_GGA_X_BPCCAC  !  BPCCAC (GRAC for the energy)
        [E Bremond, D Pilard, I Ciofini, H Chermette, C Adamo, and P Cortona, Theor Chem Acc 131, 1184 (2012)
        ]
          </li>
          <li>
           99=&gt; XC_GGA_C_REVTCA  !  Tognetti, Cortona, Adamo (revised)
        [V Tognetti, P Cortona, and C Adamo, Chem. Phys. Lett. 460, 536-539 (2008)
        ]
          </li>
          <li>
           100=&gt; XC_GGA_C_TCA  ! Tognetti, Cortona, Adamo
        [V Tognetti, P Cortona, and C Adamo, J. Chem. Phys. 128, 034101 (2008)
        ]
          </li>
          <li>
           101=&gt; XC_GGA_X_PBE !  Perdew, Burke &amp; Ernzerhof exchange
        [JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 77, 3865 (1996) ;
        JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 78, 1396(E) (1997)
        ]
          </li>
          <li>
           102=&gt; XC_GGA_X_PBE_R !  Perdew, Burke &amp; Ernzerhof exchange (revised)
        [Y Zhang and W Yang, Phys. Rev. Lett 80, 890 (1998)
        ]
          </li>
          <li>
           103=&gt; XC_GGA_X_B86 !  Becke 86 Xalfa,beta,gamma
        [AD Becke, J. Chem. Phys 84, 4524 (1986)
        ]
          </li>
          <li>
           104=&gt; XC_GGA_X_HERMAN !  Herman Xalphabeta GGA
        [F Herman, JP Van Dyke, and IB Ortenburger, Phys. Rev. Lett. 22, 807 (1969) ;
        F Herman, IB Ortenburger, and JP Van Dyke, Int. J. Quantum Chem. Symp. 3, 827 (1970)
        ]
          </li>
          <li>
           105=&gt; XC_GGA_X_B86_MGC !  Becke 86 Xalfa,beta,gamma (with mod. grad. correction)
        [AD Becke, J. Chem. Phys 84, 4524 (1986) ;
        AD Becke, J. Chem. Phys 85, 7184 (1986)
        ]
          </li>
          <li>
           106=&gt; XC_GGA_X_B88 !  Becke 88
        [AD Becke, Phys. Rev. A 38, 3098 (1988)
        ]
          </li>
          <li>
           107=&gt; XC_GGA_X_G96 !  Gill 96
        [PMW Gill, Mol. Phys. 89, 433 (1996)
        ]
          </li>
          <li>
           108=&gt; XC_GGA_X_PW86 !  Perdew &amp; Wang 86
        [JP Perdew and Y Wang, Phys. Rev. B 33, 8800 (1986)
        ]
          </li>
          <li>
           109=&gt; XC_GGA_X_PW91 !  Perdew &amp; Wang 91
        [JP Perdew, in Proceedings of the 21st Annual International Symposium on the Electronic Structure of Solids, ed. by P Ziesche and H
        Eschrig (Akademie Verlag, Berlin, 1991), p. 11. ;
        JP Perdew, JA Chevary, SH Vosko, KA Jackson, MR Pederson, DJ Singh, and C Fiolhais, Phys. Rev. B 46, 6671 (1992) ;
        JP Perdew, JA Chevary, SH Vosko, KA Jackson, MR Pederson, DJ Singh, and C Fiolhais, Phys. Rev. B 48, 4978(E) (1993)
        ]
          </li>
          <li>
           110=&gt; XC_GGA_X_OPTX !  Handy &amp; Cohen OPTX 01
        [NC Handy and AJ Cohen, Mol. Phys. 99, 403 (2001)
        ]
          </li>
          <li>
           111=&gt; XC_GGA_X_DK87_R1 !  dePristo &amp; Kress 87 (version R1)
        [AE DePristo and JD Kress, J. Chem. Phys. 86, 1425 (1987)
        ]
          </li>
          <li>
           112=&gt; XC_GGA_X_DK87_R2 !  dePristo &amp; Kress 87 (version R2)
        [AE DePristo and JD Kress, J. Chem. Phys. 86, 1425 (1987)
        ]
          </li>
          <li>
           113=&gt; XC_GGA_X_LG93 !  Lacks &amp; Gordon 93
        [DJ Lacks and RG Gordon, Phys. Rev. A 47, 4681 (1993)
        ]
          </li>
          <li>
           114=&gt; XC_GGA_X_FT97_A !  Filatov &amp; Thiel 97 (version A)
        [M Filatov and W Thiel, Mol. Phys 91, 847 (1997)
        ]
          </li>
          <li>
           115=&gt; XC_GGA_X_FT97_B !  Filatov &amp; Thiel 97 (version B)
        [M Filatov and W Thiel, Mol. Phys 91, 847 (1997)
        ]
          </li>
          <li>
           116=&gt; XC_GGA_X_PBE_SOL !  Perdew, Burke &amp; Ernzerhof exchange (solids)
        [JP Perdew, et al, Phys. Rev. Lett. 100, 136406 (2008)
        ]
          </li>
          <li>
           117=&gt; XC_GGA_X_RPBE !  Hammer, Hansen &amp; Norskov (PBE-like)
        [B Hammer, LB Hansen and JK Norskov, Phys. Rev. B 59, 7413 (1999)
        ]
          </li>
          <li>
           118=&gt; XC_GGA_X_WC !  Wu &amp; Cohen
        [Z Wu and RE Cohen, Phys. Rev. B 73, 235116 (2006)
        ]
          </li>
          <li>
           119=&gt; XC_GGA_X_mPW91 !  Modified form of PW91 by Adamo &amp; Barone
        [C Adamo and V Barone, J. Chem. Phys. 108, 664 (1998)
        ]
          </li>
          <li>
           120=&gt; XC_GGA_X_AM05 !  Armiento &amp; Mattsson 05 exchange
        [R Armiento and AE Mattsson, Phys. Rev. B 72, 085108 (2005) ;
        AE Mattsson, R Armiento, J Paier, G Kresse, JM Wills, and TR Mattsson, J. Chem. Phys. 128, 084714 (2008)
        ]
          </li>
          <li>
           121=&gt; XC_GGA_X_PBEA !  Madsen (PBE-like)
        [G Madsen, Phys. Rev. B 75, 195108 (2007)
        ]
          </li>
          <li>
           122=&gt; XC_GGA_X_MPBE !  Adamo &amp; Barone modification to PBE
        [C Adamo and V Barone, J. Chem. Phys. 116, 5933 (2002)
        ]
          </li>
          <li>
           123=&gt; XC_GGA_X_XPBE !  xPBE reparametrization by Xu &amp; Goddard
        [X Xu and WA Goddard III, J. Chem. Phys. 121, 4068 (2004)
        ]
          </li>
          <li>
           125=&gt; XC_GGA_X_BAYESIAN !  Bayesian best fit for the enhancement factor
        [JJ Mortensen, K Kaasbjerg, SL Frederiksen, JK Norskov, JP Sethna, and KW Jacobsen, Phys. Rev. Lett. 95, 216401 (2005)
        ]
          </li>
          <li>
           126=&gt; XC_GGA_X_PBE_JSJR !  PBE JSJR reparametrization by Pedroza, Silva &amp; Capelle
        [LS Pedroza, AJR da Silva, and K. Capelle, Phys. Rev. B 79, 201106(R) (2009)
        ]
          </li>
          <li>
           130=&gt; XC_GGA_C_PBE !  Perdew, Burke &amp; Ernzerhof correlation
        [JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 77, 3865 (1996) ;
        JP Perdew, K Burke, and M Ernzerhof, Phys. Rev. Lett. 78, 1396(E) (1997)
        ]
          </li>
          <li>
           131=&gt; XC_GGA_C_LYP !  Lee, Yang &amp; Parr
        [C Lee, W Yang and RG Parr, Phys. Rev. B 37, 785 (1988)
        B Miehlich, A Savin, H Stoll and H Preuss, Chem. Phys. Lett. 157, 200 (1989)
        ]
          </li>
          <li>
           132=&gt; XC_GGA_C_P86 !  Perdew 86
        [JP Perdew, Phys. Rev. B 33, 8822 (1986)
        ]
          </li>
          <li>
           133=&gt; XC_GGA_C_PBE_SOL !  Perdew, Burke &amp; Ernzerhof correlation SOL
        [JP Perdew, et al, Phys. Rev. Lett. 100, 136406 (2008)
        ]
          </li>
          <li>
           134=&gt; XC_GGA_C_PW91 !  Perdew &amp; Wang 91
        [JP Perdew, JA Chevary, SH Vosko, KA Jackson, MR Pederson, DJ Singh, and C Fiolhais, Phys. Rev. B 46, 6671 (1992)
        ]
          </li>
          <li>
           135=&gt; XC_GGA_C_AM05 !  Armiento &amp; Mattsson 05 correlation
        [ R Armiento and AE Mattsson, Phys. Rev. B 72, 085108 (2005) ;
        AE Mattsson, R Armiento, J Paier, G Kresse, JM Wills, and TR Mattsson, J. Chem. Phys. 128, 084714 (2008)
        ]
          </li>
          <li>
           136=&gt; XC_GGA_C_XPBE !  xPBE reparametrization by Xu &amp; Goddard
        [X Xu and WA Goddard III, J. Chem. Phys. 121, 4068 (2004)
        ]
          </li>
          <li>
           137=&gt; XC_GGA_C_LM !  Langreth and Mehl correlation
        [DC Langreth and MJ Mehl, Phys. Rev. Lett. 47, 446 (1981)
        ]
          </li>
          <li>
           138=&gt; XC_GGA_C_PBE_JRGX !  JRGX reparametrization by Pedroza, Silva &amp; Capelle
        [LS Pedroza, AJR da Silva, and K. Capelle, Phys. Rev. B 79, 201106(R) (2009)
        ]
          </li>
          <li>
           139=&gt; XC_GGA_X_OPTB88_VDW !  Becke 88 reoptimized to be used with vdW functional of Dion et al
        [J Klimes, DR Bowler, and A Michaelides, J. Phys.: Condens. Matter 22, 022201 (2010)
        ]
          </li>
          <li>
           140=&gt; XC_GGA_X_PBEK1_VDW !  PBE reparametrization for vdW
        [J Klimes, DR Bowler, and A Michaelides, J. Phys.: Condens. Matter 22, 022201 (2010)
        ]
          </li>
          <li>
           141=&gt; XC_GGA_X_OPTPBE_VDW !  PBE reparametrization for vdW
        [J Klimes, DR Bowler, and A Michaelides, J. Phys.: Condens. Matter 22, 022201 (2010)
        ]
          </li>
          <li>
           142=&gt; XC_GGA_X_RGE2 !  Regularized PBE
        [A Ruzsinszky, GI Csonka, and G Scuseria, J. Chem. Theory Comput. 5, 763 (2009)
        ]
          </li>
          <li>
           143=&gt; XC_GGA_C_RGE2 !  Regularized PBE
        [A Ruzsinszky, GI Csonka, and G Scuseria, J. Chem. Theory Comput. 5, 763 (2009)
        ]
          </li>
          <li>
           144=&gt; XC_GGA_X_RPW86 !  refitted Perdew &amp; Wang 86
        [ED Murray, K Lee and DC Langreth, J. Chem. Theory Comput. 5, 2754-2762 (2009)
        ]
          </li>
          <li>
           145=&gt; XC_GGA_X_KT1 !  Keal and Tozer version 1
        [TW Keal and DJ Tozer, J. Chem. Phys. 119, 3015 (2003)
        ]
          </li>
          <li>
           146=&gt; XC_GGA_XC_KT2 !  WARNING : This functional gives NaN on IBM (XG20130608).  Keal and Tozer version 2
        [TW Keal and DJ Tozer, J. Chem. Phys. 119, 3015 (2003)
        ]
          </li>
          <li>
           147=&gt; XC_GGA_C_WL !  Wilson &amp; Levy
        [LC Wilson and M Levy, Phys. Rev. B 41, 12930 (1990)
        ]
          </li>
          <li>
           148=&gt; XC_GGA_C_WI !  Wilson &amp; Ivanov
        [LC Wilson &amp; S Ivanov, Int. J. Quantum Chem. 69, 523-532 (1998)
        ]
          </li>
          <li>
           149=&gt; XC_GGA_X_MB88 !  Modified Becke 88 for proton transfer
        [V Tognetti and C Adamo, J. Phys. Chem. A 113, 14415-14419 (2009)
        ]
          </li>
          <li>
           150=&gt; XC_GGA_X_SOGGA ! Second-order generalized gradient approximation
        [Y Zhao and DG Truhlar, J. Chem. Phys. 128, 184109 (2008) ; http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <li>
           151=&gt; XC_GGA_X_SOGGA11 !  Second-order generalized gradient approximation 2011
        [R Peverati, Y Zhao, and DG Truhlar, J. Phys. Chem. Lett. 2, 1911-1997 (2011); http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <li>
           152=&gt; XC_GGA_C_SOGGA11 ! Second-order generalized gradient approximation 2011
        [R Peverati, Y Zhao, and DG Truhlar, J. Phys. Chem. Lett. 2, 1911-1997 (2011); http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <li>
           153=&gt; XC_GGA_C_WI0 !  Wilson &amp; Ivanov initial version
        [LC Wilson &amp; S Ivanov, Int. J. Quantum Chem. 69, 523-532 (1998)
        ]
          </li>
          <li>
           154=&gt; XC_GGA_XC_TH1 !  Tozer and Handy v. 1
        [DJ Tozer and NC Handy, J. Chem. Phys. 108, 2545 (1998)
        ]  WARNING : this functional is not tested. Use at your own risks.
          </li>
          <li>
           155=&gt; XC_GGA_XC_TH2 ! Tozer and Handy v. 2
        [DJ Tozer and NC Handy, J. Phys. Chem. A 102, 3162 (1998)
        ]
          </li>
          <li>
           156=&gt; XC_GGA_XC_TH3 !  Tozer and Handy v. 3
        [DJ Tozer and NC Handy, Mol. Phys. 94, 707 (1998)
        ]
          </li>
          <li>
           157=&gt; XC_GGA_XC_TH4 !  Tozer and Handy v. 4
        [DJ Tozer and NC Handy, Mol. Phys. 94, 707 (1998)
        ]
          </li>
          <li>
           158=&gt; XC_GGA_X_C09X !  C09x to be used with the VdW of Rutgers-Chalmers
        [VR Cooper, PRB 81, 161104(R) (2010)
        ]
          </li>
          <li>
           159=&gt; XC_GGA_C_SOGGA11_X !  To be used with hyb_gga_x_SOGGA11-X
        [R Peverati and DG Truhlar, J. Chem. Phys. 135, 191102 (2011); http://comp.chem.umn.edu/mfm/index.html
        ]
          </li>
          <!-- The following functional is untested in ABINIT
        &lt;li&gt;160=&gt; XC_GGA_XC_LB !  van Leeuwen &amp; Baerends
        [R van Leeuwen and EJ Baerends, Phys. Rev. A. 49, 2421 (1994)
        ]&lt;/li&gt;
        -->
          <li>
           161=&gt; XC_GGA_XC_HCTH_93 !  HCTH functional fitted to  93 molecules
        [FA Hamprecht, AJ Cohen, DJ Tozer, and NC Handy, J. Chem. Phys. 109, 6264 (1998)
        ]
          </li>
          <li>
           162=&gt; XC_GGA_XC_HCTH_120 !  HCTH functional fitted to 120 molecules
        [AD Boese, NL Doltsinis, NC Handy, and M Sprik, J. Chem. Phys. 112, 1670 (2000)
        ]
          </li>
          <li>
           163=&gt; XC_GGA_XC_HCTH_147 !  HCTH functional fitted to 147 molecules
        [AD Boese, NL Doltsinis, NC Handy, and M Sprik, J. Chem. Phys. 112, 1670 (2000)
        ]
          </li>
          <li>
           164=&gt; XC_GGA_XC_HCTH_407 !  HCTH functional fitted to 407 molecules
        [AD Boese, and NC Handy, J. Chem. Phys. 114, 5497 (2001)
        ]
          </li>
          <li>
           165=&gt; XC_GGA_XC_EDF1 !  Empirical functionals from Adamson, Gill, and Pople
        [RD Adamson, PMW Gill, and JA Pople, Chem. Phys. Lett. 284 6 (1998)
        ]
          </li>
          <li>
           166=&gt; XC_GGA_XC_XLYP !  XLYP functional
        [X Xu and WA Goddard, III, PNAS 101, 2673 (2004)
        ]
          </li>
          <li>
           167=&gt; XC_GGA_XC_B97 !  Becke 97
        [AD Becke, J. Chem. Phys. 107, 8554-8560 (1997)
        ]
          </li>
          <li>
           168=&gt; XC_GGA_XC_B97_1 !  Becke 97-1
        [FA Hamprecht, AJ Cohen, DJ Tozer, and NC Handy, J. Chem. Phys. 109, 6264 (1998);
        AD Becke, J. Chem. Phys. 107, 8554-8560 (1997)
        ]
          </li>
          <li>
           169=&gt; XC_GGA_XC_B97_2 !  Becke 97-2
        [AD Becke, J. Chem. Phys. 107, 8554-8560 (1997)
        ]
          </li>
          <li>
           170=&gt; XC_GGA_XC_B97_D !  Grimme functional to be used with C6 vdW term
        [S Grimme, J. Comput. Chem. 27, 1787 (2006)
        ]
          </li>
          <li>
           171=&gt; XC_GGA_XC_B97_K !  Boese-Martin for Kinetics
        [AD Boese and JML Martin, J. Chem. Phys., Vol. 121, 3405 (2004)
        ]
          </li>
          <li>
           172=&gt; XC_GGA_XC_B97_3 !  Becke 97-3
        [TW Keal and DJ Tozer, J. Chem. Phys. 123, 121103 (2005)
        ]
          </li>
          <li>
           173=&gt; XC_GGA_XC_PBE1W !  Functionals fitted for water
        [EE Dahlke and DG Truhlar, J. Phys. Chem. B 109, 15677 (2005)
        ]
          </li>
          <li>
           174=&gt; XC_GGA_XC_MPWLYP1W !  Functionals fitted for water
        [EE Dahlke and DG Truhlar, J. Phys. Chem. B 109, 15677 (2005)
        ]
          </li>
          <li>
           175=&gt; XC_GGA_XC_PBELYP1W !  Functionals fitted for water
        [EE Dahlke and DG Truhlar, J. Phys. Chem. B 109, 15677 (2005)
        ]
          </li>
          <li>
           176=&gt; XC_GGA_XC_SB98_1a !  Schmider-Becke 98 parameterization 1a
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           177=&gt; XC_GGA_XC_SB98_1b !  Schmider-Becke 98 parameterization 1b
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           178=&gt; XC_GGA_XC_SB98_1c !  Schmider-Becke 98 parameterization 1c
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           179=&gt; XC_GGA_XC_SB98_2a !  Schmider-Becke 98 parameterization 2a
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           180=&gt; XC_GGA_XC_SB98_2b !  Schmider-Becke 98 parameterization 2b
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           181=&gt; XC_GGA_XC_SB98_2c !  Schmider-Becke 98 parameterization 2c
        [HL Schmider and AD Becke, J. Chem. Phys. 108, 9624 (1998)
        ]
          </li>
          <li>
           183=&gt; XC_GGA_X_OL2 !  Exchange form based on Ou-Yang and Levy v.2
        [P Fuentealba and O Reyes, Chem. Phys. Lett. 232, 31-34 (1995) ; H Ou-Yang, M Levy, Int. J. of Quant. Chem. 40, 379-388 (1991)
        ]
          </li>
          <li>
           184=&gt; XC_GGA_X_APBE !  mu fixed from the semiclassical neutral atom
        [LA Constantin, E Fabiano, S Laricchia, and F Della Sala, Phys. Rev. Lett. 106, 186406 (2011)
        ]
          </li>
          <li>
           186=&gt; XC_GGA_C_APBE !  mu fixed from the semiclassical neutral atom
        [LA Constantin, E Fabiano, S Laricchia, and F Della Sala, Phys. Rev. Lett. 106, 186406 (2011)
        ]
          </li>
          <li>
           191=&gt; XC_GGA_X_HTBS!  Haas, Tran, Blaha, and Schwarz
        [P Haas, F Tran, P Blaha, and K Schwarz, Phys. Rev. B 83, 205117 (2011)
        ]
          </li>
          <li>
           192=&gt; XC_GGA_X_AIRY !  Constantin et al based on the Airy gas
        [LA Constantin, A Ruzsinszky, and JP Perdew, Phys. Rev. B 80, 035125 (2009)
        ]
          </li>
          <li>
           193=&gt; XC_GGA_X_LAG !  Local Airy Gas
        [L Vitos, B Johansson, J Kollar, and HL Skriver, Phys. Rev. B 62, 10046-10050 (2000)
        ]
          </li>
          <li>
           194=&gt; XC_GGA_XC_MOHLYP  ! Functional for organometallic chemistry
        [NE Schultz, Y Zhao, DGJ Truhlar, Phys. Chem. A, 109, 11127 (2005)
        ]
          </li>
          <li>
           195=&gt; XC_GGA_XC_MOHLYP2 !  Functional for barrier heights
        [J Zheng, Y Zhao, DGJ Truhlar, Chem. Theory. Comput. 5, 808 (2009)
        ]
          </li>
          <li>
           196=&gt; XC_GGA_XC_TH_FL !  Tozer and Handy v. FL
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           197=&gt; XC_GGA_XC_TH_FC !  Tozer and Handy v. FC
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           198=&gt; XC_GGA_XC_TH_FCFO  !  Tozer and Handy v. FCFO
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           199=&gt; XC_GGA_XC_TH_FCO  !  Tozer and Handy v. FCO
        [DJ Tozer, NC Handy, amd WH Green, Chem. Phys. Lett. 273, 183-194 (1997)
        ]
          </li>
          <li>
           200=&gt; XC_GGA_C_OPTC  !  Optimized correlation functional of Cohen and Handy
        [AJ Cohen and NC Handy, Mol. Phys. 99, 607-615 (2001)
        ]
          </li>
          <li>
           524=&gt; XC_GGA_X_WPBEH  !  short-range version of the PBE
        [J Heyd, GE Scuseria, and M Ernzerhof, J. Chem. Phys. 118, 8207 (2003)
        ]
          </li>
          <li>
           525=&gt; XC_GGA_X_HJS_PBE  !  HJS screened exchange PBE version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]
          </li>
          <li>
           526=&gt; XC_GGA_X_HJS_PBE_SOL !  HJS screened exchange PBE_SOL version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]
          </li>
          <li>
           527=&gt; XC_GGA_X_HJS_B88 ! HJS screened exchange B88 version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]   WARNING : this functional is not tested. Use at your own risks.
          </li>
          <li>
           528=&gt; XC_GGA_X_HJS_B97X  !  HJS screened exchange B97x version
        [TM Henderson, BG Janesko, and GE Scuseria, J. Chem. Phys. 128, 194105 (2008)
        ]
          </li>
          <li>
           529=&gt; XC_GGA_X_ITYH  ! short-range recipe for exchange GGA functionals
        [H Iikura, T Tsuneda, T Yanai, and K Hirao, J. Chem. Phys. 115, 3540 (2001)
        ]  WARNING : this functional is not tested. Use at your own risks.
          </li>
         </ul>
        </p>
        <p>
         MetaGGA functionals (do not forget to add a minus sign, as discussed above). See Sun et al, PRB 84, 035117 (2011) for the formulas.
        </p>
        <p>
         <ul>
          <li>
           202=&gt; XC_MGGA_X_TPSS !  Tao, Perdew, Staroverov &amp; Scuseria
        [J Tao, JP Perdew, VN Staroverov, and G Scuseria, Phys. Rev. Lett. 91, 146401 (2003) ;
        JP Perdew, J Tao, VN Staroverov, and G Scuseria, J. Chem. Phys. 120, 6898 (2004)
        ]
          </li>
          <li>
           203=&gt; XC_MGGA_X_M06L !  Zhao, Truhlar exchange
        [Y Zhao and DG Truhlar, JCP 125, 194101 (2006);
        Y Zhao and DG Truhlar, Theor. Chem. Account 120, 215 (2008)
        ]
          </li>
          <li>
           204=&gt; XC_MGGA_X_GVT4 !  GVT4 (X part of VSXC) from van Voorhis and Scuseria
        [T Van Voorhis and GE Scuseria, JCP 109, 400 (1998)
        ]
          </li>
          <li>
           205=&gt; XC_MGGA_X_TAU_HCTH ! tau-HCTH from Boese and Handy
        [AD Boese and NC Handy, JCP 116, 9559 (2002)
        ]
          </li>
          <li>
           207=&gt; XC_MGGA_X_BJ06 !  Becke &amp; Johnson correction to Becke-Roussel 89
        [AD Becke and ER Johnson, J. Chem. Phys. 124, 221101 (2006)
        ] WARNING : this Vxc-only mGGA can only be used with a LDA correlation, typically Perdew-Wang 92.
          </li>
          <li>
           208=&gt; XC_MGGA_X_TB09 !  Tran-blaha - correction to Becke &amp; Johnson correction to Becke-Roussel 89
        [F Tran and P Blaha, Phys. Rev. Lett. 102, 226401 (2009)
        ] WARNING : this Vxc-only mGGA can only be used with a LDA correlation, typically Perdew-Wang 92.
          </li>
          <li>
           209=&gt; XC_MGGA_X_RPP09 !  Rasanen, Pittalis, and Proetto correction to Becke &amp; Johnson
        [E Rasanen, S Pittalis &amp; C Proetto, arXiv:0909.1477 (2009)
        ] WARNING : this Vxc-only mGGA can only be used with a LDA correlation, typically Perdew-Wang 92.
          </li>
          <li>
           232=&gt; XC_MGGA_C_VSXC !  VSxc from Van Voorhis and Scuseria (correlation part)
        [T Van Voorhis and GE Scuseria, JCP 109, 400 (1998)
        ]
          </li>
         </ul>
        </p>
    varname: ixc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: (Teter parameterization). However, if all the pseudopotentials have the same value of pspxc, the initial value of ixc will be that common value
    commentdims: null
    defaultval: 1
    definition: Integer for the eXchange-Correlation applied to the electron-POSITRON interaction
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when [[positron]]/=0.
         <br />
         Define the type of electron-positron correlation that is used in case
        of a electron-positron two-component DFT calculation.
         <br />
         Define also the analytical formula of the enhancement factor used to compute the electron-positron annhilation rate:
         <br />
         <br />
         Electron-positron correlation functional:
         <br />
         <ul>
          <b>
           ixcpositron=1
          </b>
          :
        LDA zero positron density limit parametrized by Arponen &amp; Pajanne and provided by Boronski &amp; Nieminen [1,2]
          <br />
          <b>
           ixcpositron=11
          </b>
          :
        LDA zero positron density limit parametrized by Arponen &amp; Pajanne and fitted by Sterne &amp; Kaiser [1,3]
          <br />
          <b>
           ixcpositron=2
          </b>
          :
        LDA electron-positron correlation provided by Puska, Seitsonen, and Nieminen [1,4]
          <br />
          <b>
           ixcpositron=3
          </b>
          :
        GGA zero positron density limit parametrized by Arponen &amp; Pajanne and provided by Boronski &amp; Nieminen [1,2,5]
          <br />
          <b>
           ixcpositron=31
          </b>
          :
        GGA zero positron density limit parametrized by Arponen &amp; Pajanne and fitted by Sterne &amp; Kaiser [1,3,5]
         </ul>
         Annihilation rate enhancement factor:
         <br />
         <ul>
          <b>
           ixcpositron=1
          </b>
          :
        Boronski and Nieminen full modelisation and RPA limit [1]
          <br />
          <b>
           ixcpositron=11
          </b>
          :
        Sterne and Kaiser [2]
          <br />
          <b>
           ixcpositron=2
          </b>
          :
        Puska, Seitsonen and Nieminen [3]
          <br />
          <b>
           ixcpositron=3
          </b>
          :
        Boronski and Nieminen full modelisation and RPA limit [1], with GGA corrections
          <br />
          <b>
           ixcpositron=31
          </b>
          :
        Sterne and Kaiser [2], with GGA corrections
          <br />
         </ul>
         References:
         <ul>
          <b>
           [1]
          </b>
          J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).
          <br />
          <b>
           [2]
          </b>
          Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).
          <br />
          <b>
           [3]
          </b>
          P.A. Sterne and J.H. Kaiser, Phys. Rev. B 43, 13892 (1991).
          <br />
          <b>
           [4]
          </b>
          M.J. Puska, A.P. Seitsonen and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).
          <br />
          <b>
           [5]
          </b>
          B. Barbiellini, M.J. Puska, T. Torsti and R.M.Nieminen, Phys. Rev. B 51, 7341 (1994)
          <br />
         </ul>
        </p>
    varname: ixcpositron
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: !range
        start: 1
        stop: '[[ndtset]]'
    definition: index -J- for DaTaSETs
    dimensions:
    - '[[ndtset]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the dataset index
        of each of the datasets. This index will be used :
         <ul>
          <li>
           to determine which input variables are specific to each
        dataset, since the variable names for this
        dataset will be made from the bare variable
        name concatenated with this index, and only if
        such a composite variable name does not exist,
        the code will consider the bare variable name,
        or even, the Default;
          </li>
          <li>
           to characterize output variable names, if their
        content differs from dataset to dataset;
          </li>
          <li>
           to characterize output files ( root names appended with _DSx
        where 'x' is the dataset index ).
          </li>
         </ul>
         The allowed index values are between 1 and 9999.
         <br />
         An input variable name appended with 0 is not allowed.
         <br />
         When [[ndtset]]==0, this array is not used, and moreover,
        no input variable name appended with a digit is allowed.
        This array might be initialized thanks to the use of
        the input variable [[udtset]]. In this case, [[jdtset]] cannot
        be used.
        </p>
    varname: jdtset
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: include a JELLium SLAB in the cell
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If set to 1, a slab of uniform positive background charge density,
        that is, a jellium slab, is included in the calculation cell.
        A portion of the unit cell is filled with such positive charge density distribution
        which is equal to a bulk-mean value n
         <sub>
          bulk
         </sub>
         between two edges
        and zero in the vacuum region if present.
         <br />
         For the sake of convenience the unit cell is supposed
        to have the third crystal primitive lattice vector orthogonal
        to the other ones so that the portion of the cell filled by the jellium slab can be defined through its edges along z.
         <br />
         The bulk-mean positive charge density is fixed by the input variable [[slabwsrad]],
        while the position of the slab edges along z is defined through
        the input variables [[slabzbeg]] and [[slabzend]].
        </p>
    varname: jellslab
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    definition: electric/displacement FIELD DIRection
    dimensions:
    - 3
    excludes: null
    requires: '[[berryopt]] = 17'
    section: varff
    text: |-
        <p>
         When specifying mixed electric field boundary conditions ( [[berryopt]]=17),
        jfielddir controls whether reduced electric field ([[jfielddir]]=1)
        or reduced electric displacement field ([[jfielddir]]=2) is chosen to be fixed,
        in each of the three lattice directions (i.e., in the reduced, not the Cartesian, frame).
        For example, [[jfielddir]]=(1 1 2) tells the code to use fixed ebar_1 and ebar_2
        along the first two lattice directions and fixed d_3 along the third.
         <br />
         For the case of mixed electric field boundary conditions,
        [[red_efieldbar]] and [[red_dfield]]
        are used to control ebar and d, respectively.
        For example, for electric boundary conditions corresponding to a material
        in a parallel-plate capacitor, if you want to control d_3=d0,
        while fixing ebar_1=ebar_2=0, then the input files should have
        [[berryopt]]=17, [[jfielddir]]=(1 1 2), [[red_efieldbar]]=(0.0 0.0 a),
        and [[red_dfield]]=(b c d0).
        Here a, b, and c are the starting values.
        They can be chosen in this way: do a single run for fixed d calculation ([[red_dfield]]=0,0,d0),
        from the final results you will have ebar_3, which is a good guess for a.
        Then do another single run for fixed ebar calculation ([[red_efieldbar]]=(0 0 0)),
        from the final results you will have d_1,d_2, these are good guesses for b, c.
        </p>
    varname: jfielddir
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: value of J for PAW+U
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    section: varpaw
    text: |-
        <p>
         Gives the value of the screened exchange interaction between correlated
        electrons corresponding to [[lpawu]]
        for each species.
         <br />
         In the case where [[lpawu]] =-1,
        the value is not used.
        </p>
    varname: jpawu
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: K wavevectors for BERRY phase computation
    dimensions:
    - 3
    - '[[nberry]]'
    excludes: null
    requires: '[[berryopt]] = 1, 2, or 3'
    section: varff
    text: |-
        <p>
         Used for values of [[berryopt]] = 1, 2, or 3.
        </p>
        <p>
         This array defines, for each Berry phase calculation
        (the number of such calculations is defined by
        [[nberry]]), the
        difference of wavevector between k points for which
        the overlap matrix must be computed.
        The polarisation vector will be projected
        on the direction of that wavevector,
        and the result of the computation will be the magnitude of this
        projection.
        Doing more than one wavevector, with different independent
        direction, allows to find the full polarisation vector.
        However, note that converged results need oriented grids,
        denser along the difference wavevector than usual Monkhorst-Pack
        grids.
        </p>
        <p>
         The difference of wavevector is computed in the coordinate
        system defined by the k-points grid
        (see [[ngkpt]]
        and [[kptrlatt]]), so that
        the values of [[kberry]] are integers.
        Of course, such a k point grid must exist, and all the
        corresponding wavefunctions must be available, so that the
        computation is allowed only when [[kptopt]]
        is equal to 3. In order to save computing time, it is suggested
        to make a preliminary calculation of the wavefunctions on the
        irreducible part of the grid, with [[kptopt]]
        equal to 1, and then use these converged wavefunctions
        in the entire Brillouin zone, by reading them to initialize
        the [[kptopt]]=3 computation.
        </p>
    varname: kberry
    vartype: integer
- !variable
    characteristics: null
    commentdefault: Adequate for one molecule in a supercell
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: K - PoinTs
    dimensions:
    - 3
    - '[[nkpt]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Contains the k points in terms
        of reciprocal space primitive translations (NOT in
        cartesian coordinates!).
         <br />
         Needed ONLY
        if [[kptopt]]=0, otherwise
        deduced from other input variables.
        </p>
        <p>
         It contains dimensionless numbers in terms of which
        the cartesian coordinates would be:
         <br />
         <tele>
          k_cartesian = k1*G1+k2*G2+k3*G3
         </tele>
         <br />
         where
         <tele>
          (k1,k2,k3)
         </tele>
         represent the dimensionless "reduced
        coordinates" and
         <tele>
          G1, G2, G3
         </tele>
         are the cartesian coordinates
        of the primitive translation vectors.  G1,G2,G3 are related
        to the choice of direct space primitive translation vectors
        made in [[rprim]].
        Note that an overall norm for the k
        points is supplied by [[kptnrm]].  This allows
        one to avoid supplying many digits for the k points to
        represent such points as (1,1,1)/3.
         <br />
         Note: one of the algorithms used to set up the sphere
        of G vectors for the basis needs components of k-points
        in the range [-1,1], so the
        remapping is easily done by adding or subtracting 1 from
        each component until it is in the range [-1,1].  That is,
        given the k point normalization [[kptnrm]] described below,
        each component must lie in [-[[kptnrm]],[[kptnrm]]].
         <br />
         Note: a global shift can be provided by [[qptn]]
         <br />
         Not read if [[kptopt]]/=0 .
        </p>
    varname: kpt
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: K PoinTs BOUNDarieS
    dimensions:
    - 3
    - abs([[kptopt]])+1)
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         It is used to generate the circuit to be followed by the band structure,
        when [[kptopt]] is negative (it is
        not read if [[kptopt]] is zero or positive).
        </p>
        <p>
         There are abs([[kptopt]])
        segments to be defined, each of which starting from
        the end point of the preceeding one. Thus,
        the number of points to be input is
        abs([[kptopt]])+1.
        They form a circuit starting
        at [[kptbounds]](1:3,1)/[[kptnrm]]
        and ending at
        [[kptbounds]](1:3,abs([[kptopt]])+1)/[[kptnrm]].
        The number of divisions of each segment can be defined either using the array [[ndivk]]
        or the variable [[ndivsm]] that just defines the number of divisions for the smallest segment
        </p>
        <p>
         As for [[kpt]], [[kptbounds]] is specified
        using the primitive vectors in reciprocal space. If your Bravais lattice is simple,
        then it should be quite easy to find the coordinates of the end points.
        On the other hand, for centered, body-centered, face-centered, hexagonal, and rhombohedral
        Bravais lattice,
        the conversion might be more difficult. See the description of [[kpt]]
        for an explanation of how to convert data from the "conventional" cartesian coordinates to
        the primitive vectors in the reciprocal space. In order to help a bit, we list below a series
        of typical values, for the FCC, BCC, hexagonal and rhombohedral Bravais lattices. Note : all the data below
        are given in dimensionless units ; they have to be rescaled by the actual lengths defined by the
        [[acell]] values. However, [[kptbounds]] values can be used as such,
        if the values of [[rprim]] given below are adopted.
        </p>
        <p>
         A.
         <b>
          FCC lattice
         </b>
        </p>
        <p>
         Suppose the primitive vectors in real space are given by
         <br />
         <pre>
          rprim   0 1 1    1 0 1    1 1 0
         </pre>
         or
         <pre>
          rprim   0 1/2 1/2    1/2 0 1/2    1/2 1/2 0
         </pre>
         (these two possibilities only differ by a scaling factor, irrelevant for the definition
        of the k points in the primitive vectors in reciprocal space).

        Then, the reciprocal primitive vectors (in conventional cartesian coordinates) are
         <pre>
          (-1/2 1/2 1/2), (1/2 -1/2 1/2), (1/2 1/2 -1/2)
         </pre>
         or
         <pre>
          (-1 1 1), (1 -1 1), (1 1 -1)
         </pre>
         and, in both cases, the coordinates of several special points with respect to primitive vectors in reciprocal space are
         <pre>
          X (0   1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
          X'(1/2 1/2 1  )   (conventional cartesian coordinate 1/2 1/2 0)  (an other instance of X, in another Brillouin zone)
          L (1/2 1/2 1/2)   (conventional cartesian coordinate  1/4 1/4 1/4)
          L'(1/2 0   0  )   (conventional cartesian coordinate -1/4 1/4 1/4) (an other instance of L, on another face of the BZ)
          W (1/4 1/2 3/4)   (conventional cartesian coordinate 1/2 1/4 0)
          U (1/4 5/8 5/8)   (conventional cartesian coordinate 1/2 1/8 1/8)
          K (3/8 3/8 3/4)   (conventional cartesian coordinate 3/8 3/8 0)
         </pre>
         Note that K is actually equivalent to U, by spatial and translational symmetry.
        So, if you want to specify a typical circuit, the following might do the work :
        L-Gamma-X-W-K,U-L-W-X-K,U-Gamma with
         <br />
         <pre>
          kptbounds  1/2 0 0  0 0 0  0 1/2 1/2  1/4 1/2 3/4  3/8 3/8 3/4  1/2 1/2 1/2  1/4 1/2 3/4  1/2 1/2 1  3/8 3/8 3/4  0 0 0
         </pre>
        </p>
        <p>
         The lengths of segments (this information is useful to draw the band structure, with the correct relative
        scale between special points)
        can be found using
        the conventional cartesian coordinates :
        l(L-Gamma)=sqrt(3)/4=0.433... ;
        l(Gamma-X)=1/2=0.5 ;
        l(X-W)=1/4=0.25 ;
        l(W-K)=sqrt(2)/8=0.177... ;
        l(K-L)=sqrt(6)/8=0.306... ;
        l(L-W)=sqrt(2)/4=0.354... ;
        l(W-X)=1/4=0.25 ;
        l(X-K)=sqrt(2)/8=0.177... ;
        l(K-Gamma)=sqrt(2).3/8=0.530...
        </p>
        <p>
        </p>
        <p>
         B.
         <b>
          BCC lattice
         </b>
        </p>
        <p>
         Suppose the primitive vectors in real space are given by
         <br />
         <pre>
          rprim  -1 1 1    1 -1 1    1 1 -1
         </pre>
         (as for the FCC lattice, there is a scale invariance).
        Then, the reciprocal primitive vectors (in conventional cartesian coordinates) are
        (0 1/2 1/2), (1/2 0 1/2), and (1/2 1/2 0)
        and the coordinates of several special points with respect to primitive vectors in reciprocal space are
         <pre>
          H (-1/2 1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
          N ( 0   0   1/2)   (conventional cartesian coordinate 1/4 1/4 0)
          P ( 1/4 1/4 1/4)   (conventional cartesian coordinate 1/4 1/4 1/4)
         </pre>
         So, if you want to specify a typical circuit, the following might do the work :
        Gamma-H-N-Gamma-P-N-P-H
         <br />
         <pre>
          kptbounds  0 0 0  -1/2 1/2 1/2  0 0 1/2  0 0 0   1/4 1/4 1/4  0 0 1/2  1/4 1/4 1/4  -1/2 1/2 1/2
         </pre>
        </p>
        <p>
         The lengths of segments (this information is useful to draw the band structure, with the correct relative scale between special points)
        can be found using the conventional cartesian coordinates :
        l(Gamma-H)=1/2=0.5 ;
        l(H-N)=sqrt(2)/4=0.354... ;
        l(N-Gamma)=sqrt(2)/4=0.354... ;
        l(Gamma-P)=sqrt(3)/4=0.433... ;
        l(P-N)=1/4=0.25 ;
        l(N-P)=1/4=0.25 ;
        l(P-H)=sqrt(3)/4=0.433...
        </p>
        <p>
        </p>
        <p>
         C.
         <b>
          Hexagonal lattices
         </b>
        </p>
        <p>
         Suppose the primitive vectors in real space are given by
         <br />
         <pre>
          rprim  1 0 0    -1/2 sqrt(0.75) 0    0 0 1
         </pre>
         The coordinates of several special points with respect to primitive vectors in reciprocal space are
         <pre>
          M (1/2 0 0) or (0 1/2 0) or (-1/2 1/2 0)
          L (1/2 0 1/2) or (0 1/2 1/2) or (-1/2 1/2 1/2)
          K (1/3 1/3 0) or (2/3 -1/3 0) or (-1/3 2/3 0)
          H (1/3 1/3 1/2) or (2/3 -1/3 1/2) or (-1/3 2/3 1/2)
          A (0 0 1/2)
         </pre>
         So, if you want to specify a typical circuit, the following might do the work :
        K-Gamma-M-K-H-A-L-H-L-M-Gamma-A
         <br />
         <pre>
          kptbounds  1/3 1/3 0  0 0 0  1/2 0 0  1/3 1/3 0  1/3 1/3 1/2  0 0 1/2  1/2 0 1/2  1/3 1/3 1/2  1/2 0 1/2  1/2 0 0  0 0 0  0 0 1/2
         </pre>
        </p>
        <p>
         In order to find the lengths of segments
        (this information is useful to draw the band structure,
        with the correct relative scale between special points)
        one needs to know the a and c lattice parameters. Also, in what follows, we omit the 2*pi factor sometimes
        present in the definition of the reciprocal space vectors.
        The reciprocal vectors are (1/a 1/(sqrt(3)*a) 0) , (0 2/(sqrt(3)*a) 0), (0 0 1/c). The lengths of
        the above-mentioned segments can be computed as :
        l(K-Gamma)=2/(3*a)=0.666.../a ;
        l(Gamma-M)=1/(sqrt(3)*a)=0.577.../a ;
        l(M-K)=1/(3*a)=0.333.../a ;
        l(K-H)=1/(2*c)=0.5.../c ;
        l(H-A)=2/(3*a)=0.666.../a ;
        l(A-L)=1/(sqrt(3)*a)=0.577.../a ;
        l(L-H)=1/(3*a)=0.333.../a ;
        l(H-L)=1/(3*a)=0.333.../a ;
        l(L-M)=1/(2*c)=0.5.../c ;
        l(M-Gamma)=-1/(sqrt(3)*a)=0.577.../a ;
        l(Gamma-A)=1/(2*c)=0.5.../c
        </p>
        <p>
        </p>
        <p>
         D.
         <b>
          Rhombohedral lattices
         </b>
        </p>
        <p>
         Rhombohedral lattices are characterised by two parameters, the length of the primitive
        vectors, that we will denote a0, and the angle they form, alpha.
        These can be directly input of ABINIT, as
        [[acell]] and [[angdeg]]
        </p>
        <p>
         This will generate the primitive vectors in real space , with
         <pre>
          [[acell]] a0 a0 a0    and      [[rprim]]  a 0 c    -a/2 a*sqrt(0.75) c    -a/2 -a*sqrt(0.75) c
         </pre>
         with a^2+c^2=1, a^2=(1-cos(alpha))*2/3, c^2=(1+2*cos(alpha))*1/3, (a/c)^2=2*(1-cos(alpha))/(1+2*cos(alpha))
        and also cos(alpha)=(1-(a/c)^2/2)/(1+(a/c)^2).
        Alternatively, these values of rprim might directly be the input of ABINIT (then, the balance
        of the scaling factor might be adjusted between
        [[acell]] and [[rprim]]).
        </p>
        <p>
         Unlike for the simple cubic, FCC, BCC, hexagonal (and some other) Bravais lattice,
        the topology of the Brillouin zone will depend on the alpha (or a/c) value. We give below
        information concerning the case when cos(alpha) is positive, that is, (a/c)^2 lower than 2.
        </p>
        <p>
         The coordinates of several special points with respect to primitive vectors in reciprocal space will
        not depend on the a/c ratio, but some others will depend on it. So, some care has to be exercised.
        Notations for the Brillouin Zone special points are the same as in Phys. Rev. B 41, 11827 (1990).
         <pre>
          L (1/2 0 0) or (0 1/2 0) or (0 0 1/2) (or with negative signs)
          T (1/2 1/2 1/2)
          X (1/2 1/2 0) or (1/2 0 1/2) or (0 1/2 1/2) (or with separate negative signs)
          W (5/6 - (a/c)^2/6 , 1/2 , 1/6 + (a/c)^2/6 ) = (1 0 -1)*(1-(a/c)^2/2)/3 + (1 1 1)/2
          U ( (1+(a/c)^2)/6 , (8-(a/c)^2)/12 , (8-(a/c)^2)/12 ) = (-1 1/2 1/2)*(1-(a/c)^2/2)/3 + (1 1 1)/2
          K (1 0 -1)*(1+(a/c)^2/4)/3
         </pre>
         So, if you want to specify a typical circuit, the following might do the work (the representative points on lines of symmetry are indicated - there are sometimes more than one way to go from one point to another) :
        X-V-K-Sigma-Gamma-Lambda-T-Q-W-Y-L-sigma-Gamma-sigma-X . The suggestion is to sample this path
        with the following coordinates
        for the special points X, Gamma, T, L, Gamma, X :
         <br />
         <pre>
          kptbounds  1/2 0 -1/2   0 0 0    1/2 1/2 1/2  1 1/2 0   1 0 0  1 1/2 1/2
         </pre>
        </p>
        <p>
         In order to find the lengths of segments
        (this information is useful to draw the band structure,
        with the correct relative scale between special points)
        one needs to know the a and c lattice parameters. Also, in what follows, we omit the 2*pi factor sometimes
        present in the definition of the reciprocal space vectors.
        The reciprocal vectors are (2/(3*a) 0 1/(3*c)) , -(1/(3*a) 1/(sqrt(3)*a) 1/(3*c), -(1/(3*a) -1/(sqrt(3)*a) 1/(3*c) ). The lengths of
        the above-mentioned segments can be computed as :
        l(X-Gamma)=2/(sqrt(3)*a)=1.155.../a , with l(K-Gamma)=(1+(a/c)^2/4)*4/(3*sqrt(3)*a);
        l(Gamma-T)=1/(2*c) ;
        l(T-L)=2/(sqrt(3)*a)=1.155.../a , with l(T-W)=(1-(a/c)^2/2)*4/(3*sqrt(3)*a);
        l(L-Gamma)=sqrt(4/(a^2)+1/(c^2))/3
        l(Gamma-X)=sqrt(1/(a^2)+1/(c^2))*2/3
        </p>
        <p>
        </p>
    varname: kptbounds
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0
    definition: K-PoinTs for GW calculations
    dimensions:
    - 3
    - '[[nkptgw]]'
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         For each k-point with number igwpt in the range (1:[[nkptgw]]),
        [[kptgw]](1,igwpt)
         is the reduced coordinate of the k-point where [[GW]] corrections are required.
        while [[bdgw]] (1:2,igwpt) specifies the range of bands to be considered.
        </p>
        <p>
         At present, not all k-points are possible. Only those corresponding to the k-point
        grid defined with the same repetition parameters (
        [[kptrlatt]], or [[ngkpt]]
         ) than the GS one, but WITHOUT any shift, are allowed.
        </p>
    varname: kptgw
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: K - PoinTs NoRMalization
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Establishes a normalizing denominator
        for each k point.
        Needed only
        if [[kptopt]]&lt;=0, otherwise
        deduced from other input variables.
         <br />
         The k point coordinates as fractions
        of reciprocal lattice translations are therefore
        [[kpt]](mu,ikpt)/[[kptnrm]].  [[kptnrm]] defaults to 1 and can
        be ignored by the user.  It is introduced to avoid
        the need for many digits in representing numbers such as 1/3.
         <br />
         It cannot be smaller than 1.0d0
        </p>
    varname: kptnrm
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: K-PoinTs re-Normalized and Shifted
    dimensions:
    - 3
    - '[[nkpt]]'
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         If [[nqpt]]=0, or if one is
        doing a reponse calculation,
        this internal variable is derived from
        [[kpt]] and [[kptnrm]]:
        [[kptns]](1:3,:)=
        [[kpt]](1:3,:)/
        [[kptnrm]], so that
        it is [[kpt]] renormalized by
        [[kptnrm]].
         <br />
         If [[nqpt]]=1 and one is
        not doing a ground-state calculation,
        this internal variable is derived from
        [[kpt]],[[kptnrm]]
        and [[qptn]]
        [[kptns]](1:3,:)=
        [[kpt]](1:3,:)/
        [[kptnrm]]+
        [[qptn]](1:3), so that
        it is [[kpt]] renormalized by
        [[kptnrm]], then shifted
        by [[qptn]](1:3).
        </p>
    varname: kptns
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nspden]]==4': 4
        defaultval: 1
    definition: KPoinTs OPTion
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Controls the set up of the k-points list.
        The aim will be to initialize, by straight reading
        or by a preprocessing approach based on other input variables,
        the following input variables, giving the k points, their number,
        and their weight:
        [[kpt]],
        [[kptnrm]],
        [[nkpt]],
        and, for [[iscf]]/=-2,
        [[wtk]].
        </p>
        <p>
         Often, the k points will form a lattice in reciprocal space. In this case,
        one will also aim at initializing input variables that give
        the reciprocal of this k-point lattice, as well as its shift with respect
        to the origin:
        [[ngkpt]] or
        [[kptrlatt]],
        as well as on [[nshiftk]] and
        [[shiftk]].
        </p>
        <p>
         A global additional shift can be provided by [[qptn]]
         <ul>
          <li>
           0=&gt; read directly [[nkpt]], [[kpt]],
        [[kptnrm]] and [[wtk]].
          </li>
          <li>
           1=&gt; rely on [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Take fully into account the symmetry to generate the
        k points in the Irreducible Brillouin Zone only, with the appropriate weights.
           <br />
           (This is the usual mode for GS calculations)
          </li>
          <li>
           2=&gt; rely on
        [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Take into account only the time-reversal symmetry :
        k points will be generated in half the Brillouin zone, with the appropriate weights.
           <br />
           (This is to be used when preparing or executing a
        RF calculation at q=(0 0 0) )
          </li>
          <li>
           3=&gt; rely on [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Do not take into account any symmetry :
        k points will be generated in the full Brillouin zone, with the appropriate weights.
           <br />
           (This is to be used when preparing or executing a
        RF calculation at non-zero q )
          </li>
          <li>
           4=&gt; rely on [[ngkpt]] or
        [[kptrlatt]], as well as on
        [[nshiftk]] and
        [[shiftk]] to set up the k points.
        Take into account all the symmetries EXCEPT the time-reversal symmetry
        to generate the k points in the Irreducible Brillouin Zone, with the appropriate weights.
           <br />
           This has to be used when performing calculations with non-collinear magnetism allowed
           ([[nspden]]=4)
          </li>
          <li>
           A negative value =&gt;
        rely on [[kptbounds]],
        and [[ndivk]]
        to set up a band structure calculation along different lines
        (allowed only for [[iscf]]==-2).
        The absolute value of [[kptopt]] gives the number of segments
        of the band structure. Weights are usually irrelevant with this option, and will be left to their default value.
          </li>
         </ul>
         In the case of a grid of k points, the auxiliary variables
        [[kptrlen]],
        [[ngkpt]]  and
        [[prtkpt]] might help
        you to select the optimal grid.
        </p>
    varname: kptopt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: 'K - PoinTs grid : Real space LATTice'
    dimensions:
    - 3
    - 3
    excludes: specified([[ngkpt]])
    requires: null
    section: vargs
    text: |-
        <p>
         This input variable is used only when [[kptopt]]
        is positive. It partially defines the k point grid.
        The other piece of information is contained in
        [[shiftk]].
        [[kptrlatt]] cannot be used together with [[ngkpt]].
        </p>
        <p>
         The values kptrlatt(1:3,1), kptrlatt(1:3,2), kptrlatt(1:3,3)
        are the coordinates of three vectors in real space, expressed
        in the [[rprimd]] coordinate system (reduced coordinates).
        They defines a super-lattice in real space.
        The k point lattice is the reciprocal of this super-lattice,
        possibly shifted (see [[shiftk]]).
        </p>
        <p>
         If neither [[ngkpt]] nor [[kptrlatt]]
        are defined, ABINIT will automatically generate a set
        of k point grids, and select the best combination
        of [[kptrlatt]] and [[shiftk]]
        that allows to reach a sufficient value of [[kptrlen]].
        See this latter variable for a complete description of this
        procedure.
        </p>
    varname: kptrlatt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30.0
    definition: 'K - PoinTs grid : Real space LENgth'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This input variable is used only when [[kptopt]]
        is positive and non-zero.
        </p>
        <p>
         Preliminary explanation :
         <br />
         The k point lattice defined by [[ngkpt]]
        or [[kptrlatt]] is used to perform integrations
        of periodic quantities in the Brillouin Zone, like
        the density or the kinetic energy. One can relate the
        error made by replacing the continuous integral by a sum
        over k point lattice to the Fourier transform of the
        periodic quantity. Erroneous contributions will appear
        only for the vectors in real space that belong to the reciprocal
        of the k point lattice, except the origin.
        Moreover, the expected size of these
        contributions usually decreases exponentially with the distance.
        So, the length of the smallest of these real space vectors
        is a measure of the accuracy of the k point grid.
        </p>
        <p>
         When either [[ngkpt]] or
        [[kptrlatt]] is defined, [[kptrlen]] is not
        used as an input variable, but the length of the
        smallest vector will be placed in this variable, and echoed
        in the output file.
        </p>
        <p>
         On the other hand, when neither [[ngkpt]] nor
        [[kptrlatt]] are defined, ABINIT will
        automatically generate a large set of possible k point grids,
        and select among this set, the grids that give
        a length of smallest vector LARGER than [[kptrlen]],
        and among these grids, the one that, when used with
        [[kptopt]]=1, reduces to the smallest number
        of k points. Note that this procedure can be time-consuming.
        It is worth doing it once for a given unit cell
        and set of symmetries, but not use this procedure by default.
        The best is then to set [[prtkpt]]=1, in order
        to get a detailed analysis of the set of grids.
        </p>
        <p>
         If some layer of vacuum is detected in the unit cell
        (see the input variable [[vacuum]]), the
        computation of [[kptrlen]] will ignore the
        dimension related to the direction perpendicular
        to the vacuum layer, and generate a bi-dimensional k point grid.
        If the system is confined in a tube,
        a one-dimensional k point grid will be generated.
        For a cluster, this procedure will only generate the Gamma point.
        </p>
    varname: kptrlen
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Kohn Sham Structure file FORMat
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Governs the choice of the format for the file that
        contains the Kohn-Sham electronic structure information,
        for use in [[GW]] calculations, see the input variables
        [[optdriver]] and
        [[nbandkss]].
         <ul>
          <li>
           [[kssform]]=1, a single file .kss (double precision) containing
        complete information on the Kohn Sham Structure (eigenstates and the
        pseudopotentials used) will be generated through full diagonalization
        of the complete Hamiltonian matrix.
        The file has at the beginning the standard abinit header.
          </li>
          <li>
           [[kssform]]=3, a single file .kss (double precision) containing
        complete information on the Kohn Sham Structure (eigenstates and the
        pseudopotentials used) will be generated through the usual conjugate gradient
        algorithm (so, a restricted number of states).
        The file has at the beginning the standard abinit header.
          </li>
         </ul>
        </p>
        <p>
         Very important : for the time being, [[istwfk]]
        must be 1 for all the k-points.
        </p>
    varname: kssform
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -1
    definition: value of angular momentum L for EXact EXCHange
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[useexexch]]==1'
    section: varpaw
    text: |-
        <p>
         Give for each species the value of the angular momentum (only values 2 or 3 are allowed)
        on which to apply the exact exchange correction.
        </p>
    varname: lexexch
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: LOCAL ReaD WaveFunctions
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         This input variable is used only when running abinit in parallel.
        If [[localrdwf]]=1, the input wavefunction disk file or the KSS/SCR file in case of [[GW]]
        calculations, is read locally by each processor, while
        if [[localrdwf]]=0, only one processor reads it, and
        broadcast the data to the other processors.
        </p>
        <p>
         The option [[localrdwf]]=0 is NOT allowed when parallel I/O are activated (MPI-IO access),
        i.e. when [[iomode]]==1.
        </p>
        <p>
         In the case of a parallel computer with a unique file system,
        both options are as convenient for the user. However, if the I/O
        are slow compared to communications between processors,
        , [[localrdwf]]=0 should be much more
        efficient;
        if you really need temporary disk storage, switch to localrdwf=1 ).
        </p>
        <p>
         In the case of a cluster of nodes, with a different file system for
        each machine, the input wavefunction file must be available on all
        nodes if [[localrdwf]]=1, while it is needed only for the
        master node if [[localrdwf]]=0.
        </p>
    varname: localrdwf
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    definition: LOTF classic model for Glue model
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Glue model used in LOTF.
         <br />
         For the moment it is imposed to be 5.
        </p>
    varname: lotf_classic
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: LOTF number of iterations
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Set the number of Molecular Dynamics iterations which are computed by LOTF.
        </p>
    varname: lotf_nitex
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    definition: LOTF max number of neighbours
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Set the max number of Neighbours used in the LOTF method.
         <br />
         For the moment it is imposed to be 40.
        </p>
    varname: lotf_nneigx
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: LOTF version of MD algorithm
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Set the MD algorithm in the LOTF method.
         <br />
         For the moment it is imposed to be 2.
        </p>
    varname: lotf_version
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: -1
    definition: value of angular momentum L for PAW+U
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[usepawu]]==1 or [[usepawu]]== 2'
    section: varpaw
    text: |-
        <p>
         Give for each species the value of the angular momentum (only
        values 2 or 3 are allowed)&nbsp; on which to apply the LDA+U correction.
         <br />
         <ul>
          <li>
           If equal to 2 (d-orbitals)&nbsp; or 3 (f-orbitals), values of
        [[upawu]] and&nbsp;
        [[jpawu]] are used in the calculation.
          </li>
          <li>
           If equal to -1: do not apply LDA+U correction on the species.
          </li>
         </ul>
        </p>
    varname: lpawu
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Macro variable that activates the determination of the U and J parameter (for the PAW+U calculations)
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Sets proper input values for the determination of U and J i.e.
        for [[pawujat]] (first atom treated with PAW+U),
        [[irdwfk]] (=1),
        [[tolvrs]] (=10^(-8)),
        [[nstep]] (=255),
        [[diemix]] (=0.45),
        [[atvshift]] ([[pawujat]]) [[pawujv]]). Do not overwrite these variables manually unless you know what you do.
         <ul>
          <li>
           [[macro_uj]]=1 (and [[nsppol]]=2) Standard procedure to determine U on atom pawujat through a shift of the potential on both spin channels.
          </li>
          <li>
           [[macro_uj]]=1 (and [[nsppol]]=1) Non standard procedure to determine U from potential shift on atom pawujat (experimental).
          </li>
          <li>
           [[macro_uj]]=2 (and [[nsppol]]=2) Non standard procedure to determine U from potential shift on atom pawujat through a shift on spin channel 1 on this atom and the response on this channel (experimental).
          </li>
          <li>
           [[macro_uj]]=3 (and [[nsppol]]=2) Standard procedure to determine J from potential shift on spin channel 1 on atom pawujat and response on spin channel 2 (experimental).
          </li>
         </ul>
         Determination of U and J can be done only if the symmetry of the atomic arrangement is reduced and the atom pawujat is not connected to any other atom by symmetry relations (either input reduced symmetries manually, define concerned atom as a separate atomic species or shift concerned atom from ideal position).
        </p>
    varname: macro_uj
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    definition: MAGnetization CONstraint LAMBDA parameter
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This variable gives the amplitude of the constraint imposed on the magnetization vectors on each atom (turned on with flag variable [[magconon]]). Typical values for lambda are 10 to a few hundred. The energy will vary strongly and convergence will be difficult if lambda is too large. The constraint will be weak and the magnetization will not be close to [[spinat]] if lambda is too small. See variable [[magconon]] for more details.
        </p>
    varname: magcon_lambda
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: turn MAGnetization CONstraint ON
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Turns on the imposition of a Lagrangian constraint on the magnetization. For each atom, the magnetization is calculated in a sphere (radius [[ratsph]]) and a constraint is applied to bring it closer to the input values of [[spinat]]. The constraint can be either on the direction only (magconon 1) or on the full vector (magconon 2). The Lagrangian constraint has an amplitude [[magcon_lambda]] which should be neither too big (bad or impossible convergence) nor too small (no effect).
        </p>
    varname: magconon
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: MAXimum Number of CPUS
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         If [[autoparal]] &gt; 1 and [[max_ncpus]] is greater than 0,
        ABINIT analyzes the efficiency of the process distribution for each possible number of processors
        from 2 to [[max_ncpus]].
        After having printed out the efficiency, the code stops.
        </p>
    varname: max_ncpus
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.005
    definition: MAXimum Electric field STEP
    dimensions: scalar
    excludes: null
    requires: '[[berryopt]] = 6, 16, or 17'
    section: varff
    text: |-
        <p>
         This variable controls the maximum change of electric field when updating the electric field after each SCF iteration.
        When the calculation is difficult to converge, try reducing this value or reducing [[ddamp]].
        This variable is used in finite electric displacement field calculations ([[berryopt]]=6,16,17).
        </p>
    varname: maxestep
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 384
    definition: MAXimum Number of SYMetries
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Gives the maximum number of spatial symetries allowed in the memory.
         <br />
         The default value is sufficient for most applications; it has to be increase in the case of the use of a supercell (unit cell identically repeated).
        </p>
    varname: maxnsym
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Maximum number of BANDs
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable derives
        the maximum number of bands
        over all k-points and spin-polarisation from
        [[nband]](1:nkpt*nsppol).
        </p>
    varname: mband
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Many Body Perturbation Theory SCISSor operator
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4,99]'
    section: vargw
    text: |-
        <p>
         The Scissors operator energy added to the conductions states.
        In some cases, it mimics a second iteration self-consistent [[GW]] calculation.
        </p>
    varname: mbpt_sciss
    vartype: real
- !variable
    characteristics:
    - '[[BETHE_SALPETER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Model dielectric function, epsilon infinity
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==99 and [[bs_coulomb_term]] in [20,21] (Bethe-Salpeter
        calculas with a model dielectric function'
    section: vargw
    text: |-
        <p>
         [[mdf_epsinf]] specifies the value of the macroscopic dielectric function used
        to model the screening function (see Solid State Commun. <b>84</b>, 765 (1992)).
        The proper spatial symmetry of the screening W(r,r_prime) is enforced using Eq. (7) of Phys. Rev. B <b>37</b>, (1988)
         <br />
        </p>
    varname: mdf_epsinf
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 300
    - 300
    definition: Molecular Dynamics Temperatures
    dimensions:
    - 2
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Give the initial and final temperature
        of the Nose-Hoover thermostat ([[ionmov]]=8)
        and Langevin dynamics ([[ionmov]]=9), in
        Kelvin.
        This temperature will change linearly from the initial temperature
         <b>
          mdtemp(1)
         </b>
         at itime=1 to
        the final temperature
         <b>
          mdtemp(2)
         </b>
         at the end of the
        [[ntime]] timesteps.
        </p>
    varname: mdtemp
    vartype: real
- !variable
    characteristics: null
    commentdefault: the walls are extremely far away
    commentdims: null
    defaultval: 10000.0
    definition: Molecular Dynamics WALL location
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the location (atomic units) of walls
        on which the atoms will bounce back.
        when [[ionmov]]=6, 7, 8 or 9. For each
        cartesian direction idir=1, 2 or 3, there is a pair of walls with
        coordinates xcart(idir)=-wall and xcart(idir)=rprimd(idir,idir)+wall .
        Supposing the particle will cross the wall, its velocity normal to the
        wall is reversed, so that it bounces back.
         <br />
         By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[mdwall]] has the
        '[[LENGTH]]'
        characteristics.
        </p>
    varname: mdwall
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: MEMory TEST
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         This variable controls the memory test done in the memana routine.
        Possible values:
         <ul>
          <li>
           0 no test on the available memory is performed
          </li>
          <li>
           1 the routine tries to allocate the estimated memory, for testing
        purposes, and if a failure occurs, the routine stops.
          </li>
          <li>
           2 like 1, but before stopping, the routine will provide
        an estimation of the available memory.
          </li>
         </ul>
        </p>
    varname: mem_test
    vartype: integer
- !variable
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[imgmov]]==5': 0.4
        defaultval: 100.0
    definition: 'Minimal Energy Path search: MaXimum allowed STEP size'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Relevant only when [[imgmov]]=1 (Steepest-Descent), 2 (String Method) or 5 (Nudged Elastic Band).
         <br />
         The optimizer used to solve the Ordinary Differential Equation (ODE) can be constrained with a maximum allowed step size for each image. By default this feature is only activated for Nudged Elastic Band (NEB) and the value is inspired by
         <i>
          J. Chem. Phys. 128, 134106 (2008)
         </i>
         .
         <br />
         Note that the step size is defined for each image as
         <i>
          step = SQRT[SUM(R_i dot R_i)]
         </i>
         where the
         <i>
          R_i
         </i>
         are the positions of
        the atoms in the cell.
        </p>
    varname: mep_mxstep
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Minimal Energy Path ordinary differential equation SOLVER
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Relevant only when [[imgmov]]=2 (String Method) or 5 (Nudged Elastic Band).
         <br />
         Gives the algorithm used to solve the Ordinary Differential Equation (ODE) when searching for
        a Minimal Energy Path (MEP).
         <br />
         Possible values can be:
         <br />
         <ul>
          <li>
           0=&gt;
           <b>
            Steepest-Descent algorithm
           </b>
           following the (scaled) forces,
        the scaling factor being [[fxcartfactor]]
        (forward Euler method).
           <br />
           Compatible with all MEP search methods.
          </li>
          <br />
          <li>
           1=&gt;
           <b>
            Quick-min optimizer
           </b>
           following the (scaled) forces,
        the scaling factor being [[fxcartfactor]].
        The "quick minimizer" improves upon the steepest-descent method by
        accelerating the system in the direction of the forces. The velocity (of the image) is
        projected long the force and cancelled if antiparallel to it.
           <br />
           Compatible only with Nudged Elastic Band ([[imgmov]]=5).
           <br />
           <i>
            See, for instance: J. Chem. Phys. 128, 134106 (2008).
           </i>
           <br />
          </li>
          <br />
          <li>
           2=&gt;
           <b>
            Local Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) algorithm
           </b>
           ; each image along the
        band is minimized with a different instance of the BFGS optimizer.
           <br />
           Compatible only with Nudged Elastic Band ([[imgmov]]=5).
           <br />
           <i>
            See, for instance: J. Chem. Phys. 128, 134106 (2008).
           </i>
           <br />
           IN [[DEVELOP]]PMENT - NOT RELIABLE
          </li>
          <br />
          <li>
           3=&gt;
           <b>
            Global Broyden-Fletcher-Goldfarb-Shanno (GL-BFGS) algorithm
           </b>
           ; all images along the
        band are minimized with a single instance of the BFGS optimizer.
           <br />
           Compatible only with Nudged Elastic Band ([[imgmov]]=5).
           <br />
           <i>
            See, for instance: J. Chem. Phys. 128, 134106 (2008).
           </i>
           <br />
           IN [[DEVELOP]]PMENT - NOT RELIABLE
          </li>
          <br />
          <li>
           4=&gt;
           <b>
            Fourth-order Runge-Kutta method
           </b>
           ; the images along the band are moved
        every four steps (1&lt;=istep&lt;=[[ntimimage]])
        following the Runge-Kutta algorithm,
        the time step being [[fxcartfactor]].
           <br />
           Compatible only with Simplified String Method ([[imgmov]]=2
        and [[string_algo]]=1 or 2).
           <br />
           <i>
            See: J. Chem. Phys. 126, 164103 (2007).
           </i>
          </li>
         </ul>
         All of the optimizers can be constrained with a maximum allowed step size for each image; see [[mep_mxstep]]. This is by default the case of the Nudged Elastic Band ([[imgmov]]=5).
        </p>
    varname: mep_solver
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Maximum of nGFFT
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable contains the maximum of
        [[ngfft]](1:3).
        </p>
    varname: mgfft
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Maximum of nGFFT for the Double Grid
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable contains the maximum of
        [[ngfftdg]](1:3).
        </p>
    varname: mgfftdg
    vartype: integer
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: MIXing coefficients for ALCHemical potentials
    dimensions:
    - '[[npspalch]]'
    - '[[ntypalch]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Used for the generation of alchemical pseudoatoms, that is,
        when [[ntypalch]] is non-zero.
        </p>
        <p>
         This array gives, for each type of alchemical pseudatom (there are
        [[ntypalch]] such pseudoatoms), the mixing coefficients
        of the basic [[npspalch]] pseudopotentials for
        alchemical use. For each type of alchemical pseudoatom, the sum of the
        mixing coefficients must equal 1.
        </p>
        <p>
         The actual use of the mixing coefficients is defined by the input
        variable [[algalch]]. Note that the masses of the atoms,
        [[amu]]
        are also mixed according to the value of [[mixalch]], by default.
        </p>
        <p>
         Example 1. Suppose that we want to describe Ba(0.25) Sr(0.75) Ti O3.
         <br />
         The input variables related to the construction of the alchemical Ba(0.25) Sr(0.75)
        potential will be :
         <pre>
          npsp   4                 ! 4 pseudopotentials should be read.
          znucl  8 40 56 38        ! The nuclear charges. Note that the two
                                   ! atoms whose pseudopotentials are to be mixed
                                   ! are mentioned at the end of the series.
          ntypat  3                ! There will be three types of atoms.
          ntypalch   1             ! One pseudoatom will be alchemical.
                                   ! Hence, there will be ntyppure=2 pure pseudoatoms,
                                   ! with znucl 8 (O) and 40 (Ti), corresponding to
                                   ! the two first pseudopotentials. Out of the
                                   ! four pseudopotentials, npspalch=2 are left
                                   ! for alchemical purposes, with znucl 56 (Ba)
                                   ! and 38 (Sr).
          mixalch    0.25  0.75    ! For that unique pseudoatom to be
                                   ! generated, here are the mixing coeeficients,
                                   ! to be used to combine the Ba and Sr pseudopotentials.
         </pre>
        </p>
        <p>
         Example 2. More complicated, and illustrate some minor drawback of the
        design of input variables.
        Suppose that one wants to generate Al(0.25)Ga(0.75) As(0.10)Sb(0.90).
         <br />
         The input variables will be :
         <pre>
          npsp  4                  ! 4 pseudopotentials should be read
          znucl  13 31 33 51       ! The atomic numbers. All pseudopotentials
                                   ! will be used for some alchemical purpose
          ntypat  2                ! There will be two types of atoms.
          ntypalch   2             ! None of the atoms will be "pure".
                                   ! Hence, there will be npspalch=4 pseudopotentials
                                   !  to be used for alchemical purposes.
          mixalch    0.25  0.75 0.0  0.0   ! This array is a (4,2) array, arranged in the
                     0.0   0.0  0.1  0.9   ! usual Fortran order.
         </pre>
         Minor drawback : one should not forget to fill [[mixalch]] with the needed zero's, in this later case.
        </p>
        <p>
         In most cases, the use of [[mixalch]]
        will be as a static (non-evolving) variable. However, the possibility to have
        different values of [[mixalch]] for different images has been coded. A population of
        cells with different atomic characteristics can thus be considered,
        and can be made to evolve, e.g. with a genetic algorithm (not coded in v7.0.0 though).
        There is one restriction to this possibility : the value of [[ziontypat]] for the atoms that are mixed should be
        identical.
        </p>
    varname: mixalch
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Maximum number of Plane Waves
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable gives the maximum of the number of
        plane waves over all k-points. It is computed
        from [[ecut]] and the description
        of the cell, provided by
        [[acell]],
        [[rprim]], and/or
        [[angdeg]].
        </p>
    varname: mpw
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 3001
    definition: Maximum number of Q-space GRID points for pseudopotentials
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Govern the size of the one-dimensional information
        related to pseudopotentials, in reciprocal space :
        potentials, or projector functions.
        </p>
    varname: mqgrid
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 3001
    definition: Maximum number of Q-wavevectors for the 1-dimensional GRID  for the Double Grid in PAW
    dimensions: scalar
    excludes: null
    requires: null
    section: varpaw
    text: |-
        <p>
         Maximum number of wavevectors used to sample the local part of the potential, in PAW.
        Actually referred to as mqgrid_vl internally. Should change name to the latter ...
        See also [[mqgrid]]
        </p>
    varname: mqgriddg
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of AToms in CONstraint equations
    dimensions:
    - '[[nconeq]]'
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of atoms appearing in each of the
        [[nconeq]]
         independent equations constraining the motion of
        atoms during structural optimization or molecular dynamics (see
        [[nconeq]]
         , [[iatcon]],
        and [[wtatcon]]).
        </p>
    varname: natcon
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: (no atoms held fixed)
    commentdims: null
    defaultval: 0
    definition: Number of Atoms that are FIXed
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held fixed
        during a structural
        optimization or molecular dynamics.
        <br />
         When
        [[natfix]]
        &gt; 0,
        [[natfix]]
         entries should be provided in array
        [[iatfix]]
         .
        </p>
    varname: natfix
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Atoms that are FIXed along the X direction
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held  fixed along the X direction
        during a structural
        optimization or molecular dynamics.
         <br />
         When [[natfixx]] &gt; 0, [[natfixx]] entries should be provided
        in array [[iatfixx]].
        </p>
    varname: natfixx
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Atoms that are FIXed along the Y direction
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held fixed along the Y direction
        during a structural
        optimization or molecular dynamics.
         <br />
         When [[natfixy]] &gt; 0, [[natfixy]] entries should be provided in array [[iatfixy]]
        </p>
    varname: natfixy
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Atoms that are FIXed along the Z direction
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of atoms (not to exceed
        [[natom]]) which are to be held fixed along the Z direction
        during a structural
        optimization or molecular dynamics.
         <br />
         When [[natfixz]] &gt; 0, [[natfixz]] entries should be provided in array [[iatfixz]].
        </p>
    varname: natfixz
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of ATOMs
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the total number of atoms in the unit cell.
        Default is 1 but you will obviously want to input this
        value explicitly.
         <br />
         Note that [[natom]] refers to all atoms in the unit cell, not
        only to the irreducible set of atoms in the unit cell (using symmetry operations,
        this set allows to recover all atoms). If you want
        to specify only the irreducible set of atoms, use the
        symmetriser, see the input variable [[natrd]].
        </p>
    varname: natom
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of AToms on which PAW+U is applied
    dimensions: scalar
    excludes: null
    requires: '[[usepawu]]==1'
    section: varint
    text: |-
        <p>
         This internal variable gives the number of atoms on which the LDA/GGA+U method
        is applied. This value is determined from [[lpawu]].
        </p>
    varname: natpawu
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[SYMMETRISER]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[natom]]'
    definition: Number of AToms ReaD
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the number of atoms to be
        read from the input file, in the case the geometry builder
        or the symmetriser is used. In this case,
        [[natrd]] is also used to dimension
        the array [[typat]],
        and the arrays [[xred]],
        [[xangst]] and [[xcart]].
         <br />
         Must take into account the vacancies (see [[vacnum]] and
        [[vaclst]]).
         <br />
         Despite possible vacancies, cannot be bigger than [[natom]].
        </p>
    varname: natrd
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[natom]]'
    definition: Number of ATomic SPHeres for the atom-projected density-of-states
    dimensions: scalar
    excludes: null
    requires: '[[prtdos]] == 3 or [[pawfatbnd]] in [1,2]'
    section: vargs
    text: |-
        <p>
        [[natsph]] gives the number of atoms around which the sphere
        for atom-projected density-of-states will be built,
        in the [[prtdos]]=3 case.
        The indices of these atoms are given by [[iatsph]].
        The radius of these spheres is given by [[ratsph]].
         <br />
         If [[pawfatbnd]]=1 or 2, it gives the number of atoms around which atom-projected band structure will be
        built (the indices of these atoms are given by  [[iatsph]]).
        </p>
    varname: natsph
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of ATomic SPHeres for the l-projected density-of-states in EXTRA set
    dimensions: scalar
    excludes: null
    requires: '[[prtdos]] == 3 or [[pawfatbnd]] in [1,2]'
    section: vargs
    text: |-
        <p>
        [[natsph_extra]] gives the number of extra spheres
        for which the angular-momentum-projected density-of-states will be built,
        in the [[prtdos]]=3 case.
        The radius of these spheres is given by [[ratsph_extra]].
        This simulates the STS signal for an STM tip atom placed at the sphere position, according to the chemical nature of the tip (s- p- d- wave etc...).
         <br />
         If [[pawfatbnd]]=1 or 2, it gives the number of spheres in which l-projected band structure will be
        built.
         <br />
         The position of the spheres is given by the
         [[xredsph_extra]]
         variable.
        </p>
    varname: natsph_extra
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of ATomic potential (V) energy SHIFTs (per atom)
    dimensions: scalar
    excludes: null
    requires: '[[usepawu]] /= 0, [[atvshift]]'
    section: varff
    text: |-
        <p>
         Number of atomic potential energy shifts (per atom), to be used to define the
        array [[atvshift]].
        If non-zero, only two possibilities exist : 5 for d states
        (with [[lpawu]]=2),
        and 7 for f states (with [[lpawu]]=3).
        If non-zero, one should define
        [[usepawu]],
        [[lpawu]] and
        [[atvshift]].
        </p>
    varname: natvshift
    vartype: integer
- !variable
    characteristics: null
    commentdefault: ' the estimated number of occupied bands +1 (TODO provide
        the mathematical formulation)'
    commentdims: null
    defaultval: null
    definition: Number of BANDs
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives number of bands, occupied plus
        possibly unoccupied, for which wavefunctions are being computed
        along with eigenvalues.
         <br />
         Note : if the parameter
        [[occopt]] (see below) is not set to 2,
        [[nband]] is a scalar integer, but
        if the parameter [[occopt]] is set to 2,
        then [[nband]] must be an array [[nband]]([[nkpt]]*
        [[nsppol]]) giving the
        number of bands explicitly for each k point.  This
        option is provided in order to allow the number of
        bands treated to vary from k point to k point.
         <br />
         For the values of [[occopt]] not equal to 0 or 2, [[nband]]
        can be omitted. The number of bands will be set up
        thanks to the use of the variable [[fband]]. The present Default
        will not be used.
        </p>
        <p>
         If [[nspinor]] is 2, nband must be even for
        each k point.
        </p>
        <p>
         In the case of a [[GW]] calculation ([[optdriver]]=3 or 4),
        [[nband]] gives the number of bands to be treated to generate the screening (susceptibility
        and dielectric matrix), as well as the self-energy. However, to generate the _KSS
        file (see [[kssform]])
        the relevant number of bands is given by [[nbandkss]].
        </p>
    varname: nband
    vartype: integer
- !variable
    characteristics: null
    commentdefault: 'the estimated number of occupied bands (TODO : provide
        the mathematical formulation)'
    commentdims: null
    defaultval: null
    definition: Number of BANDs for Fock exact exchange
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the maximum number of occupied bands with which Fock exact exchange is being computed for the wavefunctions.
        </p>
    varname: nbandhf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of BANDs in the KSS file
    dimensions: scalar
    excludes: null
    requires: null
    section: vargw
    text: |-
        <p>
         This input variable is used for the preparation of a [[GW]] calculation :
        it is used in a GS run (where [[optdriver]]=0) to generate a _KSS file.
        In this run, [[nbandkss]] should be non-zero.
        The generated _KSS file can be subsequently used to calculate the irreducible polarizabilty
        $\chi^{(0)}_{KS}$ using [[optdriver]]=3
        or to calculate [[GW]] corrections setting [[optdriver]]=4.
        </p>
        <p>
         <ul>
          <li>
           If [[nbandkss]]=0, no _KSS file is created
          </li>
          <li>
           If [[nbandkss]]=-1, all the available eigenstates (energies and eigenfunctions) are stored in the
        abo_KSS file at the end of the ground state calculation. The number of states is forced to be
        the same for all k-points : it will be the minimum of the number of plane waves over all k-points.
          </li>
          <li>
           If [[nbandkss]] is greater than 0, abinit stores (about) [[nbandkss]] eigenstates in the abo_KSS file.
        This number of states is forced to be the same for all k-points.
          </li>
         </ul>
        </p>
        <p>
         See [[npwkss]] for the selection of the number of the planewave components of
        the eigenstates to be stored.
         <br />
         The input variable [[iomode]] can be used
        to read and write KSS files according to different fileformat
        (presently only [[iomode]]=0 and 3 are available in the [[GW]] part).
         <br />
         The precision of the KSS file can be tuned through the input variable [[kssform]].
         <br />
         For more details about the format of the abo_KSS file, see the routine outkss.F90.
        </p>
        <p>
         Very important : for the time being, [[istwfk]] must be 1 for all the k-points
        in order to generate a _KSS file.
        </p>
    varname: nbandkss
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of BanDs in a BLOCK
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         In case of non-standard, blocked algorithms for the
        optimization of the wavefunctions (that is, if
        [[wfoptalg]]=4):
         <ul>
          <li>
           if [[wfoptalg]]=4,
        [[nbdblock]] defines the number of blocks (the number of bands in the block is
        then [[nband]]/[[nbdblock]] ).
          </li>
         </ul>
        </p>
    varname: nbdblock
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[optdriver]]==0 and [[iscf]]<0': 2*[[nspinor]]
        '[[optdriver]]==1 and 3<=[[occopt]] and [[occopt]]<= 8': 2*[[nspinor]]
        defaultval: 0
    definition: Number of BanDs for the BUFfer
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         [[nbdbuf]] gives the number of bands, the highest in energy, that,
        among the
        [[nband]] bands, are to be considered
        as part of a buffer. This concept is useful in three situations:
        in non-self-consistent
        calculations, for the determination of the convergence tolerance ;
        for response functions of metals, to avoid instabilities,
        and also when finite electric fields or non-linear responses (with electric field
        perturbations) are considered.
        For the two first, the need of a buffer is a natural requirement
        of the problem, so that the default value is changed to 2 automatically,
        as explained in the following.
        The third case is only for implementation convenience.
        </p>
        <p>
         In non-self-consistent GS calculations ([[iscf]]&lt;0),
        the highest levels might be
        difficult to converge, if they are degenerate with another level,
        that does not belong to the set of bands treated. Then, it might
        take extremely long to reach [[tolwfr]], although
        the other bands are already extremely well-converged, and the energy
        of the highest bands (whose residual are not yet good enough), is
        also rather well converged.
         <br />
         In response to this problem, for non-zero [[nbdbuf]], the
        largest residual (residm), to be later compared with [[tolwfr]],
        will be computed only in the set of non-buffer bands (this modification
        applies for non-self-consistent as well as self-consistent calculation,
        for GS as well as RF calculations).
         <br />
         For a GS calculation, with [[iscf]]&lt;0, supposing
        [[nbdbuf]] is not initialized in the input file,
        then ABINIT will overcome the default [[nbdbuf]] value,
        and automatically set [[nbdbuf]] to 2.
        </p>
        <p>
         In metallic RF calculations, in the conjugate gradient optimisation
        of first-order wavefunctions, there is an instability situation
        when the q wavevector of the perturbation brings the eigenenergy of the
        highest treated band at some k point higher than the lowest
        untreated eigenenergy at some k+q point.
        If one accepts a buffer of frozen states, this instability can be made to
        disappear. Frozen states receive automatically a residual value of -0.1d0.
         <br />
         For a RF calculation, with 3&lt;=[[occopt]]&lt;=7,
        supposing
        [[nbdbuf]] is not initialized in the input file, then
        ABINIT will overcome the default [[nbdbuf]] value,
        and automatically set [[nbdbuf]] to 2. This value might be too low
        in some cases.
        </p>
        <p>
         Also, the number of active bands, in all cases, is imposed
        to be at least 1, irrespective of the value of [[nbdbuf]].
        </p>
    varname: nbdbuf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of BERRY phase computations
    dimensions: scalar
    excludes: null
    requires: '[[berryopt]] = 1, 2, or 3'
    section: varff
    text: |-
        <p>
         Gives the number of Berry phase computations of polarisation,
        or finite-difference estimations of the derivative of wavefunctions
        with respect to the wavevector,
        each of which might be characterized by a different change of
        wavevector [[kberry]].
        </p>
        <p>
         When equal to 0, no Berry phase calculation of polarisation
        is performed. The maximal value of [[nberry]] is 20.
        </p>
        <p>
         Note that the computation of the polarisation for a set of bands
        having different occupation numbers is meaningless (although
        in the case of spin-polarized calculations, the spin up bands
        might have an identical occupation number, that might differ
        from the identical occupation number of spin down bands).
        Although meaningless, ABINIT will perform such computation,
        if required by the user. The input variable
        [[bdberry]] governs the set of bands
        for which a Berry phase is computed.
        </p>
        <p>
         For the [[berryopt]] = 1, 2, and 3 cases, spinor wavefunctions are not allowed, nor are parallel computations.
        </p>
    varname: nberry
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: 0 when [[usepaw]]=0, 1 when [[usepaw]]=1
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==0': 0
        '[[usepaw]]==1': 1
        defaultval: 0
    definition: use XC Core-Correction in G-space
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        Historically, Abinit treats the model core charge used for the non-linear core
        correction in real space. Alternatively, it is possible to instruct the code to compute the core charge in G-space following the same approach used in
        the PAW code. The G-space formalism is more accurate than the interpolation in real space, especially when derivatives of the model core charge are
        needed, e.g. DFPT. Preliminary tests showed that the violation of the acoustic sum rule is reduced when [[nc_xccc_gspace]]==1 , especially for LDA.
        It is worth stressing, however, that [[nc_xccc_gspace]]==1
        should be used only in conjunction with NC pseudos whose model core charge that decays quickly in
        G-space. Several NC pseudos available in the Abinit table are not optimized for the G-space formalism and users are strongly invited to perform
        convergence studies with respect to ecut before using this option.
    varname: nc_xccc_gspace
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of CONstraint EQuations
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of independent equations constraining
        the motion of
        atoms during structural optimization or molecular dynamics (see
        [[natcon]]
         , [[iatcon]],
        and [[wtatcon]]).
        </p>
    varname: nconeq
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: NetCdf TIME between output of molecular dynamics informations
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         When [[nctime]] is non-zero, the molecular dynamics information
        is output in NetCDF format, every [[nctime]] time step. Here is the content of an example file :
         <pre>
        netcdf md32.outH_moldyn1 {
        dimensions:
           time = UNLIMITED ; // (11 currently)
           DimTensor = 6 ;
           DimCoord = 3 ;
           NbAtoms = 32 ;
           DimVector = 3 ;
           DimScalar = 1 ;
        variables:
           double E_pot(time) ;
              E_pot:units = "hartree" ;
           double E_kin(time) ;
              E_kin:units = "hartree" ;
           double Stress(time, DimTensor) ;
              Stress:units = "hartree/Bohr^3" ;
           double Position(time, DimCoord, NbAtoms) ;
              Position:units = "Bohr" ;
           double Celerity(time, DimCoord, NbAtoms) ;
              Celerity:units = "Bohr/(atomic time unit)" ;
           double PrimitiveVector1(DimVector) ;
           double PrimitiveVector2(DimVector) ;
           double PrimitiveVector3(DimVector) ;
           double Cell_Volume(DimScalar) ;
              Cell_Volume:units = "Bohr^3" ;
        }
         </pre>
        </p>
    varname: nctime
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: Will be generated automatically from [[ndivsm]] if the latter is defined.
    commentdims: null
    defaultval: null
    definition: Number of DIVisions of K lines
    dimensions:
    - abs([[kptopt]])
    excludes: specified([[ndivsm]])
    requires: '[[kptopt]] < 0'
    section: vargs
    text: |-
        <p>
         Gives the number of divisions of each of the segments
        of the band structure, whose path is determined by
        [[kptopt]]
        and
        [[kptbounds]].
        In this case, the absolute value of
        [[kptopt]] is the number of such segments.
        </p>
        <p>
         For example, suppose that the number of segment is just one
        ([[kptopt]]=-1),
        a value [[ndivk]]=4 will lead to the computation
        of points with relative coordinates 0.0, 0.25, 0.5, 0.75 and 1.0 , along
        the segment in consideration.
        </p>
        <p>
         Now, suppose that there are two segments
        ([[kptopt]]=-2), with
        [[ndivk]](1)=4 and [[ndivk]](2)=2, the computation of the
        eigenvalues will be done at 7 points, 5 belonging to the
        first segment, with relative coordinates 0.0, 0.25, 0.5, 0.75 and 1.0,
        the last one being also the starting point of the next segment,
        for which two other points must be computed, with relative coordinates
        0.5 and 1.0 .
        </p>
        <p>
         It is easy to compute disconnected circuits (non-chained segments),
        by separating
        the circuits with the value [[ndivk]]=1 for the intermediate
        segment connecting the end of one circuit with the
        beginning of the next one (in which case no intermediate
        point is computed along this segment).
        </p>
        <p>
         Alternatively it is possible to generate automatically the array [[ndivk]]
        by just specifying the number of divisions for the smallest segment.
        See the related input variable [[ndivsm]].
        </p>
    varname: ndivk
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of DIVisions for the SMallest segment
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
        This variable defines the number of divisions used to sample the smallest segment of the circuit employed in a band structure calculations
        (see related input variables
        [[kptopt]]
        and
        [[kptbounds]]).
        If [[ndivsm]] is given in the input file, there is no need to specify the number of divisions
        to be used for the other segments.
        Indeed [[ndivk]] is automatically calculated inside the
        code in order to generate a path where the number of divisions in each segment is proportional
        to the length of the segment itself.
        This option is activated only when [[kptopt]] is negative.
        In this case, the absolute value of
        [[kptopt]] is the number of such segments.
        </p>
    varname: ndivsm
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of DaTaSETs
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the number of data sets to be
        treated.
         <br />
         If 0, means that the multi-data set treatment is not used,
        so that the root filenames will not be appended with _DSx,
        where 'x' is the dataset index defined
        by the input variable [[jdtset]],
        and also that input names with a dataset index are not allowed.
        Otherwise, [[ndtset]]=0 is equivalent to [[ndtset]]=1.
        </p>
    varname: ndtset
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of DYNamical IMAGEs
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable gives the number of dynamical images,
        immediately deduced from the number of non-zero values present in
        [[dynimage]].
        It is used to dimension many memory-consuming arrays (one copy for each image),
        e.g. the wavefunction array (cg), the density array (rho), etc .
        </p>
    varname: ndynimage
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Nudged Elastic Band ALGOrithm
    dimensions: scalar
    excludes: null
    requires: '[[imgmov]]==5'
    section: varrlx
    text: |-
        <p>
         Gives the variant of the NEB method used.
         <br />
         Possible values can be:
         <br />
         <ul>
          <li>
           0=&gt;
           <b>
            Original NEB method
           </b>
           .
           <br />
           <i>
            See: Classical and Quantum Dynamics in Condensed Phase Simulations, edited by
        Berne, Ciccotti, Coker (World Scientific, Singapore, 1998), pp. 385-404
           </i>
          </li>
          <br />
          <li>
           1=&gt;
           <b>
            NEB + improved tangent
           </b>
           .
           <br />
           The Improved Tangent Method builds on the NEB with an improved estimate of the
        tangent direction and a resulting change of the component of the spring force acting
        on the images.
           <br />
           <i>
            See: J. Chem. Phys. 113, 9978 (2000).
           </i>
          </li>
          <br />
          <li>
           2=&gt;
           <b>
            Climbing-Image NEB (CI-NEB)
           </b>
           .
           <br />
           The CI-NEB method constitutes a small modification to the NEB method.
        Information about the shape of the MEP is retained, but a rigorous
        convergence to a saddle point is also obtained.
        By default the spring constants are variable (see [[neb_spring]]).
        As the image with the highest energy has to be identified,
        the calculation begins with several iterations of the standard NEB
        algorithm. The effective CI-NEB begins at the [[cineb_start]] iteration.
           <br />
           <i>
            See: J. Chem. Phys. 113, 9901 (2000).
           </i>
          </li>
         </ul>
         Note that, in all cases, it is possible to define the value of the spring constant connecting images with
        [[neb_spring]], keeping it constant or allowing it
        to vary between 2 values (to have higher resolution close to the saddle point).
        </p>
    varname: neb_algo
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[neb_algo]]==2':
        - 0.02
        - 0.15
        defaultval:
        - 0.05
        - 0.05
    definition: 'Nudged Elastic Band: SPRING constant'
    dimensions:
    - 2
    excludes: null
    requires: '[[imgmov]]==5'
    section: varrlx
    text: |-
        <p>
         Gives the minimal and maximal values of the spring constant connecting images for the NEB method.
         <br />
         In the standard "Nudged Elastic Band" method, the spring constant is constant along the path,
        but, in order to have higher resolution close to the saddle point, it can be better
        to have stronger springs close to it.
         <br />
         <i>
          See: J. Chem. Phys. 113, 9901 (2000).
         </i>
        </p>
    varname: neb_spring
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    definition: Number of ELECTrons
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable gives the number of electrons per unit
        cell, as computed from the sum of the valence electrons
        related to each atom (given in the pseudopotential, where it is called
        "zion"), and the input variable
        [[charge]]:
         <br />
         [[nelect]]=zion-[[charge]].
        </p>
    varname: nelect
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of FFT points
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         If space parallelisation is not used (that is, if [[paral_kgb]]==0),
        this internal variable gives the number of Fast Fourier Transform
        points in the grid generated by
        [[ngfft]](1:3). It is simply the
        product of the three components of [[ngfft]].
         <br />
         If space parallelisation is used (that is, if [[paral_kgb]]==1), then it becomes the
        number of Fast Fourier Transform points attributed to the
        particular processor. It is no longer the above-mentioned simple product,
        but a number usually close to this product divided by the
        number of processors on which the space is shared.
        </p>
    varname: nfft
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of FFT points for the Double Grid
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         If space parallelisation is not used (that is, if [[paral_kgb]]==0),
        this internal variable gives the number of Fast Fourier Transform
        points in the (double) grid generated by
        [[ngfftdg]](1:3). It is simply the
        product of the three components of [[ngfftdg]].
         <br />
         If space parallelisation is used (that is, if [[paral_kgb]]==1), then it becomes the
        number of Fast Fourier Transform points attributed to the
        particular processor. It is no longer the above-mentioned simple product,
        but a number usually close to this product divided by the
        number of processors on which the space is shared.
        </p>
    varname: nfftdg
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of FREQuencies along the IMaginary axis
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,12,22,9,19,29]'
    section: vargw
    text: |-
        <p>
         [[nfreqim]] sets the number of pure imaginary frequencies used to calculate
        the dielectric matrix in order to perform the numerical integration of the [[GW]] self-energy.
        </p>
    varname: nfreqim
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Nth FREQuencey Moment of the Imaginary part of the Dielectric Matrix
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         depending on the value of
         [[nfreqmidm]]
         will calculate the frequency moment of the Dielectric matrix or its inverse,

        <ul>
        <li>if [[nfreqmidm]] is positive : calculate (nth=[[nfreqmidm]]) frequency moment of the Dielectric matrix</li>
        <li>if [[nfreqmidm]] is negative : calculate (nth=[[nfreqmidm]]) frequency moment of the inverse Dielectric matrix</li>
        <li>if [[nfreqmidm]] = 0 : calculate first frequency moment of the full polarizability</li>
        </ul>

        see M. Taut, J. Phys. C: Solid State Phys. 18 (1985) 2677-2690.
        </p>
    varname: nfreqmidm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of FREQuencies along the REal axis
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 and [[gwcalctyp]] in [2,12,22,9,19,29]'
    section: vargw
    text: |-
        <p>
         [[nfreqre]] sets the number of real frequencies used to calculate
        the dielectric matrix in order to perform the numerical integration of the [[GW]] self-energy.
        </p>
        <p>
         It can be used also in case of [[GW]] calculations with plasmon-pole models,
         <i>
          i.e
         </i>
         [[gwcalctyp]]&lt;10,
        to reduce the number of frequencies used to evaluate the dielectric matrix from the (default) two to
        one frequency (omega=0) by setting [[nfreqre]]=1.
        This might be a good idea in case one is planning to use ppmodel&gt;1.
        This will force the calculation of the screening on a single frequency (omega=0) and hence
        reduce memory and disk space requirement.
        The only draw back is that the user will not be able to perform self energy calculation using
        [[ppmodel]]=1,
        since in the last case the dielectric matrix calculated on two frequencies is required.
        If the user is not sure which ppmodel to use, then s/he is not advised
        to use this input variable.
        Using the default values, one must be able to get a screening file that can be used with any ppmodel.
        </p>
    varname: nfreqre
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of FREQuencies for the SPectral function
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[nfreqsp]] defines the number of real frequencies used to calculate the spectral function
        of the [[GW]] Green's function.
        </p>
    varname: nfreqsp
    vartype: integer
- !variable
    characteristics: null
    commentdefault: (automatic selection of optimal values)
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Number of Grid points for Fast Fourier Transform
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         gives the size of fast Fourier transform
        (fft) grid in three dimensions.  Each number must be
        composed of the factors 2, 3, and 5 to be consistent with
        the radices available in our fft.  If no [[ngfft]] is provided or
        if [[ngfft]] is set to 0 0 0, the code will automatically provide
        an optimal set of [[ngfft]] values, based on [[acell]],
        [[rprim]] and [[ecut]]
        (see also [[boxcutmin]] for speed/accuracy concerns).
        This is the recommended procedure, of course.
         <br />
         The total number of FFT points
        is the product:
         <br />
         <tele>
          [[ngfft]](1)*[[ngfft]](2)*[[ngfft]](3)=nfft
         </tele>
         .
         <br />
         When [[ngfft]] is made smaller
        than recommended values (e.g. by setting [[boxcutmin]]
        to a value smaller than 2.0 or by setting [[ngfft]] manually), the code runs faster and the
        equations in effect are approximated by a low pass Fourier
        filter.  The code reports to standard output (unit 06) a
        parameter "boxcut" which is the smallest ratio of the fft
        box side to the G vector basis sphere diameter.  When
        boxcut is less than 2 the Fourier filter approximation is being
        used.  When boxcut gets less than about 1.5 the
        approximation may be too severe for realistic results
        and should be tested against larger values of [[ngfft]].
        When boxcut is larger than 2, [[ngfft]] could be reduced without
        loss of accuracy. In this case, the small variations
        that are observed are solely due to the
        xc quadrature, that may be handled with [[intxc]]=1
        to even reduce this effect.
        </p>
        <p>
         Internally, [[ngfft]] is an array of size 18. The present
        components are stored in [[ngfft]](1:3), while
         <ul>
          <li>
           [[ngfft]](4:6) contains slightly different (larger) values,
        modified for efficiency of the FFT
          </li>
          <li>
           [[ngfft]](7) is [[fftalg]]
          </li>
          <li>
           [[ngfft]](8) is [[fftcache]]
          </li>
          <li>
           [[ngfft]](9) is set to 0 if the parallelization of the FFT is not activated,
        while it is set to 1 if it is activated.
          </li>
          <li>
           [[ngfft]](10) is the number of processors of the FFT group
          </li>
          <li>
           [[ngfft]](11) is the index of the processor in the group of processors
          </li>
          <li>
           [[ngfft]](12) is n2proc, the number of x-z planes, in reciprocal space, treated by the processor
          </li>
          <li>
           [[ngfft]](13) is n3proc, the number of x-y planes, in real space, treated by the processor
          </li>
          <li>
           [[ngfft]](14) is mpi_comm_fft, the handle on the MPI communicator in charge of the FFT parallelisation
          </li>
          <li>
           [[ngfft]](15:18) are not yet used
          </li>
         </ul>
         <br />
         The number of points stored by this processor in real space is n1*n2*n3proc, while in reciprocal
        space, it is n1*n2proc*n3.
        </p>
    varname: ngfft
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: 'Number of Grid points for Fast Fourier Transform : Double
        Grid'
    dimensions:
    - 3
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         This variable has the same meaning as ngfft (gives the size of fast Fourier
        transform (fft) grid in three dimensions) but concerns the "double
        grid" only used for PAW calculations.
        </p>
    varname: ngfftdg
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Number of Grid points for K PoinTs generation
    dimensions:
    - 3
    excludes: specified([[kptrlatt]])
    requires: '[[kptopt]] >=0, '
    section: varbas
    text: |-
        <p>
         Used when [[kptopt]]&gt;=0,
        if [[kptrlatt]]
        has not been defined ([[kptrlatt]]
        and [[ngkpt]] are exclusive of each other).
         <br />
         Its three positive components
        give the number of k points of Monkhorst-Pack grids
        (defined with respect to primitive axis in reciprocal space)
        in each of the three dimensions.
        [[ngkpt]] will be used to generate the
        corresponding [[kptrlatt]]
        input variable.
        The use of [[nshiftk]]
        and [[shiftk]], allows to generate
        shifted grids, or Monkhorst-Pack grids defined
        with respect to conventional unit cells.
        </p>
        <p>
         When [[nshiftk]]=1,
        [[kptrlatt]] is initialized
        as a diagonal (3x3) matrix, whose diagonal elements
        are the three values [[ngkpt]](1:3). When
        [[nshiftk]] is greater than 1,
        ABINIT will try to generate [[kptrlatt]]
        on the basis of the primitive vectors of the k-lattice:
        the number of shifts might be reduced, in which case
        [[kptrlatt]] will not be diagonal
        anymore.
        </p>
        <p>
         Monkhorst-Pack grids are usually the most efficient when
        their defining integer numbers are even.
        For a measure of the efficiency, see the input variable
        [[kptrlen]].
        </p>
    varname: ngkpt
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Number of Grid pointsfor Q PoinTs generation
    dimensions:
    - 3
    excludes: specified([[qptrlatt]])
    requires: '[[nqpt]]==1 and [[kptopt]]>=0'
    section: vargs
    text: |-
        <p>
         At variance with [[ngkpt]], note that only one q point
        is selected per dataset (see [[iqpt]]).
         <br />
         Its three positive components
        give the number of q points of Monkhorst-Pack grids
        (defined with respect to primitive axis in reciprocal space)
        in each of the three dimensions.
        The use of [[nshiftq]]
        and [[shiftq]], allows to generate
        shifted grids, or Monkhorst-Pack grids defined
        with respect to conventional unit cells.
        </p>
        <p>
         For more information on Monkhorst-Pack grids, see [[ngkpt]].
        </p>
    varname: ngqpt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of IMAGEs
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Give the number of images (or replicas) of the system,
        for which the forces and stresses might be computed independently,
        in the context of the string method, the genetic algorithm, hyperdynamics or Path-Integral Molecular Dynamics
        depending on the value of [[imgmov]]).
        Related input variables : [[dynimage]],
        [[npimage]], [[ntimimage]]
        and [[prtvolimg]].
         <br />
         Images might differ by the position of atoms in the unit cell, their
        velocity, as well as by their cell geometry. The following input variables might be used to define
        the images :
         <ul>
          <li>
           [[acell]]
          </li>
          <li>
           [[amu]]
          </li>
          <li>
           [[angdeg]]
          </li>
          <li>
           [[dmatpawu]]
          </li>
          <li>
           [[jpawu]]
          </li>
         <li>
           [[mixalch]]
          </li>
          <li>
           [[rprim]]
          </li>
          <li>
           [[upawu]]
          </li>
         <li>
           [[vel]]
          </li>
         <li>
           [[vel_cell]]
          </li>
          <li>
           [[xangst]]
          </li>
          <li>
           [[xcart]]
          </li>
          <li>
           [[xred]]
          </li>
         </ul>
         These input variables, non-modified, will be used to define the image with index 1.
        For the image with the last index, the input file might specify the values
        of such input variables, appended with "_lastimg", e.g. :
         <ul>
          <li>
            acell_lastimg
          </li>
           <li>
            rprim_lastimg
          </li>
           <li>
            xcart_lastimg
          </li>
          <li>
            ...
          </li>
          </ul>
         By default, these values will be interpolated linearly to define values for the other images, unless
        there exist specific values for some images, for which the string "last" has to be replaced by the
        index of the image, e.g. for the image number 4 :
         <ul>
          <li>
            acell_4img
          </li>
           <li>
            rprim_4img
          </li>
           <li>
            xcart_4img
          </li>
          <li>
           ...
          </li>
         </ul>
         It is notably possible to specify the starting point and the end point of the path (of images), while specifying intermediate points.
         <br />
         <br />
         It usually happen that the images do not have the same symmetries and space group.
        ABINIT has not been designed to use different set of symmetries for different images.
        ABINIT will use the symmetry and space group of the image number 2, that
        is expected to have a low number of symmetries.
        This might lead to erroneous calculations, in case some image has even less
        symmetry. By contrast, there is no problem if some other image has more symmetries
        than those of the second image.
        </p>
    varname: nimage
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of K-points defining the PATH
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        This variable is used to define the number of high-symmetry k-points in the [[kptbounds]] array when [[kptopt]] > 0.
        Historically, [[kptbounds]] is used in conjuction with a negative
        value of [[kptopt]] when performing a NSCF band structure calculation. In this case, the number of k-points in kptbounds
        is given by abs(kptopt) + 1.

        There are, however, other cases in which one has to specify a k-path in the input file in order to activate some kind of post-processing tool.
        Typical examples are the interpolation of
        the GW corrections at the end of the sigma run or the interpolation
        of the KS eigenvalues along a path at the end of the SCF run (see
        also [[einterp]])
        In a nutshell, nkpath replaces [[kptopt]] when we are not performing a NSCF calculation.
        Note that, unlike [[kptopt]], nkpath represents the total number of points in the [[kptbounds]] array.
    varname: nkpath
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[kptopt]]==0': 1
        defaultval: 0
    definition: Number of K - Points
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         If non-zero,
        [[nkpt]]
        gives the number of k points in the k point array
        [[kpt]]. These points
        are used either to sample the Brillouin zone, or to
        build a band structure along specified lines.
        </p>
        <p>
         If [[nkpt]] is zero, the code deduces from other input variables
        (see the list in the description of [[kptopt]])
        the number of k points, which is possible only
        when [[kptopt]]/=0.
        If [[kptopt]]/=0 and
        the input value of [[nkpt]]/=0,
        then ABINIT will check that the number of k points
        generated from the other input variables
        is exactly the same than [[nkpt]].
        </p>
        <p>
         If [[kptopt]] is positive,
        [[nkpt]] must be coherent with the values
        of [[kptrlatt]],
        [[nshiftk]]
        and [[shiftk]].
         <br />
         For ground state calculations, one should select the
        k point in the irreducible Brillouin Zone (obtained
        by taking into account point symmetries and the time-reversal
        symmetry).
         <br />
         For response function calculations, one should
        select k points in the full Brillouin zone, if the wavevector
        of the perturbation does not vanish, or in a half of
        the Brillouin Zone if q=0. The code will automatically decrease
        the number of k points to the minimal set needed for
        each particular perturbation.
        </p>
        <p>
         If [[kptopt]] is negative,
        [[nkpt]] will be the sum of the number of points on
        the different lines of the band structure.
        For example,
        if [[kptopt]]=-3, one
        will have three segments; supposing
        [[ndivk]] is 10 12 17,
        the total number of k points of the circuit will be
        10+12+17+1(for the final point)=40.
        </p>
    varname: nkpt
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of K-PoinTs for GW corrections
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         [[nkptgw]] gives the number of k-points for which the [[GW]] calculation must be done.
        It is used to dimension [[kptgw]]
        </p>
    varname: nkptgw
    vartype: integer
- !variable
    characteristics: null
    commentdefault: ' the total number of k-point in the full Brillouin zone
        (TODO : provide the mathematical formulation)'
    commentdims: null
    defaultval: null
    definition: Number of K - Points for Fock exact exchange
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         [[nkpthf]] gives the number of k points used to sample the full Brillouin zone for the Fock exact exchange contribution.
        </p>
    varname: nkpthf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 4
    definition: Number of LINE minimisations
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives maximum number of line minimizations
        allowed in preconditioned conjugate gradient minimization
        for each band. The Default, 4, is fine.
         <br />
         Special cases, with degeneracies or near-degeneracies
        of levels at the Fermi energy may require a larger value of
        [[nline]] (5 or 6 ?)
        Line minimizations will be stopped anyway when improvement
        gets small. With the input variable [[nnsclo]],
        governs the convergence of the wavefunctions
        for fixed potential.
         <br />
         Note that [[nline]]=0 can be used to diagonalize the Hamiltonian
        matrix in the subspace spanned by the input wavefunctions.
        </p>
    varname: nline
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 4
    definition: Non LOCal ALGorithm
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
        Allows to choose the algorithm for non-local operator application.
        On super-scalar architectures, the default [[nloc_alg]]=4 is the best.
         <br />
         More detailed explanations:
         <br />
         <div style="margin-left: 40px;">
          - [[nloc_alg]]=2 : Should be efficient on vector machines. It is
        indeed the fastest algorithm for the NEC, but
        actual tests on Fujitsu machine did not gave better
        performances than the other options.
          <br />
          - [[nloc_alg]]=3 : same as [[nloc_alg]]==2, but the loop order is inverted.
          <br />
          - [[nloc_alg]]=4 : same as [[nloc_alg]]==3, but maximal use of registers
        has been coded. This should be especially efficient on
        scalar and super-scalar machines. This has been confirmed by tests.
          <br />
         </div>
         Note: internally, [[nloc_alg]] is stored in
         <i>
          nloalg(1)
         </i>
         . See also [[nloc_mem]] for the tuning of the memory used in the non-local operator application.
        </p>
    varname: nloc_alg
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usepaw]]==1': 2
        defaultval: 1
    definition: Non LOCal MEMOry
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
        Controls the memory use for the application of the non-local operator.
         <br />
         More detailed explanations:
         <br />
         <div style="margin-left: 40px;">
          - [[nloc_mem]]==1 : (k+G) vectors are not precomputed, in order to save memory space.
          <br />
          - [[nloc_mem]]==2 : (k+G) vectors are precomputed, once per k-point.
          <br />
          - [[nloc_mem]]==-1 or -2 : Negative values of [[nloc_mem]] correspond positive ones,
        where the phase precomputation has been suppressed, in order to save memory space, as an array
          <i>
           double precision :: ph3d(2,npw,[[natom]])
          </i>
          is saved (typically half the space needed
        for the wavefunctions at 1 k point - this corresponds
        to the silicon case). However, the computation of phases
        inside nonlop is somehow time-consuming.
          <br />
         </div>
         <br />
         Note: internally, sign([[nloc_mem]]) is stored in
         <i>
          nloalg(2)
         </i>
         and abs([[nloc_mem]])-1 is stored in
         <i>
          nloalg(3)
         </i>
         . See also [[nloc_alg]] for the algorithm for the non-local operator application.
        </p>
    varname: nloc_mem
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of nose masses
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of thermostats in the Martyna et al. chain of oscillators thermostats.
         The thermostat chains can be used either to perform Molecular Dynamics (MD) ([[ionmov]]=13) or to perform Path Integral Molecular Dynamics (PIMD) ([[imgmov]]=13). <br />
         The mass of these thermostats is given by [[qmass]].  <br />
        </p>
    varname: nnos
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Non-Self Consistent LOops
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Gives the maximum number of
        non-self-consistent loops of [[nline]] line minimisations,
        in the SCF case (when [[iscf]] &gt;0).  In the case [[iscf]] &lt;=0 ,
        the number of non-self-consistent loops is determined
        by [[nstep]].
         <br />
         The Default value of 0 -- for standard plane-wave calculations -- corresponds to make
        the two first fixed potential determinations
        of wavefunctions have 2 non-self consistent loops,
        and the next ones to have only 1 non-self consistent loop.
         <br />
         The Default value of 0 -- for wavelets calculations ([[usewvl]]=1) -- corresponds to make
        2 steps with 3 non-self consistent loops , 2 steps with 2 non-self consistent loops,
        then the next ones with 1 non-self consistent loop.
        </p>
    varname: nnsclo
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[usefock]]==1': 1
        defaultval: 0
    definition: Number of Non-Self Consistent LOops for Fock exact exchange
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Gives the maximum number of loops with non-self-consistent occupied states used to calculate Fock exact exchange,
        in the SCF case.
         <br />
         The Default value is 0 when [[usefock]] = 0.
        Default value is 1 when [[usefock]] = 1 and correspond to update occupied
        wavefunctions at each self-consistent loop.
        </p>
    varname: nnsclohf
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: (no use of the geometry builder)
    commentdims: null
    defaultval: 0
    definition: Number of OBJects
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the number of 'objects'
        to be used by the geometry builder in order to find the full
        set of atoms. At present, only one or two objects
        can be defined, identified as objects 'a' and 'b'.
         <br />
         Related variables for object 'a' are : [[objan]],
        [[objaat]],
        [[objarf]], [[objatr]],
        [[objaro]], [[objaax]]. Related variables
        for object 'b' are :
          [[objbn]]
         ,
          [[objbat]]
         ,
          [[objbrf]]
         ,
          [[objbtr]]
         ,
          [[objbro]]
         ,
          [[objbax]]
         .
         <br />
         More detailed explanation : when the geometry builder
        is used (i.e. when [[nobj]]==1 or [[nobj]]==2), the code
        will be given a primitive set of atoms, from which it
        will have to deduce the full set of atoms.
         <br />
         An object will be specified by the number of
        atoms it includes ([[objan]] or
          [[objbn]]
         ),
        and the list of these atoms ([[objaat]] or
          [[objbat]]
         ).
         <br />
         Examples of physical realisation of an object can be a molecule,
        or a group of atom to be repeated, or a part of a molecule
        to be rotated.
        The geometry builder can indeed repeat these objects ([[objarf]]
        or
          [[objbrf]]
         ), rotate them ([[objaro]] or
          [[objbro]]
         ) with respect
        to an axis ([[objaax]] or
          [[objbax]]
         ), and translate them
        ([[objatr]] or
          [[objbtr]]
         ).
        After having generated a geometry
        thanks to rotation, translation and repetition of objects,
        it is possible to remove some atoms, in order to create
        vacancies ([[vacnum]] and [[vaclst]]).
        The number of atoms in the primitive
        set, those that will be read from the input file, is
        specified by the variable [[natrd]]. It will be always smaller
        than the final number of atoms, given by the variable [[natom]].
        The code checks whether the primitive number of atoms
        plus those obtained by the repetition operation is
        coherent with the variable [[natom]], taking into
        account possible vacancies.
         <br />
         You should look
        at the other variables for more information.
        Go to [[objan]], for example.
         <br />
        </p>
    varname: nobj
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of OMEGA to evaluate the Spectral Function
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 and [[spmeth]]!=0'
    section: vargw
    text: |-
        <p>
         [[nomegasf]] defines the number of real frequencies used to describe the spectral function
        associated to the irreducible polarizability $\chi^{(0)}_{KS}$.
        The frequency mesh will cover the interval between 0 and the maximum (positive) transition
        energy between occupied and empty states.
        The delta function entering the expression defining the spectral function is approximated using two
        different methods according to the value of the [[spmeth]] input variable.
        </p>
        <p>
         It is important to notice that an accurate description of the imaginary part of $\chi^{(0)}_{KS}$
        requires an extremely dense frequency mesh. It should be kept in mind, however, that the memory required
        grows fast with the value of [[nomegasf]].
        </p>
    varname: nomegasf
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 12
    definition: Number of OMEGA(S) along the Imaginary axis
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4 and [[gwcalctyp]]==1'
    section: vargw
    text: |-
        <p>
         [[nomegasi]] defines the number of frequency points used to sample the self-energy along the
        imaginary axis. The frequency mesh is linear and covers the interval between OMEGASIMIN=0.01 Hartree and
        [[omegasimax]].
        </p>
    varname: nomegasi
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 9
    definition: Number of OMEGA to evaluate the Sigma Real axis Derivative
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         The number of real frequencies around the KS energy where the self-energy Sigma is evaluated.
        From these values, the derivative of Sigma at the KS energy is numerically estimated through linear interpolation.
        </p>
    varname: nomegasrd
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: NORMalize atomic PAW+U projector
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Defines whether the atomic wave function (used as projectors in PAW+U) should be renormalized to 1
        within PAW sphere.
         <ul>
          <li>
           [[normpawu]]=0 : leave projector
          </li>
          <li>
           [[normpawu]]=1 : renormalize
          </li>
         </ul>
        </p>
    varname: normpawu
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100000
    definition: NOSE thermostat INERTia factor
    dimensions: scalar
    excludes: null
    requires: '[[ionmov]]==8'
    section: varrlx
    text: |-
        <p>
        Give the inertia factor WT of the Nose-Hoover thermostat (when [[ionmov]]=8), in atomic units of weight*length2, that is (electron mass)*(Bohr)2. The equations of motion are :
        MI d2RI/dt2= FI - dX/dt MI dRI/dt
        and
        WT d2X/dt2= Sum(I) MI (dRI/dt)2 - 3NkBT
        where I represent each nucleus, MI is the mass of each nucleus (see [[amu]]), RI is the coordinate of each nucleus (see [[xcart]]), dX/dt is a dynamical friction coefficient, and T is the temperature of the thermostat (see [[mdtemp]]).
        </p>
    varname: noseinert
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1000000
    definition: Number of mpi Processors used for ScaLapacK calls
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==1 and [[paral_kgb]]==1 (Ground-state calculations
        with LOBPCG algorithm)'
    section: varpar
    text: |-
        <p>
         When using Scalapack (or any similar Matrix Algebra library), the efficiency of the eigenproblem resolution saturates as the number of CPU cores
        increases. It is better to use a smaller number of CPU cores for the LINALG calls.
         <br />
         This maximum number of cores can be set with [[np_slk]].
         <br />
         A large number for [[np_slk]] (i.e. 1000000) means that all cores are used for the
        Linear Algebra calls.
         <br />
         np_slk must divide the number of processors involved in diagonalizations ([[npband]]*[[npfft]]*[[npspinor]]).
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    varname: np_slk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors at the BAND level
    dimensions: scalar
    excludes: null
    requires: '[[paral_kgb]]==1'
    section: varpar
    text: |-
        <p>
         Relevant only for the band/FFT parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npband]] gives the number of processors among which the work load over the band level is shared.
        [[npband]], [[npfft]],
        [[npkpt]] and [[npspinor]]
        are combined to give the total number
        of processors (nproc) working on the band/FFT/k-point parallelisation.
         <br />
         See [[npfft]], [[npkpt]],
        [[npspinor]] and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.
        [[npband]] has to be a divisor or equal to [[nband]]
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    varname: npband
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors at the FFT level
    dimensions: scalar
    excludes: null
    requires: '[[paral_kgb]]==1'
    section: varpar
    text: |-
        <p>
         Relevant only for the band/FFT/k-point parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npfft]] gives the number of processors among
        which the work load over the FFT level is shared.
        [[npfft]], [[npkpt]],
        [[npband]] and [[npspinor]]
        are combined to give the total number
        of processors (nproc) working on the band/FFT/k-point parallelisation.
         <br />
         See [[npband]], [[npkpt]],
        [[npspinor]], and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.
        </p>
        <p>
         Note : [[ngfft]] is automatically adjusted to [[npfft]].
        If the number of processor is changed from a calculation to another one,
        [[npfft]] may change, and then [[ngfft]] also.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    varname: npfft
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors for Fock exact exchange
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         Relevant only for the k-point/fock parallelisation
        (option [[paral_kgb]] input variable).
         <br />
         [[nphf]] gives the number of processors among
        which the work load over the occupied states level is shared.
        [[nphf]] and [[npkpt]] are combined to give the total number
        of processors (nproc) working on the parallelisation.
         <br />
        </p>
        <p>
         Note : [[nphf]] should be a divisor or equal to the number of k-point times the number of bands for
        exact exchange ([[nkpthf]]*[[nbandhf]])
        in order to have the better load-balancing and efficiency.
         <br />
        </p>
    varname: nphf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors at the IMAGE level
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         Relevant only
        when sets of images are activated (see [[imgmov]]
        and [[nimage]] ).
         <br />
         [[npimage]] gives the number of processors among
        which the work load over the image level is shared. It is compatible with all other parallelization
        levels available for ground-state calculations.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
         <br ><br>
        <i>See [[paral_kgb]], [[npkpt]], [[npband]], [[npfft]]
        and [[npspinor]] for the additional information on the use of k-point/band/FFT parallelisation.
         </i>
        </p>
    varname: npimage
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors at the K-Point Level
    dimensions: scalar
    excludes: null
    requires: '[[paral_kgb]]==1'
    section: varpar
    text: |-
        <p>
         Relevant only for the band/FFT/k-point parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npkpt]] gives the number of processors among
        which the work load over the k-point/spin-component level is shared.
        [[npkpt]], [[npfft]], [[npband]] and
        [[npspinor]] are combined to give the total number
        of processors (nproc) working on the band/FFT/k-point parallelisation.
         <br />
         See [[npband]], [[npfft]],
        [[npspinor]] and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.
        </p>
        [[npkpt]] should be a divisor or equal to with the number of k-point/spin-components
        ([[nkpt]]*[[nsppol]])
        in order to have the better load-balancing and efficiency.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
        </p>
    varname: npkpt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors at the PERTurbation level
    dimensions: scalar
    excludes: null
    requires: '[[paral_rf]]==1'
    section: varpar
    text: |-
        <p>
         This parameter is used in connection to the parallelization over perturbations(see [[paral_rf]] ),
        for a linear response calculation.
        [[nppert]] gives the number of processors among which the work load over the perturbation level is shared.
        It can even be specified separately for each dataset.
        </p>
    varname: nppert
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[ntypat]]'
    definition: Number of PSeudoPotentials
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Usually, the number of pseudopotentials to be read is equal
        to the number of type of atoms. However,
        in the case an alchemical mixing of pseudopotential is to be used,
        often the number of pseudopotentials to be read will not equal the number of types of atoms.
        </p>
        <p>
         Alchemical pseudopotentials will be present
        when [[ntypalch]] is non-zero.
        See [[ntypalch]]
        to understand how
        to use alchemical potentials in ABINIT.
        The input variables
        ([[ntypalch]],
        [[algalch]],[[mixalch]])
        are active, and generate alchemical potentials from the available
        pseudopotentials. Also, the inner variables
        ([[ntyppure]],[[npspalch]])
        become active. See these input variables, especially
        [[mixalch]], to understand how
        to use alchemical potentials in ABINIT.
        </p>
    varname: npsp
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[npsp]]-[[ntyppure]]'
    definition: Number of PSeudoPotentials that are "ALCHemical"
    dimensions: scalar
    excludes: null
    requires: '[[ntypalch]]/=0'
    section: vargs
    text: |-
        <p>
         Gives the number of pseudopotentials that are used for alchemical mixing (when [[ntypalch]] is non-zero) :
        </p>
        <p>
         [[npspalch]]=[[npsp]]-[[ntyppure]]
        </p>
    varname: npspalch
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of Processors at the SPINOR level
    dimensions: scalar
    excludes: null
    requires: '[[paral_kgb]]==1'
    section: varpar
    text: |-
        <p>
         Can be 1 or 2 (if [[nspinor]]=2).
         <br />
         Relevant only for the band/FFT/k-point parallelisation
        (see the [[paral_kgb]] input variable).
         <br />
         [[npspinor]] gives the number of processors among
        which the work load over the spinorial components of wave-functions is shared.
        [[npspinor]], [[npfft]],
        [[npband]] and [[npkpt]]
        are combined to give the total number of processors (nproc)
        working on the band/FFT/k-point parallelisation.
        <br>Note: an optimal value for this parameter can be automatically found by using the [[autoparal]] input keyword.
         <br><br>
        <i>See [[npkpt]], [[npband]],
        [[npfft]], and
        [[paral_kgb]] for the additional information on the use of
        band/FFT/k-point parallelisation.</i>
         <br />
        </p>
    varname: npspinor
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 7
    definition: Number of PULAY ITerations for SC mixing
    dimensions: scalar
    excludes: null
    requires: '[[iscf]] in [7,17]'
    section: vardev
    text: |-
        <p>
         Gives the  number of previous iterations involved in Pulay mixing (mixing
        during electronic SC iterations).
        </p>
    varname: npulayit
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Particle VELocities
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         In the context of the electronic stopping power of impinging ion in matter,
        [[npvel]] sets the number of the ion velocities to be calculated via linear response.
         <br />
         When [[npvel]]=0, no stopping power calculation is performed.
         <br />
         The direction and the velocity maximum are set with the input variable [[pvelmax]].
        Note that the results are output for a Z=1 impinging ion, i.e. a proton.
        </p>
    varname: npvel
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of PlaneWaves for EPSilon (the dielectric matrix)
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         [[npweps]] determines the size of the planewave set used to represent the independent-particle
        susceptibility $\chi^{(0)}_{KS}$, the dielectric matrix $\epsilon$ and its inverse.
         <br />
        It is an internal variable, determined from [[ecuteps]].
        </p>
    varname: npweps
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of PlaneWaves in the KSS file
    dimensions: scalar
    excludes: null
    requires: null
    section: vargw
    text: |-
        <p>
         This input variable is used for the preparation of a [[GW]] calculation:
        the GS run (where [[optdriver]]=1 and
         <b>
          nbandkss
         </b>
         /=0) should be followed
        with a run where [[optdriver]]=3.
        Also, if [[nbandkss]]=0, no use of [[npwkss]].
        </p>
        <p>
         [[npwkss]] defines the number of planewave components of the Kohn-Sham states
        to build the Hamiltonian, in the routine outkss.F90, and so, the size of the matrix, the size of eigenvectors,
        and the number of available states, to be stored in the abo_KSS file.
        If it is set to 0, then, the planewave basis set defined by the usual Ground State input variable
        [[ecut]] is used to generate the superset of all planewaves used for all k-points.
        Note that this (large) planewave basis is the same for all k-points.
        </p>
        <p>
         Very important : for the time being, [[istwfk]] must be 1 for all the k-points.
        </p>
    varname: npwkss
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of PlaneWaves for SIGma eXchange
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         [[npwsigx]] determines the cut-off energy of the planewave set used to generate the
        exchange part of the self-energy operator.
         <br />
        It is an internal variable, determed from [[ecutsigx]].
        </p>
    varname: npwsigx
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of PlaneWaves for WaveFunctioNs
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         [[npwwfn]] is the size of the planewave set used to represent the wavefunctions
        in the formula that generates the independent-particle susceptibility $\chi^{(0)}_{KS}$.
        It is an internal variable, determined from [[ecutwfn]].
        </p>
    varname: npwwfn
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Q - POINTs
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Determines whether one q point
        must be read (See the variable [[qptn]]).
         <br />
         Can be either 0 or 1.
         <br />
         If 1 and used in ground-state calculation,
        a global shift of all the k-points is applied, to give
        calculation at k+q.
        In this case, the output wavefunction will be appended
        by _WFQ instead of _WFK (see the
         <a href="../../users/abinit_help.html">
          section 4
         </a>
         of abinit_help)
        Also, if 1 and a RF calculation is done, defines the
        wavevector of the perturbation.
        </p>
    varname: nqpt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of Q-PoinTs for the Dielectric Matrix
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         If [[nqptdm]] is equal to 0, the set of q-points for computing the dielectric matrix is
        determined automatically considering all the possible differences between the k-points contained
        in the _KSS file. When [[nqptdm]] is non-zero, the list of q points is read from [[qptdm]].
        This allows one to split the big calculation of all the dielectric matrices into smaller
        calculations that can be performed independently. The _SCR files generated in different runs
        can be merged thanks to the
         <b>
          Mrgscr
         </b>
         utility.
        If [[nqptdm]] is equal to -1, the code reports the list of q-points in the log file (YAML format) and then stops.
        </p>
    varname: nqptdm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 16
    definition: SCaling Function ORDER
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         This variable controls the order of used scaling functions when the Hartree potential is computed using the Poisson solver (see [[icoulomb]] imput variable). This variable is of seldom use since the default value is large enough. Nonetheless, possible values are 8, 14, 16, 20, 24, 30, 40, 50, 60, 100. Values greater than 20 are included in ABINIT for test purposes only.
        </p>
    varname: nscforder
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of SHIFTs for K point grids
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         This parameter
        gives the number of shifted grids
        to be used concurrently to generate the full grid of k points.
        It can be used with primitive grids defined either from
        [[ngkpt]]
        or
        [[kptrlatt]].
        The maximum allowed value of [[nshiftk]] is 8.
        The values of the shifts are given by [[shiftk]].
        </p>
    varname: nshiftk
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of SHIFTs for Q point grids
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This parameter
        gives the number of shifted grids
        to be used concurrently to generate the full grid of q points.
        It can be used with primitive grids defined either from
        [[ngqpt]]
        or
        [[qptrlatt]].
        The maximum allowed value of [[nshiftq]] is 8.
        The values of the shifts are given by [[shiftq]].
        </p>
    varname: nshiftq
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[nsppol]]'
    definition: Number of SPin-DENsity components
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If [[nspden]]=1, no spin-magnetization : the density matrix is
        diagonal, with same values spin-up and spin-down
        (compatible with [[nsppol]]=1 only,
        for both [[nspinor]]=1 or 2)
        </p>
        <p>
         If [[nspden]]=2, scalar magnetization (the axis is arbitrarily
        fixed in the z direction) : the density matrix is
        diagonal, with different values for spin-up and spin-down
        (compatible with [[nspinor]]=1,
        either with [[nsppol]]=2 -general
        collinear magnetization- or
        [[nsppol]]=1 -antiferromagnetism)
        </p>
        <p>
         If [[nspden]]=4, vector magnetization : the density matrix is full,
        with allowed x, y and z magnetization
        (useful only with [[nspinor]]=2 and
        [[nsppol]]=1, either
        because there is spin-orbit without time-reversal
        symmetry - and thus spontaneous magnetization, or
        with spin-orbit, if one allows for spontaneous
        non-collinear magnetism). Not yet available for response functions. Also note
        that, with [[nspden]]=4, time-reversal symmetry is not taken into account
        (at present ; this has to be checked) and thus [[kptopt]]
        has to be different from 1 or 2.
        </p>
        <p>
         The default ([[nspden]]=[[nsppol]])
        does not suit the case of vector magnetization.
        </p>
    varname: nspden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[pawspnorb]]==1': 2
        defaultval: 1
    definition: Number of SPINORial components of the wavefunctions
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If [[nspinor]]=1, usual case : scalar wavefunction
        (compatible with ([[nsppol]]=1,
        [[nspden]]=1) as well
        as ([[nsppol]]=2, [[nspden]]=2) )
        </p>
        <p>
         If [[nspinor]]=2, the wavefunction is a spinor
        (compatible with [[nsppol]]=1, with
        [[nspden]]=1 or 4,
        but not with [[nsppol]]=2)
        </p>
        <p>
         When [[nspinor]] is 2, the values of [[istwfk]]
        are automatically set to 1. Also, the number of bands, for each k-point,
        should be even.
        </p>
    varname: nspinor
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of SPin POLarization
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Give the number of INDEPENDENT
        spin polarisations, for which there are non-related wavefunctions. Can take the values
        1 or 2.
        </p>
        <p>
         If [[nsppol]]=1, one has an unpolarized calculation
        ([[nspinor]]=1,
        [[nspden]]=1) or
        an antiferromagnetic system
        ([[nspinor]]=1,
        [[nspden]]=2), or
        a calculation in which spin up and spin down cannot be disentangled
        ([[nspinor]]=2), that is, either
        non-collinear magnetism or presence of spin-orbit coupling,
        for which one needs spinor wavefunctions.
        </p>
        <p>
         If [[nsppol]]=2, one has a spin-polarized (collinear) calculation
        with separate and different wavefunctions for up and
        down spin electrons for each band and k point.
        Compatible only with [[nspinor]]=1,
        [[nspden]]=2. If [[nsppol]]=2, one usually uses a metallic value for [[occopt]], in order to let ABINIT find the magnetization.
        On the contrary, if [[occopt]]==1 is used, the user has to impose the magnetization, using [[spinmagntarget]],
        except for the case of a single isolated Hydrogen atom.
        </p>
        <p>
         In the present status of development,
        with [[nsppol]]=1,
        all values of [[ixc]] are allowed, while
        with [[nsppol]]=2,
        some values of [[ixc]] might not be allowed (e.g. 2, 3, 4, 5, 6, 20, 21, 22 are not allowed).
        </p>
        <p>
         See also the input variable [[nspden]]
        for the components of the density matrix with respect to
        the spin-polarization.
        </p>
    varname: nsppol
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: Number of (non-)self-consistent field STEPS
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the maximum number of cycles (or "iterations") in a SCF or non-SCF run.
         <br />
         Full convergence from random numbers is usually achieved in
        12-20 SCF iterations. Each can take from minutes to hours.
        In certain difficult cases, usually related to a small or
        zero bandgap or magnetism, convergence performance may be much worse.
        When the convergence tolerance [[tolwfr]] on the wavefunctions
        is satisfied, iterations will stop, so for well converged
        calculations you should set [[nstep]] to a value larger than
        you think will be needed for full convergence, e.g.
        if using 20 steps usually converges the system, set [[nstep]] to 30.
         <br />
         For non-self-consistent runs (
         [[iscf]] &lt; 0) nstep governs
        the number of cycles of convergence for the wavefunctions for a fixed density
        and Hamiltonian.
        </p>
        <p>
         NOTE that a choice of [[nstep]]=0 is permitted; this will
        either read wavefunctions from disk (with [[irdwfk]]=1
        or  [[irdwfq]]=1,
        or non-zero [[getwfk]]
        or [[getwfq]] in the case
        of multi-dataset) and
        compute the density, the total energy and stop, or else
        (with all of the above vanishing) will initialize
        randomly the wavefunctions and
        compute the resulting density and total energy.
        This is provided for testing purposes.
         <br />
         Also NOTE that [[nstep]]=0
        with [[irdwfk]]=1 will exactly give the same result as
        the previous run only if the latter is done with [[iscf]]&lt;10
        (potential mixing).
         <br />
         One can output the density by using [[prtden]].
         <br />
         The forces and stress tensor are computed with [[nstep]]=0.
        </p>
    varname: nstep
    vartype: integer
- !variable
    characteristics:
    - '[[SYMMETRY_FINDER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of SYMmetry operations
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives number of space group symmetries
        to be applied in this problem.  Symmetries will be input in
        array "[[symrel]]" and (nonsymmorphic) translations vectors
        will be input
        in array "[[tnons]]".  If there is no symmetry in the problem
        then set [[nsym]] to 1, because the identity is still a symmetry.
         <br />
         In case of a RF calculation, the code is able to use
        the symmetries of the system to decrease the number of
        perturbations to be calculated, and to decrease of the
        number of special k points to be used for the sampling of
        the Brillouin zone.
        After the response to the perturbations have been calculated,
        the symmetries are used to generate as many as
        possible elements of the 2DTE from those already
        computed.
        </p>
        <p>
         [[SYMMETRY_FINDER]] mode (Default mode).
        If [[nsym]] is 0, all the atomic coordinates must be
        explicitely given (one cannot use the geometry builder
        and the symmetrizer): the code will then find automatically
        the symmetry operations that leave the lattice and each
        atomic sublattice invariant. It also checks whether the
        cell is primitive (see [[chkprim]]).
         <br />
         Note that the tolerance on symmetric atomic positions and
        lattice is rather stringent :
        for a symmetry operation to be admitted,
        the lattice and atomic positions must map on themselves
        within 1.0e-8 .
        </p>
        <p>
         The user is allowed to set up systems with non-primitive unit cells (i.e.
        conventional FCC or BCC cells, or supercells without any distortion).
        In this case, pure translations will be identified as symmetries
        of the system by the symmetry finder.
        Then, the combined "pure translation + usual rotation and inversion" symmetry
        operations can be very numerous. For example, a conventional FCC cell
        has 192 symmetry operations, instead of the 48 ones of the primitive cell.
        A maximum limit of 384 symmetry operations is hard-coded. This
        corresponds to the maximum number of symmetry operations of a 2x2x2
        undistorted supercell. Going beyond
        that number will make the code stop very rapidly. If you want
        nevertheless, for testing purposes, to treat a larger number of symmetries,
        change the initialization of "msym" in the abinit.F90 main routine,
        then recompile the code.
        </p>
        <p>
         For [[GW]] calculation, the user might want to select only the symmetry operations whose
        non-symmorphic translation vector [[tnons]]
        is zero. This can be done with the help of the input variable
        [[symmorphi]]
        </p>
    varname: nsym
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of TIME steps
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the number of molecular dynamics time steps or
        Broyden
        structural optimization steps to be done if
        [[ionmov]]
         is non-zero.
         <br />
         Note that at the present
        the option [[ionmov]]=1 is initialized
        with four
        Runge-Kutta steps which costs some overhead in the startup.
        By contrast, the initialisation of
        other [[ionmov]] values is only one
        SCF call.
         <br />
         [[ntime]] is ignored if [[ionmov]]=0.
        </p>
    varname: ntime
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of TIME steps for IMAGE propagation
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the maximal number of molecular dynamics time steps or
        structural optimization steps to be done
        for the set of images, referred to as 'image-timesteps'. At each image-timestep,
        all the images are propagated simultaneously, each according to the algorithm
        determined by [[imgmov]] and the usual accompanying
        input variables, and then the next positions and velocities for each image
        are determined from the set of results obtained for all images.
        </p>
    varname: ntimimage
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of TYPe of atoms that are "ALCHemical"
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Used for the generation of alchemical pseudopotentials :
        when [[ntypalch]] is non-zero, alchemical mixing
        will be used.
        </p>
        <p>
         Among the [[ntypat]] types of atoms, the
        last [[ntypalch]] will be "alchemical" pseudoatoms, while only
        the first
         <b>
          ntyppure
         </b>
         will be uniquely associated with a pseudopotential
        (the
         <b>
          ntyppure
         </b>
         first of these, actually). The
        [[ntypalch]] types of alchemical
        pseudoatoms are to be made
        from the remaining [[npspalch]] pseudopotentials.
        </p>
        <p>
         In this case,
        the input variables
        [[algalch]],[[mixalch]]
        are active, and generate alchemical potentials from the available
        pseudopotentials.  See these input variables, especially
        [[mixalch]], to understand how
        to use alchemical potentials in ABINIT.
        </p>
    varname: ntypalch
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Number of TYPEs of atoms
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the number of types of atoms. E.g. for
        a homopolar system (e.g. pure Si) [[ntypat]] is 1.
         <br />
         The code tries to read the same number of pseudopotential files.
         <br />
         The first pseudopotential is assigned type number 1, and so
        on ...
        </p>
    varname: ntypat
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[ntypat]]-[[ntypalch]]'
    definition: Number of TYPe of atoms that are "PURe"
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives the number of type of atoms that are "pure" when alchemical mixing is used ([[ntypalch]] /= 0) :
        </p>
        <p>
         [[ntyppure]]=[[ntypat]]-[[ntypalch]]
        </p>
    varname: ntyppure
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: NUClear DIPole MOMents
    dimensions:
    - 3
    - '[[natom]]'
    excludes: null
    requires: '[[usepaw]] = 1; [[pawcpxocc]] = 2; [[kptopt]] > 2'
    section: vargs
    text: |-
        Places an array of nuclear magnetic dipole moments on the atomic positions, useful for computing the magnetization in the presence of nuclear dipoles and thus the chemical shielding by the converse method. The presence of these dipoles breaks time reversal symmetry and lowers the overall spatial symmetry.
    varname: nucdipmom
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Number of WaveFunctionS HISTory
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         In the wavelet basis set, the ground state is found by direct
        minimisation. The algorithm used can be either the steepest
        descent or the DIIS (Direct Inversion of Iteration
        Space). When [[nwfshist]] = 0, the steepest descent is used
        (
         <i>
          i.e.
         </i>
         there is no history storage of the previous
        iterations). If [[nwfshist]] is strictly positive, a DIIS
        is used. A typical value is 6. Using a DIIS increases the
        memory required by the program since N previous wavefunctions
        are stored during the electronic minimisation.
        </p>
    varname: nwfshist
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Number of Z reduced coordinates that define the spatial CHEMical POTential
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        Defines the number of z reduced coordinates that defines the spatially varying chemical potential. See the input variable [[chempot]], of which [[nzchempot]] is the second dimension.
    varname: nzchempot
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: 'OBJect A : list of AToms, OBJect B : list of AToms'
    dimensions:
    - '[[objan]]'
    excludes: null
    requires: |
        '[[nobj]]==1'
    section: vargeo
    text: |-
        <p>
        Gives the list of atoms in object a. This list is specified by giving, for each atom, its index in the list of coordinates ([[xred]], [[xangst]] or [[xcart]]), that also corresponds to a type of atom (given by the array type).
        These objects can be thought as molecules, or groups
        of atoms, or parts of molecules, to be repeated,
        rotated and translated to generate the full set
        of atoms.
        <br />
         Look at [[objarf]] for further explanations.
        <br />
        </p>
    varname: objaat
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: |-
        [[objaax]] must be provided if ([[nobj]]==1 and one component of [[objaro]] != 0). Moreover,
        [[objaax]] AND [[objbax]] must be provided if ( [[nobj]] == 2 and one component of [[objbro]] != 0 ).
    commentdims: null
    defaultval: null
    definition: 'OBJect A : AXis, OBJect B : AXis'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives, for each object, the cartesian coordinates of
        two points (first point :  [[objaax]](1:3)
        second point : [[objaax]](4:6).
         By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The two points define an axis of rotation
        of the corresponding object.
         <br />
         Note that the rotation of
        the object is done BEFORE the object is translated.
         <br />
         The sign of the rotation angle is positive if the
        object is to be rotated clockwise when looking to it
        along the axis, from point 1 (coordinates 1:3)
        toward point 2 (coordinates 4:6).
         <br />
        </p>
    varname: objaax
    vartype: real
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: |4-
         [[objan]] MUST be provided if [[nobj]]==1.
         [[objan]] and [[objbn]] MUST be provided if [[nobj]]==2.
    commentdims: null
    defaultval: null
    definition: 'OBJect A : Number of atoms, OBJect B : Number of atoms'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the number of atoms in object a. The list of atoms is given by the
        variables [[objaat]].
         <br />
        </p>
    varname: objan
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    - 1
    definition: 'OBJect A : Repetition Factors, OBJect B : Repetition Factors'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives three repetition factors of the objects a.
         <br />
         This gives the opportunity to generate a three-dimensional
        set of repeated objects, although a simple one-dimensional
        repetition will be easily obtained through the specification of
         <br />
         'nrep' 1 1
        <br>
        where 'nrep' is the 1D repetition factor.
         <br />
         The initial rotation and translation of the object,
        as well as the increment of rotation or translation
        from one object to the next are specified by
        the variables [[objaro]] and [[objatr]], for object a,
         <br />
         Note that the geometry builder will generate the full set
        of atoms from the primitive set of atoms using the
        following order : it will process each atom in the
        primitive list one by one, determine whether it belongs
        to either object a or object b, and then repeat it
        taking into account the proper rotation and translation,
        with the fastest varying repetition factor being the first,
        then the second, then the third.
         <br />
         In the final list of atoms, one will first
        find the atoms generated from atom 1 in the primitive list,
        then those generated from atom 2 in the primitive list, and
        so on.
         <br />
         If the geometry builder is only used to rotate
        or translate an object, without repeating it,
        simply use 1 1 1, which is also the Default value.
         <br />
        </p>
    varname: objarf
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: (no rotation)
    commentdims: null
    defaultval: !multiplevalue
        number: 4
        value: 0.0d0
    definition: 'OBJect A : ROtations, OBJect B : ROtations'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Give, for each object, the angles of rotation in degrees
        to be applied to the corresponding object.
         <br />
         The rotation is applied before the translation,
        and the axis is defined by the variables [[objaax]] and [[objbax]].
        See the latter variables for the definition of the sign
        of the rotation.
         <br />
         The first component [[objaro]](1) and
         <b>
          objbro
         </b>
         (1) gives
        the angle of rotation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of rotation angle
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules with
        different rotation angles.
         <br />
        </p>
    varname: objaro
    vartype: real
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: (no translation)
    commentdims: null
    defaultval: !multiplevalue
        number: 12
        value: 0.0d0
    definition: 'OBJect A : TRanslations, OBJect B : TRanslations'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Give, for each object, the vectors of translations,
        in cartesian coordinates,
        to be applied to the corresponding object.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The translation is applied after the rotation.
         <br />
         The first vector [[objatr]](3,1) and [[objbtr]](3,1) gives
        the translation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of translation
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules.
         <br />
         In general, when the objects are repeated, a translation
        vector must be given, since otherwise, the repeated objects
        pack in the same region of space. As an exception, one can
        have a set of molecules regularly spaced on a circle, in
        which case, only rotations are needed.
         <br />
         Not present in the dtset array (no internal).
        </p>
    varname: objatr
    vartype: real
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: 'OBJect A : list of AToms, OBJect B : list of AToms'
    dimensions: null
    excludes: null
    requires: '[[nobj]]==2'
    section: vargeo
    text: |-
        <p>
         Gives the list of atoms in object b. This list is specified
        by giving, for each atom, its index in the list
        of coordinates ([[xred]], [[xangst]]
        or [[xcart]]), that also
        corresponds to a type of atom (given by the array type).
        These objects can be thought as molecules, or groups
        of atoms, or parts of molecules, to be repeated,
        rotated and translated to generate the full set
        of atoms.
         <br />
         Look at [[objbrf]] for further explanations.
         <br />
        </p>
    varname: objbat
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: |-
        [[objbax]] must be provided if ([[nobj]]==1 and one component of [[objaro]] != 0). Moreover,
        [[objaax]] AND [[objbax]] must be provided if ( [[nobj]] == 2 and one component of [[objbro]] != 0 ).
    commentdims: null
    defaultval: null
    definition: 'OBJect A : AXis, OBJect B : AXis'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives, for each object, the cartesian coordinates of
        two points (first point :  [[objbax]](1:3)
        second point : [[objbax]](4:6).
         By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The two points define an axis of rotation
        of the corresponding object.
         <br />
         Note that the rotation of
        the object is done BEFORE the object is translated.
         <br />
         The sign of the rotation angle is positive if the
        object is to be rotated clockwise when looking to it
        along the axis, from point 1 (coordinates 1:3)
        toward point 2 (coordinates 4:6).
         <br />
        </p>
    varname: objbax
    vartype: real
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: ' [[objan]] and [[objbn]] MUST be provided if [[nobj]]==2.'
    commentdims: null
    defaultval: null
    definition: 'OBJect A : Number of atoms, OBJect B : Number of atoms'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the number of atoms in either
        object b. The list of atoms is given by the
        variables [[objbat]].
         <br />
        </p>
    varname: objbn
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    - 1
    definition: 'OBJect A : Repetition Factors, OBJect B : Repetition Factors'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives three repetition factors of the objects a or b.
         <br />
         This gives the opportunity to generate a three-dimensional
        set of repeated objects, although a simple one-dimensional
        repetition will be easily obtained through the specification of
         <br />
         nrep 1 1  &lt;r&gt;
        where nrep is the 1D repetition factor.
         <br />
         The initial rotation and translation of the object,
        as well as the increment of rotation or translation
        from one object to the next are specified by
        the variables [[objbro]] and [[objbtr]], for object b.
         <br />
         Note that the geometry builder will generate the full set
        of atoms from the primitive set of atoms using the
        following order : it will process each atom in the
        primitive list one by one, determine whether it belongs
        to either object a or object b, and then repeat it
        taking into account the proper rotation and translation,
        with the fastest varying repetition factor being the first,
        then the second, then the third.
         <br />
         In the final list of atoms, one will first
        find the atoms generated from atom 1 in the primitive list,
        then those generated from atom 2 in the primitive list, and
        so on.
         <br />
         If the geometry builder is only used to rotate
        or translate an object, without repeating it,
        simply use 1 1 1, which is also the Default value.
         <br />
        </p>
    varname: objbrf
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: (no rotation)
    commentdims: null
    defaultval: !multiplevalue
        number: 4
        value: 0.0d0
    definition: 'OBJect A : ROtations, OBJect B : ROtations'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Give, for each object, the angles of rotation in degrees
        to be applied to the corresponding object.
         <br />
         The rotation is applied before the translation,
        and the axis is defined by the variables [[objaax]] and [[objbax]].
        See the latter variables for the definition of the sign
        of the rotation.
         <br />
         The first component [[objaro]](1) and
         <b>
          objbro
         </b>
         (1) gives
        the angle of rotation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of rotation angle
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules with
        different rotation angles.
         <br />
        </p>
    varname: objbro
    vartype: real
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: (no translation)
    commentdims: null
    defaultval: !multiplevalue
        number: 12
        value: 0.0d0
    definition: 'OBJect A : TRanslations, OBJect B : TRanslations'
    dimensions: null
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Give, for each object, the vectors of translations,
        in cartesian coordinates,
        to be applied to the corresponding object.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since these variables have the
        '[[LENGTH]]' characteristics.
         <br />
         The translation is applied after the rotation.
         <br />
         The first vector [[objatr]](3,1) and [[objbtr]](3,1) gives
        the translation to be applied to the first
        instance of the object. The second, third or fourth
        component (resp.) gives the increment of translation
        from one instance to the next instance, defined
        by the first, second or third repetition factor (resp.) .
        This allows to generate 3D arrays of molecules.
         <br />
         In general, when the objects are repeated, a translation
        vector must be given, since otherwise, the repeated objects
        pack in the same region of space. As an exception, one can
        have a set of molecules regularly spaced on a circle, in
        which case, only rotations are needed.
         <br />
        </p>
    varname: objbtr
    vartype: real
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: OCCupation numbers
    dimensions:
    - '[[nband]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives occupation numbers for all
        bands in the problem. Needed if [[occopt]]==0 or
        [[occopt]]==2.
        Ignored otherwise. Also ignored when [[iscf]]=-2.
         <br />
         Typical band occupancy is either
        2 or 0, but can be 1 for half-occupied band or other
        choices in special circumstances.
         <br />
         If [[occopt]] is not 2,
        then the occupancies must be the same for each k point.
         <br />
         If [[occopt]]=2, then the band occupancies must be
        provided explicitly for each band, EACH k POINT,
        and EACH SPIN-POLARIZATION, in an
        array which runs over all bands, k points,
        and spin-polarizations.
         <br />
         The order of entries in the array would correspond to
        all bands at the first k point (spin up), then all bands at the
        second k point (spin up), etc, then all k-points spin down.
         <br />
         The total number of array elements
        which must be provided is
         <br />
         ( [[nband]](1)+[[nband]](2)+...+
        [[nband]]([[nkpt]]) ) *
        [[nsppol]] .
         <br />
         The occupation numbers evolve only for metallic occupations,
        that is, [[occopt]] &ge; 3 .
        </p>
    varname: occ
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: OCCupation OPTion
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Controls how input
        parameters [[nband]], [[occ]],
        and [[wtk]] are handled.
         <ul>
          <li>
           [[occopt]]=0:
           <br />
           All k points have the same number of bands
        and the same occupancies of bands.  [[nband]] is given as a
        single number, and [[occ]]([[nband]])
        is an array of [[nband]]
        elements, read in by the code.
           <br />
           The k point weights in array [[wtk]]([[nkpt]]) are
        automatically normalized by the code to add to 1.
          </li>
          <li>
           [[occopt]]=1:
           <br />
           Same as [[occopt]]=0, except that the array [[occ]] is
        automatically generated by the code, to give a semiconductor.
           <br />
           An error occurs when filling cannot be done with
        occupation numbers equal to 2 or 0 in each k-point (non-spin-polarized case),
        or with occupation numbers equal to 1 or 0 in each k-point (spin-polarized case).
        If [[nsppol]]=2  and [[occopt]]==1 is used, the user has to impose the magnetization, using [[spinmagntarget]],
        except for the case of a single isolated Hydrogen atom.
          </li>
          <li>
           [[occopt]]=2:
           <br />
           k points may optionally have different numbers of
        bands and different occupancies.  [[nband]]([[nkpt]]*[[nsppol]]) is given
        explicitly as an array of [[nkpt]]*[[nsppol]] elements.
        [[occ]]() is given explicitly for all bands at each k point,
        and eventually for each spin --
        the total number of elements is the sum of [[nband]](ikpt)
        over all k points and spins. The k point weights [[wtk]]
        ([[nkpt]]) are
        NOT automatically normalized under this option.
          </li>
          <li>
           [[occopt]]=3, 4, 5, 6 and 7
           <br />
           Metallic occupation of levels, using different occupation
        schemes (see below). The corresponding thermal
        broadening, or cold smearing, is defined by
        the input variable [[tsmear]] (see below : the variable
        xx is the energy in Ha, divided by [[tsmear]])
           <br />
           Like for [[occopt]]=1, the variable [[occ]] is not read
           <br />
           All k points have the same number of bands,
        [[nband]] is given as a single number, read by the code.
           <br />
           The k point weights in array [[wtk]]([[nkpt]]) are
        automatically normalized by the code to add to 1.
          </li>
          <ul>
           <li>
            [[occopt]]=3:
            <br />
            Fermi-Dirac smearing (finite-temperature metal)
        Smeared delta function : 0.25d0/(cosh(xx/2.0d0)**2)
           </li>
           <li>
            [[occopt]]=4:
            <br />
            "Cold smearing" of N. Marzari (see his thesis work),
        with a=-.5634 (minimization of the bump)
            <br />
            Smeared delta function :
            <br />
            exp(-xx
            <sup>
             2
            </sup>
            )/sqrt(pi) * (1.5d0+xx*(-a*1.5d0+xx*(-1.0d0+a*xx)))
           </li>
           <li>
            [[occopt]]=5:
            <br />
            "Cold smearing" of N. Marzari (see his thesis work),
        with a=-.8165 (monotonic function in the tail)
            <br />
            Same smeared delta function as [[occopt]]=4, with different a.
           </li>
           <li>
            [[occopt]]=6:
            <br />
            Smearing of Methfessel and Paxton (PRB40,3616(1989))
        with Hermite polynomial of degree 2, corresponding
        to "Cold smearing" of N. Marzari with a=0
        (so, same smeared delta function as [[occopt]]=4, with different a).
           </li>
           <li>
            [[occopt]]=7:
            <br />
            Gaussian smearing, corresponding to the 0 order
        Hermite polynomial of Methfessel and Paxton.
            <br />
            Smeared delta function : 1.0d0*exp(-xx**2)/sqrt(pi)
           </li>
           <li>
            [[occopt]]=8:
            <br />
            Uniform smearing (the delta function is replaced by a constant function of value one
        over ]-1/2,1/2[ (with one-half value at the boundaries). Used for testing purposes only.
           </li>
          </ul>
         </ul>
         WARNING : one can use metallic occupation of levels in the
        case of a molecule, in order to avoid any problem with
        degenerate levels. However, it is advised NOT to use
        [[occopt]]=6 (and to a lesser extent [[occopt]]=4 and 5),
        since the associated number of electron
        versus the Fermi energy is NOT guaranteed to be
        a monotonic function. For true metals, AND a sufficiently
        dense sampling of the Brillouin zone, this should not happen,
        but be cautious ! As an indication of this problem,
        a small variation of input parameters might lead to
        a jump of total energy, because there might be two or even
        three possible values of the Fermi energy, and the
        bissection algorithm find one or the other.
        </p>
    varname: occopt
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 50
    definition: 'OMEGA to evaluate Sigma along the Imaginary axis D: MAXimal
        value'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4 and [[gwcalctyp]]==1'
    section: vargw
    text: |-
        <p>
         [[omegasimax]] defines the maximum frequency along the imaginary the axis.
        In conjunction with [[nomegasi]],
        [[omegasimax]] uniquely defines the linear mesh employed to sample the self-energy along the imaginary axis.
        </p>
    varname: omegasimax
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 1.0
    definition: 'OMEGA to evaluate the Sigma Real axis Derivative : MAXimal
        value'
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         The maximum distance from the KS energy where to evaluate Sigma. Sigma is evaluated at
        [KS_energy - [[omegasrdmax]], KS_energy + [[omegasrdmax]]] sampled [[nomegasrd]] times.
        </p>
    varname: omegasrdmax
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: OPTimize the CELL shape and dimensions
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        Allows to optimize the unit cell shape and dimensions, when [[ionmov]]>=2 or 3.  The configuration for which the stress almost vanishes
        is iteratively determined, by using the same algorithms as for the nuclei positions. Will eventually modify [[acell]]
        and/or [[rprim]].  The ionic positions are ALWAYS updated, according to the forces.
        A target stress tensor might be defined, see [[strtarget]].
        <ul>
          <li>[[optcell]]=0 : modify nuclear positions, since [[ionmov]]=2 or 3, but no cell shape and dimension optimisation.</li>
          <li>[[optcell]]=1 : optimisation of volume only (do not modify [[rprim]], and allow an homogeneous dilatation of the three components of [[acell]])</li>
          <li>[[optcell]]=2 : full optimization of cell geometry (modify [[acell]] and [[rprim]]
               - normalize the vectors of [[rprim]] to generate the [[acell]]).
               This is the usual mode for cell shape and volume optimization. It takes into account the symmetry of the system,
               so that only the effectively relevant degrees of freedom are optimized.</li>
          <li>[[optcell]]=3 : constant-volume optimization of cell geometry (modify [[acell]] and [[rprim]] under constraint
               - normalize the vectors of [[rprim]] to generate the [[acell]])</li>
          <li>[[optcell]]=4, 5 or 6 : optimize [[acell]](1), [[acell]](2), or [[acell]](3), respectively
               (only works if the two other vectors are orthogonal to the optimized one, the latter being along its cartesian axis).</li>
          <li>[[optcell]]=7, 8 or 9 : optimize the cell geometry while keeping the first, second or third vector unchanged
               (only works if the two other vectors are orthogonal to the one left unchanged, the latter being along its cartesian axis).</li>
        </ul>
        A few details require attention when performing unit cell optimisation :
        <ul>
          <li> one has to get rid of the discontinuities due to discrete changes of plane wave number with cell size, by using a suitable value of [[ecutsm]];</li>
          <li> one has to allow for the possibility of a larger sphere of plane waves, by using [[dilatmx]];</li>
          <li> one might have to adjust the scale of stresses to the scale of forces, by using [[strfact]].</li>
          <li> if all the reduced coordinates of atoms are fixed by symmetry, one cannot use [[toldff]] to stop the SCF cycle.
              (Suggestion : use [[toldfe]] with a small value, like 1.0d-10)</li>
        </ul>
        It is STRONGLY suggested first to optimize the ionic positions without cell shape and size optimization ([[optcell]]=0), then start the cell shape and size optimization from the cell with relaxed ionic positions.
        Presently (v3.1), one cannot restart ([[restartxf]])
        a calculation with a non-zero [[optcell]] value from the
        (x,f) history of another run with a different non-zero [[optcell]]
        value. There
        are still a few problems at that level.
    varname: optcell
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: OPTions for the DRIVER
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         For each dataset, choose
        the task to be done, at the level of the "driver" routine.
        </p>
        <p>
         The choice is among :
         <br />
         [[optdriver]]=0 : ground-state calculation (GS), routine "gstate"
         <br />
         [[optdriver]]=1 : response-function calculation (RF), routine "respfn"
         <br />
         [[optdriver]]=2 : susceptibility calculation (SUS), routine "suscep"
         <br />
         [[optdriver]]=3 : susceptibility and dielectric matrix calculation (SCR), routine "screening"
         <br />
         (see the input variables [[ecutwfn]],
        [[ecuteps]],
        [[ppmfrq]],
        [[getwfk]],
        as well as [[nbandkss]] and [[nband]])
         <br />
         [[optdriver]]=4 : self-energy calculation (SIG), routine "sigma"
         <br />
         [[optdriver]]=5 : non-linear response functions (NONLINEAR), using the 2n+1 theorem, routine "nonlinear"
        <br />
        [[optdriver]] =7: electron-phonon coupling (EPH)
         <br />
        [[optdriver]] =66: GW using Lanczos-Sternheimer, see input variables whose name start with gwls_* .
         <br />
         [[optdriver]]=99 : Bethe-Salpeter calculation (BSE), routine "bethe_salpeter"
        </p>
        <p>
         If one of [[rfphon]], [[rfddk]],
        [[rfelfd]],
        or [[rfstrs]] is non-zero, while [[optdriver]]
        is not defined in the input file, ABINIT will set [[optdriver]] to 1
        automatically. These input variables ([[rfphon]],
        [[rfddk]], [[rfelfd]],
        and [[rfstrs]]) must be
        zero if [[optdriver]] is not set to 1.
        </p>
    varname: optdriver
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[toldff]] or [[tolrff]] != 0': 1
        defaultval: 2
    definition: OPTions for the calculation of FORCES
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Allows to choose options for the calculation of forces.
         <ul>
          <li>
           [[optforces]]=0 : the forces are set to zero, and many steps of the
        computation of forces are skipped
          </li>
          <li>
           [[optforces]]=1 : calculation of forces at each SCF iteration, allowing
        to use forces as criterion to stop the SCF cycles
          </li>
          <li>
           [[optforces]]=2 : calculation of forces at the end of the SCF iterations
        (like the stresses)
          </li>
         </ul>
        </p>
    varname: optforces
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: OPTion for the calculation of Non-Linear eXchange-Correlation Core Correction
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Allows to choose options for the calculation of non-linear XC correction.
        At present, only relevant for the FHI type of pseudopotentials, with pspcod=6 .
         <ul>
          <li>
           [[optnlxccc]]=1 : uses the old psp6cc.f routine, with inconsistent treatment of real-space derivatives of the core function (computed in this routine, while splined in the other parts of the code)
          </li>
          <li>
           [[optnlxccc]]=2 : consistent calculation derivatives, in the psp6cc_dhr.f routine from DHamann.
          </li>
         </ul>
        </p>
    varname: optnlxccc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: OPTion for the computation of STRess
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If set to 1, the computation of stresses is done,
        in the SCF case
        (under the conditions [[iscf]] &gt; 0 , [[prtstm]]==0 ,
        [[positron]]==0,
        and either  [[nstep]] &gt;0 , or
        [[usepaw]]==0 or [[irdwfk]]==1).
         <br />
         Otherwise, to save CPU time, if no optimization of the cell is required,
        one can skip the computation of stresses. The CPU time saving might be interesting
        for some PAW calculations.
        </p>
    varname: optstress
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[wfoptalg]] >= 10 ': -2
        defaultval: 2
    definition: ORThogonalisation ALGorithm
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Allows to choose the algorithm
        for orthogonalisation.
         <br />
         Positive or zero values make two projections per
        line minimisation, one before the preconditioning, one
        after. This is the clean application of the band-by-band
        CG gradient for finding eigenfunctions.
         <br />
         Negative values make only one projection per line minimisation.
         <br />
         The orthogonalisation step is twice faster, but the
        convergence is less good. This actually calls to
        a better understanding of this effect.
         <br />
         [[ortalg]]=0, 1 or -1 is the conventional coding.
         <br />
         [[ortalg]]=2 or -2 try to make better use of existing registers
        on the particular machine one is running.
         <br />
         More demanding use of registers
        is provided by [[ortalg]]=3 or -3, and so on.
         <br />
         The maximal value is presently 4 and -4.
         <br />
         Tests have shown that [[ortalg]]=2 or -2 is suitable for
        use on the available platforms.
        </p>
    varname: ortalg
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAPI OPTion
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <a href="http://icl.cs.utk.edu/papi/index.html">
          PAPI
         </a>
         aims to
        provide the tool designer and application engineer with a
        consistent interface and methodology for use of the
        performance counter hardware found in most major
        microprocessors. PAPI enables software engineers to see, in
        near real time, the relation between software performance and
        processor events.
         <br />
         This option can be used only when ABINIT has been compiled with the
         <code>
          --enable-papi
         </code>
         configure option.
         <br />
         If [[papiopt]]=1, then PAPI counters are used instead of
        the usual time() routine. All the timing output of ABINIT is
        then done with PAPI values. The measurements are more accurate and
        give also access to the flops of the calculation.
        </p>
    varname: papiopt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: activate PARALelization over (paw) ATOMic sites
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         Relevant only for PAW calculations.
         <br />
         This keyword controls the parallel distribution of memory over atomic sites. Calculations are
        also distributed using the "kpt-band" communicator.
          Compatible with ground-state calculations and response function calculations
         <br />
        </p>
    varname: paral_atom
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: activate PARALelization over K-point, G-vectors and Bands
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         <b>
          If paral_kgb is not explicitely put in the input file
         </b>
         ,
        ABINIT automatically detects if the job has been sent in sequential or in parallel.
        In this last case, it detects the number of processors on which the job has been sent and calculates values of
        [[npkpt]], [[npfft]],
        [[npband]], [[bandpp]] , [[npimage]] and [[npspinor]] that are compatible with the number of processors. It then set
        paral_kgb to 0 or 1 (see hereunder) and launches the job.
        </p>
        <b>
         If paral_kgb=0
        </b>
        ,
        the parallelization over k-points only is activated. In this case,
        [[npkpt]], [[npspinor]], [[npfft]] and
        [[npband]] are ignored. Require compilation option --enable-mpi="yes".
        <p>
         <b>
          If paral_kgb=1
         </b>
         ,
        the parallelization over bands, FFTs, and k-point/spin-components is activated
        (see [[npkpt]], [[npfft]]
        [[npband]] and eventually [[npspinor]]). With this parallelization, the work load is split over
        four levels of parallelization (three level of parallelisation (kpt-band-fft )+ spin) The different communications almost occur
        along one dimension only. Require compilation option --enable-mpi="yes".
        </p>
        HOWTO fix the number of processors along one level of parallelisation:
        <br />
        At first, try to parallelise over the k point and spin
        (see [[npkpt]],[[npspinor]]).
        Otherwise, for unpolarized calculation at the gamma point, parallelise over the
        two other levels: the band and FFT ones. For nproc&lt;=50,
        the best speed-up is achieved for
        [[npband]]=nproc and
        [[npfft]]=1 (which is not yet the default).
        For nproc&gt;=50, the best speed-up is achieved for
        [[npband]] &gt;=4*[[npfft]].
        <p>
         For additional information,
        download F. Bottin presentation at the
         <a href="http://www.abinit.org/community/events/program3rd">
          ABINIT workshop 2007
         </a>
        </p>
        <p>
         Suggested acknowledgments :
         <br />
         F. Bottin, S. Leroux, A. Knyazev and G. Zerah,
         <i>
          Large scale ab initio calculations based on three levels of parallelization
         </i>
         ,
        Comput. Mat. Science
         <b>
          42
         </b>
         , 329 (2008),
        also available on arXiv, http://arxiv.org/abs/0707.3405 .
        </p>
        <p>
         If the total number of processors used is compatible with the four levels of parallelization, the values for [[npkpt]], [[npspinor]], [[npfft]], [[npband]] and [[bandpp]] will be filled automatically, although the repartition may not be optimal. To optimize the repartition use:
        </p>
        <p>
         <b>
          If paral_kgb=1
         </b>
         and
         <b>
          max_ncpus = n /= 0
         </b>
         ABINIT will test automatically if all the processor numbers between 2 and n are convenient
        for a parallel calculation and print the possible values in the log file.
        A weight is attributed to each possible processors repartition. It is adviced to select a processor repartition for which the weight is high
        (as closed to the number of processors as possible). The code will then stop after the printing.
        This test can be done as well with a sequential as with a parallel version of the code.
        The user can then choose the adequate number of processor on which he can run his job.
        He must put again paral_kgb=1 in the input file and put the corresponding values for
        [[npkpt]], [[npfft]], [[npband]],[[bandpp]] and eventually [[npspinor]] in the input file.
        </p>
    varname: paral_kgb
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: activate PARALlelization over Response Function perturbations
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         This parameter activates the parallelization over perturbations which can be used during
        RF-Calculation. It is possible to use this type of parallelization in combination to the
        parallelization over k-points.
        </p>
        <p>
         Currently total energies calculated by groups, where the master process is not in, are saved
        in .status_LOGxxxx files.
        </p>
        <p>
         If [[paral_rf]] is set to -1, the code reports the list of irreducible perturbations for the specified
        q-point in the log file (YAML format) and then stops.
        </p>
        <p> [[paral_rf]] can be specified separately for each dataset. </p>
    varname: paral_rf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        ? '[[optdriver]]==0 and [[ionmov]]<6 and [[pawspnorb]]==1 and [[iscf]]>=10
            and ([[kptopt]] !=1 or [[kptopt]]!=2) and [[usepaw]]==1'
        : 2
        defaultval: 1
    definition: PAW - use ComPleX rhoij OCCupancies
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
        The only possible values for [[pawcpxocc]] are 1 or 2.
         <br />
        When
         <b>
          [[pawcpxocc]]==1
         </b>
         , "direct" decomposition of total energy cannot be printed out.
         <br />
         When
         <b>
          [[pawcpxocc]]==2
         </b>
         , PAW augmentation occupancies are treated as COMPLEX; else they are considered as REAL.
         <br />
         This is needed when time-reversal symmetry is broken (typically when spin-orbit coupling is activated).
         <br />
         <br />
         Note for ground-state calculations ([[optdriver]]=0):
         <br />
         The imaginary part of PAW augmentation occupancies is only used for the computation of the total energy by "direct scheme";
        this is only necessary when SCF mixing on potential is chosen ([[iscf]]&lt;10).
         <br />
         When SCF mixing on density is chosen ([[iscf]]&gt;=10), the "direct" decomposition
        of energy is only printed out without being used. It is thus possible to use [[pawcpxocc]]=1 in the latter case.
         <br />
         In order to save CPU time, when molecular dynamics is selected ([[ionmov]]&gt;=6) and
        SCF mixing done on density ([[iscf]]&gt;=10), [[pawcpxocc]]=2 is (by default) set to
         <b>
          1
         </b>
        </p>
    varname: pawcpxocc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAW - add CROSS term in oscillator strengths
    dimensions: scalar
    excludes: null
    requires: ([[optdriver]]==3 or [[optdriver]]==4) and [[usepaw]]==1
    section: varpaw
    text: |-
        <p>
         When
         <b>
          pawcross=1
         </b>
         , the overlap between the plane-wave part of one band and the on-site part of an other
        is taken into account in the computation of the oscillator strengths. Hence, the completeness of the on-site basis is no longer assumed.
        </p>
    varname: pawcross
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: pawecutdg MUST be specified for PAW calculations.
    commentdims: null
    defaultval: -1
    definition: PAW - Energy CUToff for the Double Grid
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Define the energy cut-off for the fine FFT grid
        (the "double grid", that allows to transfer data from the normal, coarse, FFT grid to the
        spherical grid around each atom).
         <br />
         [[pawecutdg]] must be larger or equal to
        [[ecut]]. If it is equal to it, then no fine
        grid is used. The results are not very accurate, but the computations
        proceed quite fast.
         <br />
         For typical PAW computations, where [[ecut]]
        is on the order of 15 Ha, [[pawecutdg]] must be tested according to what you want to do. For calculations that do not require a high accuracy (molecular dynamics for instance) a value of 20 Ha is enough. For calculations that require a high accuracy (response fonctions for instance) it should be on the order of 30 Ha.
        Choosing a larger value should not increase the accuracy, but does not slow down the
        computation either, only the memory. The choice made for this variable DOES have a bearing
        on the numerical accuracy of the results, and, as such, should be the object
        of a convergence study. The convergence test might be made on the total energy
        or derived quantities, like forces, but also on the two values of the
        "Compensation charge inside spheres", a quantity written in the log file.
        </p>
    varname: pawecutdg
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'PAW: print band structure in the FAT-BaND representation'
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 '
    section: varpaw
    text: |-
        <p>
        For Ground-State calculations and non self-consistent calculations only.
         <br />
         This option can be used to plot band structure. For each atom (specified by
        [[natsph]] and [[iatsph]]), each angular momentum, and each
        spin polarisation, the band structure is written in files (such as e.g. FATBANDS_at0001_Ni_is2_l2_m-1). Each file
        contains the eigenvalue, and the contribution of angular momentum L, and projection of angular momentum M,
        (for the corresponding wavefunction) to the PAW density inside the PAW sphere
        as a function of the index of the k-point.
        The output can be readily plotted with the software
         <a href="http://plasma-gate.weizmann.ac.il/Grace/">
          xmgrace
         </a>
         (e.g xmgrace FATBANDS_at0001_Ni_is2_l2_m-1).
        Relevant values are:
         <br />
         <ul>
          <li>
           0: desactivated.
          </li>
          <li>
           1: The fatbands are only resolved in L.
          </li>
          <li>
           2: The fatbands are resolved in L and M.
          </li>
         </ul>
        </p>
    varname: pawfatbnd
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: PAW - L angular momentum used to CUT the development in moments of the Densitites
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         The expansion of the densities in angular momenta is
        performed up to l=[[pawlcutd]].
         <br />
         Note that, for a given system, the maximum value of [[pawlcutd]] is
         <b>
          2*l_max
         </b>
         ,
        where l_max is the maximum l of the PAW partial waves basis.
         <br />
         <br />
         The choice made for this variable DOES have a bearing
        on the numerical accuracy of the results, and, as such, should be the object
        of a convergence study. The convergence test might be made on the total energy
        or derived quantities, like forces, but also on the two values of the
        "Compensation charge inside spheres", a quantity written in the log file.
        </p>
    varname: pawlcutd
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: PAW - maximum L used in the spherical part MIXing
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         The choice made for this variable determine how the spherical part of the
        density is mixed during electronic iterations.
         <br />
         <br />
         Only parts of rhoij quantities associated with
        l angular momenta up to l=pawlmix are mixed.
        Other parts of augmentation occupancies are not included in the mixing process.
         <br />
         This option is useful to save CPU time but DOES have a bearing on the numerical accuracy of the results.
        </p>
    varname: pawlmix
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[npfft]]==1': 0
        defaultval: 1
    definition: PAW - MIXing is done (or not) on the (fine) Double Grid
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         The choice made for this variable determines the grid on which the density (or potential) is mixed during the SCF cycle.
         <br />
         <br />
         - If
         <b>
          pawmixdg=1
         </b>
         the density/potential is mixed in REAL space using the fine FFT grid
        (defined by [[pawecutdg]] or [[ngfftdg]]).
         <br />
         - If
         <b>
          pawmixdg=0
         </b>
         the density/potential is mixed in RECIPROCAL space using the coarse FFT grid
        (defined by [[ecut]] or [[ngfft]]).
        Only components of the coarse grid are mixed using the scheme defined by [[iscf]];
        other components are only precondionned by [[diemix]] and simply mixed.
         <br />
         This option is useful to save memory and does not affect numerical accuracy of converged results.
        If
         <b>
          pawmixdg=1
         </b>
         , density and corresponding residual are stored for previous iterations and are
        REAL arrays of size [[nfftdg]].
        If
         <b>
          pawmixdg=0
         </b>
         , density and corresponding residual are stored
        for previous iterations and are COMPLEX arrays of size [[nfft]].
        The memory saving is particularly efficient when using the Pulay mixing
        ([[iscf]]=7 or 17).
         <br />
         <br />
         In
         <b>
          wavelet
         </b>
         calculations [[usewvl]]=1:
         <br />
         - pawmixdg is set to 1 by default.
         <br />
         - A value of 0 is not allowed.
         <br />
         - Density/potential is mixed in REAL space (Here only one grid is used).
        </p>
    varname: pawmixdg
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PAW - Flag for exact computation of gradients of NHAT density in eXchange-Correlation.
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Relevant only when a GGA exchange-correlation functional is used.
         <br />
         When this flag is activated, the gradients of compensation charge density (n_hat) are exactly
        computed (i.e. analytically); when it is deactivated, they are computed with a numerical scheme in
        reciprocal space (which can produce inaccurate results if the compensation charge density
        is highly localized).
         <br />
         As analytical treatment of compensation charge density gradients is CPU time demanding,
        it is possible to bypass it with [[pawnhatxc]]=0; but the numerical accuracy can be affected
        by this choice. It is recommended to test the validity of this approximation before use.
        </p>
    varname: pawnhatxc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 13
    definition: PAW - Number of PHI angles used to discretize the sphere around each atom.
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Number of phi angles (longitude) used to discretize the
        data on the atomic spheres. This discretization is completely
        defined by [[pawnphi]]
        and [[pawntheta]].
        </p>
    varname: pawnphi
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 12
    definition: PAW - Number of THETA angles used to discretize the sphere around each atom.
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Number of theta angles (latitude) used to discretize the
        data on the atomic spheres. This discretization is completely
        defined by [[pawntheta]]
        and [[pawnphi]].
        </p>
    varname: pawntheta
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PAW - only compute Non-Zero LM-moments of the contributions to the density from the spheres
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Concerns the computation of the contributions to the density from the spheres (named rho_1 -
        rho_tild_1).
         <br />
         If set to 0, all lm-moments of the sphere contributions to the density are computed at each
        electronic iteration.
         <br />
         If set to 1, only non-zero lm-moments of the sphere contributions to the density are computed
        at each electronic iteration (they are all computed at the first iteration then only
        those found to be non-zero will be computed ; thus the first iteration is more cpu intensive)
        </p>
    varname: pawnzlm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAW - OPTion for the MIXing of the spherical part
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
        In the case of PAW computations, during the self-consistent cycle,
        ABINIT mixes the density
        &rho;(r)=
         <span style="position: relative; top: -5pt; left: 6pt;">&sim;</span>&rho;(r)
        +<span style="position: relative; top: -5pt; left: 6pt;">&and;</span>&rho;(r)
        and the occupancy matrix &rho;<sub>ij</sub>.
        (<span style="position: relative; top: -5pt; left: 6pt;">&sim;</span>&rho;(r)
        is the pseudo density,
        <span style="position: relative; top: -5pt; left: 6pt;">&and;</span>&rho;(r)
        is the compensation charge density).
        It can be redundant as &rho;<sub>ij</sub> is contained in
        <span style="position: relative; top: -5pt; left: 6pt;">&and;</span>&rho;(r).
        <br>
        <ul>
          <li>If <b>pawoptmix</b>=0:<br>
          ABINIT mixes &rho;(r) and &rho;<sub>ij</sub> but the residual used
          to control the mixing algorithm is only based on &rho;(r).
          </li>
          <li>If <b>pawoptmix</b>=1:<br>
          ABINIT mixes &rho;(r) and &rho;<sub>ij</sub> and the residual used
          to control the mixing algorithm is based on &rho;(r) and &rho;<sub>ij</sub>.
          </li>
        </ul>
        This has only an influence on the efficiency of the mixing algorithm.<br>
        In cas of mixing problems, the first suggestion is to increase the size of the history
        (see [[npulayit]]). Then it is also possible to play with the parameters of
        the Kerker mixing: [[diemix]], [[diemac]], etc...
        </p>
    varname: pawoptmix
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAW - OPTion for the computation of the OSCillator matrix elements
    dimensions: scalar
    excludes: null
    requires: null
    section: varpaw
    text: |-
        <p>
        Only relevant for [[GW]] or [[BETHE_SALPETER]] calculations with PAW.
         <br />
         This variable defines the approach used for the evaluation of the oscillator matrix elements within the PAW formalism.
        Possible values are 0,1,2.
         <br />
         If [[pawoptosc]]=0 the code uses its internal
         default value (2 for SCREENING calculations, 1 for SIGMA calculations, 2 for [[BETHE_SALPETER]])
         <br />
         If [[pawoptosc]]=1 the matrix elements are computed with the expression given by Arnaud and Alouani in PRB 62. 4464
        The equation is exact provided that the set of PAW partial waves is complete.
         <br />
         If [[pawoptosc]]=2  the matrix elements are computed with the approximated expression proposed by Shishkin and
        Kresse in PRB 74. 035101
        </p>
    varname: pawoptosc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5.0
    definition: PAW - spheres OVerLap allowed (in percentage)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         When PAW is activated, a localized atomic basis is added to describe wave functions.
        Spheres around atoms are defined and they are IN PRINCIPLE not allowed to overlap. However,
        a small overlap can be allowed without compromising the accuracy of results. Be aware that
        too high overlaps can lead to unphysical results.
         <br />
         With the [[pawovlp]] variable, the user can control the (voluminal) overlap percentage
        allowed without stopping the execution.
         <br />
         [[pawovlp]] is the value (in percentage: 0...100%) obtained by dividing
        the volume of the overlap of two spheres by the volume of the smallest sphere.
         <br />
         The following values are permitted for [[pawovlp]]:
         <br />
         <div style="margin-left: 40px;">
          - [[pawovlp]]&lt;0. : overlap is always allowed
          <br />
          - [[pawovlp]]=0. : no overlap is allowed
          <br />
          - [[pawovlp]]&gt;0. and &lt;100. : overlap is allowed only if it is less than [[pawovlp]] %
         </div>
        </p>
    varname: pawovlp
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAW print band
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Forces the output of the all-electron wavefunction for
        only a single band. To be used in conjuction with:
         <b>
          <br />
          [[pawprtwf]]=1
         </b>
         and
        [[pawprt_k]].
        The indexing of the bands start with one for the lowest occupied band
        and goes up from there.
        </p>
    varname: pawprt_b
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAW print k-point
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Forces the output of the all-electron wavefunction for
        only a single k-point. To be used in conjuction with:
         <b>
          <br />
          [[pawprtwf]]=1
         </b>
         and
        [[pawprt_b]].
        The indexing follows the order in ouptput of the internal
        variable
         <b>
          kpt
         </b>
         in the beginning of the run.
        </p>
    varname: pawprt_k
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'PAW: PRinT total physical electron DENsity'
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <b>
         Deprecated :
        </b>
        See the [[prtden]].
        <p>
        </p>
    varname: pawprtden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'PAW: PRinT partial DOS contributions'
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and [[prtdos]]==3'
    section: varpaw
    text: |-
        <p>
         This input variable controls the computation and/or printing of contributions to the PAW partial DOS in _DOS file(s):
         <br />
         <div style="margin-left: 40px;">
          + Plane-waves contribution
          <br />
          + "on-site" all-electron contribution (phi)
          <br />
          - "on-site" pseudo contribution (phi_tild).
          <br />
         </div>
         If
         <b>
          pawprtdos=0:
         </b>
         <br />
         - The 3 contributions are computed; only the total partial DOS is output in _DOS file.
         <br />
         If
         <b>
          pawprtdos=1:
         </b>
         <br />
         - The 3 contributions are computed and output in _DOS file.
         <br />
         - In that case, integrated DOS is not output.
         <br />
         If
         <b>
          pawprtdos=2:
         </b>
         <br />
         - Only "on-site" all-electron contribution is computed and output in _DOS file.
         <br />
         - This a (very) good approximation of total DOS, provided that (1) the PAW local basis is complete, (2) the electronic charge is mostly contained in PAW spheres.
         <br />
         - In that case, the [[ratsph]] variable is automatically set to the PAW radius.
        </p>
    varname: pawprtdos
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'PAW: PRinT VOLume'
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Control print volume and debugging output for PAW in log file or standard output.
        If set to 0, the print volume is at its minimum.
         <br />
         [[pawprtvol]] can have values from -3 to 3:
         <br />
         - [[pawprtvol]]=-1 or 1: matrices rho_ij (atomic occupancies) and D_ij (psp strength)
        are printed at each SCF cycle with details about their contributions.
         <br />
         - [[pawprtvol]]=-2 or 2: like -1 or 1 plus additional printing: moments of "on-site" densities,
        details about local exact exchange.
         <br />
         - [[pawprtvol]]=-3 or 3: like -2 or 2 plus additional printing: details about
        PAW+U, rotation matrices of sphercal harmonics.
         <br />
         When [[pawprtvol]]&gt;=0, up to 12 components of rho_ij and D_ij matrices for the 1st and last atom are printed.
         <br />
         When [[pawprtvol]]&lt;0, all components of rho_ij and D_ij matrices for all atoms are printed.
         <br />
        </p>
    varname: pawprtvol
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'PAW: PRinT WaveFunctions'
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         This input variable controls the output of the full PAW wave functions including the on-site
        contribution inside each PAW sphere needed to reconstruct the correct nodal shape in the augmentation region.
         <b>
          pawprtwf=1
         </b>
         causes the generation of a file  _AE_WFK that contains the full
        wavefunctions in real space on the fine FFT grid defined by
        [[pawecutdg]] or [[ngfftdg]].
        Limitations: At present (v6.0),
         <b>
          pawprtwf=1
         </b>
         is not compatible neither with the k-point parallelism
        nor with the parallelism over G-vectors. Therefore the output of the _AE_WFK has to be done in sequential.
        Moreover, in order to use this feature, one has to enable the support for ETSF-IO at configure-time
        as the _AW_WFK file is written using the NETCDF file format following the ETSF-IO specification for
        wavefunctions in real space. If the code is run entirely in serial, additional output is made of various
        contributions to the all-electron wavefunction. By default the full available set of bands and k-points are
        ouput, but a single band and k-point index can be requested by using the variables
        [[pawprt_b]] and [[pawprt_k]].
        </p>
    varname: pawprtwf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nspinor]]==2': 1
        defaultval: 0
    definition: PAW - option for SPiN-ORBit coupling
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         When PAW is activated, the
         <b>
          spin-orbit coupling
         </b>
         can be added without the use of specific PAW datasets (pseudopotentials).
         <br />
         If [[pawspnorb]]=1, spin-orbit will be added.
         <br />
         If the wavefunction is spinorial (that is, if [[nspinor]]=2),
         there is no reason not to include the spin-orbit interaction, so that the default value of [[pawspnorb]]
         becomes 1 when [[nspinor]]=2.
         <br />
         Note that only the all-electron "on-site" contribution to the Hamiltonian is taken into account;
        this is a very good approximation but requires the
        following conditions to be fullfilled:
         <br />
         <div style="margin-left: 20px;">
          1- the
          <span style="position: relative; top: -8pt; left: 8pt;">
          </span>
          <span style="position: relative; top: -5pt; left: 6pt;">
           ~
          </span>
          &#966;
          <sub>
           i
          </sub>
          basis is complete enough
          <br />
          2- the electronic density is mainly
        contained in the PAW sphere
          <br />
         </div>
         <br />
         Also note that, when spin-orbit coupling is activated and there is some magnetization [[nspden]]=4, the time-reversal symmetry is broken.
         <br />
         The use of [[kptopt]]=1 or [[kptopt]]=2 is thus
        forbidden. It is advised to use [[kptopt]]=3 (no symmetry used to generate k-points)
        or [[kptopt]]=4 (only spatial symmetries used to generate k-points).
         <br />
         Be careful if you choose to use [[kptopt]]=0 (k-points given by hand); Time-reversal symmetry
        has to be avoided.
         <br />
         An artificial scaling of the spin-orbit can be introduced thanks to the [[spnorbscl]] input variable.
        </p>
    varname: pawspnorb
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PAW - option for the STorage of G_l(r).YLM(r)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]=1'
    section: varpaw
    text: |-
        <p>
         When PAW is activated, the computation of compensation charge density (so called
        "hat" density) requires the computation of g_l(r).Y_lm(r) factors (and cartesian derivatives) at each point
        of real space contained in PAW spheres. The number of atoms, of (l,m) quantum numbers
        and the sharpness of the real FFT grid can lead to a very big {g_l.Y_lm} datastructure.
        One can save memory by putting [[pawstgylm]]=0; but, in that case, g_l(r).Y_lm(r) factors
        a re-computed each time they are needed and CPU time increases.
         <br />
         <br />
         <div style="margin-left: 20px;">
          Possible choices:
          <br />
          - [[pawstgylm]]=0 : g_l(r).Y_lm(r) are not stored in memory and recomputed.
          <br />
          - [[pawstgylm]]=1 : g_l(r).Y_lm(r) are stored in memory.
          <br />
         </div>
         <br />
         <div style="margin-left: 40px;">
          Note:
          <br />
          g_l(r) are shape functions (analytically known)
          <br />
          Y_lm(r) are real spherical harmonics
         </div>
        </p>
    varname: pawstgylm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PAW - SUSceptibility, inclusion of HAT (compensation charge) contribution
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and [[optdriver]]==0 '
    section: varpaw
    text: |-
        <p>
        Ground-State calculation only.
         <br />
         When a sophisticated preconditioning scheme is selected for the SCF cycle of a Ground-State calculation
        ([[iprcel]]&gt;0), the computation of the susceptibility matrix
        is required several times during the cycle. This computation is computer time consuming, especially
        -- within PAW -- because of the inclusion of additional terms due to the compensation charge density.
        As only a crude valuation of the susceptibilty matrix is needed (to evaluate a preconditioning matrix),
        the compensation charge contribution can be neglected to save CPU time (select [[pawsushat]]=0).
        This approximation could be unfavourable in some cases; in the latter, we advise to put [[pawsushat]]=1.
         <br />
         <br />
         <div style="margin-left: 20px;">
          Possible choices:
          <br />
          - [[pawsushat]]=0 : only plane-wave contribution to suscep. matrix is computed.
          <br />
          - [[pawsushat]]=1 : the whole suscep. matrix (PW + PAW on-site) is computed.
          <br />
         </div>
        </p>
    varname: pawsushat
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: ' i.e. the first atom treated with PAW+U.'
    commentdims: null
    defaultval: 1
    definition: PAW+macro_UJ, ATom number
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Determines the atom for which U (or J) should be determined. See also [[macro_uj]].
        </p>
    varname: pawujat
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: a.u.
        value: 20
    definition: PAW+macro_UJ, sphere RADius
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         The sphere radius serves to extrapolate the U value calculated at r_paw to a larger sphere radius.
        See also [[macro_uj]].
        As most projector functions are localized within r_paw to &asymp;80%,
        20 a.u. contains &asymp;100% of the wavefunction and corresponds to r_paw &rarr; &infin;.
        </p>
    varname: pawujrad
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: eV
        value: 0.1
    definition: PAW+macro_UJ, potential shift (V)
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Amplitude of the potential shift for the determination of U (or J). See also [[macro_uj]].
        </p>
    varname: pawujv
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PAW - option for the USE of CPrj in memory (cprj=WF projected with NL projector)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         <br />
         When PAW is activated, the computation of cprj arrays is memory and time consuming.
         <br />
         When [[pawusecp]]=0, then the cprj are never kept in memory, they are recomputed when needed (this is CPU-time consuming).
        When [[pawusecp]]=1, then the cprj are computed once and then kept in memory.
         <br />
         Change the value of the keyword only if you are an experienced user (developper).
         <br />
         Remember: cprj = (WF_n .dot. p_i) (WF_n=wave function, p_i=non-local projector).
         <br />
         <br />
         For the time being, only activated for RF calculations.
         <br />
        </p>
    varname: pawusecp
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PAW - choice for eXchange-Correlation DEVelopment (spherical part)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         <ul>
          <li>
           If set to 0, the exchange-correlation term in the spherical part of energy is
        totally computed on the angular mesh
          </li>
          <li>
           If set to 1, the exchange-correlation term in the spherical part of energy is
        developed onto lm-moments at order 1
          </li>
          <li>
           If set to 2, the exchange-correlation term in the spherical part of energy is
        developed onto lm-moments at order 2 (can be memory/CPU consuming)
          </li>
         </ul>
         <br />
         Be careful: GGA requires [[pawxcdev]] &gt; 0
        </p>
    varname: pawxcdev
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 2
    definition: 'PHonon: INTegration METHod'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        Select the integration technique for computing the phonon DOS and the Eliashberg function a2fF(w).
        <p>
        <br>
        1 for Gaussian scheme (see also [[ph_smear]]).
        <br/>
        <br>
        2 for tetrahedron method (no other input is needed but requires at least 4 q-points in the BZ)
        </br>
        </p>
    varname: ph_intmeth
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    definition: 'PHonon: number of divisions for sampling the smallest segment'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable is used in conjunction with [[ph_nqpath]] and [[ph_qpath]] to define the q-path used for phonon band structures and phonon linewidths. It gives the number of points used to sample the smallest segment in the q-path specified by [[ph_qpath]].
    varname: ph_ndivsm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 20
    - 20
    - 20
    definition: 'PHonon: Number of Grid points for Q-PoinT mesh.'
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varrf
    text: |-
        This variable defines the q-mesh used to compute the phonon DOS and the Eliashberg function via Fourier interpolation.
        Related input variables: [[ph_qshift]] and [[ph_nqshift]].
    varname: ph_ngqpt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'PHonon: numer of Q-points defining the PATH'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This integer defines the number of points in the [[ph_qpath]] array.
    varname: ph_nqpath
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'PHonons: Number of q-SHIFTs'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This variable defines the number of shifts in the q-mesh used
        for the phonon DOS and for the Eliashberg functions (see [[ph_ngqpt]]).
        If not given, the code assumes a Gamma-centered mesh. The shifts
        are specified by [[ph_qshift]].
    varname: ph_nqshift
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: None
    definition: 'Phonon: Q-PATH'
    dimensions:
    - 3
    - ph_nqpath
    excludes: null
    requires: specified([[pq_nqpath]])
    section: varrf
    text: |-
        This array contains the list of special q-points used to construct the q-path for phonon band structures and phonon linewidths.
        See also [[ph_nqpath]] and [[[ph_ndivsm]].
    varname: ph_qpath
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: 'PHONONS: Q-SHIFTs for mesh.'
    dimensions:
    - 3
    - ph_nqshift
    excludes: null
    requires: '[[ph_nqshift]]'
    section: vareph
    text: |-
        This array gives the shifts to be used to construct the q-mesh for
        computing the phonon DOS and the Eliashberg functions (see also [[ph_nqshift]]. If not given, a Gamma-centered mesh is used.
    varname: ph_qshift
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.00002 Hartree
    definition: 'PHonon: SMEARing factor'
    dimensions: scalar
    excludes: null
    requires: '[[ph_intmeth]]==1'
    section: vareph
    text: |-
        The gaussian broadening used for the integration of the phonon
        DOS and the Eliashberg function. See also [[ph_intmeth]] and [[ph_ngqpt]].
    varname: ph_smear
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.1 meV
    definition: 'PHonons: frequency STEP.'
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        The step used to generate the (linear) frequency mesh for the phonon DOS and the Eliashberg function.
        The extrema of the mesh are automatically computed by the code.
    varname: ph_wstep
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[ntypat]]'
    definition: Path Integral fictitious MASSes
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[imgmov]]=9 or 13'
    section: varrlx
    text: |-
        <p>
         Only relevant if [[imgmov]]=9 or 13 (Path-Integral Molecular Dynamics).
         <br />
         Gives the fictitious masses (
         <i>
          D. Marx and M. Parrinello, J. Chem. Phys. 104, 4077 (1996)
         </i>
         )
        in atomic mass units for each kind of atom in cell. These masses are the inertial masses used
        in performing Path Integral Molecular Dynamics (PIMD), they are different from the true masses ([[amu]]) used to define the quantum spring that relates the different beads in PIMD. They can be chosen arbitrarily, but an appropriate choice will lead the different variables to move on the same time scale in order to optimize the sampling efficiency of the PIMD trajectory.
         <br />
         If [[pitransform]]=1 (normal mode transformation), or [[pitransform]]=2 (staging transformation), [[pimass]] is automatically set to its optimal value.
         <br />
        </p>
    varname: pimass
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Path-Integral Molecular Dynamics: CONSTRAINT to be applied
        on a reaction coordinate'
    dimensions: scalar
    excludes: null
    requires: '[[imgmov]]=9 or 13'
    section: varrlx
    text: |-
        Only relevant for Path-Integral Molecular Dynamics.<br/>
        Selects a constraint to be applied during the PIMD trajectory. The constraint is holonomic (it is a relation between the position variables).In practice, the total forces applied to the atomic positions are modified so as to respect the constraint.<br/>
        To date, the available constraints are:<br/>
        <ul>
        <li><b>0</b>: no constraint</li>
        <li><b>1</b>: <i>"Blue Moon Ensemble" method</i>.<br/>
        The constraint is a linear combination of the positions of atomic centroids (this linear combination is kept constant during the simulation). <br/>
        Sum[W_i * X_i]=constant<br/>
        The X_i are the coordinates of the atomic centroids. The weights W_i have to be specified with the [[wtatcon]](3,[[natcon]],[[nconeq]]), [[iatcon]]([[natcon]]) and [[natcon]] input parameters (where [[nconeq]] is fixed to 1).<br/>
        More details on the implementation in: <a href="http://doi.org/10.1273/cbij.7.12">Y. Komeiji,Chem-Bio Informatics Journal 7, 12-23 (2007)</a>.
        </li>
        </ul>
    varname: pimd_constraint
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Path Integral coordinate TRANSFORMation
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Only relevant if [[imgmov]]=9 or 13 (Path-Integral Molecular Dynamics).
        Coordinate transformation used in the integration of the Path Integral Molecular Dynamics equations of motion. The transformation, with an appropriate choice of fictitious masses ([[pimass]]), is used to force the different modes to move on the same time scale, and thus optimize the efficiency of the statistical sampling in the corresponding statistical ensemble.
        Available with a Langevin thermostat ([[imgmov]]=9) or with Nose-Hoover chains ([[imgmov]]=13).
        See M. Tuckerman et al, J. Chem. Phys. 104, 5579 (1996).
        </p>
        <p>
         If equal to 0, no transformation is applied (primitive coordinates).
         <br />
         If equal to 1, normal mode transformation (in that case, [[nimage]] must be absolutely EVEN).
         <br />
         If equal to 2, staging transformation.
        </p>
    varname: pitransform
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions Initial BAND
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the upper band to include in the calculation of Wannier functions
        </p>
    varname: plowan_bandf
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions Initial BAND
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the lower band to include in the calculation of Wannier functions
        </p>
    varname: plowan_bandi
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions COMPUTATION
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Activate computation of Projected Local Orbital Wannier functions (PLO Wannier) and  corresponding band structure.
        Variables [[plowan_bandi]],
        [[plowan_bandf]],
        [[plowan_natom]],
        [[plowan_nbl]],
        [[plowan_iatom]],
        [[plowan_lcalc]],
        [[plowan_projcalc]] are mandatory to precise the nature of the projections.
         <ul>
          <li>
           0=&gt; Default value: do not activate calculation of PLO Wannier.
          </li>
          <li>
           1=&gt; Compute PLO Wannier and band structure
          </li>
          <li>
           2=&gt; Compute PLO Wannier and band structure. In this case, the coupling in k-space between blocks of Wannier functions belonging to different
        angular momenta or atoms is removed.
          </li>
         </ul>
         Other related variables are
        [[plowan_realspace]],
        [[plowan_nt]],
        [[plowan_it]].

        The implementation is not symetrized over k-point and not parallelized.

        (The calculation of projections is
        detailed in
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">
          Phys. Rev. B 77, 205112, (2008)
         </a>
         )
        </p>
    varname: plowan_compute
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions,  ATOM Index
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the indices of the [[plowan_natom]] atoms on which the projections will be done.
        </p>
    varname: plowan_iatom
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions,  Index of Translation.
    dimensions:
    - 3
    - '[[plowan_nt]]'
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Requires [[plowan_realspace]]  to be greater than 0 and
        [[plowan_nt]]  to be greater than 0.
        Precise a given set of selected real space translation by using the real space vectors basis.
        These atoms are used to define Wannier functions in real space. These real space
        Wannier functions are used as a basis to compute the Hamiltonian.
        </p>
    varname: plowan_it
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    definition: Projected Local Orbital WANnier functions,  L values to use for CALCulation
    dimensions:
    - sum([[plowan_nbl]])
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the [[plowan_nbl]] values of angular momenta for each atom, in the order of the atoms
        as given in [[plowan_iatom]].
        </p>
    varname: plowan_lcalc
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions, Number of ATOMs
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the number of atoms on which the projection will be done
        </p>
    varname: plowan_natom
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions,  NumBer of L values
    dimensions:
    - '[[plowan_natom]]'
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the total number of angular momenta (over all atoms) to compute the projections.
        </p>
    varname: plowan_nbl
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: |-
        Projected Local Orbital WANnier functions,  Number of Translation on which the real space values of
        energy are computed
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Requires [[plowan_realspace]]  to be greater than 0.
        Gives a number of selected atoms. These atoms are used to define Wannier functions in real space. These real space
        Wannier functions are used as a basis to compute the Hamiltonian.
        </p>
    varname: plowan_nt
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    definition: Projected Local Orbital WANnier functions,  PROJectors values to use for CALCulation
    dimensions:
    - sum([[plowan_nbl]])
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         <br />
         Gives the [[plowan_nbl]] values of projectors for each atom, in the order of the atoms
        as given in [[plowan_iatom]]. The index i for the projectors refers to the  ith number on line
        orbitals of the PAW atomic data file.
        </p>
    varname: plowan_projcalc
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Projected Local Orbital WANnier functions,  activate REAL SPACE calculation.
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Can take the following values:
         <ul>
          <li>
           0=&gt; Default value: do not activate calculation of real space Wannier functions.
          </li>
          <li>
           1=&gt; Compute PLO Wannier in real space for analysis. These data can also be used in a following dataset to perform a Wannier interpolation.
          </li>
          <li>
           2=&gt; Do simple Wannier Interpolation for a given k points starting from real space Wannier function Hamiltonian
        computed in a preceding dataset.
          </li>
         </ul>
        </p>
    varname: plowan_realspace
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    definition: POLarization for Centrosymmetric geometry
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varff
    text: |-
        <p>
         When doing a finite electric displacement field calculation,
        if the structure is centrosymmetric but the polarization is non-zero (such as for AlAs),
        this non-zero polarization should be specified as [[polcen]] (in REDUCED coordinates, in atomic units) in the input file.
        See Eq.(24) in the Suppl. of Nat. Phys. (M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009))
        </p>
    varname: polcen
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: POSitron computation of DOPPLER broadening
    dimensions: null
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when [[positron]]&lt;&gt;0.<br>
         This input parameter activates the calculation of the Doppler broadening of the electron-positron annihilation radiation.<br>
         An output file containing the momentum distributions
         of annihilating electron-positron pairs is created.<br>
         Such a computation needs a core wave-function file (per atom type) to be provided.
         This core WF file should be named '&lt;psp_file_name&gt;.corewf'
         (where &lt;pspfile_name&gt; is the name of the pseudo-potential (or PAW) file)
         or 'corewf.abinit&lt;ityp&gt;' (where &lt;ityp&gt; is the index of the atom type).
         Core WF files can be obtained with the atompaw tool by the use of 'prtcorewf' keyword.
        </p>
    varname: posdoppler
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: POSITRON calculation
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
        This input parameter can be positive or negative.<br>
        Negative values for [[positron]] are only relevant for PAW calculations.<br>
        Electron-positron correlation functional is defined by [[ixcpositron]].<br>
        Other relevant input parameter: [[posocc]] (occupation number for the positron).<br>

        <br><U>Positive values for [[positron]]:</U><br>
        <i>For <b>[[positron]]=1 or 2</b>, will perform the calculation of positron
        lifetime (and annihilation rate).</i><br>
        <ul>
        <li>[[positron]]=1</b>:<br>
        Starting from a previous electronic GS density (with <b>[[positron]]=0</b>),
         a positronic ground-state calculation is performed, considering that the electrons are not perturbed
         by the presence of the positron.<br>
        This is almost correct for a positron in a perfect bulk material.
        But this approximation fails when defects exist in
        the material (for instance: the positron might be trapped by a vacancy).<br>
        The electronic density will be automatically read from a _DEN file (with or without [[irdden]]
        keyword).<br>
        At the end of the SCF cycle, the positron lifetime and annihilation rate
        are printed out.<br><br>
        <i>Additional information for the use of pseudopotentials:<br><ul>
        <li>PAW datasets: nothing to do; simply use usual electronic PAW datasets
        <li>Norm-conserving pseudopotentials: One has to use specific
         pseudopotentials for the positron calculation.
        They must be of the FHI type (pspcod=6), and must contain at their
        end, the all-electrons core density generated with FHI98PP. They must have
        lmax=lloc=0 (check that this works for the electronic GS !! No ghost, etc ...). Otherwise, their are similar to an usual FHI pseudopotential.<br>
        </i></ul><br>

        <li><b>positron=2</b>:<br>
        Starting from a previous positronic GS density (with <b>positron=1</b>),
        an electronic ground-state calculation is performed, keeping the positronic
        density constant.<br>
        The positronic density will be automatically read from a _DEN file (with or without
        [[getden]]/[[irdden]] keyword).<br>
        At the end of the SCF cycle, the positron lifetime and annihilation rate
        are printed out.<br><br>
        <i>Additional information for the use of pseudopotentials:<br><ul>
        <li>PAW datasets: nothing to do; simply use usual electronic PAW datasets
        <li>Norm-conserving pseudopotentials: One has to use specific
         pseudopotentials for the electron calculation.
        They must be of the FHI type (pspcod=6), and must contain at their
        end, the all-electrons core density generated with FHI98PP.<br>
        </i></ul><br>

        <li><b>Typical use</b>:<br>
        The calculation is done in several steps:<br>
        The first one is a normal GS calculation for the electrons, with <b>positron</b>=0.
        The only specific thing to do is to set [[prtden]]=1 (this is the defaut for ABINIT v6.x+).
        This will create the associated _DEN file which will be used as input file for the positronic
        GS calculation.<br>
        The second step is the GS calculation of the positron and subsequently its
        lifetime, with <b>positron</b>=1.
        One has to define also [[ixcpositron]].<br>
        Then, it is possible to perform an additional step, computing
        the GS electronic density in presence of the positron, with <b>positron</b>=2.<br>
        and so on...<br>
        This procedure can be automated (for PAW only) by the use of a negative value for <b>positron</b>.<br>
        At the end, a converged value of the positron lifetime (decomposed in several contributions) is printed. <br>
        See also [[posdoppler]] keyword for the calculation of Doppler broadening.<br>
        </ul>

        <br><U>Negative values for <b>positron</b>:</U><br>
        <i>For <b>positron&lt;0</b>, will perform an automatic calculation of electrons and positron
        densities in the two-component DFT context; then will compute positron lifetime (and annihilation rate).</i><br>

        <ul><li><b>positron=-1</b>:<br>
        Starting from scratch, will first perform an usual electronic ground-state
        calculation until convergence (controlled by the use of one of the <i>tolerance</i> keywords).<br>
        Then will perform a positronic ground state calculation in presence of the electrons
        and ions; then an electronic ground state calculation in presence of the positron and the ions...<br>
        and so on... until the total energy is converged.<br>
        The convergence of the total energy of the ions+electrons+positron system
        is controlled by the use of the [[postoldfe]], [[postoldff]]
        and [[posnstep]] input keywords.<br>
        With <b>positron=-1</b>, at the beginning of each new electronic/positronic step,
        the wave functions are unknown.</ul>

        <ul><li><b>positron=-10</b>:<br>
        Same as <b>positron=-1</b> except that the electronic/positronic wave functions
        are stored in memory.<br>
        Consequently, the total number of iterations to reach the convergence (diff_Etotal<[[postoldfe]]
        or diff_Forces<[[postoldff]]) is smaller.<br>
        But, this can increase the total amount of memory needed by the code.</ul>

        <ul><li><b>positron=-2</b>:<br>
        Same as <b>positron=-1</b> except that the two-component DFT cycle
        is forced to stop at the end of an electronic step.</ul>

        <ul><li><b>positron=-20</b>:<br>
        Same as <b>positron=-10</b> except that the two-component DFT cycle
        is forced to stop at the end of an electronic step.</ul><br>

        <U>Advice for use:</U><br>
        There are two typical cases which have to be differently treated:
        <ul><li><b>A positron in a perfect <U>bulk</U> system</b>:<br>
        In that case, the positron is delocalized in the whole crystal. Its density is almost zero.<br>
        Thus, the "zero density positron limit" has to be used. [[ixcpositron]] has to be choosen accordingly.<br>
        In order to have the zero density positron limit it is adviced to follow these points:<br>
        1- Put a small positronic charge (by setting a [[posocc]] to a small value) <b>OR</b> use a big supercell.<br>
        2- Use only k=gamma wave vector for the positronic calculation.<br>
        3- Use the manual procedure in 2 steps: first <b>positron</b>=0 and then <b>positron</b>=1; avoid the <b>positron=2</b> step and the automatic procedure (<b>positron</b>&lt;0).<br>
        In principle, the positron lifetime should converge with the value of [[posocc]] or the size of the supercell.<br></ul>

        <ul><li><b>A positron trapped in a <U>default</U> (vacancy...)</b>:<br>
        In that case, the positron is localized in the default. Its density can be localized in the simulation cell (provided that the cell is sufficiently large) and influences the electronic density.<br>
        So, it is advised to use the automatic procedure (<b>positron</b>&lt;0) or the manual procedure with several <b>positron</b>=0,1,2,1,... steps.<br>
        K-points can be used as in usual electronic calculations.<br>
        Also note that it is possible to use forces and stresses to perform structural minimization.<br></ul>

        References:<br>
        <ul>
        <b>[1]</b> J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).<br>
        <b>[2]</b> Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).<br>
        <b>[3]</b> P.A. Sterne and J.H. Kaiser, Phys. Rev. B 43, 13892 (1991).<br>
        <b>[4]</b> M.J. Puska, A.P. Seitsonen and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).<br>
        <b>[5]</b> B. Barbiellini, M.J. Puska, T. Torsti and R.M.Nieminen, Phys. Rev. B 51, 7341 (1994)<br>
        </ul>
    varname: positron
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 50
    definition: 'POSitron calculation: max. Number of STEPs for the two-component
        DFT'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when [[positron]]&lt;0.
         <br />
         Sets the maximum number of electronic/positronic iterations that, when reached, will cause the two-component DFT SCF cycle to stop.
         <br />
         The code will first compute the electronic ground-state, then the positronic ground state in the electronic density, then the electronic ground-state in the positronic density, ...
         <br />
         ...until diff_Etotal&lt;[[postoldfe]] or diff_Forces&lt;[[postoldff]]
        or the number of electronic/positronic steps is [[posnstep]].
         <br />
        </p>
    varname: posnstep
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'POSitron calculation: OCCupation number for the positron'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when [[positron]]/=0.
         <br />
         Sets the occupation number for the positron. Has to be &lt;=1.
         <br />
         Changing [[posocc]] is only useful for bulk calculation when one wants to perform lifetime computations using a small simulation cell (can avoid the use of a supercell). It simulates the dispersion of the positron in the whole crystal.
         <br />
        </p>
    varname: posocc
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[postoldff]]=0': 1.0E-6
        defaultval: 0.0
    definition: 'POSITRON calculation: TOLerance on the DiFference of total
        Energy'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when [[positron]]&lt;0.
         <br />
         Sets a tolerance for absolute difference of total energy (of
         <i>
          ions+electrons+positron
         </i>
         system)
        that, when reached, will cause the SCF cycle to stop before the number of
        steps is [[nstep]] or the number of electronic/positronic steps is [[posnstep]].
         <br />
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          toldfe
         </b>
         has the '[[ENERGY]]' characteristics.
        <br />
        Only one and only one of [[postoldfe]] or [[postoldff]] can be set.
        </p>
    varname: postoldfe
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'POSitron calculation: TOLerance on the DiFference of Forces'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when [[positron]]&lt;0.
         <br />
         Sets a tolerance for absolute difference of maximum force acting on ions (due to
         <i>
          ions+electrons+positron
         </i>
         system)
        that, when reached, will cause the SCF cycle to stop before the number of SCF
        steps is [[nstep]] or the number of electronic/positronic steps is [[posnstep]].
         <br />
         Only one and only one of [[postoldfe]] or [[postoldff]] can be set.
         <br />
        </p>
    varname: postoldff
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: Ha
        value: 0.0
    definition: Plasmon Pole Model FReQuency
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         <b>
          In plasmon-pole calculations
         </b>
        </p>
        <p>
         Usually only effective if [[GW]] corrections are evaluated using the plasmon-pole model of Godby-Needs
        ([[ppmodel]]==1).
         <br />
         <br />
         In the present status of the [[GW]] code, the convolution in frequency space
        defining the self-energy operator can be evaluated using two different approaches:
        numerical integration and plasmon-pole models.
         <br />
         Methods based on the numerical integration (contour deformation, analytic continuation) require
        the knowledge of the screened interaction for several frequencies. These approaches give
        the most accurate results but at the price of an increase in the CPU time required.
         <br />
         Alternatively, it is possible to approximate the dynamical behaviour of the screened interaction
        through simple analytical expressions, the so-called plasmon-pole models.
        In the plasmon-pole model proposed by Godby-Needs ([[ppmodel]]=1),
        the screening must be available at zero frequency, as well as at another imaginary frequency,
        of the order of the plasmon frequency (the peak in the EELS spectrum).
        This information is used to model the behaviour of the dielectric matrix
        for all frequencies.
        During the calculation of the screening, [[ppmfrq]] defines the imaginary frequency where the
        dielectric matrix is evaluated, in addition to the zero frequency.
        During the self-energy run, [[ppmfrq]] can be used to define the second frequency to be used
        to calculate the plasmon-pole parameters. This is particularly useful when the
        SCR file contains several frequencies along the imaginary axis.
        In this case the frequency whose value is the closest one to [[ppmfrq]] will be selected.
        Note that, if the plasmon-pole approximation is good, then, the
        choice of [[ppmfrq]] should have no influence on the final result.
        One should check whether this is the case. In general, the plasmon frequencies of bulk solids
        are of the order of 0.5 Hartree.
         <br />
         <br />
         <b>
          In Contour Deformation calculations
         </b>
        </p>
        <p>
         [[ppmfrq]] is here used to
         <b>
          override
         </b>
         the default value calculated from the average electronic
        density per unit cell. This can affect the distribution of gridpoints along the imaginary and
        real frequency axes. See
        [[cd_frqim_method]], [[gw_frqim_inzgrid]] and [[gw_frqre_inzgrid]] for more details.
        </p>
    varname: ppmfrq
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Plasmon Pole MODEL
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4]'
    section: vargw
    text: |-
        <p>
         <ul>
          <li>
           [[ppmodel]]=1 : PP model of Godby and Needs,
        See Phys Rev Lett 62, 1169 (1989)
          </li>
          <li>
           [[ppmodel]]=2 : PP model of Hybertsen and Louie,
        See Phys Rev B 34, 5390 (1986)
          </li>
          <li>
           [[ppmodel]]=3 : PP model of  W. von der Linden
        and P. Horsh see Phys Rev B 37, 8351 (1988)
          </li>
          <li>
           [[ppmodel]]=4 : PP model of Farid and Engel.
        See Phys Rev B47,15931 (1993)
          </li>
          <li>
           [[ppmodel]]=0 : no PP model, numerical integration
        (contour deformation method, see e.g. S. Lebegue  et al. PRB  67, 155208 (2003).)
          </li>
         </ul>
         Please note the difference between [[ppmodel]] 1 and [[ppmodel]] 2,3,4.
        In the first case ([[ppmodel]]=1), the plasmon-pole parameters are determined in order to reproduce
        the behaviour of the dielectric matrix at two calculated frequencies: the static limit (omega=0)
        and the imaginary frequency defined by [[ppmfrq]].
        In the last three cases, instead, the plasmon-pole parameters are found
        by using the dielectric matrix calculated only at omega=0 and enforcing the so-called f-sum rule.
        See also [[nfreqre]].
        </p>
        <p>
         Please note also that in the case of [[ppmodel]] 4, the plasmon energies are not simple mathematical parameters,
        but rather have a physical meaning (at least the lowest ones).
        Thus the calculated plasmon band structure (plasmon energy vs q vector) is reported in the output file for the
        lowest 10 bands.
        </p>
    varname: ppmodel
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PREPAre Non-Linear response calculation
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         The computation of third-order derivatives from the 2n+1 theorem
        requires the first-order wavefunctions and densities obtained from
        a linear response calculation. The standard approach in a linear
        response calculation is (i) to compute only the
        irreducible perturbations, and (ii) to use symmetries to
        reduce the number of k-points for the k-point integration.
         <br />
         This approach cannot be applied, presently (v4.1),
        if the first-order wavefunctions are to be used to compute third-order derivatives.
        First, for electric fields, the code needs the derivatives
        along the three directions. Still, in case of phonons, only the
        irreducible perturbations are required.
        Second, for both electric fields and phonons, the wavefunctions
        must be available in half the BZ (kptopt=2), or the full BZ (kptopt=3).
         <br />
         During the linear response calculation, in order to prepare a non-linear
        calculation, one should put [[prepanl]] to 1 in order
        to force ABINIT (i) to compute the electric field perturbation
        along the three directions explicitly, and (ii) to keep the full number of k-points.
        </p>
    varname: prepanl
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PREPAre GKK calculation
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         The calculation of electron-phonon coupling quantities requires the presence
        of all the perturbations (all atoms in all directions) for the chosen set
        of (irreducible) q-points. To impose this and prevent ABINIT from using
        symmetry to reduce the number of perturbations, set [[prepgkk]] to 1.
        Use in conjunction with [[prtgkk]].
        </p>
    varname: prepgkk
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PREPare Self-Consistent PHONon calculation
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Print PCINFO, PHFREQ, and PHVEC files, for use with self-consistent phonon runs, after a perturbation
        calculation. Only prints out files for the present q-point, and there is presently no tool to symmetrize
        or merge these files, so use anaddb instead (with prtscphon input variable). The abinit input
        variable is destined to someday bypass the use of anaddb for scphon calculations.
        </p>
    varname: prepscphon
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT 1-DiMensional potential and density
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set &gt;= 1, provide one-dimensional projection of
        potential and density, for each of the three axis.
        This corresponds to averaging the potential
        or the density on bi-dimensional slices of the FFT grid.
        </p>
    varname: prt1dm
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT by ATom LIST of ATom
    dimensions: null
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         This is an array of the numbers associated to the index atoms that
        the user want to print in the output or log files, this is useful when
        you have a large number of atoms and you are only interested to
        follow specific atoms, the numbers associated should be consistent
        with the list in [[xcart]] or [[xred]].
         This input varible does not affect the contents of the "OUT.nc" or
        "HIST.nc", those are NetCDF files containing the information about
        all the atoms.
        </p>
    varname: prtatlist
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Band-By-Band decomposition
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         If [[prtbbb]] is 1, print the band-by-band decomposition of
        Born effective charges and localization tensor, in case they are computed.
        See Ph. Ghosez and X. Gonze, J. Phys.: Condens. Matter 12, 9179 (2000).
        </p>
    varname: prtbbb
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT output for BoLTZTRaP code
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Print out geometry (_BLZTRP_GEOM) and eigenenergy (_BLZTRP_EIGEN) files for the
         <a href="https://www.imc.tuwien.ac.at/forschungsbereich_theoretische_chemie/forschungsgruppen/prof_dr_gkh_madsen_theoretical_materials_chemistry/boltztrap/"> BoltzTraP code</a>
         by Georg Madsen.
        </p>
    varname: prtbltztrp
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Crystallographic Information File
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         If set to 1, a CIF file is output with the crystallographic data for the present run (cell size shape and atomic positions).
        </p>
    varname: prtcif
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]]>1': 0
        defaultval: 1
    definition: PRinT the DENsity
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value , provide output of electron density
        in real space rho(r), in units of electrons/Bohr^3.
         <br />
         If [[ionmov]]==0, the name of the density file will be
        the root output name, followed by _DEN .
         <br />
         If [[ionmov]]==1 or 2, density files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _DEN
          </li>
         </ul>
         The file structure of the unformatted output file is
        described below, see section 6).
         <br />
         If  [[prtden]] is lower than 0, two files will be printed for restart every [[prtden]]  step,
        with the names being made of
         <ul>
          <li>
           the root temporary name,
          </li>
          <li>
           followed by _DEN_x , where
        x is 0000 or 0001 alternatively.
          </li>
          <li>
           The most recent of the two files should be used for restart, and copied to root input name_DS2_DEN
          </li>
          <li>
           To perform a restart, in a multidataset mode, use ndtset 2 and jdtset 2 3 (that is 2 datasets, numbered 2 and 3)
          </li>
          <li>
           In the dataset 2, get the density you just copied (getden2 -1), perform a non selfconsistent calculation and print the wave function (prtwf2 1)
          </li>
          <li>
           In the dataset 3, get  the previous wf(getwfk3 -1), and continue the calculation
          </li>
          <li>
           This complicated procedure is due to the fact that reading the density is only allowed for a non sc calculation,
        and also for a dataset different of 0 or the previous one, the option we choose here.
          </li>
         </ul>
         Please note that in the case of PAW ([[usepaw]]=1) calculations, the _DEN density output
        is not the full physical electron density. If what is wanted is the full physical electron density, say
        for post-processing with
         <a href="../../users/aim_help.html">
          AIM
         </a>
         or visualization, prtden &gt; 1 will produce physical electron
        density or other interesting quantities (see below). Nevertheless, even in the PAW case, when chaining together
        calculations where the density from one calculation is to be used in a subsequent calculation, it is necessary
        to use the _DEN files and
         <b>
          not
         </b>
         one of the other files produced with prtden &gt; 1, i.e. _PAWDEN, ATMDEN_xxx or else.
        Note that the usual _DEN file is always generated as soon as prtden &gt;= 1.

        Options 2 to 6 for prtden are relevant only for [[usepaw]]=1 and control the output of the
        full electron density in the PAW case :
         <br />
         <br />
         <div style="margin-left: 10px; ">
          <b>
           prtden=2
          </b>
          causes generation of a file _PAWDEN that contains the bulk
          <b>
           valence
          </b>
          charge density together with the PAW on-site contributions, and has the same format as the other density files.
          <br />
          <b>
           prtden=3
          </b>
          causes generation of a file _PAWDEN that contains the bulk
          <b>
           full
          </b>
          charge density (valence+core)
          <br />
          <b>
           prtden=4
          </b>
          causes generation of three files _ATMDEN_CORE, _ATMDEN_VAL and _ATMDEN_FULL which respectively contain the core, valence and full atomic protodensity (the density of the individual component atoms in vacuum superposed at the bulk atomic positions). This can be used to generate various visualizations of the bonding density.
          <br />
          <b>
           prtden=5
          </b>
          options 2 and 4 taken together.
          <br />
          <b>
           prtden=6
          </b>
          options 3 and 4 taken together.
          <br />
          <b>
           prtden=7
          </b>
          causes the generation of all the individual contributions to the bulk
          <b>
           valence
          </b>
          charge density : n_tilde-n_hat (_N_TILDE), n_onsite (_N_ONE) and n_tilde_onsite (_NT_ONE). This is for diagnosis purposes only.
          <br />
         </div>
         <br />
         Options 3 to 6 currently require the user to supply the atomic core and valence density in external files in the working directory. The files must be named properly; for example, the files for an atom of type 1 should be named: "core_density_atom_type1.dat" and "valence_density_atom_type1.dat". The file should be a text file, where the first line is assumed to be a comment, and the subsequent lines contain two values each, where the first one is a radial coordinate and the second the value of the density n(r). Please note that it is n(r) which should be supplied,
         <b>
          not
         </b>
         n(r)/r^2. The first coordinate point must be the origin, i.e.
         <b>
          <i>
           r = 0
          </i>
         </b>
         . The atomic densities are spherically averaged, so assumed to be completely spherically symmetric, even for open shells.
         <br />
         <br />
         NOTE: in the PAW case,
         <b>
          DO NOT
         </b>
         use _PAWDEN or _ATMDEN_xxx files produced by prtden &gt; 1 to chain the density output from one
        calculation as the input to another, use the _DEN file for that.
        </p>
    varname: prtden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        defaultval: 1
    definition: PRinT integral of DENsity inside atomic SPHeres
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         When this flag is activated, values of integral(s) of total density inside sphere(s) around each atom are printed in output file (for each spin component).
        Spheres around atoms are defined by a radius given by [[ratsph]] keyword.
         <br />
         Note: integral of density inside a sphere around an atom
        can be used to determine a rough approximation of the local magnetic moment;
        this is particularly useful for antiferromagnetic systems.
         <br />
         The algorithm to compute this integral is particularly primitive : the points on the FFT grids, belonging
        to the interior of the sphere are determined, and the value of the functions on these points are summed,
        taking into account a fixed volume attributed to each point.
        In particular, the integral as a function of the radius will be a constant, except when
        a new point enters the sphere, in which case a sudden jump occurs.
        However, since the purpose of this output is to get a rough idea of the repartition of the density,
        this is not a real problem. If you are interested in a more accurate estimation
        of the density within a sphere, you should use the cut3d postprocessor.
        </p>
    varname: prtdensph
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT DIPOLE
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Print out dipole of unit cell, calculated in real space for the primitive cell only. Under development.
        </p>
    varname: prtdipole
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the Density Of States
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Provide output of Density of States if set to 1, 2 or 3.
        Can either use a smearing technique ([[prtdos]]=1),
        or the tetrahedron method ([[prtdos]]=2).
        If [[prtdos]]=3, provide output of Local Density of States inside a sphere centered on an atom,
        as well as the angular-momentum projected DOS, in the same sphere. The resolution of the linear grid of energies
        for which the DOS is computed can be tuned thanks to [[dosdeltae]].
        </p>
        <p>
         If [[prtdos]]=1, the smeared density of states is obtained
        from the eigenvalues, properly weighted at each k point
        using [[wtk]], and smeared according to [[occopt]]
        and [[tsmear]]. All levels that are present in the calculation
        are taken into account (occupied and unoccupied).
        Note that [[occopt]] must be between 3 and 7 .
        Also note that the sampling of the Brillouin Zone that is needed to get a converged DOS
        is usually much finer than the sampling needed to converge the total energy or the geometry of the system,
        unless [[tsmear]] is very large (hence the DOS is not obtained properly)..
        A separate convergence study is needed.
         <br />
         In order to compute the DOS of an insulator with [[prtdos]]=1, compute its density thanks to
        a self-consistent calculation (with a non-metallic [[occopt]]
        value, 0, 1 or 2), then use [[prtdos]]=1, together
        with [[iscf]]=-3, and a metallic [[occopt]],
        between 3 and 7, providing the needed smearing.
        If [[prtdos]]=1, the name of the DOS file is the root name for the output
        files, followed by "_DOS" .
        </p>
        <p>
         If [[prtdos]]=2, the DOS is computed using the tetrahedron method.
        As in the case of [[prtdos]]=1, all levels that are present in the calculation
        are taken into account (occupied and unoccupied). In this case, the
        k-points must have been defined using the input variable [[ngkpt]]
        or the input variable [[kptrlatt]]. There must be at least
        two non-equivalent points in the Irreducible Brillouin Zone to use  [[prtdos]]=2.
        It is strongly advised to use a non-shifted k-point grid
        ([[shiftk]] 0 0 0): such grids contain naturally
        more extremal points (band minima and maxima at Gamma or at the zone-boundaries) than
        shifted grids, and lead to more non-equivalent points than shifted grids, for the same grid spacing.

        There is no need to take care of
        the [[occopt]] or [[tsmear]] input variables,
        and there is no subtlety to be taken into account for insulators. The computation
        can be done in the self-consistent case as well as in the non-self-consistent case,
        using [[iscf]]=-3. This allows to refine the DOS at fixed
        starting density.
         <br />
         In that case, if [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _DOS (like in the [[prtdos]]=1 case).
         <br />
         However, if [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _DOS.
          </li>
         </ul>
        </p>
        <p>
         If [[prtdos]]=3, the same tetrahedron method as for [[prtdos]]=2 is used, but
        the DOS inside a sphere centered on some atom is delivered, as well as the angular-momentum
        projected (l=0,1,2,3,4) DOS in the same sphere. The preparation of this
        case, the parameters under which the computation is to be done, and the file
        denomination is similar
        to the [[prtdos]]=2 case. However, three additional input variables might be provided,
        describing the atoms that are the center of the sphere (input variables
        [[natsph]] and  [[iatsph]]), as well as the radius of this
        sphere (input variable [[ratsph]]).
         <br />
         In case of PAW, [[ratsph]] radius has to be greater or equal to
        largest PAW radius of the atom types considered (which is read from the PAW atomic data file; see rc_sph or r_paw).
        Additional printing and/or approximations in PAW mode can be controlled with [[pawprtdos]] keyword
        (in particular,[[pawprtdos]]=2 can be used to compute quickly a very good approximation of the DOS).
         <br />
         <br />
         Note 1: when [[prtdos]]=3, it is possible to output m-decomposed LDOS in _DOS file; simply use [[prtdosm]] keyword.
         <br />
         Note 2: the integrated total DOS in spheres around atoms can be obtained when
        [[prtdensph]] flag is activated.
        It can be compared to the integrated DOS provided in _DOS file when [[prtdos]]=3.
        </p>
        <p>
         [[prtdos]]=4 delivers the sphere-projected DOS (like [[prtdos]]=3), on the basis of a smearing approach (like [[prtdos]]=1)
        </p>
        <p>
         [[prtdos]]=5 delivers the spin-spin DOS in the [[nspinor]]==2 case, using the tetrahedron method (as [[prtdos]]=2).
        </p>
    varname: prtdos
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the Density Of States with M decomposition
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Relevant only when [[prtdos]]=3.
         <br />
         If set to 1, the m-decomposed LDOS is delivered in DOS file.
         <br />
         Note that [[prtdosm]] computes the M-resolved partial dos for complex spherical harmonics,giving e.g.
        DOS(L,M) == DOS(L,-M) (without spin-orbit). In the contrary, the LDA+U occupation matrix,
        see [[dmatpawu]] is in the real spherical harmonics basis.
         <br />
         If set to 2, the m-decomposed LDOS is delivered in DOS file.
         <br />
         In this case, [[prtdosm]] computes the M-resolved partial dos for real spherical harmonics
        in the same basis as the LDA+U occupation matrix.
        </p>
    varname: prtdosm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]] > 1': 0
        defaultval: 1
    definition: PRinT Electron BANDS
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        This option activates the output of the electron eigenvalues.
        Possible values:

        <ul>
        <li>0 Disable the output of the band energies.</li>
        <li>1 Write eigenvalues in xmgrace format.  A file with extension `EBANDS.agr` is produced at the end of the run.
        Use `xmgrace file_EBANDS.agr` to visualize the band energies</li>
        <li>2 Write eigenvalues in gnuplot format. The code produces a `EBANDS.dat` file with the eigenvalues and a `EBANDS.gnuplot` script.
        Use `gnuplot file_EBANDS.gnuplot` to visualize the band energies.</li>
        </ul>
    varname: prtebands
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRint Electric Field Gradient
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1, [[quadmom]]'
    section: varpaw
    text: |-
        <p>
         <ul>
          <li>
           If nonzero, calculate the electric field gradient at each atomic site in the unit cell. Using
        this option requires [[quadmom]] to be set as well.
        Values will be written to main output file (search for Electric Field Gradient). If prtefg=1,
        only the quadrupole coupling in MHz and asymmetry are reported. If prtefg=2, the full electric field
        gradient tensors in atomic units are also given, showing separate contributions from the valence
        electrons, the ion cores, and the PAW reconstruction. If prtefg=3, then in addition to the prtefg=2 output,
        the EFGs are computed using an ionic point charge model. This is useful for comparing the accurate PAW-based
        results to those of simple ion-only models. Use of prtefg=3 requires that the variable
        [[ptcharge]] be set as well.
           <br />
           The option prtefg is compatible with spin polarized calculations
        (see [[nspden]]) and also LDA+U (see [[usepawu]]).
          </li>
         </ul>
        </p>
    varname: prtefg
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]] > 1': 0
        defaultval: 1
    definition: PRinT EIGenenergies
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1, a file *_EIG, containing the
        k-points and one-electron eigenvalues is printed.
        </p>
    varname: prteig
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Electron Localization Function (ELF)
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1 or a larger value, provide output of ELF
        in real space elf(r). This is a dimensionless quantity bounded between 0 and 1.
         <br />
         The name of the ELF file will be the root output name, followed by _ELF.
         <br />
         Like a _DEN file, it can be analyzed by cut3d. However unlike densities, in case of spin polarized
        calculations, the spin down component can not be obtained by subtracting the spin up component to
        the total ELF. Hence when spin polarized calculations are performed the code produces also output files with
        _ELF_UP and _ELF_DOWN extensions. (For technical reasons these files contain also two components but the second is zero.
        So to perform analysis of _ELF_UP and _ELF_DOWN files with cut3d you have to answer "ispden= 0 ==&gt; Total density"
        when cut3d ask you which ispden to choose. Also remember that spin down component can not be obtained by using cut3d on the _ELF file.
        Sorry for the inconvenience, this will be fixed in the next release.)
         <br />
         ELF is not yet implemented in non collinear spin case.
         <br />
         If prtelf is set to 2, in the case of spin polarized calculation, the total ELF is computed from an alternative approach which should better take into account the existence of spin dependent densities (see the documentation in /doc/theory/ELF of your ABINIT repository)
         <br />
         <br />
         Please note that ELF is
         <b>
          not
         </b>
         yet implemented in the case of PAW ([[usepaw]]=1) calculations.
        </p>
    varname: prtelf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Fermi Contact term
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         <ul>
          <li>
           If set to 1,  print the Fermi contact interaction at each nuclear site, that is,
        the electron density at each site. The result appears in the main output file (search for FC).
        Note that this calculation is different than what is done by cut3d, because it also computes the
        PAW on-site corrections in addition to the contribution from the valence pseudo-wavefunctions.
          </li>
         </ul>
        </p>
    varname: prtfc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Fermi SURFace file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1, provide Fermi surface file in the BXSF format (Xcrysden)
        If [[prtfsurf]]=1, a _BXSF file readable by
         <a href="http://www.xcrysden.org">
          XCrySDen
         </a>
         will
        be produced at the end of the calculation. The file contains information on the band structure
        of the system and can be used to visualize the Fermi surface or any other energy isosurface.
        [[prtfsurf]]=1 is compatible only with SCF calculations
        ([[iscf]] &gt; 1) or NSCF runs in which the
        occupation factors and Fermi level are recalculated once convergence is achieved ([[iscf]] = -3).
        The two methods should produce the same Fermi surface provided that the k-meshes are sufficiently dense.
        The k-mesh used for the sampling of the Fermi surface can be specified using the standard
        variables [[ngkpt]], ([[shiftk]], and [[nshiftk]].
        Note, however, that the mesh must be homogeneous and centered on gamma (multiple shifts are not supported by Xcrysden)
        </p>
    varname: prtfsurf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the Gradient of electron DENsity
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value, provide output of gradient of electron density
        in real space grho(r), in units of Bohr^-(5/2).
         <br />
         The names of the gradient of electron density files will be the root output name,
        followed by _GDEN1, _GDEN2, GDEN3 for each principal direction (indeed it is a vector).
         <br />
         Like a _DEN file, it can be analyzed by cut3d. The file structure of the unformatted output file is
        described below, see section 6).
        </p>
    varname: prtgden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the GEOmetry analysis
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value, provide output of geometrical analysis
        (bond lengths and bond angles). The value
        of [[prtgeo]] is taken by the code to be the
        maximum coordination number of atoms in the system.
         <br />
         It will deduce a maximum number of "nearest" and "next-nearest"
        neighbors accordingly , and compute corresponding bond lengths.
         <br />
         It will compute bond angles for the "nearest" neighbours only.
         <br />
         If [[ionmov]]==0, the name of the file will be
        the root output name, followed by _GEO .
         <br />
         If [[ionmov]]==1 or 2, one file will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _GEO
          </li>
         </ul>
         The content of the file should be rather self-explanatory.
         <br />
         No output is provided by [[prtgeo]] is lower than or equal to 0.
         <br />
         If [[prtgeo]]&gt;0, the maximum number of atoms ([[natom]]) is 9999.
        </p>
    varname: prtgeo
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the GKK matrix elements file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1, provide output of electron-phonon "gkk" matrix
        elements, for further treatment by mrggkk utility or anaddb utility. Note that
        symmetry will be disabled for the calculation of the perturbation, forcing the
        inclusion of all k-points and all perturbation directions. Additional
        information on electron-phonon treatment in ABINIT is given in the tutorial
        ~abinit/doc/tutorial/lesson_eph.html and in ~abinit/doc/users/elphon_manual.ps
        </p>
    varname: prtgkk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: prtgsr = 0
    definition: PRinT the GSR file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p> If set to 1, ABINIT will produce a GSR file at the end of the GS
        calculation. The GSR file contains the most important GS results
        (band structure, forces, stresses, electronic density). The GSR
        file can be read by AbiPy and used for futher postprocessing.
        <br> Note that, by default, the GSR file contains the electronic density
        unless [[prtden]] is set to 0.
        </p>
    varname: prtgsr
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the Kinetic energy DENsity
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value , provide output of kinetic energy density
        in real space tau(r), in units of Bohr^-5.
         <br />
         The name of the kinetic energy density file will be the root output name, followed by _KDEN.
         <br />
         Like a _DEN file, it can be analyzed by cut3d. The file structure of the unformatted output file is
        described below (see  <a href="../../users/abinit_help.html#6">
          section 6
         </a>).
         <br />
         Note that the computation of the kinetic energy density must be activate, thanks to the input variable [[usekden]].
         <br />
         Please note that kinetic energy density is
         <b>
          not
         </b>
         yet implemented in the case of PAW ([[usepaw]]=1) calculations.
        </p>
    varname: prtkden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the K-PoinTs sets
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set /= 0 , proceeds to a detailed analysis
        of different k point grids. Works only if
        [[kptopt]] is positive, and neither
        [[kptrlatt]]
        nor
        [[ngkpt]] are defined.
        ABINIT will stop after this analysis.
        </p>
        <p>
         Different sets of k point grids are defined,
        with common values of [[shiftk]].
        In each set, ABINIT increases the length of vectors of the
        supercell (see [[kptrlatt]]) by integer
        steps. The different sets are labelled by "iset".
        For each k point grid,  [[kptrlen]]
        and  [[nkpt]] are computed (the latter always
        invoking  [[kptopt]]=1, that is, full use of
        symmetries). A series is finished when the computed
        [[kptrlen]] is twice larger than the
        input variable [[kptrlen]].
        After the examination of the different sets,
        ABINIT summarizes, for each [[nkpt]], the
        best possible grid, that is, the one with the
        largest computed [[kptrlen]].
        </p>
        <p>
         Note that this analysis is also performed when
        [[prtkpt]]=0, as soon as neither [[kptrlatt]]
        nor
        [[ngkpt]] are defined. But, in this case,
        no analysis report is given, and the code selects the grid
        with the smaller [[ngkpt]]
        for the desired [[kptrlen]]. However,
        this analysis takes some times (well sometimes,
        it is only a few seconds - it depends on the value of
        the input [[kptrlen]]), and it is better
        to examine the full analysis for a given cell and set of symmetries,
        [[shiftk]] for all the production runs.
        </p>

        <p>
        if set to -2, the code stops in invars1 after the computation of the irreducible set and
        a file named kpts.nc with the list of the k-points and the corresponding weights is produced
        </p>
    varname: prtkpt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the Laplacian of electron DENsity
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value, provide output of Laplacian of electron density
        in real space grho(r), in units of Bohr^-(7/2).
         <br />
         The name of the Laplacian of electron density file will be the root output name,
        followed by _LDEN.
         <br />
         Like a _DEN file, it can be analyzed by cut3d. The file structure of the unformatted output file is
        described below (see  <a href="../../users/abinit_help.html#6">
          section 6
         </a>).
        </p>
    varname: prtlden
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRint NABLA
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         <ul>
          <li>
           If set to 1, calculate the matrix elements &lt;Psi_n|-inabla|Psi_m&gt; and write it in file _OPT to be read by the code conducti.
          </li>
         </ul>
        </p>
    varname: prtnabla
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT NESTing function
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         If set to 1, the nesting function for the k-point grid is printed. For the moment the path in q space for the nesting function is fixed, but will become an input as well.
        </p>
    varname: prtnest
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PRinT PHonon BANDS
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        This option activates the output of the phonon frequencies in the EPH code.
        Possible values:

        <ul>
        <li>0 Disable the output of the phonon frequencies.</li>

        <li>1 Write frequencies in xmgrace format.  A file with extension `PHBANDS.agr` is produced.
        Use `xmgrace file_PHBANDS.agr` to visualize the data</li>

        <li>2 Write frequencies in gnuplot format. The code produces a `PHBANDS.dat` file with the eigenvalues and a `PHBANDS.gnuplot` script.
        Use `gnuplot file_PHBANDS.gnuplot` to visualize the phonon band structure.</li>
        </ul>
    varname: prtphbands
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: PRinT the PHonon Density Of States
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        <p>
        Print the phonon density of states.
        It is activated by default when [[optdriver]]==7.
        </p>
    varname: prtphdos
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT PHonon iso-SURFace
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        Print a bxsf file (Xcrysden format) with the (interpolated)
        phonon frequencies computed of the q-mesh determined by [[ph_ngqpt]]. The file can be use to visualize isosurfaces with Xcrysden or other similar tools supporting the bxsf format.
        Note that the (dense) q-mesh must be Gamma-centered, shifted meshs are not supported by Xcrysden.
        This variable requires [[optdriver]]==7.
    varname: prtphsurf
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT POSCAR file
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Print out VASP-style POSCAR and FORCES files, for use with PHON or frophon codes for frozen phonon calculations.
        See the associated script in ~abinit/extras/post_processing/phondisp2abi.py for further details on interfacing
        with PHON, PHONOPY, etc...
        </p>
    varname: prtposcar
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT V_XC
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set &gt;=1 , provide output of the total (Kohn-Sham) potential (sum of local pseudo-potential, Hartree potential, and xc potential).
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _POT.
         <br />
         If [[ionmov]]==1 or 2, potential file will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _POT.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/abinit_help.html#localpotfile">
          section 6.6
         </a>
         of abinit_help.
        No output is provided by a negative value of this variable.
        </p>
    varname: prtpot
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRint the PSPS file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        If set to 1, the code produces a netcdf file (PSPS.nc) with the internal tables used by Abinit to apply the pseudopotential part of the KS Hamiltonian. The data can be visualized with AbiPy.
        if prtpsps is set to -1, the code will exit after the output of the PSPS.nc file.
    varname: prtpsps
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the SPin CURrent density
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value, provide output of the current density of
        different direction spins (x,y,z) in the whole unit cell. Should require spinorial wave functions [[nspinor]]
         = 2. Experimental: this does not work yet.
        </p>
    varname: prtspcur
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the STM density
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 1  or a larger value, provide output of the electron density
        in real space rho(r), made only from the electrons
        close to the Fermi energy, in a range of energy (positive or negative), determined
        by the (positive or negative, but non-zero) value of the STM bias [[stmbias]].
         <br />
         This is a very approximate way to obtain STM profiles : one can choose an equidensity surface,
        and consider that the STM tip will follow this surface. Such equidensity surface might be determined
        with the help of Cut3D, and further post-processing of it (to be implemented). The big approximations
        of this technique are : neglect of the finite size of the tip, and
        position-independent transfer matrix elements
        between the tip and the surface.
         <br />
         The charge density is provided in units of electrons/Bohr^3.
        The name of the STM density file will be the root output name, followed by _STM .
        Like a _DEN file, it can be analyzed by cut3d.
        The file structure of this unformatted output file is
        described in
         <a href="../../users/abinit_help.html#densoutputfile">
          section 6.5
         </a>
         of abinit_help.
         <br />
         For the STM charge density to be generated, one must give, as an input file, the
        converged wavefunctions obtained from a previous run, at exactly the same k-points and cut-off energy,
        self-consistently determined, using the occupation numbers from [[occopt]]=7.
         <br />
         In the run with positive [[prtstm]], one has to use :
         <ul>
          <li>
           positive [[iscf]]
          </li>
          <li>
           [[occopt]]=7, with specification of [[tsmear]]
          </li>
          <li>
           [[nstep]]=1
          </li>
          <li>
           the [[tolwfr]] convergence criterion
          </li>
          <li>
           [[ionmov]]=0 (this is the default value)
          </li>
          <li>
           [[optdriver]]=0 (this is the default value)
          </li>
         </ul>
         <br />
         Note that you might have to adjust the value of [[nband]]
        as well, for the treatment of unoccupied states, because the automatic determination
        of [[nband]] will often not include enough unoccupied
        states.
         <br />
         When [[prtstm]] is non-zero, the stress tensor is set to zero.
         <br />
         No output of _STM file is provided by [[prtstm]] lower or equal to 0.
         <br />
         No other printing variables for density or potentials should be activated (e.g. [[prtden]] has to be set to zero).
        </p>
    varname: prtstm
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT the SUSCEPtibility file (the irreducible polarizability)
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set to 0, no _SUSC file will be produced after the screening calculation,
        only the _SCR file will be output.
        </p>
    varname: prtsuscep
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT V CouLoMB
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
        If set >= 0 outputs a file with the Coulomb potential, defined as Hartree + local Pseudopotential.
        <p>
        If <b>prtvclmb=1</b> and in case of PAW ([[usepaw]] > 0), the full core potential is added for the Hartree part, with the on-site corrections vh1 - vht1.
        <p>
        If <b>prtvclmb=2</b>, only the smooth part of the Coulomb potential is output.
        <p>
    varname: prtvclmb
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Van Der Waals file
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        Print out a NetCDF file containing a vdW-DF kernel.
        <!-- See the associated script in
        ~abinit/extras/post_processing/vdw_check_kernel for further details. -->
    varname: prtvdw
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT V_HArtree
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set &gt;=1 , provide output of the Hartree potential.
         <br />
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VHA.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VHA.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/abinit_help.html#localpotfile">
          section 6.6
         </a>
         of abinit_help.
        No output is provided by a negative value of this variable.
        </p>
    varname: prtvha
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT V_HXC
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set &gt;=1 , provide output of the
        sum of the Hartree potential and xc potential.
         <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VHXC.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VHXC.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/abinit_help.html#localpotfile">
          section 6.6
         </a>
         of abinit_help.
        No output is provided by a negative value of this variable.
        </p>
    varname: prtvhxc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT VOLume
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p> Control the volume of printed output. In particular, this
        concerns the explicit echo of eigenenergies and residuals for all
        bands and k points in the main output file.
        Also, the analysis
        of the value and location of the maximal density (and magnetization).
        <br />
        Standard choice is 0. Positive values print more in the
        output and log files, while negative values are
        for debugging (or preprocessing only), and cause
        the code to stop at some point.
        <ul>
          <li> 0 =&gt; The eigenenergies and residuals for all
        bands and k points are not echoed in the main output file.
        There are exceptions: the eigenvalues of the first k point are printed
        at the end of the SCF loop, and also,
        if [[iscf]]=-2 and [[kptopt]]&lt;=0,
        the eigenvalues for all the k points are printed anyway, for a maximum
        of 50 k-points.  Due to some subtlety, if for
         <b>some</b> dataset [[prtvol]] is non-zero, the limit for input
        and output echoes cannot be enforced, so it is like if [[prtvol]]=1
        for <b>all</b> the datasets for which [[prtvol]]
        was set to 0.</li>
           <li> 1 =&gt; the eigenvalues for the
        first 50 k-points are printed in all cases, at the end of the SCF loop.</li>
           <li> 2 =&gt; all the eigenvalues  and the
        residuals are printed at the end of the SCF loop. Also, the analysis
        of the value and location of the maximal density (and magnetization)
        is printed.</li>
           <li> 3 =&gt; Print memory information for lobpcg </li>
           <li> 4 =&gt; Like 3 and prints information of lobpcg algorithm convergence</li>
           <li> 10 =&gt; the eigenvalues are printed for
        every SCF iteration, as well as other additions (to be specified
        in the future...) </li>
        </ul>
        Debugging options :
        <ul>
         <li> = -1 =&gt; stop in abinit (main program), before call
        driver. Useful to see the effect of the preprocessing of input
        variables (memory needed, effect of symmetries, k points ...) without
        going further. Run very fast, on the order of the second.</li>
         <li>  =-2 =&gt; same as -1, except that print only the first
        dataset. All the non default input variables associated to all
        datasets are printed in the output file, but only for the first
        dataset. Also all the input variables are written in the NetCDF
        file \"OUT.nc\", even if the value is the default.</li>
         <li>  = -3 =&gt; stop in gstate, before call scfcv, move or brdmin.
        Useful to debug pseudopotentials</li>
         <li>  = -4 =&gt; stop in move, after completion of all loops</li>
         <li>  = -5 =&gt; stop in brdmin, after completion of all loops</li>
         <li>  = -6 =&gt; stop in scfcv, after completion of all loops </li>
         <li>  = -7 =&gt; stop in vtorho, after the first rho is obtained</li>
         <li>  = -8 =&gt; stop in vtowfk, after the first k point is treated</li>
         <li>  = -9 =&gt; stop in cgwf, after the first wf is optimized</li>
         <li>  = -10 =&gt; stop in getghc, after the Hamiltonian is applied once</li>
        </ul>
        This debugging feature is not yet activated in the RF routines.
        Note that [[fftalg]] offers another option for debugging.</p>
    varname: prtvol
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT VOLume for IMaGes
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Control the volume of printed output
        when an algorithm using images of the cell is used ([[nimage]]&gt;1).
         <br />
         When such an algorithm is activated, the printing volume (in output file)
        can be large and difficult to read.
         <br />
         Using
         <b>
          prtvolimg=1
         </b>
         , the printing volume, for each image,
        is reduced to unit cell, atomic positions, total energy, forces, stresses, velocities
        and convergence residuals.
         <br />
         Using
         <b>
          prtvolimg=2
         </b>
         , the printing volume, for each image,
        is reduced to total energy and convergence residuals only.
        </p>
    varname: prtvolimg
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT V_PSeudoPotential
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set &gt;=1 , provide output of the local pseudo potential.
         <br />
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VPSP.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VPSP.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/abinit_help.html#localpotfile">
          section 6.6
         </a>
         of abinit_help.
        No output is provided by a negative value of this variable.
        </p>
    varname: prtvpsp
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT V_XC
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If set &gt;=1 , provide output of the exchange-correlation potential.
        </p>
        <p>
         If [[ionmov]]==0, the name of the potential file will be
        the root output name, followed by _VXC.
         <br />
         If [[ionmov]]==1 or 2, potential files will be output
        at each time step, with the name being made of
         <ul>
          <li>
           the root output name,
          </li>
          <li>
           followed by _TIMx , where
        x is related to the timestep (see later)
          </li>
          <li>
           then followed by _VXC.
          </li>
         </ul>
         The file structure of this unformatted output file is
        described in
         <a href="../../users/abinit_help.html#localpotfile">
          section 6.6
         </a>
         of abinit_help.
        No output is provided by a negative value of this variable.
        </p>
    varname: prtvxc
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT WANT file
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Flag used to indicate that either the Wannier90 or the WanT interfaces
        will be used.
         <ul>
          <li>
           [[prtwant]]=1 =&gt; Use the
           <b>
            ABINIT- WanT
           </b>
           interface.
           <p>
            Provide an output file that can be used by the WanT postprocessing
        program (see http://www.wannier-transport.org).
        The value of the prtwant indicates the version of the WanT code that
        can read it. Currently only the value [[prtwant]]=1 is implemented,
        corresponding to WanT version 1.0.1, available since Oct. 22, 2004.
           </p>
           <p>
            Notes : Several requirements must be
        fulfilled by the wavefunction. Among them, two are mandatory:
            <br />
            <ul>
             <li>
              1. An uniform grid of k-points, including the GAMMA point must be used.
             </li>
             <li>
              2. The use of time reversal symmetry is not allowed (istwfk=1)
             </li>
             <li>
              3. The list of k-points must be ordered, such that the coordinates,
        namely three-components vectors has the third index varying the most
        rapidly, then the second index, then the first index
             </li>
            </ul>
            If these requirement are not fulfilled, the program will stop and an error message is returned.
           </p>
           <p>
            As an example of k-point grid in case of systems that have some 3D character (1D systems are easy) :
            <pre>
             nkpt 8
        kpt  0   0   0
        0   0   1/2
        0   1/2 0
        0   1/2 1/2
        1/2 0   0
        1/2 0   1/2
        1/2 1/2 0
        1/2 1/2 1/2
        istwfk 8*1
            </pre>
           </p>
           <p>
            Also, in order to use WanT as a postprocessing program for ABINIT you might have to
        recompile it with the appropriate flags (see ABINIT makefile). Up to now only
        the -convert big-endian was found to be mandatory, for machines with little-endian default choice.
           </p>
          </li>
          <li>
           [[prtwant]]=2 =&gt; Use the
           <b>
            ABINIT- Wannier90
           </b>
           interface.
           <p>
            ABINIT will produce the input files required by Wannier90  and it will
        run Wannier90 to produce the Maximally-locallized Wannier functions
        (see
            <a href="http://www.wannier.org">
             http://www.wannier.org
            </a>
            ).
           </p>
           <p>
            Notes:
            <ul>
             <li>
              The files that are created can also be used by Wannier90 in
        stand-alone mode.
             </li>
             <li>
              In order to use Wannier90 as a postprocessing program for ABINIT you
        might have to recompile it with the appropriate flags (see ABINIT
        makefile). You might use ./configure --enable-wannier90
             </li>
             <li>
              There are some other variables related to the interface of Wannier90
        and ABINIT. See,
              <a href="varw90.html">
               VARW90
              </a>
              .
             </li>
            </ul>
           </p>
           <p>
           </p>
          </li>
          <li>
           [[prtwant]]=3 =&gt; Use the
           <b>
            ABINIT- Wannier90
           </b>
           interface after converting the
        input wavefunctions to
           <b>
            [[GW]] quasiparticle
           </b>
           wavefunctions.
           <p>
            ABINIT will produce the input files required by Wannier90  and it will
        run Wannier90 to produce the Maximally-localized Wannier functions
        (see
            <a href="http://www.wannier.org">
             http://www.wannier.org
            </a>
            ).
           </p>
           <p>
            Additional Notes:
            <ul>
             <li>
              An input file of LDA wave functions is required which is completely
        consistent with the _KSS file used in the self-consistent [[GW]] calculation.
        This means that [[kssform]] 3 must be used
        to create the _KSS file and the output _WFK file from the same run must
        be used as input here.
             </li>
             <li>
              Wannier90 requires [[nshiftk]]=1, and
        [[shiftk]]= 0 0 0 is recommended.  The k-point
        set used for the [[GW]] calculation, typically the irreducible BZ set created
        using [[kptopt]]=1, and that for the Abinit-
        Wannier90 interface must be consistent.
             </li>
             <li>
              Full-BZ wavefunctions should be generated in the run calling the
        interface by setting [[kptopt]]=3,
        [[iscf]]=-2, and
        [[nstep]]=3.  This will simply use symmetry to
        transform the input IBZ wavefunctions to the full BZ set, still consistent
        with the [[GW]] _KSS input.
             </li>
             <li>
              The final _QPS file created by the self-consistent [[GW]] run is required
        as input.
             </li>
             <li>
              Any value of [[gwcalctyp]] between
        between 20 and 29 should be suitable, so, for example, Hartree-Fock
        maximally-localized Wannier functions could be generated setting
        [[gwcalctyp]]=25.
             </li>
            </ul>
           </p>
          </li>
         </ul>
        </p>
    varname: prtwant
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nimage]] > 1': 0
        defaultval: 1
    definition: PRinT the WaveFunction
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         If [[prtwf]]=1 , provide output of wavefunction
        and eigenvalue file, as described in
         <a href="../../users/abinit_help.html#wavefctfile">
          section 6.7
         </a>
         of the main abinit help file.
         <br />
         For a standard ground-state calculation, the name of the wavefunction file will be
        the root output name, followed by _WFK. If [[nqpt]]=1,
        the root name will be followed by _WFQ. For response-function calculations,
        the root name will be followed by _1WFx, where x is the number of the perturbation.
        The dataset information will be added as well, if relevant.
         <br />
         No wavefunction output is provided by [[prtwf]]=0.
         <br />
         If [[prtwf]]=-1, the code writes the wavefunction file only if convergence is not
        achieved in the self-consistent cycle.
        </p>
        <p>
         <br />
         If [[prtwf]]=2, a file pwfn.data is produced, to be used as input for the
        CASINO QMC code. See more explanation at the end of this section.
         <br />
         If [[prtwf]]=3, the file that is created is nearly the same as with [[prtwf]]=1,
        except that the records that should contain the wavefunction is empty (so, such records exist, but store nothing).
        This is useful to generate size-reduced DDK files,
        to perform an optic run. Indeed, in the latter case, only matrix elements are needed [so, no wavefunction], but possibly
        a large number of conduction bands, so that the DDK file might be huge if it contains the wavefunctions.
        </p>
        <p>
         Further explanation for the [[prtwf]]=2 case. To produce a wave function suitable for use as a CASINO trial wave
        function, certain ABINIT parameters must be set correctly. Primarily,
        CASINO (and QMC methods generally) can only take advantage of
        time-reversal symmetry, and not the full set of symmetries of the crystal
        structure. Therefore, ABINIT must be instructed to generate k-points not
        just in the Irreducible Brillouin Zone, but in a full half of the
        Brillouin Zone (using time-reversal symmetry to generate the other half).
        Additionally, unless instructed otherwise, Abinit avoids the need for
        internal storage of many of the coefficients of its wave functions for
        k-points that have the property 2k=G_latt, where G_latt is a reciprocal
        lattice vector, by making use of the property that
        c_k(G)=c^*_k(-G-G_latt). Abinit must be instructed not to do this in order
        to output the full set of coefficients for use in CASINO. See the ABINIT
        theoretical background documents ABINIT/Infos/Theory/geometry.pdf and
        ABINIT/Infos/Theory/1WF.pdf for more information.
         <br />
         The first of these requirements is met by setting the ABINIT input
        variable kptopt to 2 (see ABINIT/Infos/varbas.html#kptopt) and the second
        by setting istwfk to 1 for all the k points (see
        ABINIT/Infos/vardev.html#istwfk). Since CASINO is typically run with
        relatively small numbers of k-points, this is easily done by defining an
        array of "1" in the input file.
         <br />
         For example, for the 8 k-points generated with ngkpt 2 2 2, we add the
        following lines to the input file:
         <pre>
          # Turn off special storage mode for time-reversal k-points
        istwfk 1 1 1 1 1 1 1 1
        # Use only time reversal symmetry, not full set of symmetries.
        kptopt 2
         </pre>
         Other useful input variables of relevance to the plane waves ABINIT will
        produce include ecut, nshiftk, shiftk, nband, occopt, occ, spinat and
        nsppol (see relevant input variable documents in ABINIT/Infos/). If ABINIT
        is run in multiple dataset mode, the different wave functions for the
        various datasets are exported as pwfn1.data, pwfn2.data, ..., pwfnn.data
        where the numbers are the contents of the contents of the input array
        jdtset (defaults to 1,2,...,ndtset).
         <br />
         Once the routine is incorporated into the ABINIT package it is anticipated
        that there will be an input variable to control whether or not a CASINO
        pwfn.data file is written.
        </p>
        <p>
         Other issues related to [[prtwf]]=2.
         <br />
         The exporter does not currently work when ABINIT is used in parallel mode
        on multiple processors if k-point parallelism is
        chosen. ABINIT does not store the full wave function on each processor but
        rather splits the k-points between the processors, so no one processor
        could write out the whole file. Clearly this could be fixed but we have not
        done it yet. The sort of plane wave DFT calculations usually required to
        generate QMC trial wave functions execute very rapidly anyway and will
        generally not require a parallel machines. The outqmc routine currently
        bails out with an error if this combination of modes is selected - this
        will hopefully be fixed later.
         <br />
         There has not been very extensive testing of less common situations such
        as different numbers of bands for different k-points, and more complicated
        spin polarized systems, so care should be taken when using the output in
        these circumstances.
         <br />
         If there is any doubt about the output of this routine, the first place to
        look is the log file produced by ABINIT: if there are any warnings about
        incorrectly normalized orbitals or non-integer occupation numbers there is
        probably something set wrong in the input file.
        </p>
    varname: prtwf
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT Wavefunction file on the FULL mesh
    dimensions: scalar
    excludes: null
    requires: '[[prtwf]] == 1'
    section: varfil
    text: |-
        If  set to 1 in a ground-state calculation, the code will output another WFK file (with extension FULL_WFK) containing the wavefunctions in the full BZ as well as a text file with the tables used for the tetrahedron method.

        Note that prtwf_full requires [[prtwf]] == 1 and a ground-state
        calculation done on a homogeneous k-mesh (see [[ngkpt]] and [[shiftk]]).
        The tetrahedron table is produced only if the number of k-points in the irreducible zone ([[nkpt]]) is greater than 3.
    varname: prtwf_full
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PRinT an XML output
    dimensions: scalar
    excludes: null
    requires: null
    section: varfil
    text: |-
        <p>
         Create an XML output with common values. The corresponding
        DTD is distributed in sources as extras/post_processing/abinitRun.dtd. All the DTD is not
        yet implemented and this one is currently restricted to ground-state computations
        (and derivative such as geometry optimisation).
        </p>
    varname: prtxml
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: PoinT CHARGEs
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[usepaw]]==1 and [[prtefg]]>=3 '
    section: varpaw
    text: |-
        <p>
         <br />
         <ul>
          <li>
           Array of point charges, in atomic units, of the nuclei. In the normal computation of electric field gradients
        (see [[prtefg]]) the ionic contribution is calculated from the core charges of the atomic
        sites. Thus for example in a PAW data set for oxygen where the core is 1s<sup>2</sup>, the core charge is +6 (total nuclear charge
        minus core electron charge). In point charge models, which are much less accurate than PAW calculations, all atomic sites
        are treated as ions with charges determined by their valence states. In such a case oxygen almost always would have a
        point charge of -2. The present variable taken together with [[prtefg]] performs a full
        PAW computation of the electric field gradient and also a simple point charge computation. The user inputs whatever
        point charges he/she wishes for each atom type.
          </li>
         </ul>
        </p>
    varname: ptcharge
    vartype: real
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: PoinT GROUP number for the MAgnetic space group
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         This internal variable characterizes a Shubnikov type III magnetic space group (anti-ferromagnetic
        space group). The user is advised to consult
        "The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford."
         <br />
         A Shubnikov type III magnetic space group might be defined by its Fedorov space group
        (set of all spatial symmetries, irrespective of their magnetic action), and
        the halving space group (only the symmetries that do not change the magnetization).
         <br />
         The specification of the halving space group might be done by specifying, for each
        point symmetry, the magnetic action. See Table 7.1 of the above-mentioned reference.
        Magnetic point groups are numbered from 1 to 58.
        </p>
        <p>
         Related input variables :
        [[spgroup]],
        [[spgroupma]],
        [[genafm]]
        </p>
    varname: ptgroupma
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 1.0
    definition: Particle VELocity MAXimum
    dimensions:
    - 3
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         When [[npvel]] is larger than 0, it performs electronic stopping power calculations
        on a velocity grid along the direction determined by [[pvelmax]].
         <br />
         The vector [[pvelmax]] defines both the direction and the maximum velocity.
        [[pvelmax]] is input in Cartesian coordinates.
        </p>
    varname: pvelmax
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 40%
    definition: 'Plane Wave UNBALancing: THRESHold for balancing procedure'
    dimensions: scalar
    excludes: null
    requires: '[[paral_kgb]]==1'
    section: varpar
    text: |-
        <p>
         This parameter (in %) activates a load balancing procedure when the distribution of plane wave components
         over MPI processes is not optimal. The balancing procedure is activated when the ratio between the
         number of plane waves treated by a processor and the ideal one is higher than <i>pw_unbal_thresh</i> %.
        </p>
    varname: pw_unbal_thresh
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 10.0
    definition: Q thermostat mass
    dimensions:
    - '[[nnos]]'
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         This are the masses of the chains of [[nnos]] thermostats to be used when [[ionmov]]=13 (Molecular Dynamics) or [[imgmov]]=13 (Path Integral Molecular Dynamics).
        </p>
        <p>
         If [[ionmov]]=13 (Molecular Dynamics),
        this temperature control can be used with&nbsp;
        [[optcell]] =0, 1 (homogeneous cell deformation) or 2 (full cell deformation).
         <br />
         If [[imgmov]]=13 (Path Integral Molecular Dynamics),
        this temperature control can be used with&nbsp;
        [[optcell]] =0 (NVT ensemble) or 2 (fully flexible NPT ensemble).
        In that case, [[optcell]]=2 iS NOT USABLE yet.
        </p>
    varname: qmass
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Q-wavevector of the PERTurbation
    dimensions:
    - 3
    excludes: null
    requires: '[[vprtrb]]'
    section: varff
    text: |-
        <p>
         Gives the wavevector,
        in units of reciprocal lattice primitive translations,
        of a perturbing potential of strength [[vprtrb]].  See [[vprtrb]]
        for more explanation.
        </p>
    varname: qprtrb
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Q PoinT
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Only used if [[nqpt]]=1.
        </p>
        <p>
         Combined with [[qptnrm]],
        define the q vector [[qptn]](1:3)
        in the case [[qptopt]]=0.
        </p>
        <p>
         This input variable is not internal ([[qptn]](1:3) is used
        instead), but is used to echo the value of [[qptn]](1:3),
        with renormalisation factor one.
        </p>
    varname: qpt
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0
    definition: Q-PoinTs for the Dielectric Matrix
    dimensions:
    - 3
    - '[[nqptdm]]'
    excludes: null
    requires: '[[optdriver]]==3 and [[nqptdm]]!=0'
    section: vargw
    text: |-
        <p>
         [[qptdm]] contains the set of q-points used in the screening part of ABINIT,
        instead of the automatic generation of the q points when [[nqptdm]]=0.
        These q points are given in terms of reciprocal space primitive translations (NOT in cartesian coordinates!).
        For further explanation, see the input variable [[nqptdm]].
        </p>
    varname: qptdm
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0
    definition: Q-PoinT re-Normalized
    dimensions:
    - 3
    excludes: null
    requires: '[[nqpt]]==1'
    section: varint
    text: |-
        <p>
         Only used if [[nqpt]]=1.
         <br />
         In ground-state calculation,
        the vector [[qptn]](1:3) is added to
        each renormalized k point (whatever the value of
        [[kptopt]] that was used)
        to generate the normalized, shifted, set of k-points
        [[kptns]](1:3,1:
         <b>
          nkpt
         </b>
         ).
         <br />
         In response-function calculations,
        [[qptn]](1:3)
        is the wavevector of the phonon-type calculation.
         <br />
         [[qptn]](1:3) can be produced on the basis of
        the different methods described in [[qptopt]],
        like using [[qpt]](1:3)
        with renormalisation provided by [[qptnrm]],
        or using the other possibilities defined by
        [[iqpt]],
        [[ngqpt]],
        [[nshiftq]],
        [[qptrlatt]],
        [[shiftq]],
         <br />
         For insulators, there is no restriction on the
        q-points to be used for the perturbations. By contrast,
        for metals, for the time being, it is advised to take
        q points for which the k and k+q grids are the same
        (when the periodicity in reciprocal space is taken
        into account). Tests remain to be done to see whether
        other q points might be allowed (perhaps with some
        modification of the code).
        </p>
    varname: qptn
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: Q PoinTs NoRMalization
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Only used if [[nqpt]]=1 and [[qptopt]]=0
        </p>
        <p>
         Provides re-normalization
        of [[qpt]].
        Must be positive, non-zero.
        The actual q vector (renormalized) is
        [[qptn]](1:3)=
        [[qpt]](1:3)/[[qptnrm]].
        </p>
    varname: qptnrm
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: QPoinTs OPTion
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Only used if [[nqpt]]=1.
        </p>
        <p>
         Controls the set up to generate the Q point
        [[qptn]](1:3)
        to be used for the specific dataset,
        either as a shift of k-point grid in ground-state calculations,
        or as a stand-alone phonon wavevector.
        </p>
        <p>
         There are two basic techniques to generate the Q point : either
        by specifying it directly, possibly with a renormalisation factor ([[qptopt]]=0),
        or extracting it from a grid a Q points ([[qptopt]]=1 to 4), using the
        index [[iqpt]].
        At variance with the similar generation of k points, only ONE q point
        can be used per dataset.
        </p>
        <p>
         With [[qptopt]]=1 to 4, rely on [[ngqpt]] or
        [[qptrlatt]], as well as on
        [[nshiftq]] and
        [[shiftq]] to set up a q point
        grid, from which the q point with number [[iqpt]] will be selected.
        The values [[qptopt]]=1 to 4 differ by the treatment of symmetries. Note
        that the symmetries are
        recomputed starting from the values of [[rprimd]]
        [[xred]] and
        [[spinat]]. So, the explicit value of
        [[symrel]] are not used.
        This is to allow doing calculations with [[nsym]]=1,
        sometimes needed for T-dependent electronic structure, still decreasing
        the number of q points in the case [[qptopt]]=1 or [[qptopt]]=3.
         <ul>
          <li>
           0=&gt; read directly [[qpt]],
        and its (eventual) renormalisation factor [[qptnrm]].
          </li>
          <li>
           1=&gt;
        Take fully into account the symmetry to generate the
        grid of q points in the Irreducible Brillouin Zone only.
           <br />
           (This is the usual mode for RF calculations)
          </li>
          <li>
           2=&gt;
        Take into account only the time-reversal symmetry :
        q points will be generated in half the Brillouin zone.
           <br />
          </li>
          <li>
           3=&gt;
        Do not take into account any symmetry :
        q points will be generated in the full Brillouin zone.
           <br />
          </li>
          <li>
           4=&gt;
        Take into account all the symmetries EXCEPT the time-reversal symmetry
        to generate the k points in the Irreducible Brillouin Zone.
           <br />
          </li>
         </ul>
         In the case of a grid of q points, the auxiliary variables
        [[kptrlen]],
        [[ngkpt]]  and
        [[prtkpt]] might help
        you to select the optimal grid, similarly to the case of the K point grid.
        </p>
    varname: qptopt
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: 'Q - PoinTs grid : Real space LATTice'
    dimensions:
    - 3
    - 3
    excludes: specified([[ngqpt]])
    requires: null
    section: vargs
    text: |-
        <p>
         This input variable is used only when [[qptopt]]
        is positive. It partially defines the q point grid.
        The other piece of information is contained in
        [[shiftq]].
        [[qptrlatt]] cannot be used together with [[ngqpt]].
        </p>
        <p>
         The values [[qptrlatt]](1:3,1), [[qptrlatt]](1:3,2),  [[qptrlatt]](1:3,3)
        are the coordinates of three vectors in real space, expressed
        in the [[rprimd]] coordinate system (reduced coordinates).
        They defines a super-lattice in real space.
        The k point lattice is the reciprocal of this super-lattice,
        possibly shifted (see [[shiftq]]).
        </p>
        <p>
         If neither [[ngqpt]] nor [[qptrlatt]]
        are defined, ABINIT will automatically generate a set
        of k point grids, and select the best combination
        of [[qptrlatt]] and [[shiftq]]
        that allows to reach a sufficient value of [[kptrlen]].
        See this latter variable for a complete description of this
        procedure.
        </p>
    varname: qptrlatt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: QUADrupole MOMents
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[usepaw]]==1 and [[prtefg]]>=1 '
    section: varpaw
    text: |-
        <p>
         <ul>
          <li>
           Array of quadrupole moments, in barns, of the nuclei. These values are used in conjunction with the
        electric field gradients computed with [[prtefg]] to calculate the quadrupole
        couplings in MHz, as well as the asymmetries. Note that the electric field gradient at a nuclear site is independent of
        the nuclear quadrupole moment, thus the quadrupole moment of a nucleus can be input as 0, and the
        option [[prtefg]]=2 used to determine the electric field gradient at the site.
          </li>
         </ul>
        </p>
    varname: quadmom
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: RANDOM ATomic POSitions
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Control the inner coordinates, which can be generated randomly by using 4 different methods depending
        ont its value
         <br />
         (0) if zero, no random generation and xred are taken as they have been introduced by the user
         <br />
         (1) if one, particles are generated completly random within the unit cell.
         <br />
         (2) if two, particles are generated randomly but the inner particle distance is always larger than a factor of the
        sum of the covalent bonds between the atoms (note : this is incompatible with the definition of alchemical mixing, in which
        [[ntypat]] differs from [[npsp]])
        </p>
    varname: random_atpos
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        defaultval: 2.0
        usepaw==1:
        -   - AUTO_FROM_PSP
    definition: Radii of the ATomic SPHere(s)
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Relevant only when
        [[prtdos]]=3 or [[prtdensph]]=1.
         <br />
         <br />
         When [[prtdos]]=3:
         <br />
         Provides the radius of the spheres around the [[natsph]] atoms
        of indices [[iatsph]], in which the local
        DOS and its angular-momentum projections will be analysed.
        The choice of this radius is quite arbitrary. In a plane-wave basis set,
        there is no natural definition of an atomic sphere. However, it might be wise
        to use the following well-defined and physically motivated procedure
        (in version 4.2, this procedure is NOT implemented, unfortunately) :
        from the Bader analysis, one can define the radius of the sphere
        that contains the same charge as the Bader volume. This
        "Equivalent Bader charge atomic radius" might then be used to perform
        the present analysis.
        See the
         <a href="../../users/aim_help.html">
          <b>
           AIM (Bader)
          </b>
         </a>
         help file for more explanations.
        Another physically motivated choice would be to rely on another
        charge partitioning, like the Hirshfeld one (see the cut3d utility).
        The advantage of using charge partitioning schemes comes from the fact that the
        sum of atomic DOS, for all angular momenta and atoms, integrated on the
        energy range of the occupied states,
        gives back the total charge.
        If this is not an issue, one could rely on the half of the nearest-neighbour distances, or
        any scheme that allows to define an atomic radius. Note that the choice of this
        radius is however critical for the balance between the s, p and d components. Indeed,
        the integrated charge within a given radius, behave as a different power of the
        radius, for the different channels s, p, d. At the limit of very small radii, the s component
        dominates the charge contained in the sphere ...
         <br />
         <br />
         When [[prtdensph]]=1:
         <br />
         Provides the radius of the spheres around (all) atoms in which the total charge density will be integrated.
         <br />
         <br />
         In case of PAW, [[ratsph]] radius has to be greater or equal to
        PAW radius of considered atom type (which is read from the PAW dataset file; see rc_sph or r_paw).
        </p>
    varname: ratsph
    vartype: real
- !variable
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithunit
        units: Bohr
        value: 2.0
    definition: Radii of the ATomic SPHere(s) in the EXTRA set
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        Radius for extra spheres the DOS is projected into. See [[natsph_extra]]
        and [[xredsph_extra]]
        for the number and positions of the spheres.
    varname: ratsph_extra
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Radius of the CUT-off for coulomb interaction
    dimensions: scalar
    excludes: null
    requires: null
    section: vargw
    text: |-
        <p>
         Truncation of the Coulomb interaction in real space. The meaning of [[rcut]] is governed by the cutoff shape option [[icutcoul]].
        </p>
        <p>
         If [[rcut]] is negative, the cutoff is automatically calculated so to enclose the same volume inside the cutoff as the volume of the solid.
        </p>
    varname: rcut
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: RECursion - initial guess  of the FERMI Energy
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        In the first  SCF calculation it fixes the initial guess for the Fermi energy.
        </p>
    varname: recefermi
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: RECursion - Grid Ratio
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        It represents the ratio of the two grid step: [[recgratio]]=fine_step/coarse_step and
        it is bigger or equal than 1.  It introduces a double-grid system which permits
        to compute the electronic density on a coarse grid, using a fine grid
        (defined by [[ngfft]]) in the
        discretisation of the green kernel (see [[recptrott]]).
        Successively the density and the recursion coefficients are interpolated on the fine grid by
        FFT interpolation.  Note that ngfft/recgratio=number of points of the
        coarse grid has to be compatible with the parallelization parameters.
        </p>
    varname: recgratio
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 500
    definition: RECursion - Number of point for PATH integral calculations
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Determine the number of discretisation points to compute some path
        integral in the recursion method ; those path integrals are used to
        compute the entropy and the eigenvalues energy. during the latest SFC
        cycles.
        </p>
    varname: recnpath
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: RECursion - Number of RECursions
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Determine the maximum order of recursion, that is the dimension of the
        krylov space we use to compute density. If the precision set by
        [[rectolden]] is reached before that order, the recursion method
        automatically stops.
        </p>
    varname: recnrec
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: RECursion - TROTTer P parameter
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Determine the trotter parameter used to compute the exponential of the hamiltonian in the
        recursion method: exp(-beta*(-Delta + V)) ~ (exp(-beta/(4*recptrott)
        V) exp(-beta/(4*recptrott) Delta) exp(-beta/(4*recptrott)
        V))^(2*recptrott).
        If set to 0, we use recptrott = 1/2 in the above formula.
        Increasing [[recptrott]] improve the accuracy of the trotter formula, but
        increase the dicretisation error: it may be necessary to increase
        [[ngfft]]. The discretisation error is essentially the discretisation
        error of the green kernel exp((recptrott/beta*|r|^2)) on the ngfft
        grid.
        </p>
    varname: recptrott
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: RECursion - CUTing Radius
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        Used to improve the
        computational time in the case of the recursion method in a large
        cell: the density at a point will be computed with taking account only of
        a sphere of radius [[recrcut]].
        </p>
    varname: recrcut
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: RECursion - TEST on Electron Gas
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Used in Recursion method ([[tfkinfunc]]=2).
        It is used to test an electron gas by putting the ion potential
        equal to zero.
        </p>
    varname: rectesteg
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: Default value to be changed.
    commentdims: null
    defaultval: 0.0
    definition: RECursion - TOLerance on the difference of electronic DENsity
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
        Used in Recursion method ([[tfkinfunc]]=2).
        Sets a tolerance for differences of electronic density that, reached TWICE
        successively, will cause one SCF cycle to stop. That electronic
        density difference is computed in the infinity norm (that is, it is
        computed point-by-point, and then the maximum difference is computed).
        </p>
    varname: rectolden
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: REDuced Displacement FIELD
    dimensions:
    - 3
    excludes: null
    requires: '[[berryopt]] = 16, [[red_efield]]'
    section: varff
    text: |-
        <p>
         In case [[berryopt]]=16,
        a reduced finite electric displacement field calculation is performed. The value
        of this displacement field, and its direction is determined by [[red_dfield]].
        It must be given in atomic units.
        </p>
        <p>
         [[red_dfield]] is defined via Eq.(26) in the Supplement of M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009).
        </p>
    varname: red_dfield
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: REDuced Electric FIELD
    dimensions:
    - 3
    excludes: null
    requires: '[[berryopt]] = 16'
    section: varff
    text: |-
        <p>
         In case [[berryopt]]=16,
        a reduced finite electric displacement field calculation is performed.
        In this case, the parameter red_efield specifies the initial electric field used on the first iteration, in atomic units.
        </p>
        <p>
         [[red_efield]] is defined via Eq.(25) in the Supplement of M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009).
        </p>
    varname: red_efield
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: REDuced Electric FIELD BAR
    dimensions:
    - 3
    excludes: null
    requires: '[[berryopt]] = 14'
    section: varff
    text: |-
        <p>
         In case [[berryopt]]=14,
        a reduced finite electric field calculation is performed.
        The magnitude and direction of this electric field are determined by red_efieldbar. It must be given in atomic units.
        </p>
        <p>
         [[red_efieldbar]] is defined via Eq.(28) in the Supplement of M. Stengel, N.A. Spaldin and D. Vanderbilt, Nat. Phys. 5,304 (2009).
        </p>
    varname: red_efieldbar
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: RESTART from (X,F) history
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Control the restart of a molecular dynamics or structural
        optimization job.
         <br />
         <br />
         <b>
          restartxf&gt;0 (Deprecated)
         </b>
         :The code reads from the input wf file,
        the previous history of atomic coordinates and corresponding forces, in order
        to continue the work done by the job that produced this wf file.
        If [[optcell]]/=0, the history of
        [[acell]] and
        [[rprim]] variables is also taken into account.

        The code will take into consideration the whole history (if [[restartxf]]=1),
        or discard the few first (x,f) pairs, and begin only at the
        pair whose number corresponds to [[restartxf]].
         <br />
         Works only for [[ionmov]]=2 (Broyden) and
        when an input wavefunction file is specified, thanks to the
        appropriate values of [[irdwfk]] or [[getwfk]].
         <br />
         <br />
         NOTES :
         <br />
         * The input wf file must have been produced by a run that exited cleanly.
        It cannot be one of the temporary wf files that exist when a job crashed.
         <br />
         * One cannot restart a calculation with a non-zero [[optcell]]
        value from the (x,f) history of another run with a different non-zero [[optcell]]
         value. Starting a non-zero [[optcell]]
         run from a zero
        [[optcell]] run should work.
         <br />
         * Deprecated, the use of the new options (-1 and -2) is preferred.
         <br />
         <br />
         <b>
          restartxf=0 (Default)
         </b>
         : No restart procedure is enable
        and will start a Molecular dynamics or structural optimization
        from scratch.
         <br />
         <br />
         <b>
          restartxf=-1 (New)
         </b>
         : Use the HIST file to reconstruct
        a partial calculation. It will reconstruct the different configurations
        using the forces and stress store in the HIST file, instead of calling
        the SCF procedure.
         <br />
         Enable
         <b>
          restartxf=-1
         </b>
         from the beginning is harmless.
        The only condition is to keep the input file the same in such a way
        that the same predictor is used and it will predict the same structure
        recorded in the HIST file.
         <br />
         This option will always compute extra [[ntime]]
        iterations independent of the number of iterations recovered previously.
         <br />
         <br />
         <b>
          restartxf=-2 (New)
         </b>
         :Read the HIST file and select the atomic
        positions and cell parameters with the lowest energy. Forget all the
        history and start the calculation using those values. The original
        atomic coordinates and cell parameters are irrelevant in that case.
         <br />
         <br />
         NOTES:
         <br />
         * You can use
         <b>
          restartxf=-1 or -2
         </b>
         for all predictiors that
        make no use of random numbers.
         <br />
         * You can use
         <b>
          restartxf=-1 or -2
         </b>
         to restart a calculation
        that was not completed. The HIST file is written on each iteration. So
        you always have something to recover from.
         <br />
         * You can take advantage of the appropriate values
        of [[irdwfk]] or [[getwfk]]
         to get a good wave function
        to continue your job.
        </p>
    varname: restartxf
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Response Function : 2nd Derivative of wavefunctions with
        respect to K'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
        UNUSABLE (in development)
        </p>
        <p>
        Activates computation of second derivatives of wavefunctions with respect to wavevectors.
        This is not strictly a response function but is a needed auxiliary quantity in the calculations
        of 3rd-order derivatives of the energy (non-linear response).
        The directions for the derivatives are determined by [[rfdir]] (TO BE CORRECTED!).
         <ul>
          <li>
           0=&gt;no derivative calculation
          </li>
          <li>
           1=&gt;calculation along diagonal directions (d2/(dk_i dk_i), natom+10 is activated)
          </li>
          <li>
           2=&gt;calculation along off-diagonal directions (d2/(dk_i dk_j), natom+11 is activated)
          </li>
          <li>
           3=&gt;calculation along all directions (both natom+10 and natom+11 are activated)
          </li>
         </ul>
        </p>
    varname: rf2_dkdk
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Response Function : Acoustic Sum Rule'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Control the evaluation of the
        acoustic sum rule in effective charges and dynamical matrix at Gamma
        within a response function calculation (not active at the level of producing the DDB, but
        at the level of the phonon eigenfrequencies output).
         <ul>
          <li>
           0 =&gt; no acoustic sum rule imposed
          </li>
          <li>
           1 =&gt; acoustic sum rule imposed for dynamical matrix at Gamma, and charge neutrality imposed with
        extra charge evenly distributed among atoms
          </li>
          <li>
           2 =&gt; acoustic sum rule imposed for dynamical matrix at Gamma, and charge neutrality imposed with
        extra charge given proportionally to those atoms with
        the largest effective charge.
          </li>
         </ul>
         The treatment of the acoustic sum rule and charge neutrality sum rule is finer at the level of the ANADDB utility,
        with the two independent input variables
         <a href="../../users/anaddb_help.html#asr">
          asr
         </a>
         and
         <a href="../../users/anaddb_help.html#chneut">
          chneut
         </a>
         .
        </p>
    varname: rfasr
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    definition: 'Response Function : ATomic POLarisation'
    dimensions:
    - 2
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Control the range
        of atoms for which displacements will be considered
        in phonon calculations (atomic polarizations), using the 2n+1 theorem.
         <br />
         These values are only relevant to phonon response function
        calculations.
         <br />
         May take values from 1 to [[natom]], with [[rfatpol]](1)&lt;=[[rfatpol]](2).
         <br />
         The atoms to be moved will be defined by the
         <br />
         do-loop variable iatpol :
         <br />
         do iatpol=[[rfatpol]](1),[[rfatpol]](2)
         <br />
         For the calculation of a full dynamical matrix, use
        [[rfatpol]](1)=1 and [[rfatpol]](2)=[[natom]], together with
        [[rfdir]] 1 1 1 . For selected elements of the
        dynamical matrix, use different values of [[rfatpol]] and/or
        [[rfdir]]. The name 'iatpol' is used for the part of the
        internal variable ipert when it runs from 1 to [[natom]]. The
        internal variable ipert can also assume values larger
        than [[natom]],
        denoting perturbations of electric field or stress type (see
         <a href="../../users/respfn_help.html">
          the response function help file
         </a>
         ).
        </p>
    varname: rfatpol
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Response Function with respect to Derivative with respect to K
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Activates computation of derivatives of ground state
        wavefunctions with respect to wavevectors. This is not strictly a response
        function but is a needed auxiliary quantity in the electric field
        calculations (see [[rfelfd]]) The directions for the
        derivatives are determined by [[rfdir]].
         <ul>
          <li>
           0=&gt;no derivative calculation
          </li>
          <li>
           1=&gt;calculation of first derivatives of wavefunctions with respect to k points
        (d/dk calculation). The exact same functionality is provided by
        [[rfelfd]] = 2.
          </li>
         </ul>
        </p>
    varname: rfddk
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: 'Response Function : DIRections'
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Gives the directions
        to be considered for response function calculations
        (also for the Berry phase computation of the polarization, see
        the [[berryopt]] input variable).
         <br />
         The three elements corresponds to the three primitive
        vectors, either in real space (phonon calculations),
        or in reciprocal space (d/dk, homogeneous electric field, homogeneous magnetic field
        calculations). So, they generate a basis
        for the generation of the dynamical matrix or
        the macroscopic dielectric tensor or magnetic susceptibility and magnetic
        shielding, or the effective
        charge tensors.
         <br />
         If equal to 1, response functions, as defined
        by [[rfddk]],
        [[rfelfd]], [[rfphon]], [[rfdir]]
        and [[rfatpol]], are to be computed
        for the corresponding direction. If 0, this direction
        should not be considered.
        </p>
    varname: rfdir
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Response Function with respect to the ELectric FielD
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Turns on electric field response
        function calculations. Actually, such calculations
        requires first the non-self-consistent calculation
        of derivatives with respect to k, independently of the
        electric field perturbation itself.
         <ul>
          <li>
           0=&gt;no electric field perturbation
          </li>
          <li>
           1=&gt;full calculation, with first the
        derivative of ground-state wavefunction with
        respect to k (d/dk calculation), by a
        non-self-consistent calculation, then the generation of
        the first-order response to an homogeneous
        electric field
          </li>
          <li>
           2=&gt;only the derivative of ground-state wavefunctions with
        respect to k
          </li>
          <li>
           3=&gt;only the generation of the first-order response
        to the electric field,
        assuming that the data on derivative of ground-state
        wavefunction with respect to k is available on disk.
          </li>
         </ul>
         (Note : because the tolerances to be used for derivatives or
        homogeneous electric field are different, one often does the
        calculation of derivatives in a separate dataset, followed by
        calculation of electric field response as well as phonon.
         <br />
         The options 2 and 3 proves useful in that context ;
        also, in case a scissor shift is to be used,
        it is usually not applied for the d/dk response).
        </p>
    varname: rfelfd
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Response Function with respect to MAGNetic B-field perturbation
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         It must be equal to 1
         to run response function calculations with respect to external magnetic field.
         Currently, orbital magnetism is not taken into account and the perturbing potential
         has Zeeman form.
        </p>
    varname: rfmagn
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Response Function METHod
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Selects method used in
        response function calculations. Presently, only 1
        is allowed.
        </p>
    varname: rfmeth
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Response Function with respect to PHONons
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         It must be equal to 1
        to run phonon response function calculations.
        </p>
    varname: rfphon
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Response Function with respect to STRainS
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Used to run strain response-function
        calculations (e.g. needed to get elastic constants). Define, with
        [[rfdir]], the set of perturbations.
         <ul>
          <li>
           0=&gt;no strain perturbation
          </li>
          <li>
           1=&gt;only uniaxial strain(s) (ipert=natom+3 is activated)
          </li>
          <li>
           2=&gt;only shear strain(s) (ipert=natom+4 is activated)
          </li>
          <li>
           3=&gt;both uniaxial and shear strain(s) (both ipert=natom+3 and ipert=natom+4 are activated)
          </li>
         </ul>
         See the possible restrictions on the use of strain perturbations, in the
         <a href="../../users/respfn_help.html#1">
          respfn_help file
         </a>
         .
        </p>
    varname: rfstrs
    vartype: integer
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Response Function, USER-defined
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         Available to the developpers, to activate
        the use of ipert=natom+6 and ipert=natom+7, two sets of perturbations
        that the developpers can define.
         <br />
         <ul>
          <li>
           0=&gt;no computations for ipert=natom+6 or ipert=natom+7
          </li>
          <li>
           1=&gt;response with respect to perturbation natom+6 will be computed
          </li>
          <li>
           2=&gt;response with respect to perturbation natom+7 will be computed
          </li>
          <li>
           3=&gt;responses with respect to perturbations natom+6 and natom+7 will be computed
          </li>
         </ul>
        </p>
        <p>
         In order to define and use correctly the new perturbations,
        the developper might have to include code lines or additional routines
        at the level of the following routines :
        dfpt_cgwf.F90, dfpt_dyout.F90, dfpt_symph.F90, dfpt_dyout.F90, dfpt_etot.F90,
        littlegroup_pert.F90, dfpt_looppert.F90, dfpt_mkcor.F90, dfpt_nstdy.F90,
        dfpt_nstwf.F90, respfn.F90, dfpt_scfcv.F90, irreducible_set_pert.F90,
        dfpt_vloca.F90, dfpt_vtorho.F90, dfpt_vtowfk.F90.
        In these routines, the developper should pay a particular
        attention to the rfpert array, defined in the routine respfn.F90 ,
        as well as to the ipert local variable.
        </p>
    varname: rfuser
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: RHO QuasiParticle MIXing
    dimensions: scalar
    excludes: null
    requires: null
    section: vargw
    text: |-
        <p>
         For self-consistent [[GW]] runs, [[rhoqpmix]] sets the mixing coefficient between the new and the previous
        electronic densities.
        This mixing damps the spurious oscillations in the Hartree potential when achieving self-consistency.
        [[rhoqpmix]] is meaningful only when doing self-consistency on the wavefunctions with
        [[gwcalctyp]] &#62;&#61; 20.
        </p>
    varname: rhoqpmix
    vartype: real
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: Internally, it is represented as rprim(3,3,[[nimage]])
    defaultval:
    -   - 1
        - 0
        - 0
    -   - 0
        - 1
        - 0
    -   - 0
        - 0
        - 1
    definition: Real space PRIMitive translations
    dimensions:
    - 3
    - 3
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Give, in columnwise entry,
        the three dimensionless primitive translations in real space, to be rescaled by
        [[acell]] and [[scalecart]].
        <br />
        It is [[EVOLVING]] only if [[ionmov]]==2 and [[optcell]]/=0, otherwise it is fixed.
        <br />
         If the Default is used, that is, [[rprim]] is the unity matrix,
        the three dimensionless primitive vectors are three
        unit vectors in cartesian coordinates. Each will be (possibly) multiplied
        by the corresponding [[acell]] value, then (possibly)
        stretched along the cartesian coordinates by the corresponding [[scalecart]] value,
        to give the dimensional primitive vectors, called [[rprimd]].
         <br />
         In the general case, the dimensional cartesian
        coordinates of the crystal primitive translations R1p, R2p and R3p, see
        [[rprimd]], are
         <ul>
          <li>
           R1p(i)=[[scalecart]](i)[[rprim]](i,1)*[[acell]](1)
          </li>
          <li>
           R2p(i)=[[scalecart]](i)[[rprim]](i,2)*[[acell]](2)
          </li>
          <li>
           R3p(i)=[[scalecart]](i)[[rprim]](i,3)*[[acell]](3)
          </li>
         </ul>
         where i=1,2,3 is the component of the primitive translation (i.e. x, y, and z).
         <br />
         <br />
         The [[rprim]] variable, scaled by [[scalecart]], is thus used to define directions
        of the primitive vectors, that will be multiplied (so keeping the direction unchanged) by
        the appropriate length scale [[acell]](1), [[acell]](2),
        or [[acell]](3),
        respectively to give the dimensional primitive translations
        in real space in cartesian coordinates.
         <br />
         Presently, it is requested that the mixed product
        (R1xR2).R3 is positive. If this is not the case,
        simply exchange a pair of vectors.
         <br />
         To be more specific, keeping the default value of [[scalecart]]=1 to simplify the matter,
        [[rprim]] 1 2 3 4 5 6 7 8 9 corresponds to input of the
        three primitive translations R1=(1,2,3) (to be multiplied by [[acell]](1)), R2=(4,5,6) (to be multiplied by
        [[acell]](2)), and R3=(7,8,9) (to be multiplied by [[acell](3)).
         <br />
         Note carefully that the first
        three numbers input are the first column of [[rprim]], the next
        three are the second, and the final three are the third.
        This corresponds with the usual Fortran order for arrays.
        The matrix whose columns are the reciprocal space primitive
        translations is the inverse transpose of the matrix whose
        columns are the direct space primitive translations.
        </p>
        <p>
         Alternatively to [[rprim]], directions of dimensionless primitive
        vectors can be specified by using the input variable [[angdeg]].
        This is especially useful for hexagonal lattices (with 120 or 60 degrees angles).
        Indeed, in order for symmetries to be recognized, rprim must be symmetric up to
        [[tolsym]] (10 digits by default),
        inducing a specification such as
         <pre>
          rprim  0.86602540378  0.5  0.0
                -0.86602540378  0.5  0.0
                 0.0            0.0  1.0
         </pre>
         that can be avoided thanks to [[angdeg]]:
         <pre>
          angdeg 90 90 120
         </pre>
         <br />
         Although the use of [[scalecart]] or [[acell]] is
        rather equivalent when the primitive vectors are aligned with the cartesian directions, it is not the case for
        non-orthogonal primitive vectors. In particular, beginners often make the error of trying to use [[acell]]
        to define primitive vectors in face-centered tetragonal lattice, or body-centered tetragonal lattice, or similarly
        in face or body-centered orthorhombic lattices. Let us take the example of a body-centered tetragonal lattice, that
        might be defined using the following ("a" and "c" have to be replaced by the appropriate conventional cell vector length):
         <pre>
          rprim  "a"      0        0
                  0      "a"       0
                 "a/2"   "a/2"    "c/2"
        acell 3*1     scalecart 3*1    !  ( These are default values)
         </pre>
         The following is a valid, alternative way to define  the same primitive vectors :
         <pre>
          rprim   1        0       0
                  0        1       0
                  1/2      1/2     1/2
        scalecart  "a"  "a"  "c"
        acell 3*1    !  ( These are default values)
         </pre>
         Indeed, the cell has been stretched along the cartesian coordinates, by "a", "a" and "c" factors.
        </p>
        <p>
         At variance, the following is WRONG :
         <pre>
          rprim   1       0       0
                  0       1       0
                  1/2     1/2     1/2
        acell  "a"  "a"  "c"    !   THIS IS WRONG
        scalecart 3*1    !  ( These are default values)
         </pre>
         Indeed, the latter would correspond to :
         <pre>
          rprim  "a"      0       0
                  0      "a"      0
                 "c/2"   "c/2"   "c/2"
        acell 3*1     scalecart 3*1    !  ( These are default values)
         </pre>
         Namely, the third vector has been rescaled by "c". It is not at all in the center of the tetragonal cell whose basis vectors
        are defined by the scaling factor "a".
         <br />
         As another difference between [[scalecart]] or [[acell]],
        note that [[scalecart]] is [[INPUT_ONLY]] :
        its content will be immediately applied to rprim, at parsing time,
        and then scalecart will be set to the default values (3*1). So, in case [[scalecart]] is used,
        the echo of [[rprim]] in the output file is not the value contained in the input file,
        but the value rescaled by [[scalecart]].
        </p>
    varname: rprim
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: Internally, it is represented as rprimd(3,3,[[nimage]]).
    defaultval: null
    definition: Real space PRIMitive translations, Dimensional
    dimensions:
    - 3
    - 3
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         This internal variable gives the dimensional real space primitive
        vectors, computed from [[acell]],
        [[scalecart]],
        and [[rprim]].
         <ul>
          <li>
           R1p(i)=[[rprimd]](i,1)=[[scalecart]](i)*[[rprim]](i,1)*[[acell]](1) for i=1,2,3 (x,y,and z)
          </li>
          <li>
           R2p(i)=[[rprimd]](i,2)=[[scalecart]](i)*[[rprim]](i,2)*[[acell]](2) for i=1,2,3
          </li>
          <li>
           R3p(i)=[[rprimd]](i,3)=[[scalecart]](i)*[[rprim]](i,3)*[[acell]](3) for i=1,2,3
          </li>
         </ul>
        </p>
        It is [[EVOLVING]] only if [[ionmov]]==2 and [[optcell]]/=0, otherwise it is fixed.
        <br />
    varname: rprimd
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 1
    definition: SCALE CARTesian coordinates
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the scaling factors of cartesian coordinates by which
        dimensionless primitive translations (in "[[rprim]]") are
        to be multiplied.
        [[rprim]] input variable,
        the [[acell]] input variable,
        and the associated internal [[rprimd]] internal variable.
         <br />
         Especially useful for body-centered and face-centered tetragonal lattices, as well as
        body-centered and face-centered orthorhombic lattices, see [[rprimd]].
         <br />
         Note that this input variable is [[INPUT_ONLY]] : its content will be immediately applied to rprim, at parsing time,
        and then scalecart will be set to the default values. So, it will not be echoed.
        </p>
    varname: scalecart
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 1
    - 1
    definition: Self Consistent PHONon SUPERCELL
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Give extent, in number of primitive unit cells, of the supercell being used for
        a self-consistent phonon calculation. Presumes the phonon frequencies and eigenvectors
        have been calculated in the original primitive unit cell, on a grid of q-points which
        corresponds to the supercell in the present calculation.

        TO BE IMPROVED : should contain a tutorial on how to do self-consistent phonon calculations, David Waroquiers 090831
        </p>
    varname: scphon_supercell
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Self Consistent PHONon TEMPerature
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Temperature which is imposed on phonon distribution, in the self-consistent scheme of
        Souvatzis et al. PRL
         <b>
          100
         </b>
         , 095901. Determines the extent of the finite displacements
        used, and consequent anharmonic effects. Experimental.
        </p>
    varname: scphon_temp
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nshiftk]]>1': null
        defaultval:
        - 0.5
        - 0.5
        - 0.5
    definition: SHIFT for K points
    dimensions:
    - 3
    - '[[nshiftk]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         It is used only when [[kptopt]]&gt;=0,
        and must be defined if [[nshiftk]] is larger than 1.
         <br />
         [[shiftk]](1:3,1:[[nshiftk]]) defines
        [[nshiftk]] shifts
        of the homogeneous grid of k points
        based on [[ngkpt]] or
        [[kptrlatt]].
         <br />
         The shifts induced by [[shiftk]] corresponds
        to the reduced coordinates in the coordinate system
        defining the k-point lattice. For example,
        if the k point lattice is defined using [[ngkpt]],
        the point whose reciprocal space reduced coordinates are
        ( [[shiftk]](1,ii)/[[ngkpt]](1)
        [[shiftk]](2,ii)/[[ngkpt]](2)
        [[shiftk]](3,ii)/[[ngkpt]](3) )
        belongs to the shifted grid number ii.
        </p>
        <p>
         The user might rely on ABINIT to suggest suitable and
        efficient combinations of [[kptrlatt]]
        and [[shiftk]].
        The procedure to be followed is described with the
        input variables [[kptrlen]].
        In what follows, we suggest some interesting values of the shifts,
        to be used with even values of [[ngkpt]].
        This list is much less exhaustive than the above-mentioned automatic
        procedure.
        </p>
        <p>
         1) When the primitive vectors of the lattice do NOT form
        a FCC or a BCC lattice, the default (shifted) Monkhorst-Pack
        grids are formed by using
        [[nshiftk]]=1 and [[shiftk]] 0.5 0.5 0.5 .
        This is often the preferred k point sampling, as the shift improves the sampling efficiency.
        However, it can also break symmetry, if the 111 direction is not an axis of rotation,
        e.g. in tetragonal or hexagonal systems. Abinit will complain about this breaking, and you
        should adapt [[shiftk]].
        For a non-shifted Monkhorst-Pack grid, use
        [[nshiftk]]=1 and [[shiftk]] 0.0 0.0 0.0 ,
        which will be compatible with all symmetries, and is necessary for some features such as k-point
        interpolation.
        </p>
        <p>
         2) When the primitive vectors of the lattice form a FCC lattice,
        with [[rprim]]
         <pre>
          0.0 0.5 0.5
          0.5 0.0 0.5
          0.5 0.5 0.0
         </pre>
         the (very efficient) usual Monkhorst-Pack sampling will be generated by using
        [[nshiftk]]= 4  and [[shiftk]]
         <pre>
          0.5 0.5 0.5
          0.5 0.0 0.0
          0.0 0.5 0.0
          0.0 0.0 0.5
         </pre>
        </p>
        <p>
         3) When the primitive vectors of the lattice form a BCC lattice,
        with [[rprim]]
         <pre>
          -0.5  0.5  0.5
           0.5 -0.5  0.5
           0.5  0.5 -0.5
         </pre>
         the usual Monkhorst-Pack sampling will be generated by using
        [[nshiftk]]= 2  and [[shiftk]]
         <pre>
          0.25  0.25  0.25
         -0.25 -0.25 -0.25
         </pre>
         However, the simple sampling
        [[nshiftk]]=1 and [[shiftk]] 0.5 0.5 0.5
        is excellent.
        </p>
        <p>
         4) For hexagonal lattices with hexagonal axes, e.g. [[rprim]]
         <pre>
          1.0  0.0       0.0
         -0.5  sqrt(3)/2 0.0
          0.0  0.0       1.0
         </pre>
         one can use
        [[nshiftk]]= 1  and [[shiftk]]  0.0 0.0 0.5
        </p>
        <p>
         In rhombohedral axes, e.g. using [[angdeg]] 3*60.,
        this corresponds to [[shiftk]]  0.5 0.5 0.5, to keep the shift along the
        symmetry axis.
        </p>
    varname: shiftk
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nshiftq]]>1': null
        defaultval:
        - 0.5
        - 0.5
        - 0.5
    definition: SHIFT for Q points
    dimensions:
    - 3
    - '[[nshiftq]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         It is used only when [[qptopt]]&gt;=0,
        and must be defined if [[nshiftq]] is larger than 1.
         <br />
         [[shiftq]](1:3,1:[[nshiftq]]) defines
        [[nshiftq]] shifts
        of the homogeneous grid of q points
        based on [[ngqpt]] or
        [[qptrlatt]].
        </p>
        <p>
         See [[shiftk]] for more information on the definition,
        use, and suitable values for these shifts.
        </p>
    varname: shiftq
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: SIGN of PERMutation potential
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        +1 favors alternation of species
        -1 favors segregation
    varname: signperm
    vartype: integer
- !variable
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: jellium SLAB Wigner-Seitz RADius
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Fix the bulk-mean positive charge density n<sub>bulk</sub> of a jellium slab (if the latter is employed, e.g. [[jellslab]] &ne; 0). Often called "r<sub>s</sub>" [see for example N. D. Lang and W. Kohn PRB 1, 4555 (1970)], [[slabwsrad]] is the radius of a sphere which has the same volume as the average volume per particle in a homogeneous electron gas with density n<sub>bulk</sub>, so:
         <pre>
          1/n<sub>bulk</sub> = 4/3 Pi * [[slabwsrad]]<sup>3</sup>
         </pre>
        For example, the bulk aluminum fcc lattice constant is a=4.0495 Angstroms (webelements.com), each cubic centered cell includes 4 Al atoms and each atom has 3 valence electrons, so the average volume per electron is a<sup>3</sup>/12=37.34 Bohr<sup>3</sup> which has to be equal to 4/3 Pi*r<sub>s</sub><sup>3</sup>. Consequently Al has approximately r<sub>s</sub> =2.07 Bohr, while for example magnesium has r<sub>s</sub> =2.65 Bohr, sodium 3.99 Bohr.
        <br />
        By default, given in Bohr atomic units (1 Bohr=0.5291772108 Angstroms).
        </p>
    varname: slabwsrad
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    definition: jellium SLAB BEGinning edge along the Z direction
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
        Define the edges of the jellium slab (if used, so if [[jellslab]] &ne; 0) along z, namely the slab starts at a point along z which is expressed in Bohr by <b>slabzbeg</b> and it ends at a point expressed in Bohr by [[slabzend]]. The z direction is parallel to the third crystal primitive lattice vector which has to be orthogonal to the other ones, so the length of the cell along z is [[rprimd]](3,3). In addition <b>slabzbeg</b> and [[slabzend]] have to be such that:
         <pre>
          0 &le; <b>slabzbeg</b> &lt; [[slabzend]] &le; [[rprimd]](3,3)
         </pre>
        Together with [[slabwsrad]] they define the jellium positive charge density distribution n<sub>+</sub>(x,y,z) in this way:
         <pre>
          n<sub>+</sub>(x,y,z) = n<sub>bulk</sub>     if <b>slabzbeg</b> &le; z &le; [[slabzend]]
                    = 0        otherwise,
         </pre>
        so the positive charge density is invariant along the xy plane as well as the electrostatic potential generated by it.
        </p>
    varname: slabzbeg
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    definition: jellium SLAB ENDing edge along the Z direction
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
        Define the edges of the jellium slab (if used, so if [[jellslab]] &ne; 0) along z, namely the slab starts at a point along z which is expressed in Bohr by [[slabzbeg]] and it ends at a point expressed in Bohr by <b>slabzend</b>. The z direction is parallel to the third crystal primitive lattice vector which has to be orthogonal to the other ones, so the length of the cell along z is [[rprimd]](3,3). In addition [[slabzbeg]] and <b>slabzend</b> have to be such that:
         <pre>
          0 &le; [[slabzbeg]] &lt; <b>slabzend</b> &le; [[rprimd]](3,3)
         </pre>
        Together with [[slabwsrad]] they define the jellium positive charge density distribution n<sub>+</sub>(x,y,z) in this way:
         <pre>
          n<sub>+</sub>(x,y,z) = n<sub>bulk</sub>     if [[slabzbeg]] &le; z &le; <b>slabzend</b>
                    = 0        otherwise,
         </pre>
        so the positive charge density is invariant along the xy plane as well as the electrostatic potential generated by it.
        </p>
    varname: slabzend
    vartype: real
- !variable
    characteristics:
    - '[[RESPFN]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: SMeared DELTA function
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         When [[smdelta]] in non-zero, it will trigger the calculation of the imaginary part of the second-order electronic eigenvalues, which can be related to the electronic lifetimes. The delta function is evaluated using:
         <br />
         <ul>
          <li>
           when [[smdelta]] == 1, Fermi-Dirac smearing : 0.25_dp/(cosh(xx/2.0_dp)**2
          </li>
          <li>
           when [[smdelta]] == 2, Cold smearing by Marzari using the parameter a=-.5634 (minimization of the bump): exp(-xx2)/sqrt(pi) * (1.5d0+xx*(-a*1.5d0+xx*(-1.0d0+a*xx)))
          </li>
          <li>
           when [[smdelta]] == 3, Cold smearing by Marzari using the parameter a=-.8165 (monotonic function in the tail): as 2 but different a
          </li>
          <li>
           when [[smdelta]] == 4, Smearing of Methfessel and Paxton (PRB40,3616(1989)) with Hermite polynomial of degree 2, corresponding to "Cold smearing" of N. Marzari with a=0 (so, same smeared delta function as smdelta=2, with different a).
          </li>
          <li>
           when [[smdelta]] == 5, Gaussian smearing :  1.0d0*exp(-xx**2)/sqrt(pi)
          </li>
         </ul>
        </p>
    varname: smdelta
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: '[[npsp]]'
        value: 1
    definition: Spin-Orbit treatment for each PSeudoPotential
    dimensions:
    - '[[npsp]]'
    excludes: null
    requires: '[[nspinor]]==2 and [[usepaw]]==0'
    section: vargs
    text: |-
        <p>
         For each type of atom (each pseudopotential), specify
        the treatment of spin-orbit interaction (if [[nspinor]]==2 and Norm-conserving pseudopotentials [[usepaw]]==0)
         <br />
         If 0 : no spin-orbit interaction, even if [[nspinor]]=2
         <br />
         If 1 : treat spin-orbit as specified in the pseudopotential file.
         <br />
         If 2 : treat spin-orbit in the HGH form
        (usual form, although not allowed for all pseudopotentials)
         <br />
         If 3 : treat spin-orbit in the HFN form (Hemstreet-Fong-Nelson)
        (actually, not implemented ...).
        </p>
        <p>
        For typical usage, the default value is OK. If the spin-orbit needs to be turned off for one atom, 0 might be relevant.
        Note however, that the code will stop if [[nspinor]]=2 is used and one of the pseudopotential does not contain the information
        about the spin-orbit interaction (this is the case for some old pseudopotentials). Indeed, for spinorial calculations,
        turning off the spin-orbit interaction is unphysical, and also does not save CPU time ... It should only be done for test purposes
        </p>
        <p>
         Note that if [[nspinor]]==1, the spin-orbit cannot be treated
        anyhow, so the value of [[so_psp]] is irrelevant.
        In case [[usepaw]]=1, please refer to [[pawspnorb]].
        </p>
        <p>
         Prior to v5.4, the input variable
         <b>
          so_typat
         </b>
         was used, in place of [[so_psp]]. Because the values 0 and 1 have been switched
        between [[so_psp]] and so_typat, it was dangerous to continue to allow the use of so_typat.
        </p>
    varname: so_psp
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: SPectral BROADening
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3 and [[spmeth]]==2'
    section: vargw
    text: |-
        When a screening calculation ([[optdriver]]==3) uses a spectral representation of the irreducible polarizability in which
        the delta function is replaced by the gaussian approximant ([[spmeth]]==2), the standard deviation of the gaussian
        is given by [[spbroad]].
    varname: spbroad
    vartype: real
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'SPace Group : AXes ORientation'
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         It is taken into account only when [[spgroup]]/=0; it
        allows one to define the axes orientation
        for the specific space groups for which this is needed.
        Trigonal groups (number 146,148,155,160,161,166,167):
         <ul>
          <li>
           1 represents the hexagonal axes
          </li>
          <li>
           2 represents the rhombohedral axes
          </li>
         </ul>
         Orthorhombic space groups :
        there are six possibilities corresponding to the possible
        axes permutations
         <ul>
          <li>
           1 abc -&gt; abc
          </li>
          <li>
           2 abc -&gt; cab
          </li>
          <li>
           3 abc -&gt; bca
          </li>
          <li>
           4 abc -&gt; acb
          </li>
          <li>
           5 abc -&gt; bac
          </li>
          <li>
           6 abc -&gt; cba
          </li>
         </ul>
         Monoclinic : there are 3 or 9 possibilities depending on
        the space group. See the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         for details.
        In the log/output file the notation used to describe the
        monoclinic groups is for example:
         <br />
         15:c1, A2/a_c = C2/c
         <br />
         where,
         <ul>
          <li>
           15 represents the space group number,
          </li>
          <li>
           c1 the orientation as it appears on the web page,
          </li>
          <li>
           A is the real Bravais type lattice,
          </li>
          <li>
           2/a the existent symmetry elements,
          </li>
          <li>
           _c marks the orientation of the two-fold axis or of the mirror plane,
          </li>
          <li>
           C2/c represents the parent space group.
          </li>
         </ul>
        </p>
        <p>
         How to determine which spgaxor you need:
         <ol>
          <li>
           check the reduced positions you have, for more symmetric positions, e.g. 1/2 1/4 3/4 etc... Let us say your symmetric positions are in the first coordinate (a axis) and you are using spgroup 62.
          </li>
          <li>
           look up the raw space group Wyckoff positions on
           <a href="http://www.cryst.ehu.es/cgi-bin/cryst/programs/nph-wp-list">
            the Bilbao server
           </a>
           to see where they put the corresponding symmetric positions. For spgroup 62 Bilbao puts the 1/4 3/4 in the second coordinate, ie along the b axis.
          </li>
          <li>
           in this case you need to swap the axes from the original abc order to a new order where the Bilbao axis (b) is in the first position. In this case you have 2 possibilities, spgaxor 3 or 5. If you have more than one highly symmetric coordinate you may have only a single possibility.
          </li>
         </ol>
        </p>
    varname: spgaxor
    vartype: integer
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: 'SPace Group : ORIGin'
    dimensions: scalar
    excludes: null
    requires: '[[spgroup]]!=0'
    section: vargeo
    text: |-
        <p>
         Gives the choice of origin for the axes system.
         <br />
         It is defined according to the origin choice in the
        International Tables of Crystallography.
         <br />
         It applies only to the space groups 48, 50, 59, 70, 85, 86, 88, 125,
        126, 129, 130, 133, 134, 137, 141, 142, 201, 203, 222, 224, 227, 228.
         <br />
         For details see the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         .
        </p>
    varname: spgorig
    vartype: integer
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: SPace GROUP number
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the number of the space group.
         <br />
         If [[spgroup]] is 0, the code assumes that all the symmetries
        are input through the [[symrel]] matrices and the [[tnons]]
        vectors, or obtained from the symmetry finder (the default when
        [[nsym]]==0).
         <br />
         It should be between 1 and 230.  This option can be
        used to obtain all the atoms in the unit cell, starting
        from the asymmetric unit cell.
         <br />
         The references for computing the symmetry corresponding to
        the space groups are :
         <ul>
          <li>
           International Tables for Crystallography, 1983, Ed. Theo Hahn,
        D. Reidel Publishing Company
          </li>
          <li>
           The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford.
          </li>
         </ul>
         <br />
         For details see the space group
         <a href="../../users/spacegrouphelpfile.html">
          help file
         </a>
         .
        </p>
    varname: spgroup
    vartype: integer
- !variable
    characteristics:
    - '[[SYMMETRISER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: SPace GROUP number defining a MAgnetic space group
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         This input variable might be used to define a Shubnikov
        magnetic space group (anti-ferromagnetic space group). The user is advised to consult
        "The mathematical theory of symmetry in solids,
        Representation theory for point groups and space groups, 1972,
        C.J. Bradley and A.P. Cracknell, Clarendon Press, Oxford."
         <br />
         A Shubnikov type IV magnetic space group might be defined by its Fedorov space group
        (set of spatial symmetries that do not change the magnetization), and an additional
        magnetic space group number [[spgroupma]].
         <br />
         A Shubnikov type III magnetic space group might be defined by its Fedorov space group
        (set of all spatial symmetries, irrespective of their magnetic action), and an additional
        magnetic space group number [[spgroupma]].
         <br />
         For the additional number [[spgroupma]], we follow the definition of Table 7.4 of the
        above-mentioned Bradley and Cracknell textbook.
         <br />
         Thus, one way to specify a Shubnikov IV magnetic space group, is to define both
        [[spgroup]] and [[spgroupma]].
         <br />
         For example, the group P2_1/c_prime has [[spgroup]]=14
        and [[spgroupma]]=78.
         <br />
         Alternatively,
        for Shubnikov IV magnetic groups, one might
        define [[spgroup]] and [[genafm]].
        For both the type III and IV, one might
        define by hand the set of symmetries, using [[symrel]],
        [[tnons]] and [[symafm]].
        </p>
    varname: spgroupma
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: SPIN for AToms
    dimensions: !valuewithconditions
        '[[natrd]]<[[natom]]':
        - 3
        - '[[natrd]]'
        defaultval:
        - 3
        - '[[natom]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives the initial electronic spin-magnetization
        for each atom, in unit of h-bar/2.
        </p>
        <p>
         Note that if [[nspden]]=2,
        the z-component must be given
        for each atom, in triplets (0 0 z-component).
         <br />
         For example, the electron of an hydrogen atom
        can be spin up (0 0 1.0) or spin down (0 0 -1.0).
        </p>
        <p>
         This value is only used to create
        the first exchange and correlation potential,
        and is not used anymore afterwards.
         <br />
         It is not checked against the initial occupation numbers
        [[occ]] for each spin channel.
         <br />
         It is meant to give an easy way to break
        the spin symmetry, and to allow
        to find stable local spin fluctuations, for example :
        antiferromagnetism, or the spontaneous spatial
        spin separation of elongated H2 molecule.
         <br />
         <br />
         <li>
          If the geometry builder is used, [[spinat]] will be related
        to the preprocessed set of atoms, generated by the
        geometry builder. The user must thus foresee the effect
        of this geometry builder (see [[objarf]]).
         </li>
         <br />
         <li>
          If the geometry builder is not used, and the symmetries
        are not specified by the user ([[nsym]]=0),
        spinat will be used, if present, to determine the anti-ferromagnetic
        characteristics of the symmetry operations, see [[symafm]].
          <br />
          In case of collinear antiferromagnetism
        ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=2),
        these symmetries are used to symmetrize the density.
          <br />
          In case of non-collinear magnetism
        ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=4),
        they are also used to symmetrize the density.
        In the latter case, this strongly constrains the magnetization (imposing its direction).
        If the user want to let all degrees of freedom of the magnetization evolve, it is
        then recommended to put [[nsym]]=1.
          <br />
         </li>
         <br />
         <li>
          If the symmetries are specified, and the irreducible set of atoms
        is specified, the anti-ferromagnetic characteristics of the symmetry
        operations [[symafm]] will be used to generate
        [[spinat]] for all the non-irreducible atoms.
         </li>
         <br />
         <li>
          In the case of PAW+U calculations using the [[dmatpawu]]
        initial occupation matrix, and if [[nspden]]=4, [[spinat]] is
        also used to determine the direction of the integrated magnetization matrix.
         </li>
        </p>
    varname: spinat
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -99.99
    definition: SPIN-MAGNetization TARGET
    dimensions: scalar
    excludes: null
    requires: null
    section: varff
    text: |-
        <p>
         This input variable is active only in the
        [[nsppol]]=2 case.
        If [[spinmagntarget]] is not the "magic" value of -99.99d0, the
        spin-magnetization of the primitive cell will be fixed (or optimized, if it is not possible to impose it)
        to the value of [[spinmagntarget]], in Bohr magneton units, e.g. for an Hydrogen atom, it is 1.
         <br />
        If [[occopt]] is a metallic one, the
        Fermi energies for spin up and spin down are adjusted to give the target
        spin-polarisation (this is equivalent to an exchange splitting).
        If [[occopt]]=1 and [[nsppol]]=2,
        the occupation numbers for spin up and spin down will be adjusted to give the required
        spin-magnetization (occupation numbers are identical for all k-points, with [[occopt]]=1).
        The definition of [[spinmagntarget]] is actually requested in this case, except for the single isolated Hydrogen atom.
         <br />
         If [[spinmagntarget]] is the default one, the spin-magnetization will not be constrained,
        and will be determined self-consistently, by having the same spin up and spin down
        Fermi energy in the metallic case, while for the other cases, there will be no spin-magnetization,
        except for an odd number of electrons if [[occopt]]=1 and [[nsppol]]=2.
        </p>
        <p>
         Note : for the time being, only the spin down Fermi energy
        is written out in the main output file. In the fixed
        magnetic moment case, it differs from the
        spin up Fermi energy.
        </p>
    varname: spinmagntarget
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: SPectral METHod
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         The [[spmeth]] input variable defines the method used to calculate the irreducible
        polarizability $\chi^{(0)}_{KS}$.
        </p>
        <p>
         By default $\chi^{(0)}_{KS}$ is calculated employing the Adler-Wiser expression ([[spmeth]]=0)
        with a CPU effort that scales linearly with the number of frequencies.
        This approach is convenient when few frequencies are required, and is usually
        used in conjunction with plasmon-pole models in which only one or two frequencies are calculated,
        according to the value of [[ppmodel]].
         <br />
         Unfortunately a calculation based on the Adler-Wiser expression might be quite CPU demanding
        if the matrix elements of the self-energy operator are evaluated by performing numerically
        the convolution defining the self-energy.
        The integrand function, indeed, has poles above and below the real axis, and
        the screened interaction has to be evaluated on a dense frequency mesh in order to obtain accurate
        results.
        </p>
        <p>
         In the spectral method ([[spmeth]]=1 or 2) the irreducible polarizability is expressed as
        the Hilbert transform of the imaginary part.
        The advantage in using this approach consists in the fact that, once the spectral function is known,
        the irreducible polarizability for an arbitrary frequency can be easily obtained through inexpensive
        integrations. On the other hand an accurate evaluation of the imaginary part requires a dense
        frequency mesh due to the presence of delta functions.
        Two different approaches can be used to approximate these delta functions thus allowing the use
        of affordable frequency grids.
        </p>
        <p>
         Summarizing:
         <ul>
          <li>
           0 =&gt; use Adler-Wiser expression to calculate $\chi^{(0)}_{KS}$
          </li>
          <li>
           1 =&gt; use the spectral method approximating the delta function with a triangular approximant
        as proposed in
           <b>
            REF TO BE ADDED
           </b>
          </li>
          <li>
           2 =&gt; use spectral method but approximating the delta function with a Taylor expansion of the exponential
        as proposed in
           <b>
            REF TO BE ADDED
           </b>
          </li>
         </ul>
        </p>
    varname: spmeth
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: SPin-ORBit SCaLing
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and [[pawspnorb]]>= 1 '
    section: varpaw
    text: |-
        <p>
         Scaling of the spin-orbit interaction. The default values gives the first-principles value, while
        other values are used for the analysis of the effect of the spin-orbit interaction,
        but are not expected to correspond to any physical situation.
        </p>
    varname: spnorbscl
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Scanning Tunneling Microscopy BIAS voltage
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives, in Hartree, the
        bias of the STM tip, with respect to the sample, in order to generate
        the STM density map.
         <br />
         Used with positive [[iscf]],
        [[occopt]]=7 (metallic, gaussian),
        [[nstep]]=1 ,
        and positive [[prtstm]], this
        value is used to generate a charge density map from electrons
        close to the Fermi energy, in a (positive or negative) energy range.
        Positive [[stmbias]] will lead to the inclusion of occupied (valence) states only, while
        negative [[stmbias]] will lead to the inclusion of unoccupied (conduction) states only.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[stmbias]] has the
        '[[ENERGY]]' characteristics
        (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
        With [[occopt]]=7,
        one has also to specify an independent broadening [[tsmear]].
        </p>
    varname: stmbias
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    definition: STRess FACTor
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         The stresses multiplied
        by [[strfact]] will be treated like forces in the
        process of optimization ([[ionmov]]=2,
        non-zero
        [[optcell]]).
         <br />
         For example, the stopping criterion defined by
        [[tolmxf]] relates to these scaled
        stresses.
        </p>
    varname: strfact
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: STRING method ALGOrithm
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Relevant only when [[imgmov]]=2 (String Method).
         <br />
         Gives the variant of the String Method method used.
         <br />
         Possible values can be:
         <br />
         <ul>
          <li>
           0=&gt;
           <b>
            Original String Method
           </b>
           .
           <br />
           NOT YET IMPLEMENTED
           <br />
           <i>
            See: Phys. Rev. B 66, 052301 (2002)
           </i>
          </li>
          <br />
          <li>
           1=&gt;
           <b>
            Simplified String Method
           </b>
           with parametrization by
           <b>
            equal arc length
           </b>
           .
           <br />
           Instead of using the normal force (wr the band), the full force is used; the
        reparametrization is enforced by keeping the points of the string equally spaced.
           <br />
           <i>
            See: J. Chem. Phys. 126, 164103 (2007)
           </i>
          </li>
          <br />
          <li>
           2=&gt;
           <b>
            Simplified String Method
           </b>
           with parametrization by
           <b>
            energy-weighted arc length
           </b>
           .
           <br />
           A variant of the Simplified String Method (like 2-); the reparametrization is done by using
        energy-weight arc-lengths, giving a finer distribution near the saddle point..
           <br />
           <i>
            See: J. Chem. Phys. 126, 164103 (2007) and J. Chem. Phys. 130, 244108 (2009)
           </i>
          </li>
         </ul>
        </p>
    varname: string_algo
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: STRess PRECONditioner
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         This is a scaling factor to initialize the part of
        the Hessian related to the treatment of the stresses (optimisation
        of the unit cell). In case there is an instability, decrease the
        default value, e.g. set it to 0.1 .
        </p>
    varname: strprecon
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    - 0.0
    - 0.0
    - 0.0
    - 0.0
    definition: STRess TARGET
    dimensions:
    - 6
    excludes: null
    requires: null
    section: varrlx
    text: |-
        The components of the stress tensor must be stored
        according to :
        (1,1)-&gt;1 ; (2,2)-&gt;2 ; (3,3)-&gt;3 ; (2,3)-&gt;4 ; (3,1)-&gt;5 ;
        (1,2)-&gt;6.
        The conversion factor
        between Ha/Bohr**3 and GPa is : 1 Ha/Bohr**3 = 29421.033d0 GPa.
        <br />
        Not used if [[optcell]]==0.
    varname: strtarget
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: '[[nsym]]'
        value: 1
    definition: SYMmetries, Anti-FerroMagnetic characteristics
    dimensions:
    - '[[nsym]]'
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         In case the material is magnetic (well, this is only interesting in the
        case of antiferromagnetism, collinear or not), additional symmetries might appear, that
        change the sign of the magnetization.
        They have been introduced by Shubnikov (1951). They can be used by ABINIT
        to decrease the CPU time, by using them to decrease the number of k-points.
         <br />
         [[symafm]] should be set to +1 for all the usual symmetry operations,
        that do not change the sign of the magnetization, while it should be
        set to -1 for the magnetization-changing symmetries.
         <br />
         If the symmetry operations are not specified by the user
        in the input file, that is, if [[nsym]]=0,
        then ABINIT will use the values of [[spinat]]
        to determine the content of [[symafm]].
         <br />
         The symmetries found as "antiferro magnetic" ([[symafm]]=-1) are used to symmetrize density and magnetization in the following cases:
         <br />
         - antiferromagnetism ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=2)
         <br />
         - non-collinear magnetism ([[nsppol]]=1,
        [[nspinor]]=1,
        [[nspden]]=4)
         <br />
         In other cases they are not used.
        </p>
    varname: symafm
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: SYMmetryze \chi_o
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==3'
    section: vargw
    text: |-
        <p>
         The evaluation of the irreducible polarizability for a given q-point requires an
        integration over the Brillouin zone (BZ) which is approximated by a discrete sum over k-points.
        In principle the integrand function should be evaluated for each k-point in the BZ, however it is possible
        to reduce the number of points to be explicitly considered by taking advantage of symmetry properties.
        The development input variable [[symchi]] is used to choose between these two equivalent methods:
         <ul>
          <li>
           0=&gt; the summation over k-points is performed considering ALL the points in the BZ (useful for testing and debugging).
          </li>
          <li>
           1=&gt; the summation is restricted to the k-points belonging to the irreducible wedge
        defined by the little group associated to the external vector q.
          </li>
         </ul>
        </p>
    varname: symchi
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: SYMmetrize the DYNamical MATrix
    dimensions: scalar
    excludes: null
    requires: null
    section: vareph
    text: |-
        If symdynmat is equal to 1, the dynamical matrix is symmetrized before the diagonalization (same meaning as the corresponding anaddb variable).
        Note that symdynmat==1 will automatically enable the symmetrization of the electron-phonon linewidths.
    varname: symdynmat
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: SYMMORPHIc symmetry operations
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         With [[symmorphi]]=1, symmetry operations with a non-symmorphic vector are allowed.
        With [[symmorphi]]=0, they are not allowed.
        In the latter case, if the symmetry operations are specified in the input file, the code
        will stop and print an error message if a non-symmorphic vector is encountered.
        By contrast, if the symmetry operations are to be determined automatically
        (if [[nsym]]=0), then the set of symmetries will
        not include the non-symmorphic operations.
        </p>
        <p>
         Note : this feature exist because in a previous status of the [[GW]] calculations, non-symmorphic
        symmetry operations could not be exploited. Thus, the k points were restricted
        to the IBZ. In order to prepare [[GW]] calculations, and to perform [[GW]] calculations,
        [[symmorphi]]=0 was to be used, together with [[nsym]]=0.
        </p>
    varname: symmorphi
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[nsym]]==1':
        -   - 1
            - 0
            - 0
        -   - 0
            - 1
            - 0
        -   - 0
            - 0
            - 1
        defaultval: null
    definition: SYMmetry in REaL space
    dimensions:
    - 3
    - 3
    - '[[nsym]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives "[[nsym]]" 3x3 matrices
        expressing space group symmetries in terms of their action
        on the direct (or real) space primitive translations.
         <br />
         It turns out that these can always be expressed as integers.
         <br />
         Always give the identity matrix even if no other symmetries
        hold, e.g.
        [[symrel]] 1 0 0 0 1 0 0 0 1
         <br />
         Also note that for this array as for all others the array
        elements are filled in a columnwise order as is usual for
        Fortran.
         <br />
         The relation between the above symmetry matrices [[symrel]],
        expressed in the basis of primitive translations, and
        the same symmetry matrices expressed in cartesian coordinates,
        is as follows.  Denote the matrix whose columns are the
        primitive translations as R, and denote the cartesian
        symmetry matrix as S.  Then
         <br />
         [[symrel]] = R(inverse) * S * R
         <br />
         where matrix multiplication is implied.
         <br />
         When the symmetry finder is used (see [[nsym]]), [[symrel]]
        will be computed automatically.
        </p>
    varname: symrel
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: SYMmetrization of SIGMA matrix elements
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]]==4'
    section: vargw
    text: |-
        <p>
         This option is used to switch on the symmetrization of the self-energy matrix elements ([[symsigma]]=1).
        In this case the BZ integration defining the self-energy matrix elements is
        reduced to an appropriate irreducible wedge defined by the point group of the wave-vector k
        specified in the [[kptgw]] list.
        </p>
        <p>
         The symmetrized expression leads to a considerable speedup of the run but, unfortunately,
        this option is not yet compatible with self-consistent [[GW]] calculations
        (see [[gwcalctyp]]).
        </p>
        <p>
         The algorithm implemented in [[symsigma]]=1
        constructs a symmetric invariant for the diagonal matrix elements of the self-energy
        by simply averaging the [[GW]] results within the degenerate subspace.

        Therefore particular care has to be taken in the presence of accidental degeneracies.
        since [[GW]] calculations performed with [[symsigma]]=1 will not be able to remove
        the initial accidental degeneracy.
        </p>
    varname: symsigma
    vartype: integer
- !variable
    characteristics:
    - '[[TDDFT]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: 'Time-Dependent dft : MAXimal kohn-sham ENErgy difference'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         The Matrix to be diagonalized in the Casida framework
        (see "Time-Dependent Density Functional Response Theory of Molecular
        systems: Theory, Computational Methods, and Functionals", by M.E. Casida,
        in Recent Developments and Applications of Modern Density Functional
        Theory, edited by J.M. Seminario (Elsevier, Amsterdam, 1996).)
        is a NxN matrix, where, by default, N is the product of
        the number of occupied states by the number of unoccupied states.
         <br />
         The input variable [[td_maxene]] allows to diminish N : it selects
        only the pairs of occupied and unoccupied states for which the
        Kohn-Sham energy difference is less than [[td_maxene]].
        The default value 0.0 means that all pairs are taken into account.
         <br />
         See [[td_mexcit]] for an alternative
        way to decrease N.
        </p>
    varname: td_maxene
    vartype: real
- !variable
    characteristics:
    - '[[TDDFT]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: 'Time-Dependent dft : Maximal number of EXCITations'
    dimensions: scalar
    excludes: null
    requires: null
    section: varrf
    text: |-
        <p>
         The Matrix to be diagonalized in the Casida framework
        (see "Time-Dependent Density Functional Response Theory of Molecular
        systems: Theory, Computational Methods, and Functionals", by M.E. Casida,
        in Recent Developments and Applications of Modern Density Functional
        Theory, edited by J.M. Seminario (Elsevier, Amsterdam, 1996).)
        is a NxN matrix, where, by default, N is the product of
        the number of occupied states by the number of unoccupied states.
         <br />
         The input variable [[td_mexcit]] allows to diminish N : it selects
        the first [[td_mexcit]] pairs of occupied and unoccupied states, ordered
        with respect to increasing Kohn-Sham energy difference.
        However, when [[td_mexcit]] is zero, all pairs are allowed.
         <br />
         See [[td_maxene]]
         for an alternative
        way to decrease N.
        </p>
    varname: td_mexcit
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: Thomas-Fermi KINetic energy FUNCtional
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <ul>
          <li>
           [[tfkinfunc]]=1 : <span style="text-decoration: underline;">Thomas-Fermi</span>
        kinetic functional (explicit functional of the density) is used instead of Kohn-Sham kinetic
        energy functional (implicit functional of the density through Kohn-Sham wavefunctions).<br/>
        See Perrot F., Phys. Rev. A20,586-594 (1979)).
           </li>
          <li>
           [[tfkinfunc]]=11 : <span style="text-decoration: underline;">Thomas-Fermi-Weizsacker</span>
        kinetic functional with Gradient Corrections is used.<br/>
        The convergence of a calculation with this functional needs to be initialized from a calculation without Gradient Correction.
        This is automatically done with [[tfkinfunc]]=11. For the initialization steps, the [[tfw_toldfe]] criterion is used.
        When it is reached, then the Gradient Correction is added and the SCF cycle continues.<br/>
        Note: to obtain the convergence of a Molecular Dynamics simulation with TFW, it is necessary to find the best set of
        preconditionning parameters ([[diemix]], [[diemac]], [[dielng]]) and the best value of [[npulayit]] (if the default Pulay mixing is used).
           </li>
           <li>
           [[tfkinfunc]]=12 : same as <b>tfkinfunc</b>=11,
        but without the initialization steps. Gradient correction is directly added.
           </li>
        <li>
           [[tfkinfunc]]=2 : the <span style="text-decoration: underline;">Recursion Method</span>
        is used in order to compute electronic density, entropy, Fermi energy and eigenvalues energy.
        This method computes the density without computing any orbital, is efficient at high temperature,
        with a efficient parallelization (almost perfect scalability). When that option is in use, the
        [[ecut]] input variable is no longer a convergence parameter ;
        [[ngfft]] becomes the main convergence parameter: you should adapt ecut for the ngfft
        grid you need (it is not yet automatically computed). Other convergence parameter are for the energetic values:
        [[recnrec]], [[recptrott]], [[recnpath]].<br/>
        Since the convergence of the self-consistent cycle
        is determined directly by the convergence of the density:
        [[toldfe]], [[toldff]], [[tolrff]],
        [[tolvrs]], [[tolwfr]] are not used, and are replaced by
        [[rectolden]]; the energetic values, except for the fermi energy, are only
        computed during the latest SFC cycle : the output file will show a
        jump of the total energy at the end, but it is not because of a bad
        convergence behavior. Computational speed can be improved by the use
        of  [[recrcut]] and  [[recgratio]].
        The recursion method has not be tested in the case of non cubic cell
        or with the use of symmetries.<br/>
        In the recursion method the following variables are set to:
        [[useylm]]=1,  [[userec]]=1.
          </li>
         </ul>
        </p>
    varname: tfkinfunc
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-6 or [[toldfe]] is present
    definition: 'Thomas-Fermi-Weizsacker: TOLerance on the DiFference of total
        Energy, for initialization steps'
    dimensions: scalar
    excludes: null
    requires: '[[tfkinfunc]]=11'
    section: vardev
    text: |-
        This input variable has the same definition as [[toldfe]] and is only relevant when [[tfkinfunc]]=11.<br/>
        It sets a tolerance for absolute differences of total energy that, reached TWICE successively, will cause the
        initialization steps (without gradient correction) to stop and the gradient correction to be added.<br/>
        Can be specified in Ha (the default), Ry, eV or Kelvin, since it has the 'ENERGY' characteristics.
    varname: tfw_toldfe
    vartype: real
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[SEQUENTIAL]]': 1
        defaultval: 0
    definition: TIMing OPTion
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This input variable allows to modulate the use of the timing routines.
        </p>
        <p>
         If 0 =&gt; as soon as possible, suppresses all calls to timing routines
         <br />
         If 1 =&gt; usual timing behaviour, with short analysis, appropriate
        for sequential execution
         <br />
         If 2 =&gt; close to [[timopt]]=1, except that the analysis routine
        does not time the timer, appropriate for parallel execution.
         <br />
         If 3 =&gt; close to [[timopt]]=1, except that the different parts of the lobpcg routine are timed in detail.
         <br />
         If 4 =&gt; close to [[timopt]]=1, except that the different parts of the lobpcg routine are timed in detail.
        A different splitting of lobpcg than for [[timopt]]=-3 is provided.
         <br />
         If -1 =&gt; a full analysis of timings is delivered
         <br />
         If -2 =&gt; a full analysis of timings is delivered,
        except timing the timer
         <br />
         If -3 =&gt; a full analysis of timings is delivered, including the detailed timing of the different parts of the lobpcg routine.
        (this takes time, and is discouraged for too small runs - the timing would take more time than the run !). The timer is timed.
         <br />
         If -4 =&gt; a full analysis of timings is delivered, including the detailed timing of the different parts of the lobpcg routine.
        A different splitting of lobpcg than for [[timopt]]=-3 is provided
        (this takes time, and is discouraged for too small runs - the timing would take more time than the run !). The timer is timed.
        The sum of the independent parts is closer to 100% than for [[timopt]]=-3.
        </p>
    varname: timopt
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: TaiL maximum Number of PReConditionner Conjugate Gradient iterations
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This variable is similar to [[wvl_nprccg]]
         but for the preconditionner iterations during the tail
        corrections (see [[tl_radius]]
         </a>
         ).

        TO BE IMPROVED : all tl_* and wvl_* variables should contain a link to a tutorial, David Waroquiers 090831.
        </p>
    varname: tl_nprccg
    vartype: integer
- !variable
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: TaiL expansion RADIUS
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         In the wavelet computation case, the linkage between the grid and the
        free boundary conditions can be smoothed using an exponential
        decay. This means a correction on the energy at the end on each
        wavefunction optimisation run. If this parameter is set to zero,
        no tail computation is done. On the contrary, put it to a
        positive value makes the tail correction available. The value
        correspond to a length in atomic units being the spacial expansion
        with the exponential decay around the grid.
        </p>
    varname: tl_radius
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: Translation NON-Symmorphic vectors
    dimensions:
    - 3
    - '[[nsym]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the (nonsymmorphic) translation
        vectors associated with the symmetries expressed
        in "[[symrel]]".
         <br />
         These may all be 0, or may be fractional (nonprimitive)
        translations expressed relative to the real space
        primitive translations (so, using the "reduced" system
        of coordinates, see "[[xred]]").
        If all elements of the space
        group leave 0 0 0 invariant, then these are all 0.
         <br />
         When the symmetry finder is used (see [[nsym]]), [[tnons]]
        is computed automatically.
        </p>
    varname: tnons
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    definition: TOLerance on the DiFference of total Energy
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldff]]) or specified([[tolrff]]) or specified([[tolvrs]])
    requires: null
    section: varbas
    text: |-
        <p>
         Sets a tolerance for absolute differences
        of total energy that, reached TWICE successively,
        will cause one SCF cycle to stop (and ions to be moved).
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
        [[toldfe]] has the
        '[[ENERGY]]' characteristics.
        (1 Ha=27.2113845 eV)
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
         <br />
         Because of machine precision, it is not worth to try
        to obtain differences in energy that are smaller
        than about 1.0d-12 of the total energy.
        To get accurate stresses may be quite demanding.
         <br />
         When the geometry is optimized (relaxation of atomic positions or primitive vectors), the use of
        [[toldfe]] is to be avoided. The use of [[toldff]] or
        [[tolrff]] is by far preferable, in order to have a handle on the
        geometry characteristics. When all forces vanish by symmetry (e.g. optimization of the lattice parameters
        of a high-symmetry crystal), then place [[toldfe]] to 1.0d-12, or use (better) [[tolvrs]].
         <br />
         Since [[toldfe]], [[toldff]],
        [[tolrff]],
        [[tolvrs]] and [[tolwfr]]
        are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    varname: toldfe
    vartype: real
- !variable
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    definition: TOLerance on the DiFference of Forces
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldfe]]) or specified([[tolrff]]) or specified([[tolvrs]])
    requires: null
    section: varbas
    text: |-
        <p>
         Sets a tolerance for differences of forces
        (in hartree/Bohr) that, reached TWICE successively,
        will cause one SCF cycle to stop (and ions to be moved).
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
        This tolerance applies to any particular cartesian
        component of any atom, INCLUDING fixed ones.
        This is to be used when trying to equilibrate a
        structure to its lowest energy configuration ([[ionmov]]=2),
        or in case of molecular dynamics ([[ionmov]]=1)
         <br />
         A value ten times smaller
        than [[tolmxf]] is suggested (for example 5.0d-6 hartree/Bohr).
         <br />
         This stopping criterion is not allowed for RF calculations.
         <br />
         Since
         <b>
          toldfe
         </b>
         , [[toldff]],
        [[tolrff]],
        [[tolvrs]] and [[tolwfr]]
        are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    varname: toldff
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 5.0E-5
    definition: TOLerance on the mean total energy for IMaGes
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Sets a maximal absolute energy tolerance (in hartree, averaged over dynamic images)
        below which iterations on images (the one governed by the [[ntimimage]]
         input variable) will stop.
         <br />
         This is to be used when trying to optimize a
        population of structures to their lowest energy configuration,
        taking into account the particular algorithm defined by [[imgmov]]
         <br />
         A value of about 5.0d-5 hartree or smaller
        is suggested (this corresponds to about 3.7d-7 eV).
         <br />
         No meaning for RF calculations.
        </p>
    varname: tolimg
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: TOLerance on the MaXimal Difference in Energy
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Sets a maximal difference in energy with respect to the
          two previous steps below which
        BFGS structural relaxation iterations will stop.
         <br />
         A value of about 0.0005 eV/atom or smaller is suggested.
         <br />
         In order to use tolmxde, you should explicitly set tolmxf to 0.0.
         <br />
         No meaning for RF calculations.
        </p>
    varname: tolmxde
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5.0E-5
    definition: TOLerance on the MaXimal Force
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Sets a maximal absolute force tolerance
        (in hartree/Bohr) below which
        BFGS structural relaxation iterations will stop.
         <br />
         Can also control tolerance on stresses, when [[optcell]]
         /=0,
        using the conversion factor [[strfact]].
        This tolerance applies to any particular cartesian
        component of any atom, excluding fixed ones.
        See the parameter [[ionmov]].
         <br />
         This is to be used when trying to equilibrate a
        structure to its lowest energy configuration ( [[ionmov]]
         =2).
         <br />
         A value of about 5.0d-5 hartree/Bohr or smaller
        is suggested (this corresponds to about 2.5d-3 eV/Angstrom).
         <br />
         No meaning for RF calculations.
        </p>
    varname: tolmxf
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.005
    definition: TOLerance on the Relative Difference of Eigenenergies
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Sets a tolerance for the ratio of differences of eigenenergies
        in the line minimisation conjugate-gradient algorithm. It compares the
        decrease of the eigenenergy due to the last line minimisation, with the
        one observed for the first line minimisation.
        When the ratio is lower than [[tolrde]],
        the next line minimisations are skipped.
         <br />
         The number of line minimisations is limited by
        [[nline]] anyhow.
         <br />
         This stopping criterion is present for both GS and RF calculations.
        In RF calculations, [[tolrde]] is actually doubled before comparing with the above-mentioned
        ratio, for historical reasons.
        </p>
    varname: tolrde
    vartype: real
- !variable
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    definition: TOLerance on the Relative diFference of Forces
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldfe]]) or specified([[toldff]]) or specified([[tolvrs]])'
    requires: null
    section: varbas
    text: |-
        <p>
         Sets a tolerance for the ratio of differences of forces
        (in hartree/Bohr) to maximum force, that, reached TWICE successively,
        will cause one SCF cycle to stop (and ions to be moved) : diffor &lt; tolrff * maxfor.
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
        This tolerance applies to any particular cartesian
        component of any atom, INCLUDING fixed ones.
        This is to be used when trying to equilibrate a
        structure to its lowest energy configuration ([[ionmov]]=2),
        or in case of molecular dynamics ([[ionmov]]=1)
         <br />
         A value of 0.02 is suggested.
         <br />
         This stopping criterion is not allowed for RF calculations.
         <br />
         Since
         <b>
          toldfe
         </b>
         , [[toldff]],
        [[tolrff]],
        [[tolvrs]] and [[tolwfr]]
        are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    varname: tolrff
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-8
    definition: TOLERANCE for SYMmetries
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the tolerance on the atomic positions (reduced coordinates), primitive
        vectors, or magnetization, to be considered equivalent, thanks to symmetry operations.
        This is used in the recognition of the set of symmetries of the system,
        or the application of the symmetry operations to generate from a reduced set of atoms,
        the full set of atoms. Note that a value larger than 0.01 is considered to be unacceptable.
         <br />
         Note : ABINIT needs the atomic positions to be symmmetric to each others within 1.e-8 .
        If [[tolsym]] is set to a larger value than 1.e-8, then the input atomic coordinates
        will be automatically symmetrized by the symmetry operations that will have been found.
        </p>
    varname: tolsym
    vartype: real
- !variable
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    definition: TOLerance on the potential V(r) ReSidual
    dimensions: scalar
    excludes: specified([[tolwfr]]) or specified([[toldfe]]) or specified([[toldff]]) or specified([[tolrff]])'
    requires: null
    section: varbas
    text: |-
        <p>
         Sets a tolerance for potential
        residual that, when reached, will cause one SCF cycle
        to stop (and ions to be moved).
         <br />
         If set to zero, this stopping condition is ignored.
         <br />
         Effective only when SCF cycles are done ([[iscf]]&gt;0).
         <br />
         To get accurate stresses may be quite demanding. For simple materials with internal positions determined by symmetries,
         a value of [[tolvrs]]=10^-12 empirically leads to a very approximate 10^-6 atomic unit accuracy for the optimized lattice parameter.
        </p>
        <p>
         Additional explanation : the residual of the potential is the difference between the
        input potential and the output potential, when the latter is obtained from the density
        determined from the eigenfunctions of the input potential. When the self-consistency
        loop is achieved, both input and output potentials must be equal, and the residual
        of the potential must be zero. The tolerance on the
        potential residual is imposed by first subtracting the mean of the residual of the potential
        (or the trace of the potential matrix, if the system is spin-polarized),
        then summing the square of this function over all FFT grid points. The result should be
        lower than [[tolvrs]].
         <br />
         Since
         <b>
          toldfe
         </b>
         , [[toldff]],
        [[tolrff]],
        [[tolvrs]] and [[tolwfr]]
        are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
        </p>
    varname: tolvrs
    vartype: real
- !variable
    characteristics: null
    commentdefault: The default value implies that this stopping condition is ignored. For the SCF case, one and only one of the input tolerance criteria [[tolwfr]], [[toldff]], [[tolrff]], [[toldfe]] or [[tolvrs]] must differ from zero.
    commentdims: null
    defaultval: 0.0
    definition: TOLerance on WaveFunction squared Residual
    dimensions: scalar
    excludes: specified([[toldfe]]) or specified([[toldff]]) or specified([[tolrff]]) or specified([[tolvrs]])
    requires: null
    section: varbas
    text: |-
        <p>
         The signification of this tolerance depends on
        the basis set. In plane waves, it gives a convergence tolerance for the
        largest squared "residual" (defined below) for any
        given band.  The squared residual is:
         <br />
         <pre>
          &lt; nk|(H-E)<sup>2</sup>|nk &gt;,    E = &lt; nk|H|nk &gt;
         </pre>
         <br />
         which clearly is nonnegative and goes to 0 as
        the iterations converge to an eigenstate.
        With the squared residual expressed in
        Hartrees
         <sup>
          2
         </sup>
         (Hartrees squared), the largest squared
        residual (called residm) encountered over all bands
        and k points must be less than [[tolwfr]] for iterations
        to halt due to successful convergence.
         <br />
         Note that if [[iscf]]&gt;0, this criterion should be replaced
        by those based on [[toldfe]] (preferred for [[ionmov]]==0),
        [[toldff]]
        [[tolrff]] (preferred for [[ionmov]]/=0), or
        [[tolvrs]] (preferred for theoretical reasons!).
         <br />
         When [[tolwfr]] is 0.0, this criterion is ignored,
        and a finite value of [[toldfe]], [[toldff]]
        or [[tolvrs]] must be specified.
        This also imposes a restriction
        on taking an ion step; ion steps are not permitted
        unless the largest squared residual is less than
        [[tolwfr]], ensuring accurate forces.
         <br />
         To get accurate stresses may be quite demanding.
         <br />
         Note that the preparatory GS calculations
        before a RF calculations must be highly converged.
         <br />
         Typical values for these preparatory runs are [[tolwfr]]
        between 1.0d-16 and 1.0d-22.
        </p>
        <p>
         Note that [[tolwfr]] is often used in the test cases, but this is
         <em>
          tolwfr
         </em>
         purely for historical reasons :
        except when [[iscf]]&lt;0, other critera
        should be used.
        </p>
        <p>
         In the wavelet case (see [[usewvl]] =
        1), this criterion is the favoured one. It is based on the
        norm 2 of the gradient of the wavefunctions. Typical values
        range from 5*10
         <sup>
          -4
         </sup>
         to 5*10
         <sup>
          -5
         </sup>
         .
        </p>
        <br />
        Since
        <b>
         toldfe
        </b>
        , [[toldff]],
        [[tolrff]],
        [[tolvrs]] and [[tolwfr]]
        are aimed at the same goal (causing the SCF cycle to stop),
        they are seen as a unique input variable at reading. Hence, it is forbidden that two of these input variables
        have non-zero values for the same dataset, or generically (for all datasets).
        However, a non-zero value for one such variable for one dataset will have precedence on the non-zero value for another
        input variable defined generically.
    varname: tolwfr
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: Temperature (PHYSical) of the ELectrons
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives, in Hartree, the physical temperature of the
        system, in case [[occopt]]=4, 5, 6, or 7.
         <br />
         Can be specified in Ha (the default), Ry, eV or Kelvin, since
         <b>
          ecut
         </b>
         has the
        '[[ENERGY]]' characteristics
        (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
        One has to specify an independent broadening [[tsmear]].
        The combination of the two parameters
        [[tphysel]] and [[tsmear]] is described
        in a paper by M. Verstraete and X. Gonze, Phys. Rev. B 65, 035111 (2002).
        Note that the signification of the entropy is modified with respect
        to the usual entropy. The choice has been made to use
        [[tsmear]] as a prefactor of the entropy,
        to define the entropy contribution to the free energy.
        </p>
    varname: tphysel
    vartype: real
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    definition: Temperature of SMEARing
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives the broadening of occupation
        numbers [[occ]], in the metallic cases
        ([[occopt]]=3, 4, 5, 6 and 7).
        Can be specified in Ha (the default), eV, Ry, or Kelvin, since
        [[tsmear]] has the
        '[[ENERGY]]' characteristics
        (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
         <br />
         Default is 0.01 Ha. This should be OK using gaussian like smearings (occopt 4,5,6,7) for a free-electron
         metal like Al. For d-band metals, you may need to use less.
         <br />
         Always check the convergence of the calculation
        with respect to this parameter, and simultaneously,
        with respect to the sampling of k-points (see [[nkpt]])
         <br />
         If [[occopt]]=3, [[tsmear]] is the
        physical temperature, as the broadening is based on Fermi-Dirac statistics.
        However,
        if [[occopt]]=4, 5, 6, or 7,
        the broadening is not based on Fermi-Dirac statistics, and
        [[tsmear]] is only a convergence parameter. It is still possible
        to define a physical temperature, thanks to the input variable
        [[tphysel]]. See the paper
        by M. Verstraete and X. Gonze, Phys. Rev. B (2002).
        </p>
    varname: tsmear
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[natom]]==1': 1
        defaultval: null
    definition: TYPE of atoms
    dimensions: !valuewithconditions
        '[[natrd]]<[[natom]]':
        - 3
        - '[[natrd]]'
        defaultval:
        - 3
        - '[[natom]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Array giving an integer label to every atom in the unit
        cell to denote its type.
         <br />
         The different types of atoms
        are constructed from the pseudopotential files.
        There are at most [[ntypat]] types of atoms.
         <br />
         As an example, for BaTiO3, where the pseudopotential for Ba is number 1,
        the one of Ti is number 2, and the one of O is number 3, the actual
        value of the [[typat]] array might be :
         <pre>
          typat 1 2 3 3 3
         </pre>
         <br />
         The array [[typat]] has to agree with the actual locations
        of atoms given in [[xred]] , [[xcart]] or
        [[xangst]], and the input
        of pseudopotentials has to be ordered to agree with the
        atoms identified in [[typat]].
         <br />
         The nuclear charge of the
        elements, given by the array [[znucl]], also must agree with
        the type of atoms designated in "[[typat]]".
         <br />
         The array [[typat]] is
        not constrained to be increasing. An
        internal representation of the list of atoms,
        deep in the code (array atindx), groups the atoms of same type
        together. This should be transparent to the
        user, while keeping efficiency.
        </p>
    varname: typat
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: calculation of the screened interaction U with the Constrained RPA method
    dimensions: scalar
    excludes: null
    requires: '[[nspinor]] == 1'
    section: vargw
    text: |-
        <p>
         When equal to one or two, this variable allows for the calculation of U with the cRPA method.
        An explicit test is shown in automatic tests v7/t23-t24-t25 and in v7/t68-t69.
        The present implementation is parallelized (as for usual [[GW]] calculations), use symetry over k-points only for calculations involving one correlated atom,
        and can be use when correlated bands are entangled or not.
        The constrained calculation of the polarisability can be done by eliminating
        transition betweens correlated bands (and not orbitals) with the variable [[ucrpa_bands]].
        </p>
        <p>
         For [[ucrpa]] = 1, two solutions are possible. The first one is to specify
        (with the variable [[ucrpa_bands]]) the bands to exclude from the polarisability calculation.
        The second solution is to provide an energy window (with the variable [[ucrpa_window]]). The electronic transitions
        inside this window will not be taken into account in
        the polarisability calculation.
        </p>
        <p>
         For [[ucrpa]] = 2, the ucrpa_bands should be equal to the [[dmftbandi]] and [[dmftbandf]]
        values, and the polarisability of the correlated subspace
        is constructed with a band and k-point dependent weight.
        </p>
        <p>
        The implementation is restricted to the case of [[nspinor]] = 1 (collinear case).
        </p>
        <p>
        A short presentation of the method and some aspect of the implementation can be found in Section II and Appendix A of
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.89.125110">
          B. Amadon, T. Applencourt and F. Bruneval Phys. Rev. B 89, 125110 (2014)
         </a>
         .
        </p>
        <p>
        </p>
    varname: ucrpa
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: That is, the default includes no band.
    commentdims: null
    defaultval:
    - -1
    - -1
    definition: For the calculation of U with the Constrained RPA method, gives correlated BANDS
    dimensions:
    - 2
    excludes: null
    requires: null
    section: vargw
    text: |-
        <p>
         Gives the first and last correlated bands for the cRPA calculation of the polarisability.
        </p>
        <p>
        </p>
    varname: ucrpa_bands
    vartype: integer
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: That is, the energy window is empty by default.
    commentdims: null
    defaultval:
    - -1
    - -1
    definition: For the calculation of U with the Constrained RPA method, gives energy WINDOW
    dimensions:
    - 2
    excludes: null
    requires: null
    section: vargw
    text: |-
        <p>
         Specify a window of energy for the cRPA calculation of the polarisability.
        The transition inside this window will not be taken into account in the constrained polarisabilty calculations.
        </p>
        The lower bound and the upper bound energies must be specified (two real numbers) with respect to the position of the Fermi level.
        <p>
        </p>
    varname: ucrpa_window
    vartype: real
- !variable
    characteristics: null
    commentdefault: It is not used when it is not defined
    commentdims: null
    defaultval: null
    definition: Upper limit on DaTa SETs
    dimensions:
    - 2
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Used to define the set of indices in the multi-data set
        mode, when a double loop is needed (see later).
         <br />
         The values of [[udtset]](1) must be between 1 and 999,
        the values of [[udtset]](2) must be between 1 and 9, and their
        product must be equal to [[ndtset]].
         <br />
         The values of [[jdtset]] are obtained by
        looping on the two indices defined by [[udtset]](1) and  [[udtset]](2) as follows :
         <pre>
          do i1=1,intarr(1)
           do i2=1,intarr(2)
            idtset=idtset+1
            dtsets(idtset)%jdtset=i1*10+i2
           end do
          end do
         </pre>
         So, [[udtset]](2) sets the largest value for the unity digit, that varies between 1 and [[udtset]](2).
         <br />
         If [[udtset]] is used, the input variable [[jdtset]] cannot be used.
        </p>
    varname: udtset
    vartype: integer
- !variable
    characteristics:
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: value of U for PAW+U
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    section: varpaw
    text: |-
        <p>
         Gives the value of the
        screened coulomb interaction between correlated electrons corresponding
        to [[lpawu]] for each species.
         <br />
         In the case where
        [[lpawu]]
        =-1, the value is not used.
         <br />
         In the case of a [[GW]] calculation, the U interaction defined by [[upawu]] will be REMOVED from the self energy.
        In particular, for G0 W0 calculations (perturbative calculations), the energy eigenvalues obtained
        after an underlying DFT+U calculation will be
         <br />
         E_[[GW]] = E_DFT+U + &lt; phi | Self-energy - U | phi&gt;
         <br />
         Actually, in order to perform a [[GW]] @ DFT+U calculation, one should define the same value of U in the self-energy calculation,
        than the one defined in the DFT calculation.
        The easiest is actually to define the value of U for the whole set of calculations (for the different datasets),
        including the screening, even if the U value does not play explicitly a role in the computation of the latter (well, the input
        wavefunctions will be different anyhow).
         <br />
         It is possible to perform calculations of the type [[GW]]+U_prime @ DFT+U , so keeping a U interaction  (usually smaller than the initial U)
        in the [[GW]] calculation, by defining a smaller U than the one used in the DFT calculation. This value will be subtracted in the [[GW]] correction calculation,
        as outlined above.
         <br />
         Explicitly, in order to do a calculation of a material with a DFT U value of 7.5 eV, followed by a [[GW]] calculation where there is a residual
        U value of 2 eV, one has to define :
         <pre>
          uldau1   7.5 eV   ! This is for the DFT calculation
        ...
        optdriver4  4
        uldau4   5.5 eV   ! This is for the screening calculation
         </pre>
        </p>
    varname: upawu
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: because it is not usually worth using it unless bandpp is large and it requires additional memory
    commentdims: null
    defaultval: 0
    definition: USE the GEMM routine for the application of the NON-Local OPerator
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         This keyword tells abinit to use a BLAS routine to speed up the computation of the non-local operator. This requires the precomputation of a large matrix, and has a significant memory overhead. In exchange, it provides improved performance when used on several bands at once (Chebyshev or LOBPCG algorithm with [[bandpp]]
        <p>
         The memory overhead is proportional to the number of atoms, the number of plane waves, and the number of projectors per atom. It can be mitigated by distributing the array with
         [[npfft]]
        </p>
        <p>
         The performance depends crucially on having a good BLAS installed. Provided the BLAS supports OpenMP, this option also yields very good scaling for the nonlocal operator.
        </p>
    varname: use_gemm_nonlop
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[optdriver]]==0 and [[CUDA]]': 1
        defaultval: 0
    definition: activate USE of GPU accelerators with CUDA (nvidia)
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         Only available if ABINIT executable has been compiled with cuda nvcc compiler.
         <br />
         This parameter activates the use of NVidia graphic accelerators (GPU) if present.
         <br />
         If [[use_gpu_cuda]] = 1, some parts of the computation are transmitted to the GPUs.
         <br />
         If [[use_gpu_cuda]] = 0, no computation is done on GPUs, even if present.
         <br />
         <br />
         Note that, while running ABINIT on GPUs, it is recommended to use MAGMA external library
        (i.e. Lapack on GPUs). The latter is activated during compilation stage (see "configure"
        step of ABINIT compilation process). If MAGMA is not used, ABINIT performances on GPUs
        can be poor.
        </p>
    varname: use_gpu_cuda
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: Default is 0 for the moment. Do not use non-scf method.
    commentdims: null
    defaultval: 0
    definition: USE NON-SCF calculation of GKK matrix elements (electron phonon)
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         When this flag is activated during a phonon calculation with abinit, all of the perturbations are cycled through, but only the symmetry-irreducible ones are calculated self-consistently. For the others the perturbed density is rotated by the appropriate symop and the gkk matrix elements are calculated non-self-consistently. As they do not depend on the perturbed wave functions, they are correct from the first iteration, and nstep is set to 1 for those perturbations. Note that the resulting 1DEN files are simply the rotate/symmetric ones and that the resulting 1WF files are garbage (completely unconverged) except the matrix elements in the header (equivalent to GKK files, but please use the latter much smaller files for el-ph calculations). The new default behavior with [[use_nonscf_gkk]] = 1 should be transparent for the user, with the same output files but a much quicker execution.
        </p>
        <p>
         Caveat: Note that very tight convergence of ground state and phonon calculations is necessary to get good GKK matrix elements! [[tolwfr]] = 1.e-24 or so is recommended everywhere. There may be problems using use_nonscf_gkk = 1 with non-symmorphic symmetries - please check (at least) that lifetimes for phonons go to 0 for acoustic modes at Gamma.
        </p>
    varname: use_nonscf_gkk
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE ScaLapacK
    dimensions: scalar
    excludes: null
    requires: null
    section: varpar
    text: |-
        <p>
         If set to 1, enable the use of ScaLapack within LOBPCG.
        </p>
    varname: use_slk
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE of an initial Density MATrix in Paw+U
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1 and [[usepawu]]==1'
    section: varpaw
    text: |-
        <p>
         When [[usedmatpu]]/=0, an initial density matrix (given by [[dmatpawu]]
        keyword) is used and kept fixed during the first ABS([[usedmatpu]]) SCF steps.
         <br />
         This starting value of the density matrix can be useful to find the correct ground state.
        Within LDA+U formalism, finding the minimal energy of the system is tricky; thus it is advised to test several values
        of the initial density matrix.
         <br />
         Note also that the density matrix has to respect some symmetry rules determined by the space group.
        If the symmetry is not respected in the input, the matrix is however automatically symmetrised.
         <br />
         <br />
         The sign of [[usedmatpu]] has influence only when [[ionmov]]/=0 (dynamics or relaxation):
         <br />
         - When [[usedmatpu]]&gt;0, the density matrix is kept constant only at first ionic step
         <br />
         - When [[usedmatpu]]&lt;0, the density matrix is kept constant at each ionic step
         <br />
        </p>
    varname: usedmatpu
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE Dynamical Mean Field Theory
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         If set to 1, enable the use of DFT+DMFT, see in particular the important variables
        [[dmft_solv]],
        [[dmftbandi]],
        [[dmftbandf]],
        [[dmft_nwli]],
        [[dmft_nwlo]],
        [[dmft_tollc]],
        [[dmft_tolfreq]],
        and [[dmft_iter]].
        </p>
        <p>
         The current implementation uses Wannier functions obtained from
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">
          projected local orbitals
         </a>
         as correlated orbitals (see [[dmftbandi]]  and [[dmftbandf]] input variables to define them).
        </p>
        <p>
         The Green functions are computed on a mesh of linear Matsubara frequencies. However, most of the code uses logarithmic Matsubara grid to lower the computational cost. Both [[dmft_nwli]] and [[dmft_nwlo]] are thus convergence parameters.
        </p>
        <p>
         DMFT is currently available for collinear ([[nspinor]]=1) polarized or unpolarized calculations ([[nspden]]=[[nsppol]]=2 or [[nspden]]=[[nsppol]]=1)
        and for non collinear calculations ([[nspinor]]=2,[[nspden]]=4,[[nsppol]]=1). However it is not yet available
        for collinear antiferromagnetic calculations  ([[nspden]]=2,[[nsppol]]=1) and non collinear non magnetic calculations ([[nspden]]=1, [[nsppol]]=1,[[nspinor]]=2).
        CTQMC calculations ([[dmft_solv]]=5) are not yet possible if [[nspinor]]=2.
        </p>
        <p>
         Only static calculations without relaxation or dynamics are possible (forces and stress are not computed in the scheme: so the computed values should NOT be trusted).
        </p>
        <p>
         When correlated density matrices are diagonal, all values of [[upawu]] and [[jpawu]]
         are possible. If the correlated density matrices are non diagonal, only [[jpawu]] = 0 is implemented.
        </p>
        <p>
         Relevant direct output quantities from
        converged DMFT calculations are total energy and occupation of correlated orbitals. For Hubbard I calculation ([[dmft_solv]]=2), total and partial spectral
        functions can be obtained with prtdos=1 and can be found in files OUTSpFunc* (where OUT is the root for
        output files). For CTQMC calculations ([[dmft_solv]]=5), imaginary time impurity Green function are output of the calculations and can be used to produce
        spectral function using an external Maximum Entropy Code.
        </p>
        <p>
         A typical DFT+DMFT calculation involves two runs. First, a DFT calculation is fully converged (even unoccupied wavefunctions have to be converged).
        Then, the DFT+DMFT calculation is started using DFT wavefunctions or density files.  As DFT+DMFT calculations (with CTQMC) are computationnally
        expensive, it is convenient to use prtden=-1, to write DEN file at each DFT iteration, in order to be able to restart the calculation easily.
        </p>
        <p>
         For details of the implementation see,
         <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">
          B. Amadon, F. Lechermann, A. Georges, F.  Jollet, T. O.  Wehling, and A. I.  Lichtenstein, Phys. Rev. B 77(20), (2008)
         </a>
         , for Wannier functions and
          B. Amadon, J. Phys.: Condens. Matter 24 075604 (2012) (doi:10.1088/0953-8984/24/7/075604),
        for self-consistency and Hubbard I implementation.

        If [[usedmft]]=1 and [[nbandkss]]/=0, then, the DFT+DMFT calculation is not done and only projections are computed at the end
        of the calculation. They can be used by an external code or used to compute the screened interaction (see variable [[ucrpa]]).
        </p>
    varname: usedmft
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE of EXact EXCHange
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         When [[useexexch]]=1, the hybrid functional PBE0 is used
        in PAW, inside PAW spheres only, and only for correlated orbitals given by
        [[lexexch]]. To change the ratio of exact exchange, see also [[exchmix]].
        </p>
    varname: useexexch
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE FOCK exact exchange
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable is automatically set to 1 when the value of [[ixc]]  refers to an Hartree-Fock calculation or hybrid functionals.
         <ul>
          <li>
           0 =&gt; No use of exact exchange.
          </li>
          <li>
           1 =&gt; exact exchange is required for the calculation.
          </li>
         </ul>
        </p>
    varname: usefock
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE Kinetic energy DENsity
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         If [[usekden]]=1 the kinetic energy density will be computed during the self-consistency loop,
        in a way similar to the computation of the density.
        This is needed if a meta-GGA is to be used as XC functional. Otherwise ([[usekden]]=0), the kinetic energy
        density is not computed during the self-consistency loop.
        </p>
    varname: usekden
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    definition: USE Projector Augmented Waves method
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This variable is determined by the pseudopotentials files.
        PAW calculations (see
         <a href="varpaw.html">
          PAW variables
         </a>
         ) can only
        be performed with PAW atomic data input files, while
        pseudopotential calculations are performed in ABINIT with norm-conserving
        pseudopotential input files. Most functionalities in ABINIT are available
        with either type of calculation.
        </p>
    varname: usepaw
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE PAW+U (spherical part)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         Must be non-zero if a DFT+U calculation is done, or if a [[GW]] calculation following a DFT+U calculation is done (important !).
         <ul>
          <li>
           If set to 0, the LDA+U method is not used.
           <br />
          </li>
          <li>
           If set to 1 or 2, the LDA+U method (cf [1])  is used. The full rotationally invariant
        formulation is used (see Eq. (3) of Ref [2]) for the interaction term of the energy.
        Two choices are allowed concerning the double counting term:
           <br />
          </li>
          <ul>
           <li>
            If [[usepawu]]=1, the Full Localized
        Limit (FLL) (or Atomic limit) double counting is used (cf Eq. (4) of Ref.[2] or
        Eq. (8) of Ref[3]).
            <br />
           </li>
           <li>
            If [[usepawu]]=2, the Around Mean Field (AMF) double counting is used
        (cf Eq. (7) of Ref [3]). Not valid if nspinor=2.
            <br />
           </li>
          </ul>
         </ul>
         If LDA+U is activated ([[usepawu]]=1 or 2), the [[lpawu]],
        [[upawu]] and [[jpawu]] input variables are read.
         <br />
         The implementation is done inside PAW augmentation regions only (cf Ref [4]). The initial density matrix can be
        given in the input file (see  [[usedmatpu]]).
        The expression of the density matrix is chosen thanks to
        [[dmatpuopt]]. See also
         <a href="../../users/How_to_use_LDA_plus_U.txt">
          How_to_use_LDA_plus_U.txt
         </a>
         .
        for some informations.
         <br />
         In the case of a [[GW]] calculation on top of a DFT+U, the absence of definition of a U value in the self-energy
        will LEAVE the underlying U from the DFT calculation.
        Thus, the code will actually do a [[GW]]+U @ DFT+U calculation.
        Note that the screening calculation will not be affected by the presence/absence of a U value.
         <br />
         Actually, in order to perform a [[GW]] @ DFT+U calculation, one should define the same value of U in the self-energy calculation,
        than the one defined in the DFT calculation. The code will know that the interaction corresponding to that value has to be
        SUBTRACTED inside the self-energy. The easiest is actually to define the presence of U for the whole set of calculations (for the different datasets),
        including the screening, even if the U value does not play explicitly a role in the computation of the latter (well, the input
        wavefunctions will be different anyhow).
         <br />
         It is possible to perform calculations of the type [[GW]]+U_prime @ DFT+U , so keeping a smaller U interaction in the [[GW]] calculation, by subtracting
        a smaller U than the one used in the DFT calculation. See the description of the [[upawu]] input variable.
         <br />
         References:
         <br />
         [1] V. I. Anisimov, J. Zaanen, and O. K. Andersen PRB 44, 943 (1991)
         <br />
         [2] A.I. Lichtenstein, V.I. Anisimov and J. Zaanen  PRB 52, 5467 (1995)
         <br />
         [3] M. T. Czyzyk and G.  A. Sawatzky PRB 49, 14211 (1994)
         <br />
         [4] O. Bengone, M. Alouani, P. Blochl, and J. Hugel PRB 62, 16392 (2000)
         <br />
         <br />
         <br />
         Suggested acknowledgment:
         <br />
         - B. Amadon, F. Jollet and M. Torrent, Phys. Rev. B 77, 155104 (2008).
         <br />
        </p>
    varname: usepawu
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE POTential ZERO
    dimensions: scalar
    excludes: null
    requires: null
    section: varpaw
    text: |-
        <p>
         <ul>
          <li>
           [[usepotzero]]=0, the usual convention: the smooth potential is set to zero averarage value.
          </li>
          <li>
           [[usepotzero]]=1, the new convention: the physical potential is set to zero average value.
          </li>
          <li>
           [[usepotzero]]=2, the PWscf convention: the potential of equivalent point charges is set to zero average value (convention also valid for NC pseudopotentials).
          </li>
         </ul>
        </p>
    varname: usepotzero
    vartype: integer
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USE RECursion
    dimensions: scalar
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         This internal variable is set to 1 when the recursion method is
        activated (see [[tfkinfunc]]).
        </p>
    varname: userec
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USER Integer variable A
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    varname: useria
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USER Integer variable B
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    varname: userib
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USER Integer variable C
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    varname: useric
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USER Integer variable D
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    varname: userid
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: USER Integer variable E
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable integers which the user may
        input and then utilize in subroutines of his/her own
        design.  They are not used in the official versions
        of the ABINIT code, and should ease independent
        developments (hopefully integrated in the official
        version afterwards).
         <br />
         Internally, they are available in the dtset structured datatype,
        e.g. dtset%useria .
        </p>
    varname: userie
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: USER Real variable A
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    varname: userra
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: USER Real variable B
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    varname: userrb
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: USER Real variable C
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    varname: userrc
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: USER Real variable D
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    varname: userrd
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: USER Real variable E
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         These are user-definable with the same purpose as [[useria]] and cie.
        </p>
    varname: userre
    vartype: real
- !variable
    characteristics: null
    commentdefault: use plane-wave basis set
    commentdims: null
    defaultval: 0
    definition: Use WaVeLet basis set
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Used to define if the calculation is done on a
        wavelet basis set or not.
         <br />
         The values of [[usewvl]] must be 0 or 1. Putting [[usewvl]]
        to 1, makes [[icoulomb]]
        mandatory to 1. The number of band ([[nband]]) must be set manually to
        the strict number need for an isolator system (
         <i>
          i.e.
         </i>
         number of electron over two). The cut-off is not relevant in the
        wavelet case, use [[wvl_hgrid]]
        instead.
         <br />
         In wavelet case, the system must be isolated systems (molecules or
        clusters). All geometry optimization are available (see [[ionmov]], especially the geometry
        optimisation and the molecular dynamics).
         <br />
         The spin computation is not currently possible with wavelets and
        metalic systems may be slow to converge.
        </p>
    varname: usewvl
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: -1
    definition: USE eXchange-Correlation with NHAT (compensation charge density)
    dimensions: scalar
    excludes: null
    requires: '[[usepaw]]==1'
    section: varpaw
    text: |-
        <p>
         <br />
         This flag determines how the exchange-correlation terms are computed for the pseudo-density.
         <br />
         When [[usexcnhat]]=0, exchange-correlation potential does not include the compensation charge density, i.e.
        Vxc=Vxc(tild_Ncore + tild_Nvalence).
         <br />
         When [[usexcnhat]]=1, exchange-correlation potential includes the compensation charge density, i.e.
        Vxc=Vxc(tild_Ncore + tild_Nvalence + hat_N).
         <br />
         When [[usexcnhat]]=-1,the value of [[usexcnhat]] is determined from the reading of the PAW dataset file
        (pseudopotential file). When PAW datasets with different treatment of Vxc are used in the same
        run, the code stops.
        </p>
    varname: usexcnhat
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !valuewithconditions
        '[[tfkinfunc]]==1': 1
        '[[usepaw]]==1': 1
        defaultval: 0
    definition: USE YLM (the spherical harmonics)
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         When this flag is activated, the non-local operator is applied using an algorithm based on spherical harmonics. Non-local projectors are used with their usual form:
         <br />
         <ul>
          P
          <sub>
           lmn
          </sub>
          (r)=Y
          <sub>
           lm
          </sub>
          (r)*p
          <sub>
           ln
          </sub>
          (r)
         </ul>
         <br />
         <br />
         When [[useylm]]=0, the sum over Y_lm can be reduced to a Legendre polynomial form.
        </p>
    varname: useylm
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: VACancies LiST
    dimensions:
    - '[[vacnum]]'
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the identification number(s) of atoms
        to be subtracted from the set of atoms that are obtained
        after having rotated, translated and repeated the objects.
         <br />
         Useful to created vacancies.
        </p>
    varname: vaclst
    vartype: integer
- !variable
    characteristics:
    - '[[GEOMETRY_BUILDER]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: VACancies NUMber
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the number of atoms to be subtracted
        from the list of atoms after the rotations, translations
        and repetitions have been done. The list of these
        atoms is contained in [[vaclst]].
        </p>
    varname: vacnum
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: VACUUM identification
    dimensions:
    - 3
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Establishes the presence (if 1) or absence (if 0) of a vacuum
        layer, along the three possible directions normal to the
        primitive axes.
        </p>
        <p>
         This information might be used to generate k-point grids,
        if [[kptopt]]=0 and neither
        [[ngkpt]] nor [[kptrlatt]]
        are defined (see explanations with the input variable
        [[prtkpt]]).
         <br />
         It will allow to select
        a zero-, one-, two- or three-dimensional
        grid of k points. The coordinate of the k points
        along vacuum directions is automatically set to zero.
        </p>
        <p>
         If [[vacuum]] is not defined, the input variable
        [[vacwidth]]
        will be used to determine automatically whether the
        distance between atoms is sufficient to have the
        presence or absence of vacuum.
        </p>
    varname: vacuum
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    definition: VACuum WIDTH
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Give a minimum "projected" distance between
        atoms to be found in order to declare that there
        is some [[vacuum]] present for each of the three
        directions.
        By default, given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[vacwidth]] has the
        '[[LENGTH]]' characteristics.
         <br />
         The precise requirement is that a slab
        of width [[vacwidth]], delimited by two
        planes of constant reduced coordinates in the
        investigated direction, must be empty of atoms.
        </p>
    varname: vacwidth
    vartype: real
- !variable
    characteristics:
    - '[[GW]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 3
        value: 0.0
    definition: V (potential) CUT-off GEOmetry
    dimensions:
    - 3
    excludes: null
    requires: '[[icutcoul]] in [1,2]'
    section: vargw
    text: |-
        <p>
         [[vcutgeo]] is used in conjunction with [[icutcoul]]
        to specify the geometry used to truncate the Coulomb interaction, as well as the
        particular approach to be used.
        It has a meaning only for the cylindrical symmetry
        ([[icutcoul]]=1) or in the case of surfaces
        ([[icutcoul]]=2).
        For each geometry, two different definitions of the cutoff region are available
        (see Phys. Rev. B 73, 233103 and Phys. Rev. B 73, 205119 for a complete description of the methods)
        </p>
        <p>
         In Beigi method (Phys. Rev. B 73, 233103), the cutoff region is given by the Wigner-Seitz cell
        centered on the axis of the cylinder.
        The cutoff region is thus automatically defined by the unit cell and there is no need to specify
        When [[rcut]].
        </p>
        <p>
        To define a cylinder along the z-axis use the following lines.

        icutcoul 1
        vcutgeo  0 0 1
        </p>
        <p>
         Please note that Beigi method is implemented only in the case if an orthorhombic
        Bravais lattic. For hexagonal lattices, one has to use the method of Rozzi (Phys. Rev. B 73, 205119)
        In this case, the interaction is truncated in a finite cylinder.
        Contrarily to the first approach, here one has to specify both the radius of the cylinder
        with [[rcut]]
        as well as the length of the cylinder along the periodic dimension that should always be smaller
        than the extension of the Born von Karman box.
        The length of the cylinder is given in terms of the fraction of the primitive vector along the periodic direction.
        </p>
        <p>
         For example, in order to define a finite cylinder along z of radius 2.5 Bohr and length 3*R3

        icutcoul 1
        vcutgeo  0 0 -3.0 # note the minus sign
        rcut     2.5
        </p>
        <p>
         For surface calculations ([[icutcoul]]=2),
        [[vcutgeo]] is used to define the two periodic directions defining the surface.
        Also in this case two different techniques are available.
        In the method of Beigi, the (positive) non-zero components of vcutgeo define the periodic
        directions of the infinite surface. The interaction is truncated within a slab
        of width L where L is the length of the primitive vector of the lattice along the non-periodic dimension.
        For example:

        icutcoul 2
        vcutgeo 1 1 0

        It is also possible to define a finite surface by employing negative values
        For example:

        icutcoul 2
        vcutgeo -3 -2 0

        defines ....
        </p>
    varname: vcutgeo
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 10
    definition: vdW-DF MINimum Angular CUT-off
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    varname: vdw_df_acutmin
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: |-
        vdW-DF RATIO between the highest and
        lowest Angle.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    varname: vdw_df_aratio
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    definition: vdW-DF MAXimum Angular Delta
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    varname: vdw_df_damax
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    definition: vdW-DF MINimum Angular Delta
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build angular meshes for the vdW-DF kernel.
        <br />
    varname: vdw_df_damin
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: vdW-DF D-mesh CUT-off
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_dcut
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    definition: |-
        vdW-DF RATIO between the highest and
        lowest D.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_dratio
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0
    definition: vdW-DF SOFTening distance.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_dsoft
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    definition: vdW-DF K-space CUT-off
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to filter the vdW-DF kernel in reciprocal space.
        <br />
    varname: vdw_df_gcut
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    definition: vdW-DF Number of D-mesh PoinTS
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_ndpts
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1
    definition: vdW-DF Number of G-mesh PoinTS
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_ngpts
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 30
    definition: vdW-DF Number of Q-mesh PoinTS
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_nqpts
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 2048
    definition: vdW-DF Number of R-PoinTS
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to define the sampling of the vdW-DF-kernel in real-space.
        <br />
    varname: vdw_df_nrpts
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 12
    definition: vdW-DF Number of SMOOTHening iterations
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to exponentially smoothen q near q0.
        <br />
    varname: vdw_df_nsmooth
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -1.0
    definition: vdW-DF SOFTening PHI value.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_phisoft
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 5
    definition: vdW-DF Q-mesh CUT-off
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_qcut
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 20
    definition: |-
        vdW-DF RATIO between highest and
        lowest Q
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        .
        <br />
    varname: vdw_df_qratio
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 100
    definition: vdW-DF Real-space CUT-off
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to define the vdW-DF kernel cut-off radius.
        <br />
    varname: vdw_df_rcut
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.0
    definition: vdW-DF SOFTening radius.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_rsoft
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.01
    definition: vdW-DF energy calculation threshold
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        <p>
        Sets a threshold for the energy gradient that,
        when reached, will cause the vdW-DF interactions to be calculated.
        <br />
        Adjust it to a big value (e.g. 1e12) to enable it all along the SCF
        calculation. Too small values, as well as negative values, will result
        in the vdW-DF energy contributions never being calculated.
        </p>
    varname: vdw_df_threshold
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-13
    definition: vdW-DF global TOLERANCE.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
    varname: vdw_df_tolerance
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: vdW-DF tweaks.
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        to build the vdW-DF kernel.
        <br />
        <b>
         <i>
          IMPORTANT NOTE: modifying this variable will likely transform the calculated energies and their gradients into garbage. You have been warned!
         </i>
        </b>
        <br />
    varname: vdw_df_tweaks
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: -0.8491
    definition: vdW-DF Zab parameter
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]>0'
    section: vardev
    text: |-
        Used when [[vdw_xc]]&gt;0,
        as introduced in
        <a href="http://dx.doi.org/10.1103/PhysRevLett.92.246401">
         doi:10.1103/PhysRevLett.92.246401
        </a>
        .
        <br />
    varname: vdw_df_zab
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: van der Waals Number of interacting FRAGments
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]] in [10,11]'
    section: vardev
    text: |-
        <p>
         The absolute value of vdw_nfrag is the number of vdW interacting
        fragments in the unit cell. As wannierization takes place in reciprocal space, the MLWF
        center positions could be translated by some lattice vector from the cell where atoms
        are placed. If [[vdw_nfrag]] &gt;= 1 then MLWFs are translated to the original
        unit cell, otherwise the program will keep the positions obtained by Wannier90. The
        later is usually correct if some atoms are located at the corners or at limiting
        faces of the unit cell.
        </p>
    varname: vdw_nfrag
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0
    - 0
    - 0
    definition: Van Der Waals correction from Wannier functions in SUPERCELL
    dimensions:
    - 3
    excludes: null
    requires: '[[vdw_xc]] in [10,11]'
    section: vardev
    text: |-
        <p>
         Set of dimensionless positive numbers which define the maximum multiples
        of the primitive translations ([[rprimd]]) in the supercell construction. Each component of vdw_supercell
        indicates the maximum number of cells along both positive or negative directions of the corresponding
        primitive vector i.e. the components of [[rprimd]]. In the case of layered
        systems for which vdW interactions occur between layers made of tightly bound atoms, the evaluation
        of vdW corrections coming from MLWFs in the same layer (fragment) must be avoided. Both a negative or
        null value for one component of [[vdw_supercell]]  will indicate that the  corresponding direction
        is normal to the layers.

        </p>
    varname: vdw_supercell
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-10
    definition: van der Waals TOLerance
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]]==5'
    section: vardev
    text: |-
        <p>
         The DFT-D methods (S. Grimme approach) dispersion potentials, [[vdw_xc]]==5 or 6 or 7, include a pair potential.
        The number of pairs of atoms contributing to the potential is necessarily limited. To be included
        in the potential a pair of atom must have contribution to the energy larger than [[vdw_tol]].
        </p>
    varname: vdw_tol
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: Do include the 3-body term in the correction
    commentdims: null
    defaultval: -1
    definition: van der Waals TOLerance for 3-Body Term
    dimensions: scalar
    excludes: null
    requires: '[[vdw_xc]] == 6'
    section: vardev
    text: |-
        Control the computation of the 3-body correction inside DFT-D3 dispersion correction (Grimme approach) to the total energy:
        <br />
        -If <b> vdw_tol_3bt</b>&lt;0, no 3-body correction.
        <br />
        -If <b> vdw_tol_3bt</b>&gt;0, the 3-body term is included with a tolerance = <b>vdw_tol_3bt</b>
        <br />
        <br />
        DFT-D3 as proposed by S. Grimme adds two contributions to the total energy in order to take into account of the dispersion:
        <br />
         <ul>
        <li>
        A pair-wise potential for which the tolerance is controlled by [[vdw_tol]]
        </li>
        <br />
        <li>A 3-body term which is obtained by summing over all triplets of atoms. Each individual contribution depends of the distances and angles between the three atoms. As it is impossible to sum over all the triplets in a periodic system, one has to define a stopping criterium which is here that an additional contribution to the energy must be higher than <b>vdw_tol_3bt</b>
        </li>
        </ul>
        The last term has been predicted to have an important effect for large molecules (see for e.g. <i> Grimme S.,  J. Chem. Phys. 132, 154104 (2010) </i>). It is however quite costly in computational time for periodic systems and seems to lead to an overestimation of lattice parameters for weakly bound systems (see for e.g. <i> Reckien W., J. Chem. Phys. 132, 154104(2010) </i>). Still, its contribution to energy, to forces and to stress is available (not planned for elastic constants, dynamical matrix and internal strains)
    varname: vdw_tol_3bt
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: 1
        value: '[[natom]]'
    definition: van der Waals TYPe of FRAGment
    dimensions:
    - '[[natom]]'
    excludes: null
    requires: '[[vdw_xc]] in [10,11]'
    section: vardev
    text: |-
        <p>
         This array defines the interacting fragments by assigning to each atom an
        integer index from 1 to
         <b>
          vdw_nfrag
         </b>
         . The ordering of [[vdw_typfrag]] is the same as
        [[typat]] or [[xcart]]. Internally each MLWF is
        assigned to a given fragment by computing the distance to the atoms. MLWFs belong to
        the same fragment as their nearest atom. The resulting set of MLWFs in each interacting fragment
        can be found in the output file in xyz format for easy visualization.
        </p>
    varname: vdw_typfrag
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: van der Waals eXchange-Correlation functional
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Selects a van-der-Waals density functional to
        apply the corresponding correction to the exchange-correlation energy.
        If set to zero, no correction will be applied.
         <br />
         Possible values are:
         <ul>
          <li>
           0: no correction.
          </li>
          <li>
           1: apply vdW-DF1 (DRSLL) from Dion
           <i>
            et al.
           </i>
           <br />
           <i>
            doi:10.1103/PhysRevLett.92.246401
           </i>
          </li>
          <li>
           2: apply vdw-DF2 (LMKLL) from Lee
           <i>
            et al.
           </i>
           <br />
           <i>
            arXiv:1003.5255v1
           </i>
          </li>
          <li>
           5: apply vdw-DFT-D2 as proposed by S. Grimme (adding a semi-empirical dispersion potential)
           <br />
           Available only for ground-state calculations and response functions; see [[vdw_tol]] variable
        to control convergency
           <br />
           <i>
            J. Comp. Chem. 27, 1787 (2006)
           </i>
          </li>
        <li>
           6: apply vdw-DFT-D3 as proposed by S. Grimme (refined version of DFT-D2)
           <br />
           Available only for ground-state calculations and response functions except strain; see [[vdw_tol]] variable
        to control convergency and [[vdw_dftd3_3bt]] variable to include 3-body corrections
           <br />
           <i>
            J. Chem. Phys. 132, 154104 (2010)
           </i>
          </li>
           <li>
           7: apply vdw-DFT-D3(BJ) as proposed by Grimme (based on Becke-Jonhson method J. Chem. Phys. 2004-2006)
           <br />
           Available only for ground-state calculations and response functions except strain; see [[vdw_tol]] variable
        to control convergency
           <br />
           <i>
            J. Comput. Chem. 32, 1456 (2011)
           </i>
          </li>
          <li>
           10: evaluate the vdW correlation energy from maximally localized Wannier functions, as proposed by
        P. L. Silvestrelli, also known as vdW-WF1 method.
           <br />
           <i>
            doi:10.1103/PhysRevLett.100.053002.
           </i>
           For details on this implementation please check:
           <i>
            doi:10.1016/j.cpc.2011.11.003
           </i>
           <br />
           The improvements introduced by Andrinopoulos
           <i>
            et al.
           </i>
           in
           <i>
            J. Chem. Phys. 135, 154105 (2011)
           </i>
           namely
        the amalgamation procedure, splitting of p-like MLWFs
        into
           <br />
           two s-like Wannier functions and fractional occupation of MLWFs are performed automatically.
           <br />
          </li>
          <li>
           11: evaluate the vdW correlation energy from maximally localized Wannier functions, as proposed by
        A. Ambrosetti and P. L. Silvestrelli, also known as vdW-WF2 method.
           <br />
           <i>
            doi:10.1103/PhysRevB.85.073101
           </i>
          </li>
          <li>
           14: apply DFT/vdW-QHO-WF method as proposed by Silvestrelli, which combines the quantum harmonic
        oscillator-model with localized Wannier functions.
           <br />
           <i>
            J. Chem. Phys. 139, 054106 (2013)
           </i>
           <br />
           For periodic systems a supercell approach has to be used since
           <b>
            vdw_supercell
           </b>
           is not enabled in this case.
          </li>
         </ul>
         For [[vdw_xc]]=1 and [[vdw_xc]]=2, the implementation follows the strategy devised
        in the article of Rom&aacute;n-P&eacute;rez and Soler
        (<a href="https://dx.doi.org/10.1103/PhysRevLett.103.096102">doi:10.1103/PhysRevLett.103.096102</a>)
        </p>
    varname: vdw_xc
    vartype: integer
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: It is represented internally as [[vel]](3,[[natom]],[[nimage]])
    defaultval: !multiplevalue
        number: null
        value: 0
    definition: VELocity
    dimensions:
    - 3
    - '[[natom]]'
    excludes: null
    requires: '[[ionmov]] > 0'
    section: varrlx
    text: |-
        <p>
         Gives the starting velocities
        of atoms, in cartesian coordinates, in Bohr/atomic time
        units (atomic time units given where [[dtion]]
        is described).
         <br />
         For [[ionmov]]=8 (Nose thermostat),
        if [[vel]] is not initialized, a random initial
        velocity giving the right kinetic energy will be generated.
         <br />
         If the geometry builder is used, [[vel]] will be related
        to the preprocessed set of atoms, generated by the
        geometry builder. The user must thus foresee the effect
        of this geometry builder (see [[objarf]]).
         <br />
         Velocities evolve is [[ionmov]]==1.
        </p>
    varname: vel
    vartype: real
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: 'It is represented internally as [[vel_cell]](3,3,[[nimage]]) '
    defaultval: !multiplevalue
        number: null
        value: 3
    definition: VELocity of the CELL parameters
    dimensions:
    - 3
    - 3
    excludes: null
    requires: |-
        [[imgmov]] in [9,13] and [[optcell]] > 0
        (Path-Integral Molecular Dynamics
        with NPT algorithm)
    section: varrlx
    text: |-
        <p>
         Irrelevant unless [[imgmov]]=9 or 13
        and [[optcell]]&gt;0 (Path-Integral Molecular Dynamics
        with NPT algorithm).
         <br />
         Gives the starting velocities of the dimensional cell parameters in Bohr/atomic time
        units (atomic time units given where [[dtion]]
        is described).
        </p>
    varname: vel_cell
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 100
    definition: VIScosity
    dimensions: scalar
    excludes: null
    requires: null
    section: varrlx
    text: |-
        The equation of motion is :
        <br />
        M
        <sub>
         I
        </sub>
        d
        <sup>
         2
        </sup>
        R
        <sub>
         I
        </sub>
        /dt
        <sup>
         2
        </sup>
        = F
        <sub>
         I
        </sub>
        - [[vis]] dR
        <sub>
         I
        </sub>
        /dt
        <br />
        <br />
        The atomic unit of viscosity is hartrees*(atomic time units)/Bohr
        <sup>
         2
        </sup>
        .
        Units are not
        critical as this is a fictitious damping used to relax
        structures. A typical value for silicon is 400 with
        [[dtion]] of 350 and atomic mass 28 [[amu]]. Critical
        damping is most desirable and is found only by
        optimizing [[vis]] for a given situation.
        <br />
        <br />
        In the case of Path-Integral Molecular Dynamics using the Langevin Thermostat ([[imgmov]]=9), [[vis]] defines the friction coefficient, in atomic units. Typical value range is 0.00001-0.001.
    varname: vis
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    - '[[ENERGY]]'
    commentdefault: null
    commentdims: null
    defaultval:
    - 0.0
    - 0.0
    definition: potential -V- for the PeRTuRBation
    dimensions:
    - 2
    excludes: null
    requires: '[[qprtrb]]'
    section: varff
    text: |-
        <p>
         Gives the real and imaginary
        parts of a scalar potential perturbation.
        Can be specified in Ha (the default), Ry, eV or Kelvin, since [[vprtrb]] has the
        '[[ENERGY]]' characteristics.
         <br />
         This is made
        available for testing responses to such perturbations.
        The form of the perturbation, which is added to the local
        potential, is:
         <ul>
          <li>
           ([[vprtrb]](1)+I*[[vprtrb]](2))/2 at G=[[qprtrb]]  and
          </li>
          <li>
           ([[vprtrb]](1)-I*[[vprtrb]](2))/2 at G=-[[qprtrb]]
        (see [[qprtrb]] also).
          </li>
         </ul>
        </p>
    varname: vprtrb
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 1
    definition: Wannier90- INItial PROJections
    dimensions: scalar
    excludes: null
    requires: '[[prtwant]]==2 or [[prtwant]]==3'
    section: varw90
    text: |-
        <p>
         In order to find the Maximally Localized Wannier Functions, the user
        has to provide an initial guess. A set of localized trial orbitals
        is chosen
        corresponding to some rough initial guess at the
        Wannier Functions, and these are projected onto the  Bloch
        eigenstates. See Ivo
        Souza, Nicola Marzari, and David Vanderbilt. Phys. Rev. B, 65, 035109 (2001).
         <br />
         These initial projections are stored in a file .amn and the variable
         <b>
          w90iniprj
         </b>
         is used to construct them:
         <ul>
          <li>
           <b>
            w90iniprj
           </b>
           =1:
        Random projections.
           <br />
           <br />
          </li>
          <li>
           <b>
            w90iniprj
           </b>
           =2:
        The initial projections will be a linear combination of hydrogenic
        atomic orbitals.
           <br />
           The user has to define the projections in the secondary input file
        wannier90.win
           <br />
           Information about how to define them can be found in the manual of
        Wannier90. See
           <span>
            <a href="http://www.wannier.org">
             www.wannier.org
            </a>
           </span>
          </li>
         </ul>
        </p>
    varname: w90iniprj
    vartype: integer
- !variable
    characteristics: null
    commentdefault: |-
        The default is set to zero because UNKp.s files occupy a lot of
        memory.
    commentdims: null
    defaultval: 0
    definition: Wannier90- PRINT UNKp.s file
    dimensions: scalar
    excludes: null
    requires: '[[prtwant]]==2 or [[prtwant]]==3'
    section: varw90
    text: |-
        <p>
         Defines whether or not the UNKp.s file will be printed.
         <ul>
          <li>
           [[w90prtunk]]=0: Do not print the UNKp.s files
           <br />
           <br />
          </li>
          <li>
           [[w90prtunk]]=1: Print the UNKp.s files on a fine grid
           <br />
           <br />
          </li>
          <li>
           [[w90prtunk]]&gt;1: Print the UNKp.s files on a coarse grid
           <br />
           Instead of printing every record we will print every w90prtunk records. This is useful to reduce the size of the UNKp.s files, but, the quality is also reduced.
          </li>
         </ul>
         <br />
         <br />
        These files contain the periodic part of the bloch states represented
        on a regular real space grid. They are indexed by k-point
         <b>
          p
         </b>
         (from 1 to
        nkpt) and spin
         <b>
          s
         </b>
         ('1' for 'up','2' for 'down').
         <br />
         <br />
         The name of the wavefunction file is assumed to have the form:
         <br />
         <br />
         write(wfnname,200)
         <b>
          p
         </b>
         ,
         <b>
          spin
         </b>
         <br />
         200 format ('UNK',i5.5,'.',i1)
         <br />
         <br />
         These file are unformatted.
        The first line of each file contains 5 integers: the number of
        grid points in each direction (
         <b>
          n1
         </b>
         ,
         <b>
          n2
         </b>
         and
         <b>
          n3
         </b>
         ), the k-point number
         <b>
          ikpt
         </b>
         and the total number of bands mband in the file. The following rows contain the wavefunctions in real space.
        </p>
        <p>
         These files are written in the following way for the coarse grid:
        </p>
        <pre>
         write(iun_plot) n1/w90prtunk,n2/w90prtunk,n3/w90prtunk,ikpt,nband
        write(iun_plot) (((fofr(1,jj1,jj2,jj3),fofr(2,jj1,jj2,jj3),&amp;
        &amp;      jj1=1,n1,w90prtunk),jj2=1,n2,w90prtunk),jj3=1,n3,w90prtunk)
        </pre>
        Where
        <b>
         fofr
        </b>
        is a double precision variable which contains the wavefunctions in real space.
        Note that in order to reduce the size of the UNK files we are just
        including records in the wavefunctions for 1/(w90prtunk^3) of the grid points.
        That is why we divide n1, n2 and n3 by prtunk. The output .xsf files for plotting
        with XCrysDen will also be on the coarse grid.  When this does not produce an
        acceptable plot, prtunk can be set to 1 to output every grid point.
        (You should try spline interpolation in XCrysDen first.)
    varname: w90prtunk
    vartype: integer
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: 0 when [[usepaw]]=0 (norm-conserving pseudopotentials), 10 when [[usepaw]]=1 (PAW) ; 114 if [[paral_kgb]]=1.
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    definition: WaveFunction OPTimisation ALGorithm
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         Allows one to choose the algorithm for the optimisation of the wavefunctions.
         <br />
         The different possibilities are :
         <ul>
          <li>
           [[wfoptalg]]=0 : standard state-by-state conjugate gradient algorithm,
        with no possibility to parallelize over the states;
          </li>
          <li>
           [[wfoptalg]]=2 : minimisation of the residual with respect
        to different shifts, in order to cover the whole set of occupied
        bands, with possibility to parallelize over blocks of states (or bands).
        The number of states in a block
        is defined in [[nbdblock]].
        THIS IS STILL IN DEVELOPMENT.
          </li>
          <li>
           [[wfoptalg]]=3 : minimisation of the residual with respect
        to a shift. Available only in the non-self-consistent case
        [[iscf]]=-2,
        in order to find eigenvalues and wavefunctions close to a
        prescribed value.
          </li>
          <li>
           [[wfoptalg]]=4 : (see also [[wfoptalg]]=14), a parallel code based on the Locally Optimal
        Block Preconditioned Conjugate Gradient (LOBPCG) method of Knyazev.
           <a href="http://dx.doi.org/10.1137/S1064827500366124">
            Reference : A.V. Knyazev, "Toward the Optimal Preconditioned Eigensolver
        : Locally Optimal Block Preconditioned Conjugate Gradient Method". SIAM
        Journal on Scientific Computing 23, pp517-541 (2001)
           </a>
           .
        The implementation rests on the
           <a href="http://www.mathworks.com/matlabcentral/fileexchange/48-lobpcg-m">
            matlab program by Knyazev
           </a>
           .
           <a href="http://dx.doi.org/10.1137/060661624">
            Reference A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov,
        Block Locally Optimal Preconditioned Eigenvalue Xolvers (BLOPEX) in
        hypre and PETSc (2007). SIAM Journal on Scientific Computing (SISC).
        25(5): 2224-2239
           </a>
           .
        For more information see
           <a href="http://dx.doi.org/10.1016/j.commatsci.2007.07.019">
            F. Bottin, S. Leroux, A. Knyazev, G. Zerah, Large scale
        ab initio calculations based on three levels of parallelization. (2008).
        Computational Material Science, 42(2), 329-336.
           </a>
          </li>
          <li>
           [[wfoptalg]]=10 : (for PAW) standard state-by-state conjugate gradient algorithm,
        with no possibility to parallelize over the states, but modified
        scheme described in Kresse, Furthmuller, PRB 54, 11169 (1996)
        (modified kinetic energy, modified preconditionning, minimal
        orthogonalization, ...) ;
          </li>
          <li>
           [[wfoptalg]]=14 :
        the recommended for parallel code, the same as [[wfoptalg]]=4 except that the preconditioning of
        the block vectors does not depend on the kinetic energy of each band,
        and the orthogonalization after the LOBPCG algorithm is no longer
        performed. The first modification increases the convergence and the
        second one the efficiency.
          </li>
        <li>
           [[wfoptalg]]=114 :
        A new version of [[wfoptalg]]=14 which is more efficient for few blocks and can take advantage of OpenMP if abinit is compiled with a multithreaded linear algebra library.
        With more than 1 thread [[npfft]] shoud NOT be used for the time being.
          </li>
          <li>
           [[wfoptalg]]=1 :
        new algorithm based on Chebyshev filtering, designed for very large number of processors, in the regime where LOBPCG does not scale anymore. It is not able to use preconditionning and therefore might converge slower than other algorithms. By design, it will
           <b>
            not
           </b>
           converge the last bands: it is recommended to use slightly more bands than necessary. For usage with [[tolwfr]], it is imperative to use [[nbdbuf]]. For more performance, try [[use_gemm_nonlop]]. For more information, see the
           <a href="../../theory/howto_chebfi.pdf">
            performance guide
           </a>
           and the
           <a href="https://arxiv.org/abs/1406.4350">
            paper
           </a>
           by A. Levitt and M. Torrent. Status: experimental but usable. Questions and bug reports should be sent to antoine (dot) levitt (at) gmail.com.
          </li>
         </ul>
        </p>
    varname: wfoptalg
    vartype: integer
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: WeighTs for AToms in CONstraint equations
    dimensions:
    - 3
    - '[[natcon]]'
    - '[[nconeq]]'
    excludes: null
    requires: null
    section: varrlx
    text: |-
        <p>
         Gives the weights determining how the motion of atoms
        is constrained
        during structural optimization or molecular dynamics (see [[nconeq]]
         , [[natcon]],
        and [[iatcon]]). For each of the [[nconeq]]
         independent constraint equations,
        wtatcon is a 3*[[natcon]] array giving
        weights, W
         <sub>
          I
         </sub>
         ,
        for the x, y, and z components of each of the atoms (labeled by I) in
        the list of indices [[iatcon]].
        Prior to taking an atomic step, the calculated forces, F
         <sub>
          I
         </sub>
         ,
        are
        replaced by projected forces, F'
         <sub>
          I
         </sub>
         , which satisfy the set of
        constraint equations
         <br />
         <br />
         Sum
         <sub>
          mu=x,y,z; I=1,natcon
         </sub>
         : W
         <sub>
          mu,I
         </sub>
         * F'
         <sub>
          mu,I
         </sub>
         = 0 for each of the [[nconeq]] arrays W
         <sub>
          I
         </sub>
         .
         <br />
         <br />
         Different types of motion constraints can be implemented this way. For
        example,
         <br />
         <br />
         nconeq 1 natcon 2 iatcon 1 2 wtatcon 0 0 +1 0 0 -1
         <br />
         <br />
         could be used to constrain the relative height difference of two
        adsorbate atoms on a surface (assuming their
        masses are equal), since F'
         <sub>
          z,1
         </sub>
         - F'
         <sub>
          z,2
         </sub>
         = 0
        implies z
         <sub>
          1
         </sub>
         - z
         <sub>
          2
         </sub>
         = constant.
        </p>
    varname: wtatcon
    vartype: real
- !variable
    characteristics: null
    commentdefault: Except when [[kptopt]]/=0
    commentdims: null
    defaultval: !multiplevalue
        number: '[[nkpt]]'
        value: 1.0
    definition: WeighTs for K points
    dimensions:
    - '[[nkpt]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the k point weights.
         <br />
         The
        k point weights will have their sum (re)normalized to 1
        (unless [[occopt]]=2 and [[kptopt]]=0;
        see description of [[occopt]])
        within the program and therefore may be input with any
        arbitrary normalization.  This feature helps avoid the
        need for many digits in representing fractional weights
        such as 1/3.
         <br />
         [[wtk]] is ignored if [[iscf]] is not positive,
        except if [[iscf]]=-3.
        </p>
    varname: wtk
    vartype: real
- !variable
    characteristics: null
    commentdefault: Except when [[qptopt]]/=0
    commentdims: null
    defaultval: 1
    definition: WeighTs for the current Q-points
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Gives the current q-point weight.
        </p>
    varname: wtq
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: WaVeLet BigDFT Comparison
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        This variable is used for the wavelets capabilities of ABINIT (see [[usewvl]]
        </a>
        ).
        It is used to compare the results obtained with ABINIT
        with those obtained with BigDFT stand-alone.
        When it is set to 1, ABINIT will follow the workflow as in BigDFT stand-alone.
        Therefore, the results must be exactly the same with the two codes.
    varname: wvl_bigdft_comp
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 6.0
    definition: WaVeLet Coarse grid Radius MULTiplier
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This factor is used to defined the expansion of the coarse resolution
        grid in the case of wavelets (seea [[usewvl]]
         ). The grid is made of
        points inside spheres centered on atoms. The radius of these
        spheres are the product between this factor and the covalent
        radius of element (read from the pseudo-potential file).
         <br />
         This factor is responsible for the amount of used memory (see also [[wvl_hgrid]]).
        </p>
    varname: wvl_crmult
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 10.0
    definition: WaVeLet Fine grid Radius MULTiplier
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         This factor is used to defined the expansion of the fine resolution
        grid in the case of wavelets (see [[usewvl]]
         ). This fine resolution
        grid has the same grid step than the coarse one (see
        [[wvl_crmult]]
         ), but on each
        point, 8 coefficients are stored instead of one, increasing the
        precision of the calculation in this area. The grid is made of
        points inside spheres centered on atoms. The radius of these
        spheres are the product between this factor and a value read from the pseudo-potential file.
         <br />
         This factor is responsible for the amount of used memory (see also [[wvl_hgrid]]).
        </p>
    varname: wvl_frmult
    vartype: real
- !variable
    characteristics:
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: 0.5
    definition: WaVeLet H step GRID
    dimensions: scalar
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         It gives the step size in real space for the
        grid resolution in the wavelet basis set. This value is highly
        responsible for the memory occupation in the wavelet
        computation. The value is a length in atomic units.
        </p>
    varname: wvl_hgrid
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval:
    - 1
    - 100
    definition: WaVeLet Number of GAUSSians
    dimensions:
    - 2
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         In the wavelet-PAW computation case, projectors may be
        fitted to a sum of complex Gaussians.
        The fit is done for wvl_ngauss(1), wvl_ngauss(1)+1 ... up to wvl_ngauss(2) Gaussians.
        </p>
    varname: wvl_ngauss
    vartype: integer
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 5
    definition: WaVeLet maximum Number of PReConditionner Conjugate Gradient iterations
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         In the wavelet computation case, the wavefunctions are directly
        minimised using a real-space preconditionner. This preconditionner
        has internally some conjugate gradient iterations. This value
        defines a boundary for the number of conjugate gradient
        iterations on each wavefunction convergence step.
        </p>
    varname: wvl_nprccg
    vartype: integer
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: vectors (X) of atom positions in cartesian coordinates -length in ANGSTrom-
    dimensions:
    - 3
    - min([[natom]],[[natrd]])
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the cartesian coordinates
        of atoms within unit cell, in angstrom.  This information is
        redundant with that supplied by array [[xred]] or [[xcart]].
         <br />
         If [[xred]] and [[xangst]] are ABSENT from the input file and
        [[xcart]] is
        provided, then the values of [[xred]] will be computed from
        the provided [[xcart]] (i.e. the user may use xangst instead
        of [[xred]] or [[xcart]] to provide starting coordinates).
         <br />
         One and only one of [[xred]], [[xcart]]
        and [[xangst]] must be provided.
         <br />
         The conversion factor between Bohr and Angstrom
        is 1 Bohr=0.5291772108 Angstrom, see the
         <a href="http://physics.nist.gov/cuu/Constants/index.html">
          NIST site
         </a>
         .
         <br />
         Atomic positions evolve if [[ionmov]]/=0 .
        In constrast with [[xred]] and
        [[xcart]], [[xangst]] is not internal.
        </p>
    varname: xangst
    vartype: real
- !variable
    characteristics:
    - '[[DEVELOP]]'
    commentdefault: null
    commentdims: null
    defaultval: 1.0E-14
    definition: eXchange-Correlation - DENsity POSitivity value
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         For the evaluation of the exchange-correlation functionals, the density
        cannot be negative, or even too small (e.g. the LDA exchange kernel
        behaves like the density at power -(2/3), and the density is used at the denominator
        of different factors in GGAs and metaGGAs.
        [[xc_denpos]] is the smallest value that the density can assume at the time of the
        evaluation of a XC functional, in ABINIT. When then computed density drops below [[xc_denpos]]
        before attacking the evaluation of the XC functional, then it will be (only for that purpose)
        replaced by [[xc_denpos]]. Note that the evaluation of the gradients or other quantities
        that are density-dependent is performed before this replacement.
        </p>
        <p>
         It has been observed that the SCF cycle of the Tran-Blaha mGGA can be quite hard to make converge, for systems
        for which there is some vacuum. In this case, setting [[xc_denpos]] to 1.0e-7 ... 1.0e-6 has been seen
        to allow good convergence. Of course, this will affect the numerical results somehow, and one should play
        a bit with this value to avoid incorrect calculations.
        </p>
    varname: xc_denpos
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: 99.99
    definition: Value of the c parameter in the eXchange-Correlation TB09 functional
    dimensions: scalar
    excludes: null
    requires: null
    section: vardev
    text: |-
        <p>
         The modified Becke-Johnson exchange-correlation functional by Tran and Blaha (Phys. Rev. Lett. 102, 226401 (2009)) reads :
        </p>
        <p>
         V_x(r) = c * V_x^{BR}(r) + (3*c - 2) * 1/pi * sqrt(5/12) * sqrt(2*kden(r)/den(r))
        </p>
        <p>
         in which V_x^{BR}(r) is the Becke-Roussel potential.
        </p>
        <p>
         In this equation the parameter c can be evaluated at each SCF step according to the following equation :
        </p>
        <p>
         c = alpha + beta * sqrt(1/V_{cell} * \int_{V_{cell}} |grad(den(r))|/den(r) d3r)
        </p>
        <p>
         The c parameter is evaluated thanks to the previous equation when xc_tb09_c is equal to the "magic" default value 99.99.
        The c parameter can also be fixed to some (property-optimized or material-optimized) value by using this variable.
        </p>
    varname: xc_tb09_c
    vartype: real
- !variable
    characteristics:
    - '[[EVOLVING]]'
    - '[[LENGTH]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: vectors (X) of atom positions in CARTesian coordinates
    dimensions:
    - 3
    - min([[natom]],[[natrd]])
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the cartesian coordinates
        of atoms within unit cell.  This information is
        redundant with that supplied by array [[xred]] or [[xangst]].
        By default, [[xcart]] is given in Bohr atomic units
        (1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
        if preferred, since [[xcart]] has the
        '[[LENGTH]]' characteristics.
         <br />
         If [[xred]] and [[xangst]] are
        ABSENT from the input file and [[xcart]] is
        provided, then the values of [[xred]] will be computed from
        the provided [[xcart]] (i.e. the user may use [[xcart]] instead
        of [[xred]] or [[xangst]] to provide starting coordinates).
         <br />
         One and only one of [[xred]], [[xcart]]
        and
         <b>
          xangst
         </b>
         must be provided.
         <br />
         Atomic positions evolve if [[ionmov]]/=0 .
        </p>
    varname: xcart
    vartype: real
- !variable
    characteristics:
    - '[[INTERNAL_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: eXchange Correlation functional level
    dimensions: scalar
    excludes: null
    requires: null
    section: vargs
    text: |-
        <p>
         Automatically determined from the value of [[ixc]].
         <ul>
          <li>
           0 =&gt; No XC contribution.
          </li>
          <li>
           1 =&gt; LDA functional.
          </li>
          <li>
           2 =&gt; GGA functional or hybrid functional based on GGA.
          </li>
          <li>
           3 =&gt; Functional for [[TDDFT]].
          </li>
         </ul>
        </p>
    varname: xclevel
    vartype: integer
- !variable
    characteristics:
    - '[[EVOLVING]]'
    commentdefault: null
    commentdims: represented internally as xred(3,[[natom]],[[nimage]])
    defaultval: !multiplevalue
        number: null
        value: 0.0
    definition: vectors (X) of atom positions in REDuced coordinates
    dimensions:
    - 3
    - min([[natom]],[[natrd]])
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives the atomic locations within
        unit cell in coordinates relative to real space primitive
        translations (NOT in cartesian coordinates).  Thus these
        are fractional numbers typically between 0 and 1 and
        are dimensionless.  The cartesian coordinates of atoms (in Bohr)
        are given by:
         <br />
         <tele>
          R_cartesian = xred1*rprimd1+xred2*rprimd2+xred3*rprimd3
         </tele>
         <br />
         where (xred1,xred2,xred3) are the "reduced coordinates" given in
        columns of "[[xred]]", (rprimd1,rprimd2,rprimd3) are the columns of
        primitive vectors array "[[rprimd]]" in Bohr.
         <br />
         If you prefer to work only with cartesian coordinates, you
        may work entirely with "[[xcart]]" or "[[xangst]]" and ignore [[xred]], in
        which case [[xred]] must be absent from the input file.
         <br />
         One and only one of [[xred]], [[xcart]]
        and
         <b>
          xangst
         </b>
         must be provided.
         <br />
         Atomic positions evolve if [[ionmov]]/=0 .
        </p>
    varname: xred
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: !multiplevalue
        number: null
        value: 0.0
    definition: X(position) in REDuced coordinates of the SPHeres for dos projection in the EXTRA set
    dimensions:
    - 3
    - '[[natsph_extra]]'
    excludes: null
    requires: '[[natsph_extra]] > 0'
    section: vargs
    text: |-
        <p>
         The positions in reduced coordinates of extra spheres used in the DOS projection, simulating an STS signal.
        See [[natsph_extra]] for a more complete description.
        </p>
    varname: xredsph_extra
    vartype: real
- !variable
    characteristics:
    - '[[INPUT_ONLY]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: XYZ FILE input for geometry
    dimensions: scalar
    excludes: null
    requires: null
    section: vargeo
    text: |-
        <p>
         Gives the name of a xyz format file, to take
        [[natom]], [[ntypat]], [[typat]], [[znucl]],
        and [[xangst]] from. This input can not be mixed with normal atom specifications for other datasets.
        </p>
        <p>
         Notes: do not quote the file name in the abinit input file, simply leave a space after xyzfile. The xyz format is the number of atoms on the first line, a comment line, then one line per atom, with the element as a 2 letter symbol ("As" "O" or "Pu") and the three cartesian coordinates in Angstrom.
        </p>
    varname: xyzfile
    vartype: string
- !variable
    characteristics:
    - '[[GW]]'
    - '[[ENERGY]]'
    commentdefault: 0.0036749326 Ha = 0.1 eV
    commentdims: null
    defaultval: 0.0036749326
    definition: Z-CUT
    dimensions: scalar
    excludes: null
    requires: '[[optdriver]] in [3,4,99]'
    section: vargw
    text: |-
        <p>
         It is meant to avoid some divergencies that might occur during the evaluation of the Adler-Wiser expression of
        the irreducible polarizability ([[optdriver]]=3) or during the numerical treatment
        of the integrals defining the contribution to the self-energy matrix elements
        ([[optdriver]]=4).
        If the denominator becomes smaller than [[zcut]], a small imaginary part (depending on [[zcut]]) is added,
        in order to avoid the divergence.
        </p>
        <p>
         When [[optdriver]]=99, [[zcut]] defines the small complex shift
        used to avoid divergences in the expression for the macroscopic dieletric function.
        It simulates the experimental uncertainty and the finite lifetime of the quasiparticles
        (although the true lifetime should be k- and band-dependent).
        The value of [[zcut]] affects the number of iteration needed to achieve convergence
        in the Haydock iterative method. In this case, [[zcut]] should be
        larger than the typical distance between the eigenvalues of the exciton Hamiltonian.
         <br />
         Ideally, one should make a convergence study decreasing the value of [[zcut]] for increasing number of k-points.
        </p>
    varname: zcut
    vartype: real
- !variable
    characteristics:
    - '[[MAGNETIC_FIELD]]'
    commentdefault: null
    commentdims: null
    defaultval: 0
    definition: ZEEMAN FIELD
    dimensions:
    - 3
    excludes: null
    requires: null
    section: varff
    text: |-
        <p>
         Give the value of the Zeeman field, H, acting on the spinorial wavefunctions.
        Note that Tesla are admitted. This sets the magnitude of mu_0*H, in Tesla,
        with H in Amperes/metre.
        </p>
    varname: zeemanfield
    vartype: real
- !variable
    characteristics: null
    commentdefault: null
    commentdims: null
    defaultval: '[[AUTO_FROM_PSP]]'
    definition: Z (charge) of the IONs for the different TYPes of AToms
    dimensions:
    - '[[ntypat]]'
    excludes: null
    requires: null
    section: varint
    text: |-
        <p>
         Charge of the pseudo-ion (=number of valence electrons
        that are needed to screen exactly the pseudopotential).
        </p>
    varname: ziontypat
    vartype: real
- !variable
    characteristics:
    - '[[NO_MULTI]]'
    commentdefault: null
    commentdims: null
    defaultval: null
    definition: charge -Z- of the NUCLeus
    dimensions:
    - '[[npsp]]'
    excludes: null
    requires: null
    section: varbas
    text: |-
        <p>
         Gives nuclear charge for each
        type of pseudopotential, in order.
         <br />
         If [[znucl]] does not agree with nuclear charge,
        as given in pseudopotential files, the program writes
        an error message and stops.
        </p>
        <p>
         N.B. : In the pseudopotential files, [[znucl]] is called "zatom".
        </p>
        <p>
         For a "dummy" atom, with znucl=0 , as used in the case of calculations
        with only a jellium surface, ABINIT sets arbitrarily the covalent radius to one.
        </p>
    varname: znucl
    vartype: real

