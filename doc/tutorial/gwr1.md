---
authors: MG
---

# First tutorial on GWR (GW in real-space and imaginary time)

## The quasi-particle band structure of Silicon in the GW approximation.

This tutorial aims at showing how to calculate self-energy corrections to the
DFT Kohn-Sham (KS) eigenvalues in the one-shot GW approximation using the GWR code

The user should be familiarized with the four basic tutorials of ABINIT,
see the [tutorial home page](/tutorial),
and is strongly encouraged to read the [introduction to the GWR code](/tutorial/gwr_intro) before running these examples.

This tutorial should take about 2 hours.

[TUTORIAL_README]

### Ground-state and band structure

*Before beginning, you might consider creating a different subdirectory to work in. Why not create Work_gwr?*

The file *tgwr_1.abi* is the input file for the first step:
a KS SCF run followed by a band structure calculation along a high-symmetry $\kk$-path.
Copy it to the working directory with:

```sh
mkdir Work_gwr
cd Work_gwr
cp ../tgwr_1.abi .
```

You may want to immediately start the job in background with:

```sh
abinit tgwr_1.abi > tgwr_1.log 2> err &
```

so that we have some time to discuss the input while ABINIT is running.

{% dialog tests/tutorial/Input/tgwr_1.abi %}

The first dataset produces the density file that is then used to compute
the band structure in the second dataset.
Since all the input files of this tutorial use the same geometry, pseudos and [[ecut]],
we declare these variables in an external file that will be included in all the other input files
using the syntax:

```
# Include geometry and pseudos
include "gwr_include.abi"
```

If you open the include file:

{% dialog tests/tutorial/Input/gwr_include.abi %}

you will notice that we are using NC pseudos taken from the standard scalar-relativistic table of the PseudoDojo.
For GW calculations, we strongly recommend using pseudos from the stringent table
as they have closed-shells treated as valence that are important for a correct description of exchange effects [[cite:Setten2018]].
In the case of silicon, there is no difference between the standard and the stringent version.

For efficiency reasons, we are using underconverged parameters:
a 2x2x2 $\Gamma$-centered $\kk$-mesh and a cutoff energy [[ecut]] of XXX
that is slightly smaller that the recommended value

At this point, the calculation should have completed and
it is time to have a look at the electronic band structure to understand
to position of the band edges.

!!! tip

    If |AbiPy| is installed on your machine, you can use the |abiopen| script
    with the `--expose` option to visualize the band structure from the GSR.nc file:

        abiopen.py tgwr_1o_DS2_GSR.nc --expose

    ![](base1_assets/abiopen_tgwr1_1.png)

    To print the results to terminal, use:

        abiopen.py tgwr_1o_DS2_GSR.nc -p


Silicon is an indirect band gap semiconductor:
The CBM is located at the $\Gamma$ point
The KS fundamental band gap is XXX that is strongly underestimanted wrt experiment.

!!! important

    Similarly to the conventional GW code, also GWR can compute QP corrections only
    for the $\kk$-points belonging to the mesh found in the WFK file.
    Before running GW calculations is always a good idea to analyze carefully the KS band
    structure to understand the location of the band edges and select the most appropriate $\kk$-mesh


### Generation of the WFK file with empty states

In the second input file, we use the density computed previously (tgwr\_1o\_DS1\_DEN)
to generate WFK files with empty states.

Start the job in background with:

```sh
abinit tgwr_2.abi > tgwr_2.log 2> err &
```

{% dialog tests/tutorial/Input/tgwr_2.abi %}

Note that here we are using the specialized [[gwr_task]] = "HDIAGO" to perform the **direct diagonalization**
of the KS Hamiltonian initialized from the DEN file.
This procedure differs from the one used in the other GW tutorials in which the WFK file
is generated by performing an **iterative diagonalization** in which only the applications of the Hamiltoniana is required.
The reason is that the **direct diagonalization** outperforms iterative methods when many empty states are required.

Here we ask for 100 states as in the previous GW tutorial, we found that [[nband]] = 100 can be considered converged within 30 meV.

!!! important

    The direct diagonalization is MPI-parallelized across three different levels:
    collinear spin $\sigma$ (not used here), $\kk$-points and scalapack distribution of the $H^\sigma_\kk(\bg,\bg')$ matrix.
    Abinit will try to find an optimal distribution of the workload at runtime yet there are a couple
    of things worth keeping in mind when choosing the number of MPI processes for this step.
    Ideally the total number of cores should be a multiple of [[nkpt]] * [[nsppol]] to avoid load imbalance.

    In order to compute **all** the eigenvectors of the KS Hamiltonian, one can use:

    gwr_task "HDIAGO_FULL"

    In this case the value of [[nband]] is automatically set to the total number of plawewaves
    for that particular $\kk-point$.
    No stopping criterion such as [[tolwfr]] or the number of iterations [[nstep]] are required when Scalapack is used.


### Our first GWR calculation

For our first example, we use a minimalistic input file so that we can discuss
the most important input variables and the content of the main output file.
First of all, you may want to start immediately the computation by issuing:

```sh
abinit tgwr_3.abi > tgwr_3.log 2> err &
```

with the following input file:

{% dialog tests/tutorial/Input/tgwr_3.abi %}

so that we have more time to discuss the meaning of the different input variables

The third input file performs a GWR calculation using the DEN and the WFK file produced previously.
The input file contains some variables that have the same meaning as in the conventional GW code
and other variables that are specific to GWR.
Let us start from the GWR-specific variables whose name starts with *gwr_*.

We use [[optdriver]] 6 to enter the GWR code and
the value of [[gwr_task]] indicates that we are performing a one-shot calculation
with a 6-point minimax mesh ([[gwr_ntau]] = 6).
This is the minimum number of points one can use.


[[gwr_boxcutmin]] is set to 1.1 to accelerate the calculation,
but this is one of the parameters that should be subject to convergence studies.
Please take some time to read the variable description.

[[getden_filepath]] specifies the density file used to compute $v_{xc}(\rr)$,
while [[getwfk_filepath]] specifies the WFK file with empty states.
Note that the $\kk$-mesh specified in the input via [[ngkpt]], [[nshiftk]] and [[shiftk]] must
agree with the one found in the WFK file.

Now, let us turn our attention to the variables that are also used in the legacy GW code.
In the [first GW tutorial](/tutorial/gw1), we have already performed convergence studies,
and we found that [[nband]] = 100 can be considered converged within 30 mev, which is fair to compare with experimental accuracy.
Also ecuteps = 6.0 can be considered converged within 10 meV.
We will not repeat these convergence studies here and we just use these values for our calculation so that
we can focus on the analysis of the output file and the post-processing of the results.
Note that, as discussed in [[cite:Setten2017]], the convergence study for $\kk$-points the number
of bands and the cutoff energies can be decoupled in the sense that one can start from
a reasonaby coarse $\kk$-mesh to find the converged values of [[nband]], [[ecuteps]], [[ecutsigx]]
and then fix these values and look at the convergence with respect to the BZ mesh.

The cutoff for the exchange part of the self-energy is defined by [[ecutsigx]].
Theoretically, we need [[ecutsigx]] = 4 [[ecut]] to have an exact treatment of $\Sigma_x$.
The computation of the exchange is relatively fast as only occupied states are involved.

The cutoff of the polarizability and $W$ is defined by [[ecuteps]] as in the conventional GW code

The $\kk$-points for the QP corrections can be specified in different ways.

Explicitly via [[nkptgw]], [[kptgw]] and [[bdgw]]
Implicitly via [[gw_qprange]]

For the spectral function, we have the following variables [[nfreqsp]], [[freqspmax]]

[[inclvkb]] == 2, [[symsigma]]

We can now have a look at the main output file:

{% dialog tests/tutorial/Refs/tgwr_3.abo %}

First of all, we find a section that summarizes


The most important GWR parameters are summarized in this Yaml document

```yaml
--- !GWR_params
iteration_state: {dtset: 1, }
gwr_task: G0W0
nband: 100
ntau: 6
ngkpt: [2, 2, 2, ]
ngqpt: [2, 2, 2, ]
chi_algo: supercell
sigma_algo: 'BZ-convolutions'
nkibz: 3
nqibz: 3
inclvkb: 2
q0: [  1.00000000E-05,   2.00000000E-05,   3.00000000E-05, ]
gw_icutcoul: 6
green_mpw: 412
tchi_mpw: 190
g_ngfft: [12, 12, 12, 12, 12, 12, ]
gwr_boxcutmin:   1.10000000E+00
P gwr_np_kgts: [1, 1, 1, 1, ]
P np_kibz: [1, 1, 1, ]
P np_qibz: [1, 1, 1, ]
min_transition_energy_eV:   2.20247744E-02
max_transition_energy_eV:   3.84181232E+00
eratio:   1.74431404E+02
ft_max_err_t2w_cos:   3.39269547E-02
ft_max_err_w2t_cos:   4.27492521E-03
ft_max_err_t2w_sin:   1.00974389E+00
cosft_duality_error:   4.08855664E-04
Minimax imaginary tau/omega mesh: !Tabular | # tau, weight(tau), omega, weight(omega)
    1 1.16987E-01   3.20191E-01   8.71836E-03   1.84660E-02
    2 8.20298E-01   1.25063E+00   3.30978E-02   3.36974E-02
    3 3.19454E+00   3.95048E+00   8.75746E-02   8.49211E-02
    4 1.01456E+01   1.10178E+01   2.40282E-01   2.55119E-01
    5 2.85210E+01   2.82127E+01   7.50121E-01   9.22624E-01
    6 7.50861E+01   7.27575E+01   2.97572E+00   4.74388E+00
...
```


